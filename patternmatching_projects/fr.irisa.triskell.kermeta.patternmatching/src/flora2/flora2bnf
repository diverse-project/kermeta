%% To avoid confusion between some language elements and meta-syntax
%% (e.g., parentheses and brackets are part of BNF and also of the language
%% being described), we enclose some symbols in single quotes to make it
%% clear that they are part of the language syntax, not of the grammar.
%% However, in FLORA these symbols can be used with or without the quotes.
Rule := Head (':-' Body)? .

Query := '?-' Body.

Directive := ':-' ExportDirective | OperatorDirective | SetSemanticsDirective
             | IgnoreDependencyCheckDirective | PrologDirective
             
Head := HeadLiteral
Head := Head (',' | 'and') Head

HeadLiteral := BinaryRelationship | ObjectSpecification | Term

Body := BodyLiteral
Body := BodyConjunt | BodyDisjunct | BodyNegative | ControlFlowStatement
Body := Body '@' ModuleName
Body := BodyConstraint

ModuleName := 'prolog()' | 'prolog(' atom ')' | atom | 'flora(' atom ') '

BodyConjuct := Body (',' | 'and') Body
BodyDisjunct := Body (';' | 'or') Body
BodyNegative := (('not' | '+') Body) | 'false' Body ''
BodyConstraint := '' CLPR-style constraint ''

ControlFlowStatement := IfThenElse | UnlessDo
                    | WhileDo | WhileLoop
                    | DoUntil | LoopUntil

IfThenElse := 'if' Body 'then' Body ('else' Body)? | Body '<-' Body
UnlessDo := 'unless' Body 'do' Body
WhileDo := 'while' Body 'do' Body
WhileLoop := 'while' Body 'loop' Body
DoUntil := 'do' Body 'until' Body
LoopUntil := 'loop' Body 'until' Body

BodyLiteral := BinaryRelationship | ObjectSpecification | Term
             | DBUpdate | Refresh | NewoidOp | Builtin | Loading
             | CatchExpr | ThrowExpr | TruthTest
             
Builtin := ArithmeticComparison, Unification, MetaUnification, etc.

Loading := '[' LoadingCommand (',' LoadingCommand)* ']'
LoadingCommand := filename ('>>' atom)

BinaryRelationship := PathExpression ':' PathExpression
BinaryRelationship := PathExpression '::' PathExpression

ObjectSpecification := PathExpression '[' SpecBody ']'

SpecBody := 'not' MethodSpecification
SpecBody := SpecBody ',' SpecBody
SpecBody := SpecBody ';' SpecBody

MethodSpecification := ('#' | '*')? Term
MethodSpecification := PathExpression ValueReferenceConnective PathExpression

ValueReferenceConnective := '->' | '->>' | '*->' | '*->>' |
                            '=>' | '=>>' | '*=>' | '*=>>' |
                            '+>' | '*+>' | '->->' | '*->->'
                            
PathExpression := atom | number | string | variable | specialOidToken
PathExpression := Term | List | ReifiedFormula
PathExpression := PathExpression PathExpressionConnective PathExpression
PathExpression := BinaryRelationship
PathExpression := ObjectSpecification
PathExpression := Aggregate

PathExpressionConnective := '.' | '..' | '!' | '!!'

specialOidToken := anonymousOid | numberedOid | thisModuleName

ReifiedFormula := $ (Body | '(' Rule ')')+

%% No quotes are allowed in the following special tokens!
%% No space allowed between _# and integer
%% anonymousOid & numberedOid can occur only in rule head
%% or in reified formulas
anonymousOid := '_#'
%% No space between _# and integer

numberedOid := '_#'integer
thisModuleName := '_@'

List := '[' PathExpression (',' PathExpression)* ('|' PathExpression)? ']'

Term := Functor '(' Arguments ')'
Term := '#' Functor '(' Arguments ')'

Functor := PathExpression

Arguments := PathExpression (',' PathExpression)*

Aggregate := AggregateOperator '' TargetVariable (GroupingVariables)? '|' Body ''
AggregateOperator := 'max' | 'min' | 'avg' | 'sum' | 'collectset' | 'collectbag'
%% Note: only one TargetVariable is permitted.
%% It must be a variable, not a term. If you need to aggregate over terms,
%% as for example, in collectset/collectbag, use the following idiom:
%% S = collectset V | ... , V=Term
TargetVariable := variable
GroupingVariables := '[' variable, (',' variable)* ']'

DBUpdate := DBOp '' UpdateList ('|' Body)? ''
DBOp := 'insert' | 'insertall' | 'delete' | 'deleteall' | 'erase' | 'eraseall'
UpdateList := HeadLiteral ('@' atom)?
UpdateList := UpdateList (',' | 'and') UpdateList
Refresh := 'refresh' UpdateList ''

RuleUpdate := RuleOp '' RuleList ''
RuleOp := 'insertrule' | 'insertrule_a' | 'insertrule_z' |
          'deleterule' | 'deleterule_a' | 'deleterule_z'
RuleList := Rule | '(' Rule ')' ( (',' | 'and') '(' Rule ')' )*

NewoidOp := 'newoid' Variable ''

CatchExpr := 'catch' Body, Term, Body ''
ThrowExpr := 'throw' Term ''
TruthTest := 'true' Body '' | 'unknown' Body '' | 'false' Body ''