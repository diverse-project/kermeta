/* $Id: ModelPattern2Flora.kmt,v 1.6 2008-09-26 12:46:40 bmorin Exp $
 * Creation date: October 4, 2006
 * License:
 * Copyright:
 * Authors:
 */
 
package kermeta::flora2::pattern;

require kermeta

require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore"  
require "platform:/lookup/fr.irisa.triskell.kermeta.flora2/src/flora2/Flora2wVisitor.kmt"

require "platform:/lookup/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/Model2Flora.kmt"

    
using kermeta::standard  
using kermeta::language::structure 
using kermeta::persistence 
using kermeta::interpreter
using kermeta::utils
 
using ecore
//using flora2::visitors
using patternframework
using kermeta::flora2 
 

class ModelPattern2Flora inherits Model2Flora { 
   attribute featureIdentifiers : Set<String>
    
   method initialize() is do
      var tableWithVariables : IDTableWithVariable init IDTableWithVariable.new 
      tableWithVariables.initialize()
      featureIdentifiers := Set<String>.new
      initializeTable( tableWithVariables)
   end	

   // return a unique query for all object
   operation transformModelPattern(modelPattern : ModelPattern) : flora2::Query is do 
      var query : flora2::Query init flora2::Query.new
	  var formula : flora2::CompoundedFormula init flora2::CompoundedFormula.new      
	  formula.operator := flora2::ConnectiveOp.conjunctionOp      	  
	  query.body := formula      
	  
	  // FIXME :do not clear (objTable.clear()) the table. if you want to use the method more than once
	  // you should initialize again the class
         objTable.clear()   
      //setting identifier (properties that will be treated diferently
      modelPattern.featureIdentifier.each{ str | featureIdentifiers.add(str)}
      //setting roles (variables in flora) in the objectTable
	  var tableWithVariables : IDTableWithVariable 
	  tableWithVariables  ?= objTable	          
      tableWithVariables.setRoles(modelPattern.pattern.roles)
       
      modelPattern.pattern.content.each { o | 
          var clauses : flora2::Clause[0..*] init clausesAboutObject( o, true)
  	      var queryAux : flora2::Query
  	      queryAux ?= clauses.one
  	      formula.elements.add(queryAux.body)
  	   }   
  	   
      modelPattern.falsepositivepatterns.each{ negmodel |
     	 tableWithVariables.setRoles(negmodel.roles)      
      
     	 var negationClause : flora2::Negation init flora2::Negation.new
     	 var negformula : flora2::CompoundedFormula init flora2::CompoundedFormula.new      
	     negformula.operator := flora2::ConnectiveOp.conjunctionOp      	       	 
     	 negationClause.expression := negformula     
         negmodel.content.each { o | 
            var clauses : flora2::Clause[0..*] init clausesAboutObject( o, true)
  	        var queryAux : flora2::Query
     	    queryAux ?= clauses.one
  	        negformula.elements.add( queryAux.body)
  	     }
  	      formula.elements.add(negationClause)  	     
  	   }  	     	   
       result := query
   end		

   // return a set of query for each object
   method transformModel(objects: Set<Object>) : flora2::Clause[0..*] is do 
      var clauses : oset flora2::Clause[0..*] init OrderedSet<flora2::Clause>.new
      objTable.clear()
      objects.each { o | clauses.addAll (clausesAboutObject( o, true))} 
       result := clauses
   end		
   
	method createStandardClause(body : flora2::Expression) : flora2::Clause is do
	     var query : flora2::Query init flora2::Query.new
	     query.body := body  
	     result := query
	end
	
	method getExpressionFromStandardClause(clause : flora2::Clause) : flora2::Expression  is do
	   var query : flora2::Query init flora2::Query.new
       query ?= clause
       result := query.body
	end	   	 

	method getTermOfAnDataType(objHost : Object,  pro : Property, proInstance: Object) : flora2::Term is do
	    var term : flora2::Term  
        var tableWithVariables : IDTableWithVariable 
        tableWithVariables  ?= objTable	 	    
        
	     if PObject.isInstance(objHost) and tableWithVariables.isVariant(objHost) and
	        (featureIdentifiers.exists{ str | str.equals(pro.name)} 
	            or proInstance.isVoid) then
           
          term := tableWithVariables.getInrelevantVariableID( proInstance)    	    
        else
          term := super(objHost, pro, proInstance) 
        end
        result := term
    end    
	
	// the  method getTermOfPropertyInstance does not need to be redifined, because no pending definition about
	// the property instance will be 
 

	operation lastIdVariants ( template : ModelPattern) : OrderedSet<String> is do	
      var vars : OrderedSet<String> init OrderedSet<String>.new	

      template.pattern.roles.each{r |  vars.add(objTable.getId( r.player))}
      template.falsepositivepatterns.each{ negmodel |      
           negmodel.roles.each{ r  |
                    vars.add(objTable.getId( r.player))}}
       result := vars
	end  
	
	method getInstanceExpression (term: flora2::Term,  className : String) : flora2::Expression is do
/*	  var formula : flora2::CompoundedFormula init flora2::CompoundedFormula.new      
	  formula.operator := flora2::ConnectiveOp.conjunctionOp      
      formula.elements.add ( createsInstanceClause (term, "?_class"+term.oid().toString ))
      
      var isa_subclass : flora2::ISASubclass init flora2::ISASubclass.new 
      var elementOid : flora2::Constant init flora2::Constant.new
      elementOid.symbolName :=  "?_class"+term.oid().toString     
      isa_subclass.element := elementOid
      var superclassOid : flora2::Constant init flora2::Constant.new
      superclassOid.symbolName := className        
      isa_subclass.superclass := superclassOid
                
      formula.elements.add ( isa_subclass)
	  result := formula	  
*/
      result := createsInstanceClause (term, className)
	end	
 
}


   
class IDTableWithVariable inherits IDTable {
   reference roles : PRole[0..*]

   method initialize() is do
      roles.clear
      super()
   end
      
   operation initializeRoles(rol : PRole[0..*]) is do  
      initialize()
      roles.addAll(rol)
   end
   
   operation setRoles(rol : PRole[0..*]) is do
     roles.clear
     roles.addAll(rol)     
   end
   
  /* This method controls a hashtable of Obj-> Id in order to give a unique Id 
     for each object */	   
   method getId( obj : Object) : String is do
      if not hasAnId(obj) then 
         var newId : String          
         if isVariant(obj) then
            newId := "?"+roleOfVariant(obj)         
         else
            newId := "?_"+"obj"+obj.oid.toString
         end              
          
         assignIDObj(newId, obj)
      end
      
      result := super(obj)
   end
     
  operation isVariant (obj : Object) : Boolean is do	           
    result := roles.exists{r | r.player.equals(obj)}             
  end  

  operation roleOfVariant (obj : Object) : String is do	           
    result := roles.detect{r | r.player.equals(obj)}.name
  end       	
	
	  
	operation getInrelevantVariableID (obj : Object) : flora2::Term is do 
	  var varTerm : flora2::Variable init flora2::Variable.new
	  varTerm.symbolName := "?_obj"+obj.oid().toString
	  result := varTerm		
	end  


 
}

