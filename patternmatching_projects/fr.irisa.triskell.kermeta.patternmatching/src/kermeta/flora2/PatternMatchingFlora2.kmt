/* $Id: PatternMatchingFlora2.kmt,v 1.12 2008-09-26 12:46:40 bmorin Exp $
 * Creation date: October 19, 2006
 * License:
 * Copyright:
 * Authors:
 */

package kermeta::pattern::flora2;

require kermeta

require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/PatternMatching.kmt"

require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/flora2/Flora2wVisitor.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/FloraInterpreter.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/Ecore2Flora.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/Model2Flora.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/visitor/Flora2SerializerVisitor.kmt"
 
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/flora2/ModelPattern2Flora.kmt"

 
using ecore
using kermeta::standard  
using kermeta::utils
using kermeta::pattern
using flora2
using flora2::visitors
using kermeta::flora2
using kermeta::flora2::pattern

class PatternMatchingFlora2 inherits PatternMatching
{
   attribute debug : Boolean 
   
   attribute interpreter : FloraInterpreter
   attribute tranfoModel2Flora : Model2Flora
   attribute tranfoPattern2Flora : ModelPattern2Flora
   
   attribute metamodelFactClauses : OrderedSet<flora2::Clause> 
   attribute modelFactClauses : OrderedSet<flora2::Clause> 
   attribute queryPattern : flora2::Query
   
   //attribute resultBindings : Sequence<Hashtable<Object, Object>>
   
	method optimizedMatchStep1(metamodel : Sequence<EPackage>, model : Set<Object>, 
	       template : patternframework::ModelPattern,
	       keepMetamodel : Boolean, keepModel : Boolean, keepTemplate : Boolean) : Sequence<Hashtable<Object, Object>> is
	do
		initialize
		if debug then stdio.writeln("...PatternMatchingFlora2.Step1()") end 
		//interpreter.flush

		if debug then stdio.writeln("...creating facts related to the metamodel")  end
		if metamodelFactClauses == void or not(keepMetamodel) then
			computeFactsForMetamodel(metamodel)
		end 
        insertFactsForMetamodel()
        
        if debug then stdio.writeln("...creating facts related to the model")  end
        if modelFactClauses == void or not(keepModel) then
			computeFactsForModel(model)
		end 
        insertFactsForModel()
        	
        if debug then stdio.writeln("...creating a query for the pattern ")  end
       	if queryPattern == void or not(keepTemplate) then
       		computeQueryForTemplate(template)
		end

       if debug then stdio.writeln("...running flora2 interpreter ")  end
      /* if keepTemplate and  resultBindings != void then
       		result := resultBindings
       else               
	*/		result := search(template)
	 //  end
	end
   
   method matchStep1(metamodel : Sequence<EPackage>, model : Set<Object>, 
       template : patternframework::ModelPattern) : Sequence<Hashtable<Object, Object>> is do
		result := optimizedMatchStep1(metamodel, model, template, false, false, false)
   end    

	/**
	* This operation actually search the template
	*/
	operation search(template : patternframework::ModelPattern): Sequence<Hashtable<Object, Object>> is
    do
		var itBindings : Iterator<Hashtable<String, String>> 
		
		itBindings := interpreter.queryInDefaultModule(queryPattern, 
               tranfoPattern2Flora.lastIdVariants(template))

        if debug then stdio.writeln("...linking bindings ")  end                      
        var resultBindings : Sequence<Hashtable<Object, Object>> init Sequence<Hashtable<Object, Object>>.new
        from itBindings until itBindings.isOff loop  
	    	var hash : Hashtable<String, String> init itBindings.next
        	var hashObj : Hashtable<Object, Object> init Hashtable<Object, Object>.new	    
	      	if debug then stdio.writeln("#--- Bindings in the flora side (Identifier into Identifier)") end
	    	hash.keys.each{ k | 
	       		if debug then stdio.writeln(k.toString + " => " + hash.getValue(k).toString) end
	       		hashObj.put(
              		tranfoPattern2Flora.objTable.getObj( k),
              		tranfoModel2Flora.objTable.getObj( hash.getValue(k)))
	          	if debug then stdio.writeln(tranfoPattern2Flora.objTable.getObj( k).toString + " => " + tranfoModel2Flora.objTable.getObj( hash.getValue(k)).toString) end              
	    	}   
	    	resultBindings.add( hashObj)
	  	end  
	  	result := resultBindings  
    end

	/**
	* This operation computes facts related to the metamodel
	*/
	operation computeFactsForMetamodel(metamodel : Sequence<EPackage>) is
    do    
		metamodelFactClauses := OrderedSet<flora2::Clause>.new
	    var tranfoEcore2Flora : Ecore2Flora init Ecore2Flora.new
	    metamodelFactClauses.addAll( tranfoEcore2Flora.transformMetamodel(metamodel)) 
	    if debug then 
	      	stdio.writeln("inserting "+metamodelFactClauses.select{c |Fact.isInstance(c)}.
	        collect{c | var fact : Fact fact ?= c}.size.toString+" facts related to the metamodel") 
	    end 
   end

	/**
	* This operation inserts facts related to the metamodel
	*/
   operation insertFactsForMetamodel() is
   do       
       //Prolog tables may be abolished, so we have to insert again all the facts
       metamodelFactClauses.select{c |Fact.isInstance(c)}.
	                   collect{c | var fact : Fact fact ?= c}.
	                   each{fact |
	                   		if debug then stdio.writeln("%>inserting "+fact.toString)  end
	                   		interpreter.insertFactInDefaultModule(fact)}
   end

   /**
   * This operation computes facts related to the model
   */
	operation computeFactsForModel(model : Set<Object>) is
	do
		modelFactClauses := OrderedSet<flora2::Clause>.new
		modelFactClauses.addAll(tranfoModel2Flora.transformModel(model)) 	
	end
   
   /**
   * This operation inserts facts related to the model
   */
   operation insertFactsForModel() is
   do	
		
		if debug then 
        	stdio.writeln("inserting "+modelFactClauses.select{c |Fact.isInstance(c)}.
            collect{c | var fact : Fact fact ?= c}.size.toString+" facts related to the model") 
        end    

        modelFactClauses.select{c |Fact.isInstance(c)}.
                   collect{c | var fact : Fact fact ?= c}.
                   each{fact |
                   		if debug then stdio.writeln("%>inserting "+fact.toString)  end
                   		interpreter.insertFactInDefaultModule(fact)}  
   end
   
   /**
   * This operation computes the Prolog query from the template
   */
   operation computeQueryForTemplate(template : patternframework::ModelPattern) is
   do	
 		queryPattern := tranfoPattern2Flora.transformModelPattern(template)
   end

   operation initialize() is
   do
       // ### ------------------
       debug := false
       // ### ------------------
       
       if debug then stdio.writeln("initializing...") end
       
       /*if resultBindings == void then
	       resultBindings := Sequence<Hashtable<Object, Object>>.new
	   end*/
       
   	   if interpreter == void then 
   	   		interpreter := FloraInterpreter.new
       		interpreter.initialize 
       end
       
       if tranfoModel2Flora == void then
        	tranfoModel2Flora := Model2Flora.new              
        	tranfoModel2Flora.initialize() 
       end
       
        if tranfoPattern2Flora == void then
   			tranfoPattern2Flora := ModelPattern2Flora.new
   			tranfoPattern2Flora.initialize()
   		end
   		
   		if debug then stdio.writeln("OK!") end
   end

   /**
   This operation should be called after the last execution of the pattern matching
   to finalize properly the matching
   */   
   method finalize() is
   do
		interpreter.finalize
   end
}