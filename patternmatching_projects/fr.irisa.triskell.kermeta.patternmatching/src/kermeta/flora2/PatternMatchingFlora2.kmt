/* $Id: PatternMatchingFlora2.kmt,v 1.9 2008-02-12 17:10:41 bmorin Exp $
 * Creation date: October 19, 2006
 * License:
 * Copyright:
 * Authors:
 */

package kermeta::pattern::flora2;

require kermeta

require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/PatternMatching.kmt"
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore"

require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/flora2/Flora2wVisitor.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/FloraInterpreter.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/Ecore2Flora.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/Model2Flora.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/visitor/Flora2SerializerVisitor.kmt"
 
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/flora2/ModelPattern2Flora.kmt"


 
using ecore
using kermeta::standard  
using kermeta::utils
using kermeta::pattern
using flora2
using flora2::visitors
using kermeta::flora2
using kermeta::flora2::pattern


class PatternMatchingFlora2 inherits PatternMatching
{
   attribute debug : Boolean 
   
   attribute interpreter : FloraInterpreter
   attribute tranfoModel2Flora : Model2Flora
   attribute tranfoPattern2Flora : ModelPattern2Flora
   
   attribute metamodelFactClauses : OrderedSet<flora2::Clause> //facts related to the metamodel (not supposed to change)
   attribute modelFactClauses : OrderedSet<flora2::Clause> //facts related to the model (may change)
   attribute queryPattern : flora2::Query //query (not supposed to change)
   
   method matchStep1(metamodel : Sequence<EPackage>, model : Set<Object>, 
       template : patternframework::ModelPattern) : Sequence<Hashtable<Object, Object>> is do

		initialize
		if debug then stdio.writeln("...PatternMatchingFlora2.Step1()") end 
		interpreter.flush

		if debug then stdio.writeln("...creating facts related to the metamodel")  end  
        insertFactsForMetamodel(metamodel)
        
        if debug then stdio.writeln("...creating facts related to the model")  end
        insertFactsForModel(model)

       //  creating a query for the pattern ...
        if debug then stdio.writeln("...creating a query for the pattern ")  end              
		insertQueryForTemplate(template)

       if debug then stdio.writeln("...running flora2 interpreter ")  end                
      result := search(template)

   end    

	/**
	* This operation actually search the template
	*/
	operation search(template : patternframework::ModelPattern): Sequence<Hashtable<Object, Object>> is
    do
		var itBindings : Iterator<Hashtable<String, String>> init
               interpreter.queryInDefaultModule(queryPattern, 
               tranfoPattern2Flora.lastIdVariants(template))

       if debug then stdio.writeln("...linking bindings ")  end                      
      var resultBindings : Sequence<Hashtable<Object, Object>> init Sequence<Hashtable<Object, Object>>.new
      from itBindings until itBindings.isOff loop  
	    var hash : Hashtable<String, String> init itBindings.next
        var hashObj : Hashtable<Object, Object> init Hashtable<Object, Object>.new	    
	      if debug then stdio.writeln("#--- Bindings in the flora side (Identifier into Identifier)") end
	    hash.keys.each{ k | 
	       if debug then stdio.writeln(k.toString + " => " + hash.getValue(k).toString) end
	       hashObj.put(
              tranfoPattern2Flora.objTable.getObj( k),
              tranfoModel2Flora.objTable.getObj( hash.getValue(k)))
	          if debug then stdio.writeln(tranfoPattern2Flora.objTable.getObj( k).toString + " => " + tranfoModel2Flora.objTable.getObj( hash.getValue(k)).toString) end              
	    }   
	    resultBindings.add( hashObj)
	  end  
	  result := resultBindings  
    end

	/**
	* This operation computes and inserts facts related to the metamodel
	* We assume that the metamodel remains unchanges between two matching
	* However, it is possible to compute these facts by removing the condition
	*/
   operation insertFactsForMetamodel(metamodel : Sequence<EPackage>) is
   do
   		if metamodelFactClauses == void then
   			metamodelFactClauses := OrderedSet<flora2::Clause>.new     
	        var tranfoEcore2Flora : Ecore2Flora init Ecore2Flora.new
	        metamodelFactClauses.addAll( tranfoEcore2Flora.transformMetamodel(metamodel))
	        
	        if debug then 
	        	stdio.writeln("inserting "+metamodelFactClauses.select{c |Fact.isInstance(c)}.
	            collect{c | var fact : Fact fact ?= c}.size.toString+" facts related to the metamodel") 
	        end
       end
       
       //Prolog tables may be abolished, so we have to insert again all the facts
       metamodelFactClauses.select{c |Fact.isInstance(c)}.
	                   collect{c | var fact : Fact fact ?= c}.
	                   each{fact |
	                    if debug then stdio.writeln("%>inserting "+fact.toString)  end
	                   	interpreter.insertFactInDefaultModule(fact)}
   end
   
   /**
   * This operation computes and inserts facts related to the model
   * We assume that the model can change between two matching
   * so, we compute and inserts again these facts
   */
   operation insertFactsForModel(model : Set<Object>) is
   do		
		modelFactClauses.clear
		modelFactClauses.addAll(tranfoModel2Flora.transformModel(model)) 
		
		if debug then 
        	stdio.writeln("inserting "+modelFactClauses.select{c |Fact.isInstance(c)}.
            collect{c | var fact : Fact fact ?= c}.size.toString+" facts related to the model") 
        end    

        modelFactClauses.select{c |Fact.isInstance(c)}.
                   collect{c | var fact : Fact fact ?= c}.
                   each{fact |
                    if debug then stdio.writeln("%>inserting "+fact.toString)  end
                   	interpreter.insertFactInDefaultModule(fact)}  
   end
   
   /**
   * This operation computes the Prolog query from the template
   * We assume that the query (i.e., the template) is identical for each matching
   * However, it is possible to compute the query by removing the condition
   */
   operation insertQueryForTemplate(template : patternframework::ModelPattern) is
   do	
   		if queryPattern == void then //if the template may change, just remove this condition
   			queryPattern := tranfoPattern2Flora.transformModelPattern(template)              
        end   
   end

   operation initialize() is
   do
       // ### ------------------
       debug := false
       // ### ------------------
       
   	   if interpreter == void then 
   	   		interpreter := FloraInterpreter.new
       		interpreter.initialize 
       end
       
       if tranfoModel2Flora == void then
        	tranfoModel2Flora := Model2Flora.new              
        	tranfoModel2Flora.initialize() 
       end
       
        if tranfoPattern2Flora == void then
   			tranfoPattern2Flora := ModelPattern2Flora.new
   			tranfoPattern2Flora.initialize()
   		end
   		
   		if modelFactClauses == void then
   			modelFactClauses := OrderedSet<flora2::Clause>.new
   		end
   end

   /**
   This operation should be called after the last execution of the pattern matching
   to finalize properly the matching
   */   
   method finalize() is
   do
		interpreter.finalize
   end
}