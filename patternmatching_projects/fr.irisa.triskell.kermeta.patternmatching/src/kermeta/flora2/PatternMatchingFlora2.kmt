/* $Id: PatternMatchingFlora2.kmt,v 1.8 2008-02-12 14:34:35 bmorin Exp $
 * Creation date: October 19, 2006
 * License:
 * Copyright:
 * Authors:
 */

package kermeta::pattern::flora2;

require kermeta

//require "platform:/resource/fr.irisa.triskell.kermeta.ecore/src/kermeta/ecore.kmt"

require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/PatternMatching.kmt"
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore"

require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/flora2/Flora2wVisitor.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/FloraInterpreter.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/Ecore2Flora.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/Model2Flora.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.flora2/src/kermeta/flora2/visitor/Flora2SerializerVisitor.kmt"
 
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/flora2/ModelPattern2Flora.kmt"


 
using ecore
using kermeta::standard  
using kermeta::utils
using kermeta::pattern
using flora2
using flora2::visitors
using kermeta::flora2
using kermeta::flora2::pattern


class PatternMatchingFlora2 inherits PatternMatching
{
   attribute debug : Boolean 
   
   attribute interpreter : FloraInterpreter //interpreter is now an attribute
   attribute factClauses :  OrderedSet<flora2::Clause> //facts are now an attribute
   attribute tranfoMode2Flora : Model2Flora
   
   method matchStep1(metamodel : Sequence<EPackage>, model : Set<Object>, 
       template : patternframework::ModelPattern) : Sequence<Hashtable<Object, Object>> is do
        // ### ------------------
        debug := true
        // ### ------------------
        if debug then stdio.writeln("...PatternMatchingFlora2.Step1()") end
                      
        //var factClauses : flora2::Clause[0..*] init OrderedSet<flora2::Clause>.new
        factClauses := OrderedSet<flora2::Clause>.new
     
       //  creating facts related to the metamodel and model ...        
        if debug then stdio.writeln("...creating facts related to the metamodel")  end       
        var tranfoEcore2Flora : Ecore2Flora init Ecore2Flora.new
        factClauses.addAll( tranfoEcore2Flora.transformMetamodel(metamodel))
        if debug then stdio.writeln("...creating facts related to the model")  end       
        
        //var tranfoMode2Flora : Model2Flora init Model2Flora.new
        tranfoMode2Flora := Model2Flora.new              
        tranfoMode2Flora.initialize() 
        factClauses.addAll( tranfoMode2Flora.transformModel(model))

       //  creating a query for the pattern ...
        if debug then stdio.writeln("...creating a query for the pattern ")  end              
        var tranfoPattern2Flora : ModelPattern2Flora init ModelPattern2Flora.new               
        tranfoPattern2Flora.initialize()             
        var queryPattern : flora2::Query init 
                    tranfoPattern2Flora.transformModelPattern(template)

       if debug then stdio.writeln("...running flora2 interpreter ")  end              
       //var interpreter : FloraInterpreter init FloraInterpreter.new
       if interpreter == void then 
       		initialize 
       end
       
        if debug then stdio.writeln("flushing tables...") end 
	  	interpreter.flush
       
       //  inserting facts related to the metamodel and model ...
       if debug then stdio.writeln("inserting "+factClauses.select{c |Fact.isInstance(c)}.
                   collect{c | var fact : Fact fact ?= c}.size.toString+" facts related to the metamodel and model ...") end
      
       factClauses.select{c |Fact.isInstance(c)}.
                   collect{c | var fact : Fact fact ?= c}.
                   each{fact |
                    if debug then stdio.writeln("%>inserting "+fact.toString)  end
                   	interpreter.insertFactInDefaultModule(fact)}


       var itBindings : Iterator<Hashtable<String, String>> init
               interpreter.queryInDefaultModule(queryPattern, 
               tranfoPattern2Flora.lastIdVariants(template))
      //interpreter.finalize

       if debug then stdio.writeln("...linking bindings ")  end                      
      var resultBindings : Sequence<Hashtable<Object, Object>> init Sequence<Hashtable<Object, Object>>.new
      from itBindings until itBindings.isOff loop  
	    var hash : Hashtable<String, String> init itBindings.next
        var hashObj : Hashtable<Object, Object> init Hashtable<Object, Object>.new	    
	       stdio.writeln("#--- Bindings in the flora side (Identifier into Identifier)")
	    hash.keys.each{ k | 
	       stdio.writeln(k.toString + " => " + hash.getValue(k).toString)
	       hashObj.put(
              tranfoPattern2Flora.objTable.getObj( k),
              tranfoMode2Flora.objTable.getObj( hash.getValue(k)))
	       stdio.writeln(tranfoPattern2Flora.objTable.getObj( k).toString + " => " + tranfoMode2Flora.objTable.getObj( hash.getValue(k)).toString)              
	    }   
	    resultBindings.add( hashObj)
	  end
      result := resultBindings

   end    

   operation initialize() is
   do
   	   interpreter := FloraInterpreter.new
       interpreter.initialize 
   end

   /**
   This operation should be called after the last execution of the pattern matching
   to finalize properly the matching
   */   
   method finalize() is
   do
		interpreter.finalize
   end
}