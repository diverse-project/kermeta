/* $Id: Ecore2Flora.kmt,v 1.1 2006-10-24 12:27:26 rodrigotex Exp $
 * Creation date: October 4, 2006
 * License:
 * Copyright:
 * Authors:
 */
 
@mainClass "kermeta::pattern::flora2::Main"
@mainOperation "main"
 
package kermeta::pattern::flora2;

require kermeta

require "platform:/resource/fr.irisa.triskell.kermeta.ecore/src/kermeta/ecore.kmt"
require "../../flora2/Flora2wVisitor.ecore"
require "./Ecore2FloraBasics.kmt"
require "../pattern/metamodel/PatternFramework.ecore"
require "../reflection/ReflectionHandler.kmt"
   
using kermeta::standard 
using kermeta::reflection 
using kermeta::persistence 
using kermeta::interpreter
using kermeta::utils

using ecore
//using flora2::visitors
using patternframework
 

class Ecore2Flora inherits Ecore2FloraBasicElements {

   /* Returns a set of clauses for a given metamodel. Each classifier (EClass or Datatype) 
    * of the metamodel is mapped into a CompoundedExpression with expressions for the declaration
    * of the type, features and operations.
    * The mapping of each class is delegated to transformClass
    */
   operation transformMetamodel(epackages: Sequence<EPackage>) : flora2::Clause[0..*] is do 
      var clauses : oset flora2::Clause[0..*] init OrderedSet<flora2::Clause>.new
      
      // FIXME : Allow more packages, check how to do that with modules in Flora2
      var eclassifiers : EClassifier[0..*] init epackages.one.eClassifiers
      
      eclassifiers.select{ e | EClass.isInstance(e)}.collect{ c| var eclass : EClass eclass ?=c}.
         each{c | clauses.add( createClauseForClassDeclaration(c))} 
      result := clauses   
   end
}


class ModelPattern2Flora inherits Model2Flora { 
   attribute featureIdentifiers : Set<String>
    
   method initialize() is do
      var tableWithVariables : IDTableWithVariable init IDTableWithVariable.new 
      tableWithVariables.initialize()
      featureIdentifiers := Set<String>.new
      initializeTable( tableWithVariables)
   end	

   // return a unique query for all object
   operation transformModelPattern(modelPattern : ModelPattern) : flora2::Query is do 
      var query : flora2::Query init flora2::Query.new
	  var formula : flora2::CompoundedFormula init flora2::CompoundedFormula.new      
	  formula.operator := flora2::ConnectiveOp.conjunctionOp      	  
	  query.body := formula      
	  
	  // FIXME :do not clear (objTable.clear()) the table. if you want to use the method more than once
	  // you should initialize again the class
         objTable.clear()   
      //setting identifier (properties that will be treated diferently
      modelPattern.featureIdentifier.each{ str | featureIdentifiers.add(str)}
      //setting roles (variables in flora) in the objectTable
	  var tableWithVariables : IDTableWithVariable 
	  tableWithVariables  ?= objTable	          
      tableWithVariables.setRoles(modelPattern.pattern.roles)
       
      modelPattern.pattern.content.each { o | 
          var clauses : flora2::Clause[0..*] init clausesAboutObject( o, true)
  	      var queryAux : flora2::Query
  	      queryAux ?= clauses.one
  	      formula.elements.add(queryAux.body)
  	   }   
  	   
      modelPattern.falsepositivepatterns.each{ negmodel |
     	 tableWithVariables.setRoles(negmodel.roles)      
      
     	 var negationClause : flora2::Negation init flora2::Negation.new
     	 var negformula : flora2::CompoundedFormula init flora2::CompoundedFormula.new      
	     negformula.operator := flora2::ConnectiveOp.conjunctionOp      	       	 
     	 negationClause.expression := negformula     
         negmodel.content.each { o | 
            var clauses : flora2::Clause[0..*] init clausesAboutObject( o, true)
  	        var queryAux : flora2::Query
     	    queryAux ?= clauses.one
  	        negformula.elements.add( queryAux.body)
  	     }
  	      formula.elements.add(negationClause)  	     
  	   }  	     	   
       result := query
   end		

   // return a set of query for each object
   method transformModel(objects: Set<Object>) : flora2::Clause[0..*] is do 
      var clauses : oset flora2::Clause[0..*] init OrderedSet<flora2::Clause>.new
      objTable.clear()
      objects.each { o | clauses.addAll (clausesAboutObject( o, true))} 
       result := clauses
   end		
   
	method createStandardClause(body : flora2::Expression) : flora2::Clause is do
	     var query : flora2::Query init flora2::Query.new
	     query.body := body  
	     result := query
	end
	
	method getExpressionFromStandardClause(clause : flora2::Clause) : flora2::Expression  is do
	   var query : flora2::Query init flora2::Query.new
       query ?= clause
       result := query.body
	end	   	 

	method getTermOfAnDataType(objHost : Object,  pro : Property, proInstance: Object) : flora2::Term is do
	    var term : flora2::Term  
        var tableWithVariables : IDTableWithVariable 
        tableWithVariables  ?= objTable	 	    
        
	     if PObject.isInstance(objHost) and tableWithVariables.isVariant(objHost) and
	        (featureIdentifiers.exists{ str | str.equals(pro.name)} 
	            or proInstance.isVoid) then
           
          term := tableWithVariables.getInrelevantVariableID( proInstance)    	    
        else
          term := super(objHost, pro, proInstance) 
        end
        result := term
    end    
	
	// the  method getTermOfPropertyInstance does not need to be redifined, because no pending definition about
	// the property instance will be 
 

	operation lastIdVariants ( template : ModelPattern) : OrderedSet<String> is do	
      var vars : OrderedSet<String> init OrderedSet<String>.new	

      template.pattern.roles.each{r |  vars.add(objTable.getId( r.player))}
      template.falsepositivepatterns.each{ negmodel |      
           negmodel.roles.each{ r  |
                    vars.add(objTable.getId( r.player))}}
       result := vars
	end  

}

class Model2Flora inherits Ecore2FloraBasicElements { 	
   attribute objTable : IDTable
   attribute packageName : String 
   attribute handler : ReflectionHandler 
   	
   operation initialize() is do
      objTable := IDTable.new
      handler := ReflectionHandler.new
      objTable.initialize()
   end	
   
   operation initializeTable(table : IDTable) is do
      objTable := table
      handler := ReflectionHandler.new
   end	   
   	
   operation transformModel(objects: Set<Object>) : flora2::Clause[0..*] is do 
      var clauses : oset flora2::Clause[0..*] init OrderedSet<flora2::Clause>.new
      objTable.clear
      objects.each { o | clauses.addAll (clausesAboutObject( o, false))} 

      result := clauses
   end	
   
   operation clausesAboutObject(obj : Object, isToCompoundClauses : Boolean) : flora2::Clause[0..*] is do 
      var clauses : oset flora2::Clause[0..*] init OrderedSet<flora2::Clause>.new
	  var formula : flora2::CompoundedFormula init flora2::CompoundedFormula.new      
	  formula.operator := flora2::ConnectiveOp.conjunctionOp      
      
      // create a initial clause. Declaration will have Facts and Patterns Queries  
	  clauses.add( createStandardClause(formula)) 	  
      // Adding type declaration ( obj : Class)
	  formula.elements.add( createsInstanceClause(objTable.getTermId(obj), obj.getMetaClass.name))
	  
	  var pendingClauses : OrderedSet <flora2::Clause> init OrderedSet<flora2::Clause>.new
	  var pros : OrderedSet<Property> init OrderedSet<Property>.new
	  pros.addAll( obj.getMetaClass.ownedAttribute)	  
      handler.getAllSuperClasses(obj.getMetaClass).each{c | pros.addAll(c.ownedAttribute)} 

      from var it2 : Iterator<Property> init pros.iterator
      until it2.isOff loop             
        var pro : Property init it2.next
        var propertyInstances : Sequence<Object> init handler.getSequenceProperties(obj, pro)
        
        // Each instance of a property has it own expression
        //for example Obj[name -> "toto"], ..., Obj[address -> "Rennes"]
        from var it3 : Iterator<Object> init propertyInstances.iterator      
        until it3.isOff loop        
          var inst : Object init it3.next
          var proType : Type init  pro.type
          
          // already exists a clause for the instance?
          var term : flora2::Term           
          if ( Class.isInstance( proType)) then
             if (not objTable.hasAnId(inst) ) then
                pendingClauses.addAll( clausesAboutObject(inst, isToCompoundClauses))
             end   
             term := getTermOfPropertyInstance(obj, pro, inst)
          else
            var dataType : DataType 
            dataType ?= proType           
          
            term := getTermOfAnDataType(obj, pro, inst) 
            clauses.add( createStandardClause( createsInstanceClause(term, dataType.name))) 
          end

//             if not (PNamedElement.isInstance(obj) and inst.isVoid) then   
          if ( term != void) then formula.elements.add(createsDataClause(objTable.getTermId(obj), pro.name, term)) end
        end   
      end  
      
      pendingClauses.each{ auxClause | 
         if not isToCompoundClauses then
            clauses.add(auxClause)
         else 
	        formula.elements.add( getExpressionFromStandardClause( auxClause))
         end
      }

	  result := clauses           	
	end   
	
	operation createStandardClause(body : flora2::Expression) : flora2::Clause is do
	     var fact : flora2::Fact init flora2::Fact.new
	     fact.expression := body  
	     result := fact 
	end
	
	operation getExpressionFromStandardClause(clause : flora2::Clause) : flora2::Expression  is do
       var fact : flora2::Fact 
       fact ?= clause
       result := fact.expression
	end	
	
	operation getTermOfAnDataType(objHost : Object, pro : Property, proInstance : Object) : flora2::Term is do
	   var term : flora2::Term  
        if proInstance.getMetaClass.name == "String" then
          var strTerm : flora2::String init flora2::String.new
          strTerm.strName ?= proInstance
          term := strTerm
        else if proInstance.getMetaClass.name == "Integer" then
          var intTerm : flora2::Integer init flora2::Integer.new
          intTerm.intName ?= proInstance
          term := intTerm              
        else if proInstance.getMetaClass.name == "Boolean" then                        
          // FIXME see how to represent it in Flora
        end end end
       result := term   
	end
	
	operation getTermOfPropertyInstance(objHost : Object, pro : Property, proInstance: Object) : flora2::Term is do
       result := objTable.getTermId(proInstance)	         
	end 
}

/* class that manages an unique id for each object */
class IDTable {

   attribute  forwardTable : Hashtable<Object, String>
   attribute  reverseTable : Hashtable<String, Object>   
   attribute handler : ReflectionHandler 
   	
   operation initialize() is do
      forwardTable := Hashtable<Object, String>.new
      reverseTable := Hashtable<String, Object>.new      
      handler := ReflectionHandler.new
   end	
   
  /* This method controls a hashtable of Obj-> Id in order to give a unique Id 
     for each object */	   
   operation getId( obj : Object) : String is do
      if forwardTable.getValue(obj) == void  then 
         assignIDObj("obj"+obj.oid.toString, obj)
      end      
      result := forwardTable.getValue(obj)
   end
   
   operation assignIDObj(newId : String, obj :Object ) is do
     forwardTable.put(obj, newId)   
     // give priority for the fist insertion in the reversetable
     if (reverseTable.getValue(newId) == void) then
         reverseTable.put(newId, obj)  
     end      
   end

   operation getObj( strId : String) : Object is do
      result := reverseTable.getValue(strId) 
   end

   operation clear() is do 
      forwardTable.clear
      reverseTable.clear
   end
  
  operation hasAnId( obj : Object) : Boolean is do
       result := forwardTable.getValue(obj) != void 
  end   
  
   operation getTermId( obj : Object) : flora2::Constant is do   
     var termId : flora2::Constant init flora2::Constant.new
     termId.symbolName := getId(obj)
     result := termId
   end  
}
   
class IDTableWithVariable inherits IDTable {
   reference roles : PRole[0..*]

   method initialize() is do
      roles := OrderedSet<PRole>.new
      super()
   end
      
   operation initializeRoles(rol : PRole[0..*]) is do  
      initialize()
      roles.addAll(rol)
   end
   
   operation setRoles(rol : PRole[0..*]) is do
     roles.clear
     roles.addAll(rol)     
   end
   
  /* This method controls a hashtable of Obj-> Id in order to give a unique Id 
     for each object */	   
   method getId( obj : Object) : String is do
      if not hasAnId(obj) then 
         var newId : String          
         if isVariant(obj) then
            newId := "?"+roleOfVariant(obj)         
         else
            newId := "?_"+"obj"+obj.oid.toString
         end              
          
         assignIDObj(newId, obj)
      end
      
      result := super(obj)
   end
     
  operation isVariant (obj : Object) : Boolean is do	           
    result := roles.exists{r | r.player.equals(obj)}             
  end  

  operation roleOfVariant (obj : Object) : String is do	           
    result := roles.detect{r | r.player.equals(obj)}.name
  end       	
	
	  
	operation getInrelevantVariableID (obj : Object) : flora2::Term is do 
	  var varTerm : flora2::Variable init flora2::Variable.new
	  varTerm.symbolName := "?_obj"+obj.oid().toString
	  result := varTerm		
	end  
 
}
