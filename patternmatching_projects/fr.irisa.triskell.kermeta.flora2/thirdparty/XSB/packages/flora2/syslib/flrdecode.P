/* File:        flrdecode.P  -- Decoder; used for human-readability
**
** Author(s): Michael Kifer
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) The Research Foundation of SUNY, 2003
**
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** 
** 
*/


:- compiler_options([xpp_on]).

#include "flrheader.flh"
#include "flora_terms.flh"
#include "flora_porting.flh"
#include "flora_characters.flh"



:- import
	flatten/2,
        ground/1
   from basics.

%%:- import term_to_atom/2 from string.

:- import
	flora_decode_predicate/6,
        is_flora_callable_literal/1
    from flrwrapper.
:- import flora_prlgdef/2 from flrprolog.
:- import flora_opdef/3 from flroperator.

:- import
	flora_concat_items/2,
	flora_concat_atoms/2,
	flora_get_substring/4,
	flora_match_substring/5
   from flrporting.

:- import flora_warning_line/2 from flrprint.

:- import flora_abort/1 from flrutils.

:- import flora_trim_last/2 from flrtrim.

:- export 
	flora_decode_goal_as_list/2,
	flora_decode_goal_as_atom/2,
	flora_decode_oid_as_list/2,
	flora_decode_oid_as_atom/2,
	flora_write_goal/1,
	flora_write_goal/2,
	flora_write_oid/1,
	flora_write_oid/2,
	flora_write_fact/1,
	flora_write_fact/2,
	flora_write_rule_head/1,
	flora_write_rule_head/2,
	flora_write_rule_body/1,
	flora_write_rule_body/2.	



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_goal %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_goal(Stream,Goal) :-
	flora_decode_goal(Goal,Code,0),
	flatten(Code,FlatCode),
	write_flat_code(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_goal(Goal) :-
	telling(Stream),
	flora_write_goal(Stream,Goal).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_oid %%%%%%%%%%%%%%%%%%%%%%%%%%%
	
flora_write_oid(Stream,Goal) :-
	flora_decode_oid(Goal,Code),
	flatten(Code,FlatCode),
	write_flat_code(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_oid(Goal) :-
	telling(Stream),
	flora_write_oid(Stream,Goal).
			
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_fact %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_fact(Stream,Goal) :-
	flora_decode_fact(Goal,Code,0),
	flatten(Code,FlatCode),
	write_flat_code_without_ws(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_fact(Goal) :-
	telling(Stream),
	flora_write_fact(Stream,Goal).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_rule_head %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_rule_head(Stream,Goal) :-
	flora_decode_goal(Goal,Code,0),
	flatten(Code,FlatCode),
	write_flat_code_without_ws(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_rule_head(Goal) :-
	telling(Stream),
	flora_write_rule_head(Stream,Goal).
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_rule_body %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_rule_body(Stream,Goal) :-
	flora_decode_goal(Goal,Code,0),
	flatten(Code,FlatCode),
	write_flat_code(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_rule_body(Goal) :-
	telling(Stream),
	flora_write_rule_body(Stream,Goal).
		


write_flat_code(_,[]) :- !.
write_flat_code(Stream,[H|T]) :-
	nonvar(H),
	H = [_|_],
	!,
	write_flat_code(Stream,H),
	write_flat_code(Stream,T).
write_flat_code(Stream,[H|T]) :-
	!,	
	(var(H) ->
	   write(Stream,FL_VARSYM),
	   write(Stream,H)	      
	 ;
	 write(Stream,H)
	),
	write_flat_code(Stream,T).

write_flat_code_without_ws(_,[]) :- !.

write_flat_code_without_ws(Stream,[H|T]) :-
	nonvar(H),
	H = [_|_],
	!,
	write_flat_code_without_ws(Stream,H),
	write_flat_code_without_ws(Stream,T).

write_flat_code_without_ws(Stream,[H|T]) :-	
	!,
	(H == FL_AT -> 
	   write(Stream,'');
	   (
	    (var(H) ->
	      write(Stream,FL_VARSYM),
	      write(Stream,H)	      
	    ;
	    write(Stream,H)
	    ),
	   write_flat_code_without_ws(Stream,T)
	   )
	).
		


%%%%%%%%%%%%%%%%%%%%%%%% flora_decode_goal_as_atom/2 %%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_decode_goal_as_atom(Goal,CodeAtom) :-
	flora_decode_goal_as_list(Goal,Code),
	flora_concat_items(Code,CodeAtom).

%%%%%%%%%%%%%%%%%%%%%%%% flora_decode_goal_as_list/2 %%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_decode_goal_as_list(Goal,FlatCode) :-
	flora_decode_goal(Goal,Code,0),
	flatten(Code,FlatCode).

%%%%%%%%%%%%%%%%%%%%%%%% flora_decode_oid_as_atom/2 %%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_decode_oid_as_atom(Goal,CodeAtom) :-
	flora_decode_oid_as_list(Goal,Code),
	flora_concat_items(Code,CodeAtom).

%%%%%%%%%%%%%%%%%%%%%%%% flora_decode_oid_as_list/2 %%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_decode_oid_as_list(Goal,FlatCode) :-
	flora_decode_oid(Goal,Code),
	flatten(Code,FlatCode).

%%%%%%%%%%%%%%%%%%%%% flora_decode_fact(+Call,-Code,+Depth) %%%%%%%%%%%%%%%%%
%% Returns a (possibly nested) list of atoms whose concatenation           %%
%% represents a readable representation of Fact                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	

flora_decode_fact(Call,Code,Depth) :-
	classify_call(Call,Type,Basename,ArgList,Workspace),
	Depth1 is Depth+1,
	( Type == (hilog)
	-> decode_hilog_call_without_trimming_last_arg(Basename,ArgList,Workspace,Code,0,Depth1)
        ; Type == (nontabled-hilog)
        -> decode_nontabled_hilog_call_non_trim_last(Basename,ArgList,Workspace,Code,0,Depth1)
	; Type == (flogic)
	-> decode_molecule(Basename,ArgList,Workspace,Code,0,Depth1)
	),
	!.

	
%%%%%%%%%%%%%%%%%%%%% flora_decode_goal(+Goal,-Code,+Depth) %%%%%%%%%%%%%%%%%
%% Returns a (possibly nested) list of atoms whose concatenation           %%
%% represents a readable representation of Goal                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_decode_goal(Call,[FL_VARSYM,Call],_Depth) :-
	var(Call), !.

flora_decode_goal(Call,Code,Depth) :-
	classify_call(Call, Type,Basename,ArgList,Workspace),
	(Type = (basefact,CallType)
	-> Code = ['(Checking against base facts) '|RestCode]
	;  Code = RestCode, Type = CallType
	),
	Depth1 is Depth+1,
	( CallType == (hilog)
	-> 
	    (var(Workspace)
	    -> decode_hilog_term(Basename,ArgList,RestCode,1,Depth1)
	    ;
		decode_hilog_call(Basename,ArgList,Workspace,RestCode,0,Depth1)
	    )
        ; CallType == (nontabled-hilog)
        -> decode_nontabled_hilog_call(Basename,ArgList,Workspace,RestCode,0,Depth1)
	; CallType == (flogic)
	-> decode_molecule(Basename,ArgList,Workspace,RestCode,0,Depth1)
	; CallType == (inheritance)
	-> decode_molecule(Basename,ArgList,Workspace,MolCode,0,Depth1),
	    RestCode = ['(Trying to derive by inheritance) '|MolCode]
	; CallType == (explicit_definition)
	-> decode_molecule(Basename,ArgList,Workspace,MolCode,0,Depth1),
	    RestCode = ['(Checking explicit definition for method) '|MolCode]
	; CallType == (dynhead_before)
	-> decode_molecule(Basename,ArgList,Workspace,MolCode,0,Depth1),
	    RestCode = ['(Trying to derive via dynamic before-rules) '|MolCode]
	; CallType == (dynhead_after)
	-> decode_molecule(Basename,ArgList,Workspace,MolCode,0,Depth1),
	    RestCode = ['(Trying to derive via dynamic after-rules) '|MolCode]
	),
	!.


%% The rest are classified as Prolog. These can be real prolog terms
%% or Flora primitives like insert{...}, throw{...}, etc.
%% Even if a call is a prolog call, its arguments can be Flora stuff, so
%% decode_literal_internal/3 processes them accordingly.
flora_decode_goal(Call,Code,Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(Call,Code,0,Depth1),
	!.

%% Debugging
flora_decode_goal(Call,_,_) :-
	flora_abort([Call,': flora_decode_goal/2 failed to decode']).


%%%%%%%%%%%%%%%%%%%% flora decode oid %%%%%%%%%%%%%%%%%%%%%%%
%% Call is an oid, although it may be a reified term.
flora_decode_oid(Call,Code) :-
	decode_literal_internal(Call,Code,1,0).



%%%%%%%%%%%%%%%%%%%% decode_head %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
decode_head(Head,HeadCode,Depth) :-
	Depth1 is Depth+1,
	(is_list(Head)
	-> decode_list_add_separator(Head,HeadCode,flora_decode_goal(_,_,Depth1),', ')
	; flora_decode_goal(Head,HeadCode,Depth1)
	).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Decoding molecule %%%%%%%%%%%%%%%%%%%%%%%%%

%% Level=0: top level; Level=1: reified predicate/molecule argument of a functor
decode_molecule(Wrapper,ComponentList,Workspace,[ReifyStart,[MolCode|WCode],ReifyEnd],Level,Depth) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	(flora_match_substring(FLDEBUGPREFIX,Wrapper,forward,0,End),! ; End=0),
	flora_get_substring(Wrapper,End,_,BaseWrapper),
	decode_list_as_list(ComponentList,ComponentListCode,decode_literal_internal(_,_,1,Depth1)),
	decode_molecule_base(BaseWrapper,ComponentListCode,MolCode),
	workspace_code(Workspace,WCode).

%% Wrapper, Args, Code
decode_molecule_base(WRAP_MVD, [O,M,V|_], [O,'[',M,' -> ',V,']']).
decode_molecule_base(WRAP_MVDDEF, [O,M|_], [O,'..',M,'[]']).
decode_molecule_base(WRAP_IMVD, [O,M,V|_], [O,'[',M,' *-> ',V,']']).
decode_molecule_base(WRAP_IMVDDEF, [O,M|_], [O,'!',M,'[]']).
decode_molecule_base(WRAP_MVDSIG, [O,M,V|_], [O,'[',M,' => ',V,']']).
decode_molecule_base(WRAP_IMVDSIG, [O,M,V|_], [O,'[',M,' *=> ',V,']']).
decode_molecule_base(WRAP_BOOLSIG, [O,P|_], [O,'[',' => ',P,']']).
decode_molecule_base(WRAP_IBOOLSIG, [O,P|_], [O,'[',' *=> ',P,']']).
decode_molecule_base(WRAP_TRANSIG, [O,P|_], [O,'[',' =>% ',P,']']).
decode_molecule_base(WRAP_ITRANSIG, [O,P|_], [O,'[',' *=>% ',P,']']).
decode_molecule_base(WRAP_MVDCON, [O,M,L,U|_], [O,'[',M,'{',L,':',U,'}=>?']).
decode_molecule_base(WRAP_IMVDCON, [O,M,L,U|_], [O,'[',M,'{',L,':',U,'}*=>?']).
decode_molecule_base(WRAP_MVDCONDEF, [O,M,L,U|_], [O,'[',M,'{',L,':',U,'}=>?']).
decode_molecule_base(WRAP_IMVDCONDEF, [O,M,L,U|_], [O,'[',M,'{',L,':',U,'}*=>?']).
decode_molecule_base(WRAP_MVDINC, [O,M,V|_], [O,'[',M,' +>> ',V,']']).
decode_molecule_base(WRAP_IMVDINC, [O,M,V|_], [O,'[',M,' *+>> ',V,']']).
decode_molecule_base(WRAP_MVDTOLIST, [O,M,V|_], [O,'[',M, ' ->-> ',V,']']).
decode_molecule_base(WRAP_IMVDTOLIST, [O,M,V|_], [O,'[',M, ' *->-> ',V,']']).
decode_molecule_base(WRAP_ISA, [O,C|_], [O,':',C]).
decode_molecule_base(WRAP_SUB, [Sub,Sup|_], [Sub,'::',Sup]).
decode_molecule_base(WRAP_EXISTS, [O|_], [O,'[',']']).
%% boolean method
decode_molecule_base(WRAP_METH, [O,P|_], [O,'[',P,']']).
%% inheritable boolean method
decode_molecule_base(WRAP_IMETH, [O,P|_], [O,'[*',P,']']).
%% procedural boolean method
decode_molecule_base(WRAP_TRAN, [O,P|_], [O,'[%',P,']']).

decode_molecule_base(WRAP_OBJEQL, [O1,O2|_], [O1,' :=: ',O2]).

%%%%%%%%%%%%%%%%%%%%% Decode HiLog Call %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Level=0: top level; Level=1: reified predicate argument of a functor
decode_nontabled_hilog_call(HiLogPred,Args,WS,[ReifyStart,'%',Code,ReifyEnd],Level,Depth) :-
        decode_hilog_call(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth).

decode_hilog_call(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth) :-
	((Level==0; var(WS))
	-> ReifyStart='',ReifyEnd=''
	; ReifyStart='${',ReifyEnd='}'
	),
	Depth1 is Depth+1,
	decode_literal_internal(HiLogPred,HiLogPredCode,1,Depth1),
	Code = [HiLogPredCode|RestCode1],
	%% var(WS), Level>0 means it is hilog term, not predicate
	(var(WS), Level > 0
	-> Args = ArgsTruncated
	;
	    flora_trim_last(Args,ArgsTruncated)
	),
	(ArgsTruncated == []
	-> ((nonvar(WS) ; Level==0), atom(HiLogPred) % top level proposition & a == a()
	   -> RestCode1 = RestCode2
	   ; RestCode1 = ['(',')'|RestCode2]
	   )
	;
	    decode_list_add_separator(ArgsTruncated,ArgCode1,decode_literal_internal(_,_,1,Depth1),','),
	    RestCode1 = ['(',ArgCode1,')'|RestCode2]
	),
	(nonvar(WS)
	-> workspace_code(WS,WSCode),
	    RestCode2 = WSCode
	; RestCode2 = []
	).
	

decode_nontabled_hilog_call_non_trim_last(HiLogPred,Args,WS,[ReifyStart,'%',Code,ReifyEnd],
  Level,Depth) :-
        decode_hilog_call_without_trimming_last_arg(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth).
	
decode_hilog_call_without_trimming_last_arg(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth) :-
	((Level==0; var(WS))
	-> ReifyStart='',ReifyEnd=''
	; ReifyStart='${',ReifyEnd='}'
	),
	Depth1 is Depth+1,
	decode_literal_internal(HiLogPred,HiLogPredCode,1,Depth1),
	Code = [HiLogPredCode|RestCode1],
		
	(Args == []
	-> ((nonvar(WS) ; Level==0), atom(HiLogPred) % top level proposition & a == a()
	   -> RestCode1 = RestCode2
	   ; RestCode1 = ['(',')'|RestCode2]
	   )
	;
	    decode_list_add_separator(Args,ArgCode1,decode_literal_internal(_,_,1,Depth1),','),
	    RestCode1 = ['(',ArgCode1,')'|RestCode2]
	),
	(nonvar(WS)
	-> workspace_code(WS,WSCode),
	    RestCode2 = WSCode
	; RestCode2 = []
	).	

decode_hilog_term(HiLogPred,Args,Code,Level,Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(HiLogPred,HiLogPredCode,1,Depth1),
	Code = [HiLogPredCode|RestCode1],
	(Args == []
	-> (Level==0
	   -> RestCode1 = RestCode2
	   ; RestCode1 = ['(',')'|RestCode2]
	   )
	;
	    decode_list_add_separator(Args,ArgCode1,decode_literal_internal(_,_,1,Depth1),','),
	    RestCode1 = ['(',ArgCode1,')'|RestCode2]
	),
	RestCode2 = [].


%%%%%%%%%%%%%%%%%%%%%% Decode Prolog Call %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% flora prolog-style builtin: declared as flora_prlg in flrprolog.P
decode_prolog_call([F,Args,Arity],Code,Depth) :-
	flora_prlgdef(F,Arity),
	!,
	Depth1 is Depth+1,
	decode_builtin(F,Arity,Args,Code,Depth1).
%% prolog call
decode_prolog_call([F,Args,_Arity],Code,Depth) :-
        escape(F,EscF),
	(Args == []
	->  Code = [EscF,'@prolog()']
	;
	    Depth1 is Depth+1,
	    decode_list_add_separator(Args,ArgsCode,decode_literal_internal(_,_,1,Depth1),','),
	    Code = [EscF,'(',ArgsCode,')@prolog()']
	).

decode_builtin(F,0,_,[EscF],_Depth) :- escape(F,EscF), !.
%% This would have to be expanded to deal with unary ops 
%% (i.e., print them as op arg)
decode_builtin(F,1,[Arg],[EscF,'(',ArgCode,')'],Depth) :-
	!,
	Depth1 is Depth+1,
        escape(F,EscF),
	decode_literal_internal(Arg,ArgCode,1,Depth1).
%% This deals with binary ops
decode_builtin(F,2,[Arg1,Arg2],Code,Depth) :-
	!,
        escape(F,EscF),
	Depth1 is Depth+1,
	decode_literal_internal(Arg1,Arg1Code,1,Depth1),
	decode_literal_internal(Arg2,Arg2Code,1,Depth1),
	((flora_opdef(_,xfx,F); flora_opdef(_,yfx,F); flora_opdef(_,xfy,F))
	->  Code = [Arg1Code, ' ', EscF, ' ', Arg2Code]
	;   Code = [EscF,'(',Arg1Code,',',Arg2Code,')']
	).
decode_builtin(F,_,Args,[EscF,'(',ArgsCode,')'],Depth) :-
	Depth1 is Depth+1,
        escape(F,EscF),
	decode_list_add_separator(Args,ArgsCode,decode_literal_internal(_,_,1,Depth1),',').


%%%%%%%%%%%%%%%%%%%%%% IF %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_if_statement([Cond,Then],['if (',CondCode,') then (',ThenCode,')']) :-
	flora_decode_goal(Cond,CondCode,0),
	flora_decode_goal(Then,ThenCode,0).
decode_if_statement([Cond,Then,Else],['if (',CondCode,') then (',ThenCode,') else (',ElseCode,')']) :-
	flora_decode_goal(Cond,CondCode,0),
	flora_decode_goal(Then,ThenCode,0),
	flora_decode_goal(Else,ElseCode,0).

%%%%%%%%%%%%%%%%%%%%%% UNLESS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_unless(Cond,Action,['unless (',CondCode,') do (',ActionCode,')']) :-
	flora_decode_goal(Cond,CondCode,0),
	flora_decode_goal(Action,ActionCode,0).


%%%%%%%%%%%%%%%%%%%%%% WHILE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_while(LoopType,Cond,Action,['while (',CondCode,') ',LoopType,' (',ActionCode,')']) :-
	flora_decode_goal(Cond,CondCode,0),
	flora_decode_goal(Action,ActionCode,0).

%%%%%%%%%%%%%%%%%%%%%% UNTIL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_until(LoopType,Action,Cond,[LoopType,' (',ActionCode,') until (',CondCode,')']) :-
	flora_decode_goal(Action,ActionCode,0),
	flora_decode_goal(Cond,CondCode,0).


%%%%%%%%%%%%%%%%%%%%% Updates %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is_update_call(FLLIBINSERT, FL_INSERT).
is_update_call(FLLIBINSERTALL, FL_INSERTALL).
is_update_call(FLLIBBTINSERT, FL_BTINSERT).
is_update_call(FLLIBBTINSERTALL, FL_BTINSERTALL).
is_update_call(FLLIBDELETE, FL_DELETE).
is_update_call(FLLIBDELETEALL, FL_DELETEALL).
is_update_call(FLLIBBTDELETE, FL_BTDELETE).
is_update_call(FLLIBBTDELETEALL, FL_BTDELETEALL).
is_update_call(FLLIBERASE, FL_ERASE).
is_update_call(FLLIBERASEALL, FL_ERASEALL).
is_update_call(FLLIBBTERASE, FL_BTERASE).
is_update_call(FLLIBBTERASEALL, FL_BTERASEALL).
is_update_call(FLLIBINSERTRULE_A, FL_INSERTRULE_A).
is_update_call(FLLIBINSERTRULE_Z, FL_INSERTRULE_Z).
is_update_call(FLLIBDELETERULE_A, FL_DELETERULE_A).
is_update_call(FLLIBDELETERULE_Z, FL_DELETERULE_Z).
is_update_call(FLLIBDELETERULE, FL_DELETERULE).

%% Level=0: top level;
%% Level=1: reified predicate/molecule argument of a functor
decode_update(UpdName,
	      [UpdLiterals],
	      [ReifyStart,UpdName,'{',UpdLiteralsCode,'}',ReifyEnd],
	      Level) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_update_literals(UpdLiterals,UpdLiteralsCode).

decode_update(UpdName,
	      [UpdLiterals,Query],
	      [ReifyStart,UpdName,'{',UpdLiteralsCode,'| ',QueryCode,'}',ReifyEnd],
	      Level) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_literal_internal(Query,QueryCode,0,0),
	decode_update_literals(UpdLiterals,UpdLiteralsCode).

%% decodes lists of update literals [FLSYSDBUPDATE(Lit,_Storage,_Module),...]
decode_update_literals([],[]) :- !.
decode_update_literals([H|L],[H|LCode]) :-
        var(H),
        !,
        decode_update_literals(L,LCode).
decode_update_literals([FLSYSDBUPDATE(Lit,_Storage,_Module)|T],[LitCode,Comma|TCode]) :-
	!,
	decode_literal_internal(Lit,LitCode,0,0),
	(T == [] -> Comma = '' ; Comma = ', '),
	decode_update_literals(T,TCode).
decode_update_literals([FLSYSRULEUPDATE(Head,Body,_,_)|T],
		       [[HeadCode,' :- ', BodyCode],Comma|TCode]) :-
	!,
	decode_head(Head,HeadCode,0),
        decode_literal_internal(Body,BodyCode,0,0),
	(T == [] -> Comma = '' ; Comma = ', '),
	decode_update_literals(T,TCode).
decode_update_literals([H|T],[HCode|TCode]) :-
	H= FLLIBMODLIT(_,_,_,_),
	!,
	decode_literal_internal(H,HCode,0,0),
	decode_update_literals(T,TCode).

decode_update_literals([Lit|T],[LitCode,Comma|TCode]) :-
	decode_literal_internal(Lit,LitCode,0,0),
	(T == [] -> Comma = '' ; Comma = ', '),
	decode_update_literals(T,TCode).


%%%%%%%%%%%%%%%%%%%%% Aggregate Ops %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Level=0: top level; Level=1: reified predicate/molecule argument of a functor
decode_aggregate(AggName,AggVar,GrpVarList,Query,AggResult,
		 [ReifyStart,AggResultCode,' = ',AggName,
		  '{',AggVar,GrpVarListCode,'| ',QueryCode,'}',ReifyEnd],
		 Level) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_literal_internal(AggResult,AggResultCode,0,0),
	(GrpVarList==[]
	-> GrpVarListCode = ''
	;  decode_list_add_separator(GrpVarList,InterimCode,=(_,_),','),
	    GrpVarListCode = ['[',InterimCode,']']
	),
	decode_literal_internal(Query,QueryCode,0,0).

is_aggregate_call(FLLIBMIN,FL_MIN).
is_aggregate_call(FLLIBMAX,FL_MAX).
is_aggregate_call(FLLIBSUM,FL_SUM).
is_aggregate_call(FLLIBAVG,FL_AVG).
is_aggregate_call(FLLIBCOUNT,FL_COUNT).
is_aggregate_call(FLLIBCOLLECTSET,FL_COLLECTSET).
is_aggregate_call(FLLIBCOLLECTBAG,FL_COLLECTBAG).

%%%%%%%%%%%%%%%%%%%%%% Decode canonical form of a call %%%%%%%%%%%%%%%%%%%

decode_canon(FLCANON(_,_,_,Callable), Decoding,Depth) :-
	nonvar(Callable),
	!,
	Depth1 is Depth+1,
	flora_decode_goal(Callable,Decoding,Depth1).

decode_canon(FLCANON(InTerm,_,_Callable), Decoding,Depth) :-
	var(InTerm),
	!,
	Depth1 is Depth+1,
	flora_decode_goal(InTerm,Decoding,Depth1).

decode_canon(FLCANON(Wrap,Args,Mod,_Callable), Decoding,Depth) :-
	nonvar(Wrap),
	is_list(Args),
	!,
        %% FLCANON wraps only predicates but no terms
        ( var(Mod) -> flora_trim_last(Args,TrimmedArgs); Args=TrimmedArgs ),
	InTerm =.. [Wrap|TrimmedArgs],
	Depth1 is Depth+1,
	flora_decode_goal(InTerm,DecodedInTerm,Depth1),
	workspace_code(Mod,ModCode),
	Decoding = [DecodedInTerm,ModCode].

%% If this happens then need to debug
decode_canon(Canon,Canon,_Depth).


%%%%%%%%%%%%%%%%%%%%% Flora built-in primitives foo{...} %%%%%%%%%%%%%%%%%
decode_primitive(BuiltinName,ArgsCode,
		 [ReifyStart,BuiltinName,'{',ArgsCode,'}',ReifyEnd],
		 Level) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}').


%%%%%%%%%%%%%%%%%%%%%%%%%% Decode list as commalist %%%%%%%%%%%%%%%%%%
%% Takes a list, applies transformation ConversionCall(In,Out)      %%
%% and produces a list of the results separated by a separator      %%
%% The last arg specifies the separator between list items          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
decode_list_add_separator([],[],_,_) :- !.
decode_list_add_separator([L|R],[CodeL,'| ',CodeR],ConversionCall,_Separator) :-
	var(R),
	!,
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall1,L),
	call(ConversionCall1),
	arg(2,ConversionCall1,CodeL),
	arg(1,ConversionCall,R),
	call(ConversionCall),
	arg(2,ConversionCall,CodeR).

decode_list_add_separator([L],[CodeL],ConversionCall,_Separator) :-
	!,
	arg(1,ConversionCall,L),
	call(ConversionCall),
	arg(2,ConversionCall,CodeL).
decode_list_add_separator([L|R],[CodeL,'| ',CodeR],ConversionCall,_Separator) :-
	R \= .(_,_),
	!,
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall1,L),
	call(ConversionCall1),
	arg(2,ConversionCall1,CodeL),
	arg(1,ConversionCall,R),
	call(ConversionCall),
	arg(2,ConversionCall,CodeR).
decode_list_add_separator([L|R],[CodeL,Separator|CodeR],ConversionCall,Separator) :-
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall,L),
	call(ConversionCall),
	arg(2,ConversionCall,CodeL),
	decode_list_add_separator(R,CodeR,ConversionCall1,Separator).

%%%%%%%%%%%%%%%%%%%%%%%%%% decode list of goals as list %%%%%%%%%%%%%%%
%% Takes a list, applies transformation ConversionCall(In,Out)       %%
%% to each member and produces a list of the results                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
decode_list_as_list([],[],_) :- !.
decode_list_as_list([G|GoalList],[GCode|GoalCodeList],ConversionCall) :-
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall,G),
	call(ConversionCall),
	arg(2,ConversionCall,GCode),
	decode_list_as_list(GoalList,GoalCodeList,ConversionCall1).

/*
%%%%%%%%%%%%%%%%%%%%%%%%%% Decode commalist as commalist %%%%%%%%%%%%%
%% Takes a commalist (G1,G2,G3,...), applies transformation         %%
%% ConversionCall(In,Out) and produces a list of the results        %%
%% by a separator given in the last argument                        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
decode_commalist_add_separator((G1,G2),[CodeG1,Separator|CodeG2],ConversionCall,Separator) :-
	!,
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall,G1),
	call(ConversionCall),
	arg(2,ConversionCall,CodeG1),
	(var(G2) -> G2=CodeG2
	; decode_commalist_add_separator(G2,CodeG2,ConversionCall1,Separator)
	).

decode_commalist_add_separator(G,CodeG,ConversionCall,_Separator) :-
	!,
	arg(1,ConversionCall,G),
	call(ConversionCall),
	arg(2,ConversionCall,CodeG).
*/
	
%%%%%%%%%%%%%%%%%%%%%%%%%%% workspace_code %%%%%%%%%%%%%%%%%%%%%%%%%%%%
workspace_code(WS,WSCode) :-
	(((WS==main);(WS==FL_THISMODULE);(WS==FL_INVALIDMODULE))
	-> WSCode = []
	; WSCode = ['@',WS]
	).

%%%%%%%%%%%%%%%%%%%%%%%%%%% Decode anonymous OID %%%%%%%%%%%%%%%%%%%%%%
decode_anon_oid(NewOid,Code) :-
	atom(NewOid),
	flora_match_substring(FL_NEWOID_PREFIX,NewOid,forward,0,Pos),
	flora_get_substring(NewOid,Pos,_,Suffix),
	Code = ['_#''',Suffix].



%%%%%%%%%%%%%%%%%%%%%% Classifier %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classify_call(Call, Type,Basename,ArgList,Workspace) :-
	flora_decode_predicate(Call,Type1,Workspace,Prefix,Basename1,ArgList1),
	%% The following is a debugging statement.
	%% Helps weed out calls that should be suppressed by the debugger
	/*
	writeln(('Decodecall: ',Call,Type1,Workspace,Prefix,Basename1,ArgList,ArgList1)),
	*/
	(Type1 == (flora)
	-> (Prefix==inheritance_
	   -> Basename = Basename1, Type = (inheritance), ArgList = ArgList1

	   ; Prefix==local_
	   -> Basename = Basename1, Type = (explicit_definition), ArgList = ArgList1
	   
	   ; Prefix==dyna_ % This is actually hidden (possible future use)
	   -> Basename = Basename1, Type = (dynhead_before), ArgList = ArgList1
	   ; Prefix==dynz_ % This is actually hidden (possible future use)
	   -> Basename = Basename1, Type = (dynhead_after), ArgList = ArgList1

	   ;   %% must be a hilog predicate derivative formed by specialization
	       %% such as FLORA_PREFIX'usermod''main''flapply_#303'
	       flora_concat_atoms([WRAP_HILOG,'_'],Prefix)
	   ->  Type = (hilog), ArgList1 = [Basename | ArgList]
	   ; Type = Type1, Basename = Basename1, ArgList = ArgList1
	   )
	; Type1 == (prolog), Basename1 = flora_db_find_base,
	    Call = flora_db_find_base(Trie,RealCall),
	    flora_match_substring(FLORA_PREFIX,Trie,forward,0,_)
	->  %% Checking against base facts
	    flora_decode_predicate(RealCall,RealType,Workspace,_,Basename,ArgList),
	    Type = (basefact,RealType)
	%% Hilog term that is not a hilog predicate
	; Type1 == (prolog), (Basename1=WRAP_HILOG;Basename1=WRAP_TABLED_HILOG)
	->  Type = (hilog), ArgList1 = [Basename | ArgList]
        ; Type1 == (hilog), Prefix == ''
        ->  Type = (nontabled-hilog), Basename = Basename1, ArgList = ArgList1 
	; Type = Type1, Basename = Basename1, ArgList = ArgList1
	).


%%%%%%%%%%%%%%%%%%%% internal decode goal util %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Prevent loops on infinite terms
decode_literal_internal(_Call,['...'],_Level,Depth) :-
	Depth > 500,
	!.

%% Level=0: top level; Level=1: reified predicate/molecule arg of a functor
decode_literal_internal(Call,Code,_Level,_Depth) :-
	(atomic(Call);var(Call)),
	!,
	(atom(Call), flora_decode_predicate(Call,_,WS,_,Basename,_),
            escape(Basename,EscBasename),
	    nonvar(WS), nonvar(EscBasename)
	->  workspace_code(WS,WSCode),
	    Code = [EscBasename|WSCode]
	; decode_anon_oid(Call,OidCode)
	->  Code = OidCode
	;   Call == []
	->  Code = ['[',']']
	;   escape(Call,EscCall), Code = [EscCall]
	).

%%decode_literal_internal(FL_TRANSACTIONAL(Term),['%',Code],Level,Depth) :-
decode_literal_internal(FL_TRANSACTIONAL(Term),Code,Level,Depth) :-
        !,
        decode_literal_internal(Term,Code,Level,Depth).

decode_literal_internal(FL_URI(Term),['_','"',Code,'"'],Level,Depth) :-
        !,
        decode_literal_internal(Term,Code,Level,Depth).

decode_literal_internal(FLLIBNEWMODULE(_ThisModule,NewModuleName),
			[ReifyStart,FL_NEWMODULE,'{',NewModuleName,'}',ReifyEnd],
			Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}').

decode_literal_internal((NameOrVar = Var),[NameCode,' = ',Var],_Level,_Depth) :-
	var(Var),
	(var(NameOrVar),NameCode=NameOrVar; atom(NameOrVar),escape(NameOrVar,NameCode)),
	!.

%% This occurs when you have hilog-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODLIT(WRAP_HILOG,Args,Module,_Caller),Code,Level,Depth) :-
	!,
	%% Don't increment nesting level
	(nonvar(Args), !
	; flora_abort('FLLIBMODLIT(WRAP_HILOG,Args,Module,Caller): Internal error. Invalid goal in decode_literal_internal/3')
	),
	Args = [Basename|ArgList],
	Depth1 is Depth+1,
	(var(Module) ->
	    flora_trim_last(ArgList,TrimmedArgs),
	    decode_hilog_term(Basename,TrimmedArgs,TermCode,Level,Depth1),
	    workspace_code(Module,ModuleCode),
	    TCode = [TermCode, ModuleCode]
	;
	    decode_hilog_call(Basename,ArgList,Module,TCode,Level,Depth1)
	),
        (TCode = ['${'|Rest] ->
            Code = ['${','%'|Rest]
        ;
            Code = ['%',TCode]
        ).

decode_literal_internal(FLLIBMODLIT(WRAP_TABLED_HILOG,Args,Module,_Caller),Code,Level,Depth) :-
	!,
	%% Don't increment nesting level
	(nonvar(Args), !
	; flora_abort('FLLIBMODLIT(WRAP_TABLED_HILOG,Args,Module,Caller): Internal error. Invalid goal in decode_literal_internal/3')
	),
	Args = [Basename|ArgList],
	Depth1 is Depth+1,
	(var(Module) ->
	    flora_trim_last(ArgList,TrimmedArgs),
	    decode_hilog_term(Basename,TrimmedArgs,TermCode,Level,Depth1),
	    workspace_code(Module,ModuleCode),
	    Code = [TermCode, ModuleCode]
	;
	    decode_hilog_call(Basename,ArgList,Module,Code,Level,Depth1)
	).

%% This occurs when you have X@..., i.e., the literal part is a variable
decode_literal_internal(FLLIBMODLIT(FL_LIBMOD,Args,Module,_Caller),
			[ReifyStart,ArgCode,ModuleCode,ReifyEnd],
			Level,Depth) :-
	!,
	%% Don't increment nesting level
	((var(Args) ; atomic(Args))
	-> ArgCode = Args, workspace_code(Module,ModuleCode),
	   (Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}')
        ; (Args = FLLIBMODLIT(_,_,_,_); is_flora_callable_literal(Args)) ->
            ReifyStart='',ReifyEnd='',ModuleCode='',
	    Depth1 is Depth+1,
            decode_literal_internal(Args,ArgCode,Level,Depth1)
	;
	   (Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	    Depth1 is Depth+1,
	    decode_literal_internal(Args,ArgCode,Level,Depth1),
	    workspace_code(Module,ModuleCode)
	).

%% This occurs when you have flogic-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODLIT(Basename,Args,Module,_Caller),Code,Level,Depth) :-
	!,
	Depth1 is Depth+1,
	%% Don't increment nesting level
	decode_molecule(Basename,Args,Module,Code,Level,Depth1).


%% This occurs when you have hilog-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODOBJ(WRAP_HILOG,Args,Module,_Caller,ResultObj),
			[ResCode,'=','${',Code,'}'],Level,Depth) :-
	!,
	(nonvar(Args), !
	; flora_abort('FLLIBMODOBJ(WRAP_HILOG,Args,Module,Caller,Result): Internal error: Invalid goal in decode_literal_internal/3')
	),
	Args = [Basename|ArgList],
	Depth1 is Depth+1,
	(var(Module) ->
	    flora_trim_last(ArgList,TrimmedArgs),
	    decode_hilog_term(Basename,TrimmedArgs,TermCode,Level,Depth1),
	    workspace_code(Module,ModuleCode),
	    Code = ['%', TermCode, ModuleCode]
	;
	    decode_hilog_call(Basename,ArgList,Module,TCode,0,Depth1),
            (TCode = ['${'|Rest] -> Code = ['${','%'|Rest]; Code = ['%',TCode])
	),
	decode_literal_internal(ResultObj,ResCode,1,Depth1).

%% This occurs when you have hilog-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODOBJ(WRAP_TABLED_HILOG,Args,Module,_Caller,ResultObj),
			[ResCode,'=','${',Code,'}'],Level,Depth) :-
	!,
	(nonvar(Args), !
	; flora_abort('FLLIBMODOBJ(WRAP_TABLED_HILOG,Args,Module,Caller,Result): Internal error: Invalid goal in decode_literal_internal/3')
	),
	Args = [Basename|ArgList],
	Depth1 is Depth+1,
	(var(Module) ->
	    flora_trim_last(ArgList,TrimmedArgs),
	    decode_hilog_term(Basename,TrimmedArgs,TermCode,Level,Depth1),
	    workspace_code(Module,ModuleCode),
	    Code = [TermCode, ModuleCode]
	;
	    decode_hilog_call(Basename,ArgList,Module,Code,0,Depth1)
	),
	decode_literal_internal(ResultObj,ResCode,1,Depth1).

%% This occurs when you have X@..., i.e., the literal part is a variable
decode_literal_internal(FLLIBMODOBJ(FL_LIBMOD,Args,Module,_Caller,ResultObj),
			[ResCode, '=', '${',ArgCode,ModuleCode,'}'],
			_Level,Depth) :-
	!,
	Depth1 is Depth+1,
	((var(Args) ; atomic(Args)) -> ArgCode = Args
	;  decode_literal_internal(Args,ArgCode,0,Depth1)
	),
	decode_literal_internal(ResultObj,ResCode,1,Depth1),
        ( Module == FL_INVALIDMODULE ->
            ModuleCode = ''
        ;
	    workspace_code(Module,ModuleCode)
        ).

%% This occurs when you have flogic-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODOBJ(Basename,Args,Module,_Caller,ResultObj),
			[ResCode,'=',Code],_Level,Depth) :-
	!,
	Depth1 is Depth+1,
	%% Don't increment nesting level
	decode_molecule(Basename,Args,Module,Code,1,Depth1),
	decode_literal_internal(ResultObj,ResCode,1,Depth1).

decode_literal_internal(FLCANON(X,Y,Mod,Callable,_TF), Code,_Level,Depth) :-
	!,
	Depth1 is Depth+1,
	decode_canon(FLCANON(X,Y,Mod,Callable), Code,Depth1).


decode_literal_internal(FLLIBREFRESH(_ThisModule,GoalList),Code,Level,Depth) :-
	!,
	Depth1 is Depth+1,
	decode_list_add_separator(GoalList,GLCode,decode_literal_internal(_,_,0,Depth1),', '),
	decode_primitive(FL_REFRESH,GLCode,Code,Level).

decode_literal_internal(FLLIBCATCH(Call,Catcher,Handler),Code,Level,Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(Call,CallCode,0,Depth1),
	decode_literal_internal(Catcher,CatcherCode,0,Depth1),
	decode_literal_internal(Handler,HandlerCode,0,Depth1),
	decode_primitive(FL_CATCH,[CallCode,',',CatcherCode,',',HandlerCode],Code,Level).

decode_literal_internal(FLLIBTHROW(Catcher),Code,Level, Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(Catcher,CatcherCode,0,Depth1),
	decode_primitive(FL_THROW,CatcherCode,Code,Level).

decode_literal_internal(P2H_PREDICATE(Prolog,Hilog,_,_),Code,Level,Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(Prolog,PrologCode,0,Depth1),
	decode_literal_internal(Hilog,HilogCode,0,Depth1),
	decode_primitive(FL_P2H,[PrologCode,',',HilogCode],Code,Level).

decode_literal_internal(FLLIBIFTHENELSE(Cond,Then,Else),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_if_statement([Cond,Then,Else],Code).

decode_literal_internal(FLLIBIFTHEN(Cond,Then),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_if_statement([Cond,Then],Code).

decode_literal_internal(FLLIBUNLESSDO(Cond,Action),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_unless(Cond,Action,Code).

decode_literal_internal(FLLIBWHILEDO(Cond,Action),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_while('do',Cond,Action,Code).

decode_literal_internal(FLLIBWHILELOOP(Cond,Action),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_while('loop',Cond,Action,Code).

decode_literal_internal(FLLIBDOUNTIL(Action,Cond),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_until('do',Action,Cond,Code).

decode_literal_internal(FLLIBLOOPUNTIL(Action,Cond),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_until('loop',Action,Cond,Code).


decode_literal_internal(FLLIBNEWOID(Id),[ReifyStart,'newoid{',Id,'}',ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}').

decode_literal_internal(FLLIBTRUTHVALUE(Call,Truth),[ReifyStart,TruthCode,'{',CallCode,'}',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_literal_internal(Call,CallCode,0,Depth1),
	Truth=TruthCode.

%% flLoad in the form of [...]
decode_literal_internal(FLLIBLOAD([Arg],_,_,_),[ReifyStart,'[',LoadCode,']',ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	(Arg = '>>'(File,Module)
	-> LoadCode = [File,'>>',Module]
	;  LoadCode = Arg
	).

decode_literal_internal(FLLIBUNIVEQFORM(Left,Right),
		     [ReifyStart,LeftCode,' ',FL_UNIVEQFORM,' ',RightCode,ReifyEnd],
		     Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_literal_internal(Left,LeftCode,0,Depth1),
	decode_literal_internal(Right,RightCode,0,Depth1).

%% var commalist - protects the next two clauses from meaningless unification
decode_literal_internal((L,R),[ReifyStart,'(',[LCode,', '|RCode],')',ReifyEnd],Level,Depth) :-
	(var(L) ; var(R)),
	!,
	ReifyStart='',ReifyEnd='',
	Depth1 is Depth+1,
	decode_literal_internal(L,LCode,Level,Depth1),
	decode_literal_internal(R,RCode,Level,Depth1).

%% Call prolog predicate in a different module; must be before commalist
%% We loose the module name in decoding
decode_literal_internal((X =.. _List, call(X)),
			[ReifyStart,'call(',Code,')',ReifyEnd],
			Level,
			Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_literal_internal(X,Code,0,Depth1).

%% Aggregates should be handled before commalists
decode_literal_internal((Call, AggResultVar=InterimResultVar),Code,Level,_Depth) :-
	compound(Call),
	Call =.. [AggLib,AggVar,GrpVarList,Query,InterimResultVar],
	is_aggregate_call(AggLib,AggName),
	!,
	decode_aggregate(AggName,AggVar,GrpVarList,Query,AggResultVar,Code,Level).

%% commalist
decode_literal_internal((L,R),[ReifyStart,'(',[LCode,', '|RCode],')',ReifyEnd],Level,Depth) :-
	!,
	%%(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	ReifyStart='',ReifyEnd='',
	Depth1 is Depth+1,
	decode_literal_internal(L,LCode,Level,Depth1),
	decode_literal_internal(R,RCode,Level,Depth1).

%% list
decode_literal_internal(Call,['[', ']'],_Level,_Depth) :-
	Call == [],
	!.
decode_literal_internal(Call,['"', Code, '"'],_Level,_Depth) :-
	is_charlist(Call),
        ground(Call),
	!,
        escape(Call,EscCall),
	atom_codes(Code,EscCall).
decode_literal_internal('.'(H,T),['[',Code,']'],Level,Depth) :-
	!,
	Depth1 is Depth+1,
	decode_list_add_separator('.'(H,T),Code,decode_literal_internal(_,_,Level,Depth1),', ').
decode_literal_internal(';'(L,R),[ReifyStart,'(',LCode,'; ',RCode,')',ReifyEnd],Level,Depth) :-
	!,
	Depth1 is Depth+1,
	%%(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	ReifyStart='',ReifyEnd='',
	decode_literal_internal(L,LCode,Level,Depth1),
	decode_literal_internal(R,RCode,Level,Depth1).

%% Can this happen?
decode_literal_internal('->'(Call1,Call2),[ReifyStart,Call1Code,' -> ',Call2Code,ReifyEnd],Level,Depth) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_literal_internal(Call1,Call1Code,Level,Depth1),
	decode_literal_internal(Call2,Call2Code,Level,Depth1).

%% call(...), tnot(...), not(...), \+ (...)
decode_literal_internal(FLORA_TNOT_PREDICATE(Subcall),[ReifyStart,'(','not ',SubcallCode,')',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_decode_goal(Subcall,SubcallCode,Depth1).
decode_literal_internal(tnot(Subcall),[ReifyStart,'(not ',SubcallCode,')',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_decode_goal(Subcall,SubcallCode,Depth1).
decode_literal_internal(not(Subcall),[ReifyStart,'(\+ ',SubcallCode,')',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_decode_goal(Subcall,SubcallCode,Depth1).
decode_literal_internal('\+'(Subcall),[ReifyStart,'(\+ ',SubcallCode,')',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_decode_goal(Subcall,SubcallCode,Depth1).
decode_literal_internal(call(Subcall),[ReifyStart,'call(',SubcallCode,')',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_decode_goal(Subcall,SubcallCode,Depth1).

decode_literal_internal(FLSYSRULEUPDATE(Head,Body,_,_),
			[ReifyStart,HeadCode, ' :- ', BodyCode, ReifyEnd],
			Level, Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_head(Head,HeadCode,Depth1),
	flora_decode_goal(Body,BodyCode,Depth1).

%% An update
decode_literal_internal(Call,Code,Level,_Depth) :-
	compound(Call),
	Call =.. [UpdPred,_ThisMofule,UpdLiterals|Query],
	is_update_call(UpdPred,UpdName),
	!,
	(Query==[]
	-> 
	    decode_update(UpdName,[UpdLiterals],Code,Level)
	; Query = [RealQuery],
	    decode_update(UpdName,[UpdLiterals,RealQuery],Code,Level)
	).

decode_literal_internal(Call,Code,Level,Depth) :-
	(\+callable(Call)
	-> flora_abort([Call,': Ill-formed HiLog term in decode_literal_internal/3'])
	;
	    Depth1 is Depth+1,
	    classify_call(Call,Type,BasenameOrPred,Args,WS),
	    (Type == (hilog)
	    -> (var(WS)
	       -> decode_hilog_term(BasenameOrPred,Args,Code,Level,Depth1)
	       ;
		   decode_hilog_call(BasenameOrPred,Args,WS,Code,Level,Depth1)
	       )
            ; Type == (nontabled-hilog)
            -> decode_nontabled_hilog_call(BasenameOrPred,Args,WS,Code,Level,Depth1)
	    ; Type == (prolog)
	    ->  functor(Call,Functor,Arity),
		decode_prolog_call([Functor,Args,Arity],Code,Depth1)
	    ; Type == (flogic)
	    -> decode_molecule(BasenameOrPred,Args,WS,Code,Level,Depth1)
	    ;	%% cannot decode
		%%flora_abort([Call,': decode_literal_internal/3 failed to decode'])
		flora_warning_line('~w: decode_literal_internal/3 failed to decode',
				   [Call]),
		flora_concat_items([Call], Code)
	    )
	).



/*
%% Keep for now in case we decide to be sophisticated and print true var names
%% Extracts and writes variables from the list [=(name,internalVar), ...]
%% or from the list [internalVar, internalVar, ...]
flora_write_vars(V) :- V== [], !.
flora_write_vars([V|Rest]) :- 
	var(V), !, flora_write_vars(V,Rest).
flora_write_vars([=(_N,V)|Rest]) :- 
    	!, flora_write_vars(V,Rest).

flora_write_vars(V,Rest) :-
	write(V),
	(Rest == [] -> true
	 ; write(','), flora_write_vars(Rest)
	).
*/

/****************************************************************************
 escape(+Text1, -Text2)
 for strings, replace every occurency of \ with \\ so that \n is printed
 as it is instead of being interpreted
 ****************************************************************************/
escape(NL,NL) :-
        var(NL),
        !.

escape(Atom,Code) :-
        atom(Atom),
        !,
        atom_codes(Atom,Str),
        escape(Str,EscStr,Flag),
	atom_codes(NA,EscStr),
        ( Flag == escaped -> Code = ['''',NA,'''']; Code = NA ).

escape(L,NL) :- is_list(L), !, escape(L,NL,_Flag).

%% Neither list nor atom - don't do anything
escape(L,L) :- !.
        
escape([],[],_Flag) :- !.

escape([H|L],[CH_BACKSLASH,HC|EL],escaped) :-
        special_character(H,HC),
        !,
        escape(L,EL,_Flag).
%% Backslash before special character is escaped: '\\n' is internally 
%% translated as \ n and is printed as '\\n'
escape([CH_BACKSLASH,H|L],[CH_BACKSLASH,CH_BACKSLASH,H|EL],escaped) :-
        special_character(_,H),
        !,
        escape(L,EL,_Flag).
escape([CH_BACKSLASH,H|L],[CH_BACKSLASH,CH_BACKSLASH|HEL],escaped) :-
        special_character(H,_),
        !,
        escape([H|L],HEL,_Flag).
escape([CH_BACKSLASH,CH_BACKSLASH|L],[CH_BACKSLASH,CH_BACKSLASH|EL],escaped) :-
        !,
        escape([CH_BACKSLASH|L],EL,_Flag).
escape([H|L],[H|EL],Flag) :-
        escape(L,EL,Flag).

/****************************************************************************
 special_character(+C, -NC)
 recognize special characters \a, \b, \t, \n, \v, \f, \r
 ****************************************************************************/
special_character(CH_ALARM, CH_a) :- !.
special_character(CH_BACKSPACE,CH_b) :- !.
special_character(CH_TAB,CH_t) :- !.
special_character(CH_NEWLINE,CH_n) :- !.
special_character(CH_VERTAB,CH_v) :- !.
special_character(CH_FORMFEED,CH_f) :- !.
special_character(CH_RETURN,CH_r) :- !.
