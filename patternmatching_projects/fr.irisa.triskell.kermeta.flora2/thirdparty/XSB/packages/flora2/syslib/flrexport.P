/* File:      flrexport.P
**
** Author(s): Vishal Chowdhary
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) The Research Foundation of SUNY, 1999-2001
** 
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
**
*/

:- compiler_options([xpp_on]).
#include "flora_terms.flh"

%% (ExportingModule, ModuleExportedTo, UpdatableTag, Exported_Term)
:- dynamic flora_export_registry(_,_,_,_).

%% to prevent error checking in case on uninitialized/ undefined calls.
:- dynamic flora_undefinedness_export_registry/2.

:- export
	flora_reset_export_registries/1,
	FLLIBEXPORT/1,
	flora_add_undef_export_call/2,
	flora_remove_undef_export_call/1,
	flora_check_export_registry/3,
	flora_check_export_registry/4,
	flora_check_export_registry_internal/4.

:- import 
	flora_error_notexported/1, 
	flora_error_invalid_export/1
   from flrundefined.
   
:- import 
	convert_to_body_literal/2, 
	convert_to_signature/3,
	convert_to_value_atom/3,
	get_canonical_form/2 
   from flrcanon.


%% to extract the individual terms from the detailed code.
is_flexport(FLEXPORT(UpdTag, ExportingModule, ListOfModulesExportedTo, Term),UpdTag, ExportingModule, ListOfModulesExportedTo, Term).
is_flexport(FLEXPORT(DynamicModule, UpdTag, ExportingModule, ListOfModulesExportedTo, Term),DynamicModule, UpdTag, ExportingModule, ListOfModulesExportedTo, Term).

is_fllibmodlit(FLLIBMODLIT(_,_,_,_)).

/****************************************************************************
  flora_reset_export_registries(+ModuleName)
****************************************************************************/
flora_reset_export_registries(Module) :-
	retractall(flora_export_registry(Module,_,_,_)).


/****************************************************************************
  FLLIBEXPORT(+ExportedPredicatesList)
  Each of the terms in the List are themselves lists. Thus they
  need to be processed recursively.
****************************************************************************/
FLLIBEXPORT([H|T]) :-
	(
	  (
	    (
	      is_flexport(H,UpdTag, ExportingModule, ListOfModulesExportedTo, Term)
	    ;
	      is_flexport(H, WS, UpdTag, ExportingModule, ListOfModulesExportedTo, Term)
	    ),
	    FLLIBEXPORT(WS,UpdTag, ExportingModule, ListOfModulesExportedTo, Term)
	  )
	;
	  %% could be a list within itself.
	  FLLIBEXPORT(H)	
	),
	FLLIBEXPORT(T).

FLLIBEXPORT([]) :- !.


/****************************************************************************
  FLLIBEXPORT(+WorkSpace,+Updatable,+ExportingModule,+ListOfModulesExportedTo,+Functor)
****************************************************************************/
FLLIBEXPORT(WS,UpdateTag,ExportingModule,[],Term) :-
        flora_assert_into_export_registry(WS,ExportingModule,_ModuleExportedTo,UpdateTag,Term).

FLLIBEXPORT(WS,UpdateTag,ExportingModule,ListOfModulesExportedTo,Term) :-
	FLLIBEXPORT_INTERNAL(WS,UpdateTag,ExportingModule,ListOfModulesExportedTo,Term).

FLLIBEXPORT_INTERNAL(WS,UpdateTag,ExportingModule,[T|L],Term) :-
	!,
	flora_assert_into_export_registry(WS,ExportingModule,T,UpdateTag,Term),
	FLLIBEXPORT_INTERNAL(WS,UpdateTag,ExportingModule,L,Term).

FLLIBEXPORT_INTERNAL(_WS,_UpdateTag,_ExportingModule,[],_Term) :- !.


/****************************************************************************
  flora_assert_into_export_registry/5
  flora_assert_into_export_registry(+DynamicModulename,+ExportingModule,+ModuleExportedTo,+UpdateTag,+Term)
  The predicate that asserts the exported term, along with the module name(s) 
  it is exported too, to the registry.
****************************************************************************/
flora_assert_into_export_registry(DynamicModulename,ExportingModule,ModuleExportedTo,UpdateTag,Term) :-
	!,
	( var(DynamicModulename) ->	
	    (
	      is_fllibmodlit(Term) ->
	      %% need to check whether it is FLLIBMODLIT
	      %% error!! Since it should have been initialized before.
	      flora_error_invalid_export(Term)
	    ;
	      (
		flora_export_registry(ExportingModule, ModuleExportedTo, UpdateTag, Term), !
	      ;
		%% write('flora_export_registry('),write(ExportingModule),write(','),write(ModuleExportedTo),write(','),write(UpdateTag),write(','),writeln(Term),write(')'),
		assert(flora_export_registry(ExportingModule, ModuleExportedTo, UpdateTag, Term)),
		convert_to_signature(Term,inheritable,SigTerm),
		assert(flora_export_registry(ExportingModule, ModuleExportedTo, UpdateTag, SigTerm)),
		convert_to_signature(Term,noninheritable,SigTerm2),
		assert(flora_export_registry(ExportingModule, ModuleExportedTo, UpdateTag, SigTerm2)),
		convert_to_value_atom(Term,inheritable,SigTerm3),
		assert(flora_export_registry(ExportingModule, ModuleExportedTo, UpdateTag, SigTerm3))
	      )
	    )
	;
	    (
	      is_fllibmodlit(Term) ->
	      (
		%% do we need to convert it into canonical form??
		get_canonical_form(Term,FLCANON(_,_,_,TermCode,_)),
		(
		  flora_export_registry(DynamicModulename, ModuleExportedTo, UpdateTag, TermCode), !
		;
		  %%write('flora_export_registry('),write(DynamicModulename),write(','),write(ModuleExportedTo),write(','),write(UpdateTag),write(','),writeln(TermCode),write(')'),
		  assert(flora_export_registry(DynamicModulename, ModuleExportedTo, UpdateTag, TermCode))
		)
	      )
	    ;
	      (
		flora_export_registry(DynamicModulename, ModuleExportedTo, UpdateTag, Term), !
	      ;
		%%write('flora_export_registry('),write(DynamicModulename),write(','),write(ModuleExportedTo),write(','),write(UpdateTag),write(','),writeln(Term),write(')'),
		assert(flora_export_registry(DynamicModulename, ModuleExportedTo, UpdateTag, Term))
	      )
	    )
	).


/****************************************************************************
  flora_check_export_registry_internal(+CallerMod,+ModBeingCalled,+Term,+UpdateTag)
	
	CallerMod = The module name of the predicate that is calling the 
		     predicate from the external module (ModBeingCalled).
	
	Term = The representation of the predicate is of the form:	
			FLORA_USER_WORKSPACE(CallerMod,FunctorType)Term
	       where Term = (...)
	
	UpdateTag = UPDATABLE/ READABLE.

	It is invoked by the flora_check_export_registry predicates.
****************************************************************************/
flora_check_export_registry_internal(CallerMod,ModBeingCalled,Term,UpdateTag) :-
	%%write('flora_check_export_registry_internal--'),write(CallerMod),write(','),write(Term),write(','),write(UpdateTag),write(','),writeln(ModBeingCalled),
	(
	  flora_no_predicates_exported(ModBeingCalled)
	;
	  %% If external module = current module - let the call pass through.
	  CallerMod == ModBeingCalled ->
	  true	
	;
	  %% check if it unifies without any transformations...
	  flora_export_registry(ModBeingCalled,CallerMod,UpdateTag,Term)
	;
	  %% transformations mvd -> d_mvd types.
	  convert_to_body_literal(Term,ExptTerm),
	  %% check the export registry.
	  flora_export_registry(ModBeingCalled,CallerMod,UpdateTag,ExptTerm)
	).


/****************************************************************************
  flora_no_predicates_exported(Module)
  
  If no predicates are exported by a module, then it basically means that it
  does not require any encapsulation. All its predicates are accessible to 
  all the other modules.
  If any predicates are exported it will fail, else it will succeed.
****************************************************************************/
flora_no_predicates_exported(Module) :-
	flora_export_registry(Module,_ExtMod,_UpdTag,_Term),
	!, fail.

%% no predicate exported, hence succeeds.
flora_no_predicates_exported(_Module) :- !.


/****************************************************************************
  flora_check_export_registry(+Caller,+ModBeingCalled,+Term,+UpdateTag)
  Called by the flrdb, insert delete, predicates with the Updatable tag.
  flora_check_export_registry/4
****************************************************************************/
%% basic idea: if the check succeeds, the call is failed & hence it
%% makes the next call & proceeds towards unification with the answers.
flora_check_export_registry(Caller,ModBeingCalled,Term,UpdateTag) :-
	flora_check_export_registry_internal(Caller,ModBeingCalled,Term,UpdateTag),
	!.
%% check if call is protected from undefinedness checking (when module
%% name was unbound)
flora_check_export_registry(_Caller,_ModBeingCalled,Term,_UpdateTag) :-
	flora_export_undef_check_protected(Term),
	!,
	fail.
%%error handling.
flora_check_export_registry(_Caller,_ModBeingCalled,Term,_UpdateTag) :-
	flora_error_notexported(Term).

/******************************************************************************
**  flora_check_export_registry/3
******************************************************************************/
flora_check_export_registry(CallerMod,ModBeingCalled,Term) :-
	flora_check_export_registry_internal(CallerMod,ModBeingCalled,Term,_UpdateTag),
	!,
	fail.

%% check if call is protected from undefinedness checking (when module
%% name was unbound)
%% flora_check_export_registry/3
flora_check_export_registry(_CallerInfo,_ModBeingCalled,Term) :-
	flora_export_undef_check_protected(Term),
	!,
	fail.
flora_check_export_registry(_CallerInfo,_ModBeingCalled,Term) :-
	flora_error_notexported(Term).


/****************************************************************************
  flora_add_undef_export_call(+Predicate,+Id)
  Predicate is the call to be recorded as temporarily protected
            from the undefinedness check.
  Id is a unique Id that is used to delete the call from the registry.
****************************************************************************/
flora_add_undef_export_call(Predicate,Id) :-
	%% write('Undefindness check add -- '), writeln(Predicate),
	assert(flora_undefinedness_export_registry(Predicate,Id)).


/****************************************************************************
  flora_remove_undef_export_call(+Id)
****************************************************************************/
flora_remove_undef_export_call(Id) :-
	retractall(flora_undefinedness_export_registry(_,Id)).


%% Tell if call is protected
flora_export_undef_check_protected(Predicate) :-
	%% write('Undefindness check -- '),writeln(Predicate),
	(
	  flora_undefinedness_export_registry(Predicate,_Id),
	  !
	;
	  %% transformations mvd -> d_mvd types.
	  convert_to_body_literal(Predicate,PredicateTerm),
	  %% check the undefindness registry.
	  %% write('Undefindness check -- '),writeln(PredicateTerm),
	  flora_undefinedness_export_registry(PredicateTerm,_Id)
	).
