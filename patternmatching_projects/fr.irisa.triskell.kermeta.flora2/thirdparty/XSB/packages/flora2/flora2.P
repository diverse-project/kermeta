/* File:      flora2.P
**
** Author(s): Michael Kifer
**            Guizhen Yang
**
** Contact:   flora-users@lists.sourceforge.net
** 
** Copyright (C) The Research Foundation of SUNY, 1998 - 2002
** 
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
**
** $Id: flora2.P,v 1.19 2006/05/17 22:23:10 kifer Exp $
** 
*/


:- compiler_options([xpp_on]).


:- import
	bootstrap_package/2,
	unload_package/1
   from packaging.

:- import
	flImportPredicate/4
   from flrimport.

:- import
	flora_load_module_internal/2, flora_load_module_internal/1,
	flora_add_module_dyn/2, flora_add_module_dyn/1,
        flora_save_module_internal/2, flora_save_module_internal/1,
	flora_abort/1,
	flora_compile_internal/2, flora_compile_internal/1,
	flora_compile_add/2, flora_compile_add/1
   from flrutils.

:- import flora_configuration/2,
	flora_module_registry/1
   from flrregistry.

:- import flora_sysmod_file/3 from flrlibman.
:- import flora_call_string_command/4 from flrutils.

:- import
	flora_concat_atoms/2,
	flora_set_counter/2,
	flora_get_counter/2,
	flora_slash/1
   from flrporting.

:- import flora_shell_loop/0 from usermod.

:- import hide_this_show/2 from usermod.

:- import xpp_include_dir/1 from parse.

:- import search_module/6 from consult.

:- import slash/1 from machine.

:- dynamic hide_this_show(_,_).
:- index(hide_this_show/2,trie).

:- export
	bootstrap_flora/0,
	unstrap_flora/0,
	(flImport)/1,
	(flLoad)/1,
	(flCompile)/1,
	(flAdd)/1,
	(flCompileAdd)/1,
        (flSave)/1,
	flLoadedModule/1,
	flora_query/4,
	flora_shell/0.


/*****************************************************************************/

?- search_module(flora2,Dir,_,_,_,_),
   (search_module(floraInstallMode,_,_,_,_,_)
   -> [floraInstallMode]
   ;
       slash(S),
       atom_concat(Dir,S,Dir1),
       atom_concat(Dir1,flora2,FloraDir),
       asserta(library_directory(FloraDir)),
       [floraInstallMode]
   ).
?- current_predicate(flrregistry:flora_configuration/2),
   flora_configuration(standalone,no),
   flora_configuration(standalone,yes),
   abort('FLORA-2 is loaded as a package and as a standalone application').

bootstrap_flora :-
	\+ flora_configuration(loaded,yes),
	flora_configuration(installdir,FloraDir),
	flora_slash(S),
	flora_concat_atoms([pkgs,S,prolog],PkgsProlog),
	(
	  %% running FLORA as a standalone version
	  flora_configuration(standalone,yes),
	  !,
	  asserta(library_directory(FloraDir)),
	  [flrversion],
	  flora_assert_directories([syslib,lib,debugger,pkgs,PkgsProlog,p2h])
	;
	  %% running FLORA as an XSB package
	  bootstrap_package([flora2,syslib,lib,debugger,pkgs,PkgsProlog,p2h],
			    flora),
	  [flrversion]
	),
	!,
	assert(flora_configuration(loaded,yes)),
	flora_concat_atoms([FloraDir,S,closure],Closure),
	flora_concat_atoms([FloraDir,S,includes],Includes),
	flora_concat_atoms([FloraDir,S,flrincludes],FlrIncludes),
	flora_concat_atoms([FloraDir,S,genincludes],GenIncludes),
	assert(xpp_include_dir(Closure)),
	assert(xpp_include_dir(Includes)),
	assert(xpp_include_dir(FlrIncludes)),
	assert(xpp_include_dir(GenIncludes)),
	assert(flora_configuration(includedirs, [Closure,Includes,FlrIncludes,GenIncludes])),
	flora_set_counter(flora_compile_id,0), % disambiguates _# in flAdd
	[p2h_config].

bootstrap_flora.

flora_assert_directories([]).
flora_assert_directories([H|T]) :-
	flora_slash(S),
	flora_configuration(installdir,FloraInstallDir),
	flora_concat_atoms([FloraInstallDir,S,H], Directory),
	assert(library_directory(Directory)),
	flora_assert_directories(T).


/*****************************************************************************/
unstrap_flora :-
	flora_configuration(includedirs,IncludeDirs),
	remove_include_dirs(IncludeDirs),
	(flora_configuration(standalone,yes), ! ; unload_package(flora)),
	retractall(flora_configuration(loaded,_)),
	flora_set_counter(flora_shell_loaded,0).


/*****************************************************************************/
%% don''t show flora_shell in trace
:- assert(hide_this_show(flora_shell,0)). 


/*****************************************************************************/
flora_shell :-
	bootstrap_flora,
	notrace,
	( flora_get_counter(flora_shell_loaded,1), !
	;
	  consult(flrshell),
	  flora_shell_loop
	).

/************************************************************************
  Flora import stuff

  Syntax:
      :- flImport Pred/Arity as Pred1(_,_,...) from File[.flr]>>FloraModule
  or
      :- flImport Pred/Arity as Pred1(_,_,...) from FloraModule

  Also (to load into the default module)
      :- flLoad file.
  or
      :- flLoad file>>module.

  To compile (without loading):
      :- flCompile file.
  or
      :- flCompile file>>module.

  To add file to an existing module without overriding:
      :- flAdd file.
  or
      :- flAdd file>>module.

  To save module to a flora file:
      :- flSave file.
  or
      :- flSave module>>file.
            
  To compile for adding to an existing module without overriding:
      :- flCompileAdd file.
  or
      :- flCompileAdd file>>module.

************************************************************************/

:- op(500,yfx,(as)).
:- op(1170,fx,(flImport)).

:- op(1050,fx,(flLoad)).	% loads file into module: flLoad(File>>Module)
:- op(1050,fx,(flCompile)).     % compile file for loading into module: flCompile(File>>Module)

:- op(1050,fx,(flSave)).	% save module into file: flSave(Module>>File)

:- op(1050,fx,(flAdd)).	        % add file to module: flAdd(File>>Module)
:- op(1050,fx,(flCompileAdd)).  % compile for adding to module: flCompileAdd(File>>Module)

%% The other operators, '>>' and 'from', are already defined in Prolog

flImport(from(as(What,AsWhat),FileMod)) :- !,
	(atom(FileMod)  % in this case FileMod is a module name
	-> (flLoadedModule(FileMod)
	   -> flImportPredicate(What,AsWhat,_,FileMod)
	   ;  flora_abort(['Trying to import hilog predicate ', What,
		     ' from unloaded FLORA module ', FileMod])
	   )
	; FileMod = File>>Module 
	-> flImportPredicate(What,AsWhat,File,Module)
	).

flImport(X) :- flora_abort(['Invalid flImport syntax: ', X]).

flLoad(File>>Module) :- !, flora_load_module_internal(File,Module).
flLoad(File) :- flora_load_module_internal(File).

/*************************************************************************
  
  flSave(+ModuleName,+FlrFile)
  flSave(+FlrFile)
   
  Purpose: -save Module into FlrFile
           -shell command
           -if ModuleName is omitted, main by defaut	   
  Comments: none
	   
*************************************************************************/

flSave(Module>>File) :- !, flora_save_module_internal(Module,File).
flSave(File) :- flora_save_module_internal(File).


flCompile(File>>Module) :- !, flora_compile_internal(File,Module).
flCompile(File) :- flora_compile_internal(File).


%% Add file contents to module
flAdd(File>>Module) :- !, flora_add_module_dyn(File,Module).
flAdd(File) :- flora_add_module_dyn(File).

%% Compile for adding to module
flCompileAdd(File>>Module) :- !, flora_compile_add(File,Module).
flCompileAdd(File) :- flora_compile_add(File).

%% tells if ModuleName is loaded
flLoadedModule(ModuleName) :- 
	flora_module_registry(ModuleName),
	not flora_sysmod_file(ModuleName,_,_).


/***************************************************************************/
%% Some utilities that must be duplicated here because they can't be imported

remove_include_dirs([]).
remove_include_dirs([H|T]) :-
	(retract(xpp_include_dir(H)) ; true),
	remove_include_dirs(T).


/************************************************************************
    flora_query(+String,+Vars,-Status,-Exception)

   Execute a query specified in String.

   String: A query string
   Vars:   A list of the form [Name1=Var1, Name2=Var2,...].
           Name is a name of a variable mentioned in String, for instance, 
	   '?X' (note: must be quoted, since it is an atom).
	   Var is a variable where you want the binding for the variable 
	   Name in String to be returned. For instance, 
	   if String is 'p(?X,?Y).'
	   Vars can be ['?X' = Xyz, '?Y' = Qpr]
	   Then Xyz will be bound to the value of ?X in p(?X,?Y) after
	   the execution and Qpr will be bound to the value of ?Y in p(?X,?Y).
   Status: indicates the status of compilation of the command in String.
   Exception: is a possible exception during the runtime execution 
              of the command in String.
*************************************************************************/
flora_query(String,Vars,Status,Exception) :-
	flora_call_string_command(String,Vars,Status,Exception).
