/* File:      flrprettyprint.flr
**
** Author(s): Michael Kifer
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) The Research Foundation of SUNY, 2001
** 
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: flrprettyprint.flr,v 1.17 2005/12/22 22:37:19 hwan Exp $
**
*/

/*   To pretty print an object:
**	?- obj[%pp_self]@flora(pp).
**	?- obj[%pp_self(module)]@flora(pp).
**   To save it in a file:
**	?- obj[%pp_self(module,outfile)]@flora(pp).
**   To pretty print a class:
**      ?- class[%pp_class]@flora(pp).
**      ?- class[%pp_class(module)]@flora(pp).
**   To save result of a pretty-printed class in a file:
**      ?- class[%pp_class(module,outfile)]@flora(pp).
**   To print the information about class membership:
**      ?- class[%pp_isa]@flora(pp).
**      ?- class[%pp_isa(module)]@flora(pp).
**   To save it in a file:
**      ?- class[%pp_isa(module,outfile)]@flora(pp).
*/

:- export
        ?_[%pp_class(?_,?_)],
	?_[%pp_class(?_)],
	?_[%pp_class],
        ?_[%pp_self(?_,?_)],
	?_[%pp_self(?_)],
	?_[%pp_self],
        ?_[%pp_isa(?_,?_)],
	?_[%pp_isa(?_)],
	?_[%pp_isa].
	

// Need to add signature printing


// Methods to ignore during pretty printing
%flora_print_ignore('________') :- true.

// Pretty print the class info and save in outfile
?Class[%pp_class(?Module,?Outfile)] :-
	tell(?Outfile)@prolog(),
    	?Class[%pp_class(?Module)],
	told@prolog().
// Print class in Module
?Class[%pp_class(?Module)] :-
	%flora_pp_immediate_superclasses(?Class,?Module),
    	?Class[%pp_self(?Module)],
	(?X : ?Class)@?Module,
	ground(?X)@prolog(basics),  // to ground X, if non-ground
	?X[%pp_self(?Module)],
	fail.
?_Class[%pp_class(?_)] :- true.

?Class[%pp_class] :- caller{?Mod}, ?Class[%pp_class(?Mod)].

// Print obj from Module
?X[%pp_self(?Module)] :-
	%flora_pp_immediate_classes(?X,?Module),
	%flora_pp_write_header(?X),
	%flora_pp_write_body_set(?X,?Module),
	%flora_pp_write_comma_conditional(${?X[?_->?_,?_*->?_]@?Module}),
	%flora_pp_write_body_iset(?X,?Module),
	%flora_pp_write_comma_conditional(${?X[(?_->?_; ?_*->?_),?_]@?Module}),
	%flora_pp_write_body_bool(?X,?Module),
	%flora_pp_write_comma_conditional(${?X[(?_->?_; ?_*->?_; ?_),*?_]@?Module}),
	%flora_pp_write_body_ibool(?X,?Module),
	%flora_pp_write_comma_conditional(${?X[(?_->?_; ?_*->?_; ?_; *?_),%?_]@?Module}),
	%flora_pp_write_body_tran(?X,?Module),
	nl@prolog(), writeln('].')@prolog(), nl@prolog().
// Print obj in Module to an Outfile
?X[%pp_self(?Module,?Outfile)] :-
	tell(?Outfile)@prolog(),
	?X[%pp_self(?Module)],
	told@prolog().

?X[%pp_self] :- caller{?Mod}, ?X[%pp_self(?Mod)].

// Print all the isa info in one shot.
?Class[%pp_isa(?Module)] :-
	%flora_pp_immediate_isa(?Class,?Module),
	%flora_pp_subclasses_isa(?Class,?Module).
// Same, but save in a file
?Class[%pp_isa(?Module,?File)] :-
	tell(?File)@prolog(),
	?Class[%pp_isa(?Module)],
	told@prolog().

?Class[%pp_isa] :- caller{?Mod}, ?Class[%pp_isa(?Mod)].


%flora_pp_write_header(?X) :-
    	atom(?X)@prolog(),
	!,
    	%fmt_write('''%s''[', ?X)@flora(io),
    	nl@prolog().
%flora_pp_write_header(?X) :-
    	is_charlist(?X)@prolog(),
	!,
    	%fmt_write('"%s"[',?X)@flora(io),
    	nl@prolog().
%flora_pp_write_header(?X) :- %write(?X)@flora(io), writeln('[')@prolog().

// Print out scalar methods
%flora_pp_write_body_scalar(?Obj,?Module) :-
    	?MethLst1 = collectset{?SM | ?Obj[?SM -> ?_]@?Module},
	sort(?MethLst1, ?MethLst2)@prolog(),
	%flora_pp_write_body_scalar1(?Obj, ?MethLst2,?Module).

// Test if method is to be ignored and either skip it or print it.
%flora_pp_write_body_scalar1(?_, [], ?_Module) :- true.
%flora_pp_write_body_scalar1(?Obj, [?MethInv|?MethInvs],?Module) :-
        ?MethInv = [?M|?_Args],
	%flora_print_ignore(?M),
	!,
	// skip this method
	%flora_pp_write_body_scalar1(?Obj, ?MethInvs,?Module).
%flora_pp_write_body_scalar1(?Obj, [?MethInv|?MethInvs],?Module) :-
	?Obj[?MethInv -> ?Val]@?Module,
	write('    ')@prolog(), %flora_pp_write_method_invocation(?MethInv),
	write(' -> ')@prolog(), %flora_pp_write_value(?Val),
	%flora_pp_write_comma_maybe(?MethInvs),
	%flora_pp_write_body_scalar1(?Obj, ?MethInvs,?Module).

// Print out inheritable scalar *->
%flora_pp_write_body_iscalar(?Obj,?Module) :-
    	?MethLst1 = collectset{?SM | ?Obj[?SM *-> ?_]@?Module},
	sort(?MethLst1, ?MethLst2)@prolog(),
	%flora_pp_write_body_iscalar1(?Obj, ?MethLst2,?Module).

// Test if method is to be ignored and either skip it or print it.
%flora_pp_write_body_iscalar1(?_, [], ?_Module) :- true.
%flora_pp_write_body_iscalar1(?Obj, [?MethInv|?MethInvs],?Module) :-
        ?MethInv = [?M|?_Args],
	%flora_print_ignore(?M),
	!,
	// skip this method
	%flora_pp_write_body_iscalar1(?Obj, ?MethInvs,?Module).
%flora_pp_write_body_iscalar1(?Obj, [?MethInv|?MethInvs],?Module) :-
	?Obj[?MethInv *-> ?Val]@?Module,
	write('    ')@prolog(), %flora_pp_write_method_invocation(?MethInv),
	write(' *-> ')@prolog(), %flora_pp_write_value(?Val),
	%flora_pp_write_comma_maybe(?MethInvs),
	%flora_pp_write_body_iscalar1(?Obj, ?MethInvs,?Module).

// Print set-valued
%flora_pp_write_body_set(?Obj,?Module) :-
    	?MethLst1 = collectset{?MM | ?Obj[?MM -> ?_]@?Module},
	sort(?MethLst1, ?MethLst2)@prolog(),
	%flora_pp_write_body_set1(?Obj, ?MethLst2,?Module).

%flora_pp_write_body_set1(?_Obj, [],?_Module) :- true.
%flora_pp_write_body_set1(?Obj, [?MethInv|?MethInvs],?Module) :-
        ?MethInv = [?M|?_Args],
	%flora_print_ignore(?M),
	!,
	// skip this method
	%flora_pp_write_body_set1(?Obj, ?MethInvs,?Module).
%flora_pp_write_body_set1(?Obj, [?MethInv|?MethInvs],?Module) :-
	?Vals = collectset{?V| ?Obj[?MethInv -> ?V]@?Module},
	write('    ')@prolog(), %flora_pp_write_method_invocation(?MethInv),
	write(' -> ')@prolog(), %flora_pp_write_set(?Vals),
	%flora_pp_write_comma_maybe(?MethInvs),
	%flora_pp_write_body_set1(?Obj, ?MethInvs,?Module).

// Inheritable *->
%flora_pp_write_body_iset(?Obj,?Module) :-
    	?MethLst1 = collectset{?MM | ?Obj[?MM *-> ?_]@?Module},
	sort(?MethLst1, ?MethLst2)@prolog(),
	%flora_pp_write_body_iset1(?Obj, ?MethLst2,?Module).

%flora_pp_write_body_iset1(?_Obj, [],?_Module) :- true.
%flora_pp_write_body_iset1(?Obj, [?MethInv|?MethInvs],?Module) :-
        ?MethInv = [?M|?_Args],
	%flora_print_ignore(?M),
	!,
	// skip this method
	%flora_pp_write_body_iset1(?Obj, ?MethInvs,?Module).
%flora_pp_write_body_iset1(?Obj, [?MethInv|?MethInvs],?Module) :-
	?Vals = collectset{?V| ?Obj[?MethInv *-> ?V]@?Module},
	write('    ')@prolog(), %flora_pp_write_method_invocation(?MethInv),
	write(' *-> ')@prolog(), %flora_pp_write_set(?Vals),
	%flora_pp_write_comma_maybe(?MethInvs),
	%flora_pp_write_body_iset1(?Obj, ?MethInvs,?Module).

// Transactions %p(...)
%flora_pp_write_body_tran(?Obj,?Module) :-
    	?MethLst1 = collectset{?Tran | ?Obj[%?Tran]@?Module},
	sort(?MethLst1, ?MethLst2)@prolog(),
	%flora_pp_write_body_tran1(?Obj, ?MethLst2,?Module).

%flora_pp_write_body_tran1(?_Obj, [],?_Module) :- true.
%flora_pp_write_body_tran1(?Obj, [?MethInv|?MethInvs],?Module) :-
        ?MethInv = [?M|?_Args],
	%flora_print_ignore(?M),
	!,
	%flora_pp_write_body_tran1(?Obj, ?MethInvs,?Module).
%flora_pp_write_body_tran1(?Obj, [?MethInv|?MethInvs],?Module) :-
	write('    %')@prolog(), %flora_pp_write_method_invocation(?MethInv),
	%flora_pp_write_comma_maybe(?MethInvs),
	%flora_pp_write_body_tran1(?Obj, ?MethInvs,?Module).

// Boolean p(...)
%flora_pp_write_body_bool(?Obj,?Module) :-
    	?MethLst1 = collectset{?Bool | ?Obj[?Bool]@?Module},
	sort(?MethLst1, ?MethLst2)@prolog(),
	%flora_pp_write_body_bool1(?Obj, ?MethLst2,?Module).

%flora_pp_write_body_bool1(?_Obj, [],?_Module) :- true.
%flora_pp_write_body_bool1(?Obj, [?MethInv|?MethInvs],?Module) :-
        ?MethInv = [?M|?_Args],
	%flora_print_ignore(?M),
	!,
	%flora_pp_write_body_bool1(?Obj, ?MethInvs,?Module).
%flora_pp_write_body_bool1(?Obj, [?MethInv|?MethInvs],?Module) :-
	write('    ')@prolog(), %flora_pp_write_method_invocation(?MethInv),
	%flora_pp_write_comma_maybe(?MethInvs),
	%flora_pp_write_body_bool1(?Obj,?MethInvs,?Module).

// Inheritable Boolean *p(...)
%flora_pp_write_body_ibool(?Obj,?Module) :-
    	?MethLst1 = collectset{?Bool | ?Obj[*?Bool]@?Module},
	sort(?MethLst1, ?MethLst2)@prolog(),
	%flora_pp_write_body_ibool1(?Obj, ?MethLst2,?Module).

%flora_pp_write_body_ibool1(?_Obj, [],?_Module) :- true.
%flora_pp_write_body_ibool1(?Obj, [?MethInv|?MethInvs],?Module) :-
        ?MethInv = [?M|?_Args],
	%flora_print_ignore(?M),
	!,
	%flora_pp_write_body_ibool1(?Obj, ?MethInvs,?Module).
%flora_pp_write_body_ibool1(?Obj, [?MethInv|?MethInvs],?Module) :-
	write('    *')@prolog(), %flora_pp_write_method_invocation(?MethInv),
	%flora_pp_write_comma_maybe(?MethInvs),
	%flora_pp_write_body_ibool1(?Obj,?MethInvs,?Module).


// Write comma, if List is not empty 
%flora_pp_write_comma_maybe([]) :- !.
%flora_pp_write_comma_maybe([?_First| ?_Rest]) :- writeln(',')@prolog().

// The cut here is iffy, because it cuts a tables predicate Cond.
// However, the table must have been completed here because tables 
// predicates don't depend on %flora_pp_write_comma_conditional/1.
// So it might be OK.
%flora_pp_write_comma_conditional(?Cond) :-
	if ?Cond then writeln(',')@prolog(),
        !.



%flora_pp_write_method_invocation(?M) :-
	?M =.. ?ML,
	%ground_list(?ML),
	%write(?M)@flora(io).

%flora_pp_write_set(?L) :-
    	write('{')@prolog(),
	%flora_pp_write_set1(?L),
	write('}')@prolog().

%flora_pp_write_set1([]) :- true.
%flora_pp_write_set1([?Elt]) :- %flora_pp_write_value(?Elt).
%flora_pp_write_set1([?Elt, ?Elt2 | ?Rest]) :-
    	%flora_pp_write_value(?Elt), write(',')@prolog(),
	%flora_pp_write_set1([?Elt2|?Rest]).
        
%flora_pp_write_value(?Val) :-
	atom(?Val)@prolog(),
	!,
	%fmt_write('''%s''', ?Val)@flora(io).
%flora_pp_write_value(?Val) :-
	is_charlist(?Val)@prolog(),
	!,
	%fmt_write('"%s"', ?Val)@flora(io).
%flora_pp_write_value(?Val) :-
	%write(?Val)@flora(io).

%flora_pp_immediate_isa(?Class,?Module) :-
	(?X : ?Class)@?Module, 
	ground([?X,?Class])@prolog(basics),
	// no intermediate class
	not flora_in_between_isa(?X,?Class,?Module),
	%flora_pp_write_value(?X), write('		:  ')@prolog(),
	%flora_pp_write_value(?Class),
	writeln('.')@prolog(),
	fail.
%flora_pp_immediate_isa(?_,?_) :- true.

// There is an intermediate class between X and Class
flora_in_between_isa(?X,?Class,?Module) :-
	(?X:?C1)@?Module, ?C1 \= ?Class, (?C1::?Class)@?Module.


%flora_pp_subclasses_isa(?Class,?Module) :-
	(?Sub :: ?Class)@?Module,
	?Sub \= ?Class,
	not flora_in_between_sub(?Sub,?Class,?Module),
	%flora_pp_immediate_isa(?Sub,?Module),
        %flora_pp_subclasses_isa(?Sub,?Module),
	fail.
%flora_pp_subclasses_isa(?_,?_) :- true.

flora_in_between_sub(?Sub,?Class,?Module) :-
	(?Sub :: ?Sub1)@?Module,
	?Sub \= ?Sub1, ?Sub1 \= ?Class,
	(?Sub1 :: ?Class)@?Module.
	
// immediate classes of Obj
%flora_pp_immediate_classes(?Obj,?Module) :-
	(?Obj : ?Class)@?Module,
	ground([?Obj,?Class])@prolog(basics),
	not flora_in_between_isa(?Obj,?Class,?Module),
	%flora_pp_write_value(?Obj), write('	:  ')@prolog(),
	%flora_pp_write_value(?Class),
	write('.')@prolog(), nl@prolog(),
	fail.
%flora_pp_immediate_classes(?_Obj,?_Module) :- true.

%flora_pp_immediate_superclasses(?Class,?Module) :-
	(?Class :: ?Super)@?Module, ground(?Super)@prolog(basics),
	?Class \= ?Super,
	not flora_in_between_sub(?Class,?Super,?Module),
	%flora_pp_write_value(?Class),
	write('	:: ')@prolog(),
	%flora_pp_write_value(?Super),
	write('.')@prolog(), nl@prolog(),
	fail.
%flora_pp_immediate_superclasses(?_,?_) :- true.

// Replaces each var with atom '?' for nicer output
%ground_list([]) :- !.
%ground_list([?H|?T]) :-
	(var(?H)@prolog(), !, ?H='?' ; true),
	%ground_list(?T).
