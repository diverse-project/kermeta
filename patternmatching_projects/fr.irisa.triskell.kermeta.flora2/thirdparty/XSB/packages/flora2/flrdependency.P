/* File:      flrdependency.P  -- the dependency checker
**
** Author(s): Chang Zhao
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) The Research Foundation of SUNY, 2002
** 
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: flrdependency.P,v 1.26 2006/06/19 21:38:20 hwan Exp $
**
*/


%%%% Check dependency of tabled predicates on updates or procedural methods.
%%%% Such dependency is considered a likely error and warning is issued.
%%%%
%%%% Usage: check_for_dependencies(+CodeList,-ErrWarnList)
%%%%        generate_rules(+CodeList)
%%%%        depend(+Sk1,+Sk2,+Option).

:- compiler_options([xpp_on]).
#include "flora_terms.flh"
#include "flora_errors.flh"
#include "flora_characters.flh"

:- table rec_depend/6.
:- use_subsumptive_tabling rec_depend(_,_,_,_,_,_).

#define MAXDEPTH	4
#define STARTPOINT	1
#define DEFAULT_WORKSPACE   FL_THISMODULE

#mode save
#mode nostring "\!#'"
#define PREFIXING(X)            PREFIXINGWS(#1,DEFAULT_WORKSPACE)
#define PREFIXINGWS(X,Y)        FLORA_USER_MODULE_PREFIX#2'#1'
#mode restore

#define PREFIXED_WRAP_ISA       PREFIXING(WRAP_ISA)
#define PREFIXED_WRAP_SUB       PREFIXING(WRAP_SUB)
#define PREFIXED_WRAP_METH      PREFIXING(WRAP_METH)
#define PREFIXED_WRAP_IMETH     PREFIXING(WRAP_IMETH)
#define PREFIXED_WRAP_MVDSIG    PREFIXING(WRAP_MVDSIG)
#define PREFIXED_WRAP_IMVDSIG   PREFIXING(WRAP_IMVDSIG)
#define PREFIXED_WRAP_MVDCONDEF   PREFIXING(WRAP_MVDCONDEF)
#define PREFIXED_WRAP_IMVDCONDEF   PREFIXING(WRAP_IMVDCONDEF)
#define PREFIXED_WRAP_MVDCON    PREFIXING(WRAP_MVDCON)
#define PREFIXED_WRAP_IMVDCON   PREFIXING(WRAP_IMVDCON)
#define PREFIXED_WRAP_MVD       PREFIXING(WRAP_MVD)
#define PREFIXED_WRAP_IMVD      PREFIXING(WRAP_IMVD)
#define PREFIXED_WRAP_EXISTS    PREFIXING(WRAP_EXISTS)
#define PREFIXED_WRAP_MVDDEF    PREFIXING(WRAP_MVDDEF)
#define PREFIXED_WRAP_IMVDDEF   PREFIXING(WRAP_IMVDDEF)
#define PREFIXED_WRAP_BOOLSIG   PREFIXING(WRAP_BOOLSIG)
#define PREFIXED_WRAP_IBOOLSIG  PREFIXING(WRAP_IBOOLSIG)
#define PREFIXED_WRAP_TRANSIG   PREFIXING(WRAP_TRANSIG)
#define PREFIXED_WRAP_ITRANSIG  PREFIXING(WRAP_ITRANSIG)
#define PREFIXED_WRAP_OBJEQL    PREFIXING(WRAP_OBJEQL)
#define PREFIXED_WRAP_TRAN      PREFIXING(WRAP_TRAN)

#define PREFIXED_WRAP_HILOG           PREFIXING(WRAP_HILOG)
#define PREFIXED_WRAP_TABLED_HILOG     PREFIXING(WRAP_TABLED_HILOG)

/****************************************************************************
  utilities
 ****************************************************************************/
default_tabled(PREFIXED_WRAP_ISA,3).
default_tabled(PREFIXED_WRAP_SUB,3).
default_tabled(PREFIXED_WRAP_METH,3).
default_tabled(PREFIXED_WRAP_IMETH,3).
default_tabled(PREFIXED_WRAP_MVDSIG,4).
default_tabled(PREFIXED_WRAP_IMVDSIG,4).
default_tabled(PREFIXED_WRAP_MVDCONDEF,5).
default_tabled(PREFIXED_WRAP_IMVDCONDEF,5).
default_tabled(PREFIXED_WRAP_MVDCON,5).
default_tabled(PREFIXED_WRAP_IMVDCON,5).
default_tabled(PREFIXED_WRAP_MVD,4).
default_tabled(PREFIXED_WRAP_IMVD,4).
default_tabled(PREFIXED_WRAP_EXISTS,2).
default_tabled(PREFIXED_WRAP_MVDDEF,3).
default_tabled(PREFIXED_WRAP_IMVDDEF,3).
default_tabled(PREFIXED_WRAP_BOOLSIG,3).
default_tabled(PREFIXED_WRAP_IBOOLSIG,3).
default_tabled(PREFIXED_WRAP_TRANSIG,3).
default_tabled(PREFIXED_WRAP_ITRANSIG,3).
default_tabled(PREFIXED_WRAP_OBJEQL,3).

default_tabled(PREFIXED_WRAP_TABLED_HILOG,2).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,3).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,4).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,5).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,6).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,7).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,8).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,9).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,10).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,11).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,12).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,13).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,14).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,15).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,16).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,17).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,18).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,19).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,20).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,21).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,22).

procedural(WRAP_TRAN,3).
procedural(WRAP_HILOG,1).
procedural(WRAP_HILOG,2).
procedural(WRAP_HILOG,3).
procedural(WRAP_HILOG,4).
procedural(WRAP_HILOG,5).
procedural(WRAP_HILOG,6).
procedural(WRAP_HILOG,7).
procedural(WRAP_HILOG,8).
procedural(WRAP_HILOG,9).
procedural(WRAP_HILOG,10).
procedural(WRAP_HILOG,11).
procedural(WRAP_HILOG,12).
procedural(WRAP_HILOG,13).
procedural(WRAP_HILOG,14).
procedural(WRAP_HILOG,15).
procedural(WRAP_HILOG,16).
procedural(WRAP_HILOG,17).
procedural(WRAP_HILOG,18).
procedural(WRAP_HILOG,19).
procedural(WRAP_HILOG,20).
procedural(WRAP_HILOG,21).

dboperation(FLLIBINSERT,1).
dboperation(FLLIBINSERTALL,1).
dboperation(FLLIBBTINSERT,1).
dboperation(FLLIBBTINSERTALL,1).
dboperation(FLLIBDELETE,1).
dboperation(FLLIBDELETEALL,1).
dboperation(FLLIBBTDELETE,1).
dboperation(FLLIBBTDELETEALL,1).
dboperation(FLLIBERASE,1).
dboperation(FLLIBERASEALL,1).
dboperation(FLLIBBTERASE,1).
dboperation(FLLIBBTERASEALL,1).

dboperation(FLLIBINSERT,2).
dboperation(FLLIBINSERTALL,2).
dboperation(FLLIBBTINSERT,2).
dboperation(FLLIBBTINSERTALL,2).
dboperation(FLLIBDELETE,2).
dboperation(FLLIBDELETEALL,2).
dboperation(FLLIBBTDELETE,2).
dboperation(FLLIBBTDELETEALL,2).
dboperation(FLLIBERASE,2).
dboperation(FLLIBERASEALL,2).
dboperation(FLLIBBTERASE,2).
dboperation(FLLIBBTERASEALL,2).

dboperation(FLLIBINSERT,3).
dboperation(FLLIBINSERTALL,3).
dboperation(FLLIBBTINSERT,3).
dboperation(FLLIBBTINSERTALL,3).
dboperation(FLLIBDELETE,3).
dboperation(FLLIBDELETEALL,3).
dboperation(FLLIBBTDELETE,3).
dboperation(FLLIBBTDELETEALL,3).
dboperation(FLLIBERASE,3).
dboperation(FLLIBERASEALL,3).
dboperation(FLLIBBTERASE,3).
dboperation(FLLIBBTERASEALL,3).

moduleloading(FLLIBLOAD,4).
moduleloading(FL_LOAD,1).
moduleloading(FL_ADD,1).

is_upd(FLLIBINSERT(_ThisMod,List,Condition),insert,List,Condition) :- !.
is_upd(FLLIBBTINSERT(_ThisMod,List,Condition),btinsert,List,Condition) :- !.
is_upd(FLLIBDELETE(_ThisMod,List,Condition),delete,List,Condition) :- !.
is_upd(FLLIBBTDELETE(_ThisMod,List,Condition),btdelete,List,Condition) :- !.
is_upd(FLLIBERASE(_ThisMod,List,Condition),erase,List,Condition) :- !.
is_upd(FLLIBBTERASE(_ThisMod,List,Condition),bterase,List,Condition) :- !.
%%------------ Recognizes index structures associated with update ops
is_updIdxStruct(FLLIBINSERT(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBBTINSERT(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBDELETE(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBBTDELETE(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBERASE(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBBTERASE(List,Condition),List,Condition) :- !.

is_updall(FLLIBINSERTALL(_ThisMod,List,Condition),insertall,List,Condition) :- !.
is_updall(FLLIBBTINSERTALL(_ThisMod,List,Condition),btinsertall,List,Condition) :- !.
is_updall(FLLIBDELETEALL(_ThisMod,List,Condition),deleteall,List,Condition) :- !.
is_updall(FLLIBBTDELETEALL(_ThisMod,List,Condition),btdeleteall,List,Condition) :- !.
is_updall(FLLIBERASEALL(_ThisMod,List,Condition),eraseall,List,Condition) :- !.
is_updall(FLLIBBTERASEALL(_ThisMod,List,Condition),bteraseall,List,Condition) :- !.
%%---- Recognizes index structures associated with update ops
is_updallIdxStruct(FLLIBINSERTALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBBTINSERTALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBDELETEALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBBTDELETEALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBERASEALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBBTERASEALL(List,Condition),List,Condition) :- !.

is_upd(FLLIBINSERT(_ThisMod,List),insert,List,_) :- !.
is_upd(FLLIBBTINSERT(_ThisMod,List),btinsert,List,_) :- !.
is_upd(FLLIBDELETE(_ThisMod,List),delete,List,_) :- !.
is_upd(FLLIBBTDELETE(_ThisMod,List),btdelete,List,_) :- !.
is_upd(FLLIBERASE(_ThisMod,List),erase,List,_) :- !.
is_upd(FLLIBBTERASE(_ThisMod,List),bterase,List,_) :- !.
%%---
is_updIdxStruct(FLLIBINSERT(List),List,_) :- !.
is_updIdxStruct(FLLIBBTINSERT(List),List,_) :- !.
is_updIdxStruct(FLLIBDELETE(List),List,_) :- !.
is_updIdxStruct(FLLIBBTDELETE(List),List,_) :- !.
is_updIdxStruct(FLLIBERASE(List),List,_) :- !.
is_updIdxStruct(FLLIBBTERASE(List),List,_) :- !.

is_updall(FLLIBINSERTALL(_ThisMod,List),insertall,List,_) :- !.
is_updall(FLLIBBTINSERTALL(_ThisMod,List),btinsertall,List,_) :- !.
is_updall(FLLIBDELETEALL(_ThisMod,List),deleteall,List,_) :- !.
is_updall(FLLIBBTDELETEALL(_ThisMod,List),btdeleteall,List,_) :- !.
is_updall(FLLIBERASEALL(_ThisMod,List),eraseall,List,_) :- !.
is_updall(FLLIBBTERASEALL(_ThisMod,List),bteraseall,List,_) :- !.
%%----
is_updallIdxStruct(FLLIBINSERTALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBBTINSERTALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBDELETEALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBBTDELETEALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBERASEALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBBTERASEALL(List),List,_) :- !.

is_agg(FLLIBMIN(Var,Group,Cond,Result),min,Var,Group,Cond,Result) :- !.
is_agg(FLLIBMAX(Var,Group,Cond,Result),max,Var,Group,Cond,Result) :- !.
is_agg(FLLIBSUM(Var,Group,Cond,Result),sum,Var,Group,Cond,Result) :- !.
is_agg(FLLIBAVG(Var,Group,Cond,Result),avg,Var,Group,Cond,Result) :- !.
is_agg(FLLIBCOUNT(Var,Group,Cond,Result),count,Var,Group,Cond,Result) :- !.
is_agg(FLLIBCOLLECTSET(Var,Group,Cond,Result),collectset,Var,Group,Cond,Result)
	:- !.
is_agg(FLLIBCOLLECTBAG(Var,Group,Cond,Result),collectbag,Var,Group,Cond,Result)
	:- !.

is_control(FLLIBIFTHEN(If,Then),FLLIBIFTHEN,[If,Then]) :- !.
is_control(FLLIBIFTHENELSE(If,Then,Else),FLLIBIFTHENELSE,[If,Then,Else]) :- !.

is_constraint(PRCONSTRAINT(Constr),Constr).

/****************************************************************************
  cut_off(+Term_before_cutoff,-Term_after_cutoff)
  cut off a term whose depth is greater than MAXDEPTH
 ****************************************************************************/
cut_off(T1,T2) :- cut_off(T1,T2,1).

cut_off(T1,T2,N) :-
	( N>MAXDEPTH ->
	    writeln('Too deep'),
	    fail
	;
	    ( (atomic(T1); var(T1)) ->
	        T2=T1,
		!
            ;
	        ( N=MAXDEPTH ->
		    functor(T1,Func,Nargs),
		    functor(T2,Func,Nargs)
	        ;
		    NewN is N+1,
		    T1 =.. [Func|Args],
		    cut_off_list(Args,NewArgs,NewN),
		    T2 =.. [Func|NewArgs]
	        )
	    )
	).
		
cut_off_list([],[],_) :- !.
cut_off_list([H|T],[NewH|NewT],N) :-
	cut_off(H,NewH,N),
	cut_off_list(T,NewT,N).

/****************************************************************************
  depth(+Term,-Depth_of_the_term)
  compute the depth of a term
 ****************************************************************************/
depth(X,0) :- atomic(X), !.
depth(X,0) :- var(X), !.
depth(X,N1) :-
        !,
	X =.. [_F|Y],
	param_depth(Y,N),
	N1 is N+1.

/****************************************************************************
  param_depth(+ParamList,-MaxDepth)
  given a list of parameters, returns the max depth of all params
 ****************************************************************************/
param_depth([X],N) :- depth(X,N),!.
param_depth([H|T],N) :-
	depth(H,N1),
	param_depth(T,N2),
	( (N1>N2) ->
            N = N1
        ;
            N = N2
        ).

/****************************************************************************
  depend(+Sk1,+Sk2,-T1,-T2,+Option)
  possible options: u -- depends on update
                    a -- depends on aggregation
                    n -- depends negatively
                    p -- depends positively
    		    arb -- arbitrary
  check whether Sk1 depends on Sk2 with given option, T1 and T2 are
  instantiations of Sk1 and Sk2, respectively
 ****************************************************************************/
depend(Sk1,Sk2,T1,T2,Opt) :-
	retractall(dependency(_,_,_,_)),
	depend(Sk1,Sk2),
	dependency((T1,_IT1),(T2,_IT2),anu(A,N,U),_),
	( (Opt=u, atom(U))
	; (Opt=a, atom(A))
	; (Opt=n, atom(N))
	; (Opt=p, var(N))
	; (Opt=arb)
	).

/****************************************************************************
  depend(+Sk1,+Sk2,+Option)
  decides whether Sk1 depends on Sk2 without caring about the 
  instantiations
 ****************************************************************************/
depend(Sk1,Sk2,Opt) :- 
	depend(Sk1,Sk2,_IT1,_IT2,Opt).

/****************************************************************************
  depend(+Sk1,+Sk2)
  decide whether term skeleton Sk1 depends on Sk2
  and whether the dependency is through aggregation, negation, update
  dependency/4 will be asserted for each path pattern from Sk1 to Sk2
 ****************************************************************************/
depend(Sk1,Sk2) :-
	retractall(target(_,_,_)),
	( is_list(Sk2) ->
	    list_to_targets(Sk2)
	;
            get_canonical_form(Sk2,FLCANON(Wrap,Args,Mod,_Callable,_TF)),
	    assert(target(Wrap,Args,Mod))
	),
	findall((RuleHead),match_rule(Sk1,RuleHead,_,_),HeadList),
	remove_dup(HeadList,NewHeadList),
	depend_list(NewHeadList).

list_to_targets([]) :- !.
list_to_targets([H|T]) :-
        get_canonical_form(H,FLCANON(Wrap,Args,Mod,_Callable,_TF)),
	assert(target(Wrap,Args,Mod)),
	list_to_targets(T).
	
	
remove_dup([],[]) :- !.
remove_dup([H|T],NewList) :-
	( member(H,T) ->
	    remove_dup(T,NewList)
	;
	    remove_dup(T,InterList),
	    NewList = [H|InterList]
	).

depend_list([]) :- !.
depend_list([(H)|T]) :-
    H = (HC,_HI),
    retractall(dependency(_,_,_,_)),
    get_canonical_form(HC,FLCANON(Wrap,Args,Mod,_Callable,_TF)),
    ( ignored(W1,A1,M1), subsumes(ignored(W1,A1,M1),ignored(Wrap,Args,Mod)) ->
        true
    ;
        (
            depend_detail(H,dep(Body,anu(A,N,U),Template)),
            assert(dependency(H,Body,anu(A,N,U),Template)),
            fail
        ;
            true
        ),
        aggregate_warnings
    ),
    depend_list(T).

depend_detail((_Sk1,IndSk1),dep(S,anu(A,N,U),Templ)) :-
    same_rule(IndSk1,_RuleHead,(B,BI),anu(A,N,U)),
    get_canonical_form(B,FLCANON(Wrap,Args,Mod,_Callable,_TF)),
    ( ignored(W1,A1,M1), subsumes(ignored(W1,A1,M1),ignored(Wrap,Args,Mod)) ->
        fail
    ;
        ( var(Wrap),S = (B,BI); nonvar(Wrap),target(Wrap,Args,Mod),S = (B,BI); copy_term(B,CP),rec_depend(CP,S,A,N,U,Templ))
    ).


/****************************************************************************
  rec_depend(+Head,-(Body,IndexedBody),-A,-N,-U,-T)
  Search for all possible dependencies rooted from Head. 
  For each rule whose head can unify with Head, we consider the body. If
  1) the rule body unifies with some target, then we have found a dependency
  2) otherwise, the body and its cut-off form will be recursively checked
 ****************************************************************************/
rec_depend(H,S,A,N,U,T) :-
    match_rule(H,_RuleHead,(RB,RBI),anu(A,N,U)),
    get_canonical_form(RB,FLCANON(Wrap,Args,Mod,_Callable,_TF)),
    ( ignored(W1,A1,M1), subsumes(ignored(W1,A1,M1),ignored(Wrap,Args,Mod)) ->
        fail
    ;
        ( var(Wrap),S = (RB,RBI); nonvar(Wrap),target(Wrap,Args,Mod),S = (RB,RBI); 
        ( (depth(RB,Depth),Depth>MAXDEPTH) ->
            cut_off(RB,NRB),
            T=t,
            copy_term(NRB,CP), rec_depend(CP,S,A,N,U,T)
        ;
            copy_term(RB,CP), rec_depend(CP,S,A,N,U,T)
        ))
    ).


/****************************************************************************
  match_rule(+Term,-Head,-Body,?anu(A,N,U))
  find rules whose heads unify with Term
 ****************************************************************************/
match_rule(T,(H,IH),B,anu(A,N,U)) :-
	rule((H,IH),B,anu(A,N,U)),
	T=H.

/****************************************************************************
  same_rule(+IndTerm,-Head,-Body,?anu(A,N,U))
  find rules whose heads unify with Term
 ****************************************************************************/
same_rule(IT,(H,IH),B,anu(A,N,U)) :-
	rule((H,IH),B,anu(A,N,U)),
	IT=IH.


/****************************************************************************
  generate_rules(+CodeList)
  generate rules from intermediate code
  assert tabled head -- tabled_head(_)
  assert hilog predicates excluded from dependency checking -- ignored(_)
 ****************************************************************************/
generate_rules([]) :- !.
generate_rules(CodeList) :-
	retractall(rule(_,_,_)),
	parse_codelist(CodeList),
	retractall(flora_depchk_prefixdef(_,_,_)).

/****************************************************************************
  parse_codelist(+CodeList)
  generate rules from a list of intermediate code
 ****************************************************************************/
parse_codelist([T]) :-
	!,
	parse_code(T).

parse_codelist([T|L]) :-
	parse_code(T),
	parse_codelist(L).


parse_code(Term) :-
	( is_prrule(Term,Head,Body) ->
            parse_rule(Head,Body)
	;
          is_prdirective(Term,Direct) ->
	    ( is_prignoredep(Direct,PList) ->
		assert_ignoredlist(PList)

	    ; is_prprefixdef(Direct,PrefixName,PrefixBody) ->
		is_pratom(PrefixName,NameAtom,_Index),
		is_pratom(PrefixBody,BodyAtom,_Index2),
		flora_concat_atoms(['flora_prefix_',NameAtom],NameCode),
		(flora_depchk_prefixdef(DEFAULT_WORKSPACE,NameCode,_)->retract(flora_depchk_prefixdef(DEFAULT_WORKSPACE,NameCode,_));true),
		assert(flora_depchk_prefixdef(DEFAULT_WORKSPACE,NameCode,BodyAtom))

	    ; true
	    )
        ;
            true
	).

assert_ignoredlist([]) :- !.
assert_ignoredlist([H|L]) :-
	flora_build_struct(H,DEFAULT_WORKSPACE,FLBODYPREFIX,_VarList,HC,_HCI,Status),
	( Status == [] ->
	    ( var(HC) ->
		true    
	    ; 
		( functor(HC,DB,3), dboperation(DB,3) ->
		    HC =.. [DB,WS,DBList,Cond],
		    canonical_list(DBList,CDBList),
		    get_canonical_form(Cond,FLCANON(_W,_A,_M,CallCond,_TF)),
		    NHC =.. [DB,WS,CDBList,CallCond]
		;
		    functor(HC,DB,2), dboperation(DB,2) ->
		    HC =.. [DB,WS,DBList],
		    canonical_list(DBList,CDBList),
		    NHC =.. [DB,WS,CDBList]
		;
		    functor(HC,DB,4), moduleloading(DB,4) ->
		    HC =.. [DB,LList|_Rest],
		    NHC =.. [DB,LList,_,_,_]
		;
		    NHC = HC
		),
		get_canonical_form(NHC,FLCANON(Wrap,Args,Mod,_Callable,_TF))
	    ),
	    assert(ignored(Wrap,Args,Mod)),
	    assert_ignoredlist(L)
	;
	    true
	).

parse_rule(Head,Body) :-
	flora_build_struct(Head,DEFAULT_WORKSPACE,FLBODYPREFIX,VarList,HeadCode,HCI,Status_Head),
	( Status_Head == [] ->
	    functor(HeadCode,F,N),
	    ( default_tabled(F,N) -> assert(tabled_head((HeadCode,HCI))); true),
	    flora_build_struct(Body,DEFAULT_WORKSPACE,FLBODYPREFIX,VarList,BodyCode,BCI,Status_Body),
	    ( Status_Body == [] ->
		assert_rule((HeadCode,HCI),BodyCode,BCI,anu(_,_,_))
	    ;
		true
	    )
	;
	    true
	).

assert_rule(_H,BodyCode,_BI,_) :-
	var(BodyCode),
	!.

assert_rule(_H,FLLIBMODLIT(FL_LIBMOD,_,_,_),_BI,_) :-
        !.

assert_rule(HeadCode,BodyCode,(BCI,_I),anu(A,N,U)) :-
	(BodyCode=','(Body1,Body2); BodyCode=';'(Body1,Body2)),
	(BCI=','(BCI1,BCI2); BCI=';'(BCI1,BCI2)),
	!,
	assert_rule(HeadCode,Body1,BCI1,anu(A,N,U)),
	assert_rule(HeadCode,Body2,BCI2,anu(A,N,U)).

assert_rule(HeadCode,BodyCode,(BCI,_I),anu(A,_,U)) :-
	(BodyCode=not(NewBody); BodyCode=tnot(NewBody)),
	(BCI=not(NewBCI); BCI=tnot(NewBCI)),
	!,
	assert_rule(HeadCode,NewBody,NewBCI,anu(A,n,U)).

assert_rule(_HeadCode,BodyCode,(_BCI,_I),anu(_A,_N,_U)) :-
	is_constraint(BodyCode,_),
	!.
	
assert_rule(HeadCode,BodyCode,(BCI,Index),anu(A,N,U)) :-
	is_upd(BodyCode,_,List,Cond),
	!,
	is_updIdxStruct(BCI,(ListI,_I),CondI),
	assert(rule(HeadCode,(BodyCode,(BCI,Index)),anu(A,N,u))),
	assert_rule(HeadCode,Cond,CondI,anu(A,N,U)),
	assert_rules(HeadCode,List,ListI,anu(A,N,u)).

assert_rule(HeadCode,BodyCode,(BCI,Index),anu(A,N,U)) :-
	is_updall(BodyCode,_,List,Cond),
	!,
	is_updallIdxStruct(BCI,(ListI,_I),CondI),
	assert(rule(HeadCode,(BodyCode,(BCI,Index)),anu(a,N,u))),
	assert_rule(HeadCode,Cond,CondI,anu(A,N,U)),
	assert_rules(HeadCode,List,ListI,anu(A,N,u)).

assert_rule(HeadCode,BodyCode,(BCI,Index),anu(_,N,U)) :-
	is_agg(BodyCode,_,_,_,Condition,_),
	!,
	is_agg(BCI,_,_,_,ConditionI,_),
	assert(rule(HeadCode,(BodyCode,(BCI,Index)),anu(a,N,U))),
	assert_rule(HeadCode,Condition,ConditionI,anu(a,N,U)).

assert_rule(HeadCode,BodyCode,(BCI,_I),anu(A,N,U)) :-
	is_control(BodyCode,_,Args),
	!,
	is_control(BCI,_,ArgsI),
	assert_rules(HeadCode,Args,ArgsI,anu(A,N,U)).

assert_rule(HeadCode,BodyCode,(BCI,_I),anu(A,N,U)) :-
	BodyCode = flsysdbupdate(NewBody,_,_),
	!,
	BCI = flsysdbupdate(NewBCI,_,_),
	assert_rule(HeadCode,NewBody,NewBCI,anu(A,N,U)).

assert_rule(HeadCode,BodyCode,BCwithIndex,anu(A,N,U)) :-
	assert(rule(HeadCode,(BodyCode,BCwithIndex),anu(A,N,U))).

assert_rules(_,[],_,_) :- !.
assert_rules(HeadCode,[H|T],[HI|TI],anu(A,N,U)) :-
    assert_rule(HeadCode,H,HI,anu(A,N,U)),
    assert_rules(HeadCode,T,TI,anu(A,N,U)).

/****************************************************************************
 check_for_dependencies(+CodeList,-WarnList)
 check whether tabled predicates depend on procedural/database operations.
 ****************************************************************************/
check_for_dependencies(CodeList,WarnList) :-
        retractall(tabled_head(_)),
	retractall(warning_seen(_,_,_,_,_)),
        retractall(target(_,_,_)),
        retractall(ignored(_,_,_)),
        flora_abolish_table_predicate(rec_depend(_,_,_,_,_,_)),
        assert_targets,

	generate_rules(CodeList),
        findall(Head,tabled_head(Head),TabledList),
        depend_list(TabledList),
	generate_warnings(WarnList),
	!.

check_for_dependencies(_CodeList,[error(UNKNOWN_ERROR)]).

assert_targets :- 
        procedural(F,A),
        length(Args,A),
        assert(target(F,Args,_Mod)),
        fail.

assert_targets :- 
        dboperation(F,A),
        length(Args,A),
        assert(target(F,Args,_Mod)),
        fail.

assert_targets :- 
        moduleloading(F,A),
        length(Args,A),
        assert(target(F,Args,_Mod)),
        fail.

assert_targets :- !.

/****************************************************************************
 aggregate_warnings
 find all asserted dependency/4, generate warnings and aggregate them
 ****************************************************************************/
aggregate_warnings :-
	findall(((T1,IT1),(T2,IT2),anu(A,N,U),Temp),
		dependency((T1,IT1),(T2,IT2),anu(A,N,U),Temp),
		DependencyList
	       ),
	aggregate_warnings(DependencyList).

aggregate_warnings([]) :- !.
aggregate_warnings([((T1,IT1),(T2,IT2),_,_)|T]) :-
	flora_set_counter(min_ind,0),
	flora_set_counter(next_min_ind,0),
	to_string(T1,IT1,Str1,RuleID),
	flora_get_counter(min_ind,HMinInd),
	flora_get_counter(next_min_ind,HNMinInd),

	flora_set_counter(min_ind,0),
	flora_set_counter(next_min_ind,0),
	to_string(T2,IT2,Str2,_RID),
	flora_get_counter(min_ind,BMinInd),

        functor(T2,Wrap,NArgs),
        ( dboperation(Wrap,NArgs) ->
	    Type = 'db operation'
	; moduleloading(Wrap,NArgs) ->
            Type = 'loading operation'
        ;
            (get_canonical_form(T2,FLCANON(WRAP_HILOG,_As,_Mod,_Callable,_TF)) ->
                Type = 'procedural predicate'
            ;
	        Type = 'procedural method'
            )
	),

        fmt_write_string(WarnHead,"Tabled literal in the head of rule that starts with %s", args(Str1)),
        fmt_write_string(WarnBody," depends on %s %s", args(Type,Str2)),

	( warning_seen(RuleID,HInd1,HInd2,BMinInd,_) ->
	    ( (HInd1<HMinInd;HInd1=HMinInd),(HInd2<HNMinInd;HInd2=HNMinInd) ->
	        true
	    ;
	        retract(warning_seen(RuleID,HInd1,HInd2,BMinInd,_)),
		assert(warning_seen(RuleID,HMinInd,HNMinInd,BMinInd,(WarnHead,WarnBody)))
	    )
	;
	    assert(warning_seen(RuleID,HMinInd,HNMinInd,BMinInd,(WarnHead,WarnBody)))
	),
	aggregate_warnings(T).

/****************************************************************************
 to_string(+Term,+IndexedTerm,-Str,-RuleID)
 ****************************************************************************/
to_string(Term,IndTerm,Str,RuleID) :-
	flora_decode_goal_as_atom(Term,Text),
	set_indexes(IndTerm),
	flora_get_counter(min_ind,Index),
	( (Index==NO_INDEX) ->
	    fmt_write_string(Str,"`%s'",args(Text)),
	    RuleID==NO_INDEX
	;
 	    flora_token_rulenum(Index,RuleID),
 	    flora_nth_token(Index,Token),
	    flora_token_text(Token,_T,BL,BC,_EL,_EC),
	    fmt_write_string(Str,"`%s' near line(%d)/char(%d)",
			     args(Text,BL,BC))
	).

/****************************************************************************
 set_indexes(+IndTerm)
 set the counters min_ind and next_min_ind for IndTerm
 ****************************************************************************/
set_indexes(T) :-
	( (atomic(T);var(T)) ->
	    true
        ; is_list(T) ->
            set_indexes_list(T)
        ).

set_indexes((T,Index)) :-
        !,
	( Index == NO_INDEX ->
	    true
	;
	    flora_get_counter(min_ind,MinInd),
	    flora_get_counter(next_min_ind,NextMinInd),
	    ( (Index<MinInd; MinInd=0) ->
	        flora_set_counter(next_min_ind,MinInd),
	        flora_set_counter(min_ind,Index)
	    ;
	        ( (Index<NextMinInd; NextMinInd=0) ->
	            flora_set_counter(next_min_ind,Index)
	        ;
	            true
	        )
	    )
	),
	( (atomic(T);var(T)) ->
	    true
        ; is_list(T) ->
            set_indexes_list(T)
	;
	    T =.. [_F|Args],
	    set_indexes_list(Args)
	).

set_indexes(T) :-
        T =.. [_F|Args],
        set_indexes_list(Args).
        

set_indexes_list([]) :- !.
set_indexes_list([H|L]) :-
	set_indexes(H),
	set_indexes_list(L).
	 
 	
/****************************************************************************
 generate_warnings(-WarnList)
 ****************************************************************************/
generate_warnings(WarnList) :-
	findall((HInd1,BInd,WarnMsg),warning_seen(_,HInd1,_,BInd,WarnMsg),WL),
	sort(WL, SortedWL),
	append_warnings(SortedWL,WarnList).

append_warnings([],[]) :- !.
append_warnings([(HInd,BInd,WarnMsg)|T],[warning(HInd,BInd,WarnMsg)|InterWarnList]) :-
	append_warnings(T,InterWarnList).


/****************************************************************************
 canonical_list(+L1,-L2)
 ****************************************************************************/
canonical_list([], []) :- !.
canonical_list([H|L],[Callable|NL]) :-
        get_canonical_form(H,FLCANON(_,_,_,Callable,_TF)),
        canonical_list(L,NL).

