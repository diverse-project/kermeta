/* File:      assert.P
** Author(s): Kostis Sagonas, David S. Warren
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: assert.P,v 1.36 2006/05/21 21:54:04 tswift Exp $
** 
*/


:- compiler_options([xpp_on,sysmod,optimize]).
#include "builtin.h"
#include "psc_defs.h"
#include "thread_defs_xsb.h"

/*======================================================================*/
/* Predicates to add dynamic clauses in Prolog's database:		*/
/*  - assert(+Clause)							*/
/*	same as assert(Clause, 1, 1)					*/
/*  - asserta(+Clause)							*/
/*	same as assert(Clause, 0, 1)					*/
/*  - assertz(+Clause)							*/
/*	same as assert(Clause, 1, 1)					*/
/*  - asserti(+Clause, +Index)						*/
/*	same as assert(Clause, 1, Index)				*/
/* where:								*/
/*    assert(+Clause, +AorZ, +Index)            			*/
/*	Asserts a clause.		                                */
/*	AorZ/\1:  0 for insertion as the first clause, 1 for as last.	*/
/*	AorZ/\2:  0 for uniform treatment of anonymous variables,	*/
/*		  2 for special treatment of anonymous variables.	*/
/*	Index: the number of the argument on which to index; 		*/
/*		0 for no indexing. (If there is index declaration, this	*/
/*			argument is ignored.)				*/
/*======================================================================*/

/*======================================================================*/
/* Formats for dynamic code:						*/
/* PSC rec point to:							*/
/*	PrRef:								*/
/*		0: BC instruction: fail (if empty),			*/
/*			jump and save breg (if nonempty)		*/
/*		4: Addr of first Clref on ALL chain			*/
/*		8: Addr of last Clref on ALL chain			*/
/*									*/
/* PrRef's point to chain of ClRef's (one of 3 types):			*/
/* (the -8 location stores length of buff + flag indicating ClRef type	*/
/*	ClRef2 (for compiled code):					*/
/*		-8: length of buffer (+2)				*/
/*		-4: Addr of previous ClRef (or PrRef)			*/
/*		0: Try-type instruction, for chain			*/
/*		4: (cont) Addr of next ClRef on chain			*/
/*		8: jump							*/
/*		12: Addr of compiled code				*/
/*	ClRef0 (for unindexed asserted code):				*/
/*		-8: length of buffer (+0)				*/
/*		-4: Addr of previous ClRef (or PrRef)			*/
/*		0: Try-type instruction, for chain			*/
/*		4: (cont) Addr of next ClRef on chain			*/
/*		8+: BC for asserted clause				*/
/*	ClRef1 (for group of indexed clauses, aka SOB record):		*/
/*		-8: length of buffer (+1)				*/
/*		-4: Addr of previous ClRef (or PrRef)			*/
/*		0: Try-type instruction, for chain			*/
/*		4: (cont) Addr of next ClRef on chain			*/
/*		8: BC switch-on-bound instruction (drop thru if var)	*/
/*		11: (cont) arg to index on				*/
/*		12: (cont) address of Hash Table			*/
/*		16: (cont) size of Hash Table				*/
/*		20: BC jump to	(or fail if empty)			*/
/*		24: (cont) Addr of first ClRefI on all subchain		*/
/*		28: Addr of last ClRefI on all subchain			*/
/*		32: Number of clauses in hash table			*/
/*		36+: Hash Table						*/
/*									*/
/* ClRef1's point to indexed clauses, each represented by a ClRefI:	*/
/*	ClRefI (for an indexed clause):					*/
/*		-8: length of buffer (+3)				*/
/*		-4: Addr of previous ClRefI on all chain		*/
/*		0: Try-type instruction, for all subchain		*/
/*		4: (cont) Addr of next ClRefI on all subchain		*/
/*		8: BC noop(6) to skip next 12 bytes			*/
/*		12: Addr of previous ClRefI on bucket chain		*/
/*		16: Try-type instruction, for hash bucket subchain	*/
/*		20: (cont) Addr of next ClRefI in bucket		*/
/* and for each additional index:					*/
/*		24: BC noop(6) to skip next 12 bytes			*/
/*		28: Addr of previous ClRefI on bucket chain		*/
/*		32: Try-type instruction, for hash bucket subchain	*/
/*		36: (cont) Addr of next ClRefI in bucket		*/
/*		40+: BC for asserted code				*/
/*									*/
/*======================================================================*/


% NOTE: Predicate assert0/1 is a quicker assert/1 with no error
%	checking, provided for system usage only.

assert0(Clause) :- assert(Clause,1,1).


assert(Clause)  :-
	check_assert(Clause, 'assert/1'),
	call_xsb_hook(xsb_assert_hook(_),Clause,all),
	assert(Clause,1,1,'assert/1').
asserta(Clause) :-
	check_assert(Clause,'asserta/1'),
	call_xsb_hook(xsb_assert_hook(_),Clause,all),
	assert(Clause,0,1,'asserta/1').
assertz(Clause) :-
	check_assert(Clause,'assertz/1'),
	call_xsb_hook(xsb_assert_hook(_),Clause,all),
	assert(Clause,1,1,'assertz/1').


/* Obsolete.
call_assert_hook(Clause) :-
	term_psc(assert_hook(_),Psc),
	psc_type(Psc,Type),
	(Type > T_ORDI % basically means: != T_ORDI
	 ->	call_c(assert_hook(Clause))
	 ;	true
	).
*/

% NOTE: Predicates asserti[a,z]/2 though exported, are not available to
%	the user (in the intepreter) and so no error checking is done.
%	Should they become available in the interpreter error checking
%	must be added to them.

asserti(Clause, Index) :- assert(Clause,1,Index).
assertai(Clause,Index) :- assert(Clause,0,Index).
assertzi(Clause,Index) :- assert(Clause,1,Index).

% Safeguard.
assert(Clause,AZL,Index):- assert(Clause,AZL,Index,'assert/1').

assert(Clause, AZL, Index1,ErrPred) :-
	(Clause = (Head:-_)
	 ->	conpsc(Head, PSC)
	 ;	Clause = Head -> conpsc(Head, PSC)
	),
	psc_arity(PSC, Arity),
	('_$trie_asserted'(Clause) 
	 ->	t_assert_1(Clause, _Flag)
	 ;	( '_$index'(Head,Index,HashTabSize)
		 ->	true
		 ;	integer(Index1)
		 ->	(Index1 > Arity
			 ->	Index = 0,default_assert_size(HashTabSize)
			 ;	Index1 < 0
			 ->	Index = 1,default_assert_size(HashTabSize)
			 ;	Index = Index1,default_assert_size(HashTabSize)
			)
		 ;	Index = Index1,default_assert_size(HashTabSize)
		),
		NArity is Arity+1, % to hold the cut addr
		convert_to_dyna(Head,Prref,ErrPred),
		cut_transform(Clause,Nclause),
		code_to_buff(Nclause,AZL),
		AZ is AZL /\ 1,
		assert_buff_to_clref(Head,NArity,Prref,AZ,Index,HashTabSize)
	).

/* Must fail after code is put into buffer, to reset variables bound in 
   the process */
code_to_buff(Clause,AZ) :-
	(AZ =< 1
	 ->	assert_code_to_buff(Clause), fail
	 ;	bind_single_occ_vars(Clause,'$assertAVAR'),
		assert_code_to_buff(Clause), fail
	).
code_to_buff(_,_).

/* bind all single-occurrence variables in Term to Val.  Used so
assert in C will know which variables are anonymous and can generate
better code for them (and not use registers) */
bind_single_occ_vars(Term,Val) :-
	(ground(Term)
	 ->	true
	 ;	accumulate_vars(Term,AllVars,[]),
		parsort(AllVars,asc,0,SAllVars),
		SAllVars = [V1|RVars],
		bind_single_occs_f(RVars,V1,Val)
	).

accumulate_vars(Term,Vars0,Vars) :-
	(var(Term)
	 ->	Vars0 = [Term|Vars]
	 ; atomic(Term)
	 ->	Vars0 = Vars
	 ;	Term =.. [_|Args],
		accumulate_vars_list(Args,Vars0,Vars)
	).

accumulate_vars_list([],Vars,Vars).
accumulate_vars_list([T|Ts],Vars0,Vars) :-
	accumulate_vars(T,Vars0,Vars1),
	accumulate_vars_list(Ts,Vars1,Vars).

bind_single_occs_f([],Val,Val).
bind_single_occs_f([V1|RVars],V1a,Val) :-
	(V1 == V1a
	 ->	bind_single_occs(RVars,V1a,Val)
	 ;	V1a = Val,
		bind_single_occs_f(RVars,V1,Val)
	).

bind_single_occs([],_V1a,_Val).
bind_single_occs([V1|RVars],V1a,Val) :-
	(V1 == V1a
	 ->	bind_single_occs(RVars,V1a,Val)
	 ;	bind_single_occs_f(RVars,V1,Val)
	).

/*======================================================================*/
/* check_assert(+Clause, +Predicate_Called)				*/
/*	Given the Clause to be asserted in the database and the flavor	*/
/*	of assert used, checks the Clause for errors so  that Prolog's	*/
/*	database remains consistent. As usual, if an error is detected	*/
/*	the predicate aborts.						*/
/*	The errors that can occur are:					*/
/*	  - instantiation error: If Head of Clause is uninstantiated.	*/
/*	  - type error: If Head of Clause is not a callable term or	*/
/*		if Body contains a non-callable goal.			*/
/*	  - permission error: If the predicate corresponding to Head	*/
/*		is one of XSB's built-in predicates (Database error).	*/
/*======================================================================*/

check_assert((Head :- Body), Pred) :- 
	!,			% This captures Clause being variable
	( var(Head) ->
	    instantiation_error(Pred,1,nonvar)
	; check_assert_fact(Head, Pred), 
	  ( check_body(Body) -> true
	  ; type_error(callable,Body,Pred,1)
	  )
	).
check_assert(Head, Pred) :- check_assert_fact(Head, Pred).

% TLS: note that checking for static is done in convert_to_dyna
check_assert_fact(Head, Pred) :- 	% asserting a fact
	( callable(Head) -> 
	    ( functor(Head, F, A),
		standard_symbol(F, A, _Prop),
		\+ standard_dynamic_symbol(F, A) ->
		permission_error(modify,builtin,F/A,Pred)
	    ;	true
	    )
	; type_error(callable,Head,Pred,1)
	).

check_body(X) :- var(X), !.
check_body((X,Y)) :- !, check_body(X), check_body(Y).
check_body(X) :- callable(X).

/*======================================================================*/
/* cut_transform(+Clause, -NewClause)					*/
/*	Transform cuts to '_$cutto'.					*/
/*======================================================================*/

cut_transform((Head:-Body),(Nhead:-Nbody)) :- !,
	Head =.. Hlist,
	append(Hlist,[Cutpoint],Nhlist),
	Nhead =.. Nhlist,
	goal_cut_trans(Body,Nbody,Cutpoint).
cut_transform(Head,Head). /* leave unchanged, Arity is one less */

/*======================================================================*/
/* convert_to_dyna(+PredHead, -Prref, +ErrPred)				*/
/*	Convert the predicate to DYNA, and return its Prref.		*/
/*	If it is already a dynamic pred, simply return its Prref.	*/
/*======================================================================*/

% TLS: went into inf loop when Spec was var and failed when Spec was
% 1.  Note that convert_to_dyna/3 only handles cases where there is a 
% prref and that prref is inconsistent.

dynamic(Spec):- 
	(var(Spec) -> 
	    instantiation_error(dynamic,1,nonvar)
	 ;  dynamic_1(Spec) ).

dynamic_1((P1,P2)) :- !, dynamic(P1), dynamic(P2).
dynamic_1(Spec) :- 
	mpa_to_skel(Spec,Head), !,
	conpsc(Head,Psc),
	psc_type(Psc,SymType),
	(SymType \== T_DYNA
	 ->	psc_set_ep(Psc,4), % set to addr of fail instruction
		psc_set_type(Psc,T_DYNA)
	 ;	true
	),
	convert_to_dyna(Head,_,'dynamic/1'),!.
dynamic_1(Spec) :- 
	type_error(comma_list_callable,Spec,dynamic,1).

convert_to_dyna(PHead,Prref,ErrPred) :-
	xsb_sys_mutex_lock(MUTEX_DYNAMIC),
	conpsc(PHead, PSC),
	psc_type(PSC, SYMTYPE),
	( SYMTYPE =:= T_DYNA ->			/* already dynamic */
	   db_get_prref(PSC,Prref)
	; SYMTYPE =:= T_ORDI  ->   	     /* undefined, it's first clause */
		db_new_prref(PSC,PHead,Prref)
	; SYMTYPE =:= T_UDEF  ->    	     /* unloaded, this is 1st clause */
		db_new_prref(PSC,PHead,Prref)
	; SYMTYPE =:= T_PRED ->		     /* compiled, illegal */
                functor(PHead, F, A),
		xsb_sys_mutex_unlock(MUTEX_DYNAMIC),
		permission_error(modify,static,F/A,ErrPred)
	; 
		xsb_sys_mutex_unlock(MUTEX_DYNAMIC),
		type_error(callable,PHead,ErrPred,1)
	),
	xsb_sys_mutex_unlock(MUTEX_DYNAMIC).

/*======================================================================*/
/* db_new_prref(+PSC,+PHead,-Prref):					*/
/*	creates an empty Prref, i.e.  one with no clauses in it.  	*/
/*	If called, it will simply fail.  Prref must be a variable at 	*/
/*	the time of call.  It points the entry point of the psc record	*/
/*	pointed to by PSC to this Prref.  So in effect it makes it	*/
/*	dynamic.	 						*/
/*	Prref ->:							*/
/*		-4: Addr of last Clref on ALL chain			*/
/*		0: BC instruction: fail (if empty),			*/
/*			jump and save breg (if nonempty)		*/
/*		4: Addr of first Clref on ALL chain			*/
/*======================================================================*/

db_new_prref(PSC,_PHead,Prref) :-
	db_build_prref(PSC, _Tabled, Prref).

/*======================================================================*/
/* get_dynamic_pred_ep(+PHead,+CallingRef,-PredEP,-PSC):    	        */
/*	returns the PredEP for the predicate that is the main functor	*/
/*      symbol of PHead.  CallingRef is used in the error message	*/
/*      thrown if PHead is a compiled predicate.  The predicate fails	*/
/*      if PHead is undefined, and succeeds returning the PredEP if	*/
/*      PHead is a dynamic predicate.					*/
/*                                                                      */
/* TLS: changed to return PSC, also                                     */ 
/*									*/
/*======================================================================*/

get_dynamic_pred_ep(Head,CallingPred,PredEP,PSC) :-
	conpsc(Head, PSC),
	psc_type(PSC,Type),
	(Type =:= T_PRED		/* is compiled */
	 ->	functor(Head,F,A),
		permission_error(modify,static,F/A,CallingPred)
	 ;	Type =:= T_DYNA, % is DYNA 
		psc_ep(PSC, PredEP) % get PredEP
	).
	

/*======================================================================*/
/* retract(+Fact)							*/
/*	this routine retracts facts. It does so by running the chain of */
/*	buffers, explicitly. When it finds a fact that unifies, it 	*/
/*	overwrites the first instruction in the buffer (after the 	*/
/*	retrymeelse instruction) to be a fail. This is somewhat of a 	*/
/*	kludge but is easy. Besides you shouldn't be using retract 	*/
/*	anyway. 							*/
/*	(dsw 4/21/92) It's also incorrect. It deletes ALL clauses in	*/
/*	the group COMPILED with it. This is particularly unpleasant in	*/
/*	op/3, where redefining a 'builtin' operator, deletes them ALL.	*/
/*======================================================================*/


retract(Rule) :-	% changed for multifile predicates (2/24/98)
	(Rule = (Head :- Body)
	 ->	true
	 ;	Head = Rule, Body = true
	),
	call_xsb_hook(xsb_retract_hook(_),[Head,Body],all),
	(nonvar(Head), '_$multifile_retract'(Head, _, _)
	 % argument 1 fo retract/1 must be instantiated
	 ->	do_multifile_retract(Head, Body)
	 ;	retract0((Head :- Body))
	).

do_multifile_retract(Head, Body) :-
	'_$multifile_retract'(Head, _, New_Head),
	check_retract(New_Head, multifile_retract/1),
	(get_dynamic_pred_ep(New_Head,'retract/1',PredEP,PSC)
	 ->	true
	 ;	db_retract(New_Head, Body, PredEP, PSC)
	).


retract0(Rule) :-	% original retract/1, is used in standard.P
	(Rule = (Head :- Body)
	 ->	true
	 ;	Head = Rule, Body = true
	),
	check_retract(Head, retract/1),
	get_dynamic_pred_ep(Head,'retract/1',PredEP,PSC),
	db_retract(Head, Body, PredEP,PSC).

retractall(Fact) :-
	call_xsb_hook(xsb_retract_hook(_),[Fact,true],all),
	(nonvar(Fact), '_$multifile_retract'(Fact, _, _)
	 ->	do_multifile_retractall(Fact)
	 ;	retractall0(Fact)
	).

do_multifile_retractall(Fact) :-
	'_$multifile_retract'(Fact, _, New_Fact),
	retractall0(New_Fact),
	fail.
do_multifile_retractall(_).

retractall0(Fact) :-
	check_retract(Fact, retractall/1),
	(get_dynamic_pred_ep(Fact,'retractall/1',PredEP,PSC)
	 ->	db_retractall(Fact, PredEP,PSC)
	 ;	true
	).

retract_nr(Rule) :-
	obsolete(retract_nr/1, retract/1),
	(Rule = (Head :- Body)
	 ->	true
	 ;	Head = Rule, Body = true
	),
	check_retract(Head, retract_nr/1),
	get_dynamic_pred_ep(Head,'retract_nr/1',PredEP,PSC),
	db_retract_nr(Head, Body, PredEP,PSC).

reclaim_space(Fact) :-
	obsolete(reclaim_space/1, gc_dynamic/0),
	check_retract(Fact, reclaim_space/1),
	(get_dynamic_pred_ep(Fact,'reclaim_space/1',PredEP,_PSC)
	 ->	db_reclaim_space(Fact, PredEP)
	 ;	true
	).

/*======================================================================*/
/*									*/
/* retract_last_fact(+Skel) should only be applied to dynamic predicates*/
/* containing only facts.  Skel must be a most-general term.		*/
/* retract_last retracts the last fact of the predicate and returns	*/
/* the bindings in Skel.						*/
/*									*/
/*======================================================================*/

retract_last_fact(Skel) :-
	(is_most_general_term(Skel)
	 ->	true
	 ;      instantiation_error(retract_last_fact/1,1,skeleton)
	),
	get_dynamic_pred_ep(Skel,'retract_last_fact/1',PredEP,PSC),
	db_get_last_clause(PredEP,Clref,_Type,EntryPoint),
	do_dyn_code_call(EntryPoint,Skel),
	db_retract0(Clref,0,PSC).

do_dyn_code_call(EntryPt,Skel) :-
	code_call(EntryPt,Skel,1). % 1 => dynamic pred, and last call in clause.

/*======================================================================*/
/* check_retract(+Head_of_Clause, +Predicate_Called)			*/
/*	Given the Head of the Clause to be retracted from the database	*/
/*	checks it for exceptions so that Prolog's database remains	*/
/*	consistent. As usual, if an error is detected the predicate	*/
/*	aborts.								*/
/*	The errors that can occur are:					*/
/*	  - instantiation error: If Head_of_Clause is uninstantiated.	*/
/*	  - type error: If Head_of_Clause is not a callable term.	*/
/*	  - permission error: If the predicate corresponding to Head	*/
/*		is one of XSB's built-in predicates (Database error).	*/
/*	Note that it is not a type error to call the retract(s) with	*/
/*	Head a functor of a non-dynamic procedure, or with a body	*/
/*	instantiated to a non-valid Prolog body. In these cases		*/
/*	predicate retract or retractall simply fail.			*/
/*======================================================================*/

% TLS: note that static check is done in get_dynamic_pred_ep
check_retract(Head, Pred) :-
	( var(Head) ->
	    instantiation_error(Pred,1,nonvar)
	; (callable(Head) -> 
	    (   functor(Head, F, A),
		standard_symbol(F, A, _Prop),
		\+ standard_dynamic_symbol(F, A) ->
		    permission_error(modify,builtin,F/A,Pred)
		;   true
		)
	;  type_error(callable,Head,Pred,1))
	).

/*======================================================================*/
/* abolish(+Pred/+Arity) or abolish(+PredSpec)				*/
/*	Removes all procedures specified from the Prolog database.	*/
/*	After this command is executed the current program functions	*/
/*	as if the named procedures had never existed. Predicate		*/
/*	abolish/[1,2] removes all clauses of the specified procedure	*/
/*	regardless of whether they are dynamic or compiled, but it	*/
/*	cannot abolish built-in predicates or predicates in unloaded	*/
/*	modules.							*/
/*	As it ought to, abolish/[1,2] does not complain when trying to	*/
/*	abolish an undefined predicate.					*/
/*======================================================================*/
abolish(Spec) :-
	(var(Spec)
	 ->     instantiation_error(abolish/1,1,nonvar)
	 ; Spec = (Pred/Arity)
	 ->	(var(Pred)
                 -> instantiation_error(abolish/1,1,
		                        'nonvar predicate indicator')
		 ; check_arity_integer(Arity,abolish/1,1),
		   functor(Nspec,Pred,Arity)
		)
	 ; Nspec = Spec, functor(Nspec,Pred,Arity)
	),
	(standard_symbol(Pred,Arity,_Prop)
	 ->	permission_error(modify,builtin,Pred/Arity,abolish/1)
	 ;      call_xsb_hook(xsb_retract_hook(_),[Nspec,true],all),
		abolish1(Nspec)
	).

/*======================================================================*/
/* abolish(+Pred, +Arity)						*/
/*	Predicate abolish/2 is an obsolete special case of abolish/1	*/
/*	maintained here to provide compatibility with DEC-10 Prolog,	*/
/*	Quintus Prolog, C Prolog and earlier versions of SB and		*/
/*	PSB-Prolog.							*/
/*======================================================================*/

abolish(Pred,Arity) :-
	functor(Spec,Pred,Arity),
	abolish1(Spec).

abolish1(Term) :-
	retract_index(Term),
	retract_trie_index(Term),
	retract_table(Term),
	conpsc(Term,Psc),
	psc_type(Psc, Type),
	(Type =:= T_DYNA	    % DYNA
	 ->	db_abolish(Psc)
	 ; Type =:= T_PRED	    % normal compiled predicate
	 ->	psc_ep(Psc,Ep),	    % get entry point
		unload_seg(Ep),	    % free the space
		psc_set_type(Psc, T_ORDI),
		psc_set_ep(Psc, 0)
		/*,psc_set_env(Psc, T_UNLOADED)*/
	 ;	Type =:= T_ORDI	 /* need to check imported !!!! */
	).


/*======================================================================*/
/* clause(+Head, ?Body)							*/
/*	Predicate clause/2 searches the database for a clause whose	*/
/*	head matches the given Head and whose body matches Body. So	*/
/*	Head must be instantiated. This procedure is non-deterministic.	*/
/*	it can be used to backtrack through all the clauses matching	*/
/*	a given Head and Body. It fails when there are no (or no	*/
/*	further) matching clauses in the database.			*/
/*	In the case of unit-clauses, Body is unified with 'true'.	*/
/*======================================================================*/

clause(Head, Body) :-
	check_clause(Head),
	clause0(Head, Body0),
	goal_cut_untrans(Body0, Body).


clause0(Head, Body) :-
	get_dynamic_pred_ep(Head,'clause0/2',PredEP,_PSC),
	db_clause(Head,Body,PredEP,_Clref).


/*======================================================================*/
/* check_clause(+Head_of_Clause)					*/
/*	Given the Head of the Clause to be asserted in the database	*/
/*	checks this Head for errors. As usual, if an error is detected	*/
/*	the predicate aborts.						*/
/*	The errors that can occur are:					*/
/*	  - instantiation error: If Head of Clause is uninstantiated.	*/
/*	  - type error: If Head of Clause is not a callable term.	*/
/*	  - permission error: If the predicate corresponding to Head	*/
/*		is one of XSB's built-in predicates (Database error).	*/
/*	Note that it is not a type error to call clause/2 with Head a	*/
/*	functor of a non-dynamic procedure, or with body instantiated	*/
/*	to a non-valid Prolog body. In these cases predicate clause/2	*/
/*	simply fails.							*/
/*======================================================================*/

% TLS: note that static check is done in get_dynamic_pred_ep
check_clause(Head) :-
	( var(Head) ->
	    instantiation_error(clause/2,1,nonvar)
	;   callable(Head) -> 
	    (	functor(Head, F, A),
		standard_symbol(F, A, _Prop),
		\+ standard_dynamic_symbol(F, A)
	    ->	permission_error(access,builtin,F/A,clause/2)
	    ;	true
	    )
	  ; type_error(callable,Head,clause/2,1)
	).

/*======================================================================*/
/*======================================================================*/
t_assert(Clause, Flag) :- check_assert(Clause,'trie_assert/1'),
	t_assert_1(Clause, Flag).

t_assert_exit(Clause) :- abort(('Illegal Term in trie_assert:',Clause)).

t_assert_1((Head :- Body), _Flag) :- t_assert_exit((Head :- Body)).
t_assert_1(Clause, Flag) :- 
	conpsc(Clause, PSC),
	psc_arity(PSC, Arity),
	convert_to_dyna(Clause,Prref,trie_assert/1),
%	writeln(clause(Clause) +psc(PSC) +arity(Arity) +prref(Prref)),
	trie_assert_builtin(Clause,PSC,Arity,Prref,Flag).

/*======================================================================*/
/* exchange_definitions(+Skel1,+Skel2)					*/
/*	Skel1 and Skel2 are predicate terms.  This predicate exchanges	*/
/*	the entry points and types in the PSC records of the two	*/
/*	predicates.							*/
/*======================================================================*/

exchange_definitions(Skel1,Skel2) :-
	conpsc(Skel1,PSC1),
	conpsc(Skel2,PSC2),
	psc_type(PSC1,Type1),
	psc_type(PSC2,Type2),
	psc_ep(PSC1,EP1),
	psc_ep(PSC2,EP2),
	psc_set_ep(PSC1,EP2),
	psc_set_ep(PSC2,EP1),
	psc_set_type(PSC1,Type2),
	psc_set_type(PSC2,Type1).

trie_assert_builtin(_Clause,_PSC,_Arity,_Prref,_Flag) :-
	'_$builtin'(TRIE_ASSERT).

