/* File:      thread.P
** Author(s): Rui Marques
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: thread.P,v 1.11 2006/05/31 22:30:08 tswift Exp $
** 
*/

:- compiler_options([xpp_on,sysmod]).
#include "standard.h"
#include "thread_defs_xsb.h"
#include "flag_defs_xsb.h"

%thread_request(A,B,C,D,E,F,G,H):- 
%	thread_request(A,B,C,D,E).

/* ==================================================================  */
/* User-level API */

/* Error checking for pthread_create() done in C -- all args are input.*/
thread_create( Goal, ThreadId , Options) :- 
	check_callable(Goal,thread_create/2,1),
	check_var(ThreadId,thread_create/2,2),
	check_options_list(Options,GLSize,TCSize,ComplSize,PDLSize,Detached),
	writeln(thread_request( XSB_THREAD_CREATE, Goal, ThreadId, 
	                GLSize,TCSize,ComplSize,PDLSize,Detached)),
	thread_request( XSB_THREAD_CREATE, Goal, ThreadId, 
	                GLSize,TCSize,ComplSize,PDLSize,Detached).

:- import writeln/1 from standard.

check_options_list(Options,_GLSize,_TCSize,_ComplSize,_PDLSize,_Detached):- 
	check_nonvar(Options,thread_create/3,3),
	fail.
check_options_list([],GLSize,TCSize,ComplSize,PDLSize,Detached):- !,
	(var(GLSize) -> GLSize = 0 ; true),
	(var(TCSize) -> TCSize = 0 ; true),
	(var(ComplSize) -> ComplSize = 0 ; true),
	(var(PDLSize) -> PDLSize = 0 ; true),
	(var(Detached) -> Detached = 0 ; true).
check_options_list([Option|Rest],GLSize,TCSize,ComplSize,PDLSize,Detached):- !,
	(Option = glsize(N) ->  set_thread_create_arg(N,GLSize,glsize)
          ; (Option = tcsize(N) -> set_thread_create_arg(N,TCSize,tcsize)
            ; (Option = complsize(N) -> set_thread_create_arg(N,ComplSize,complsize)
              ; (Option = pdlsize(N) -> set_thread_create_arg(N,PDLSize,pdlsize)
                ; (Option = detached(Boolean) -> 
		    (Boolean == true -> Detached = 1 ; Detached = 0)
	            ; 	domain_error(thread_create_option,Option,
		                     thread_create/3,3,'') ) ) ) ) ),
       check_options_list(Rest,GLSize,TCSize,ComplSize,PDLSize,Detached).
check_options_list(Culprit,_GLSize,_TCSize,_ComplSize,_PDLSize,_Detached):- 
	domain_error(thread_create_option_list,Culprit,thread_create/3,3,'').

set_thread_create_arg(Option,Arg,OptionName):- 
	(\+ (Option = Arg) -> 
	    misc_error(('Conflicting options in thread_create/3: ',
	                 OptionName,' set to ',Arg,' and ',Option))
         ; Arg = Option).

/*---------------*/
	    
thread_create( Goal, ThreadId ) :- 
	check_callable(Goal,thread_create/2,1),
	check_var(ThreadId,thread_create/2,2),
	thread_request( XSB_THREAD_CREATE, Goal, ThreadId, 0,0,0,0,0).

/*---------------*/

thread_exit( ExitCode ) 	    :- 
	check_integer(ExitCode,thread_exit/1,1),
	thread_request( XSB_THREAD_EXIT, ExitCode,_, _,_,_,_,_).

thread_exit 		    :- thread_exit( 0).

/*---------------*/

/* Need to check errorval on return, as well as checking input state
   of exitcode */
thread_join(Input, ExitCode) :-
	check_var(ExitCode,thread_join/2,2),
	(var(Input) -> 
	    instantiation_error(thread_join/2,1,ground)
	;  (integer(Input) -> 
	       thread_request( XSB_THREAD_JOIN,Input,Exit,_,_,_,_,_ ),
	       ExitCode = Ball - Exit,
	       ('_$thread_exit_ball'(Id,Ball) -> 
		     retractall('_$thread_exit_ball'(Id,_))
		   ; Ball = no_error_ball)
	    ; (Input = [Id|Rest] -> 
	         ExitCode = [Ball-Exit|ERest],
	         thread_request(XSB_THREAD_JOIN, Id,Exit,_,_,_,_,_),
		 ('_$thread_exit_ball'(Id,Ball) -> 
		     retractall('_$thread_exit_ball'(Id,_))
		   ; Ball = no_error_ball),
	         thread_join(Rest, ERest) 
	       ; (Input = [] -> 
		    ExitCode = []
		  ; domain_error(listof_threadid,Input,thread_join/1,2,'')
	      ) ) ) ).

thread_join( ThreadId )	    :- thread_join( ThreadId, _).

thread_self( ThreadId )	    :- 
	check_var(ThreadId,thread_self/1,1),
	thread_request( XSB_THREAD_SELF, ThreadId, _, _, _, _, _, _ ).

thread_detach(ThreadId) :-
	check_integer(ThreadId,thread_detach/1,1),
	thread_request( XSB_THREAD_DETACH, ThreadId, _, _, _ , _, _, _).

thread_yield:-
	thread_request( XSB_THREAD_YIELD, _,_,_, _, _, _, _).

abolish_private_tables:-
	thread_request( ABOLISH_PRIVATE_TABLES, _,_,_, _, _, _, _).

abolish_shared_tables:-
	thread_request( ABOLISH_SHARED_TABLES, _,_,_, _, _, _, _).

/* ==================================================================  */

/* Obsolescent */
xsb_thread_create(One,Two,Three):- thread_create(One,Two,Three).
xsb_thread_create(One,Two):- thread_create(One,Two).

xsb_thread_cancel(Id):- thread_cancel(Id).

xsb_thread_detach(ThreadId):- thread_detach(ThreadId).

xsb_thread_exit(ExitCode):- thread_exit(ExitCode).
xsb_thread_exit:- thread_exit.

xsb_thread_join(Input, ExitCode) :- thread_join(Input, ExitCode).
xsb_thread_join(Input) :- thread_join(Input).

xsb_thread_property(Id,Property) :- thread_property(Id,Property).

xsb_thread_self(ThreadId):- thread_self(ThreadId).

xsb_thread_yield:- thread_yield.

/* ==================================================================  */

/* System provided mutexes for users */
user_mutex( N, N1, Call) :-
	check_integer(N,Call,1),
	(N1 is N + MUTEX_USER1 - 1,
	 N1 >= MUTEX_USER1,
	 N1 < MAX_SYS_MUTEXES -> 
	   true
         ; domain_error(user_mutex,N,Call,1,'') ).

xsb_user_mutex_lock(N) :- 
	user_mutex(N,N1,xsb_user_mutex_unlock/1), 
	xsb_sys_mutex_lock(N1).
xsb_user_mutex_unlock(N) :- 
	user_mutex(N,N1,xsb_user_mutex_unlock/1), 
	xsb_sys_mutex_unlock(N1).

xsb_show_mutexes:- 
	thread_request( XSB_SHOW_MUTEXES, _,_,_, _,_,_,_).

xsb_mutex_init_np0( MutexId, KindNP) :-
	thread_request( XSB_MUTEX_INIT, KindNP, MutexId, _, _,_,_,_ ).
/* "mutex kind" is a non portable extension to POSIX */
xsb_mutex_init(MutexId) :-
	thread_request( XSB_MUTEX_INIT, XSB_FAST_MUTEX, MutexId, _, _,_,_,_).
xsb_mutex_lock(MutexId) :-
	thread_request( XSB_MUTEX_LOCK, MutexId, _, _, _, _, _, _ ).
xsb_mutex_trylock(MutexId) :-
	thread_request( XSB_MUTEX_TRYLOCK, MutexId, _, _, _, _, _, _).
xsb_mutex_unlock(MutexId) :-
	thread_request( XSB_MUTEX_UNLOCK, MutexId, _, _, _, _, _, _ ).
xsb_mutex_destroy(MutexId) :-
	thread_request( XSB_MUTEX_DESTROY, MutexId, _, _, _, _, _, _  ).

xsb_mutex_init_np( fast, MutexId) :-
	xsb_mutex_init_np0( MutexId, XSB_FAST_MUTEX).
xsb_mutex_init_np( recursive, MutexId) :-
	xsb_mutex_init_np0( MutexId, XSB_RECURSIVE_MUTEX).
xsb_mutex_init_np( error_check, MutexId) :-
	xsb_mutex_init_np0( MutexId, XSB_ERRORCHECK_MUTEX).

xsb_sys_mutex_lock(Id) :- 
	thread_request( XSB_SYS_MUTEX_LOCK, Id, _, _, _, _, _, _ ).
xsb_sys_mutex_unlock(Id) :- 
	thread_request( XSB_SYS_MUTEX_UNLOCK, Id, _, _, _, _, _, _ ).

thread_property(Id,Property) :- 
	thread_request( XSB_THREAD_PROPERTY, Id,Prop1, _, _, _, _, _ ),
	(Prop1 == 1 -> Property = detached ; Property = joinable).

thread_cancel(Id):- 
	check_nonvar(Id,thread_cancel/1,1),
	(Id == 0 -> 
	    permission_error(cancel,main_thread,0,thread_cancel/1)
	  ; true),
	thread_request( XSB_THREAD_INTERRUPT, Id,_, _, _, _, _, _ ).
	
/* ==================================================================  */

xsb_set_init_glstack_size(S) :-
	thread_request( XSB_SET_INIT_GLSTACK_SIZE, S, _, _, _ ,_ , _, _).

xsb_set_init_tcpstack_size(S) :-
	thread_request( XSB_SET_INIT_TCPSTACK_SIZE, S, _, _, _ ,_,_,_).
	  
xsb_set_init_pdl_size(S) :-
	thread_request( XSB_SET_INIT_PDL_SIZE, S, _, _, _ ,_,_,_).

xsb_set_init_complstack_size(S) :-
	thread_request( XSB_SET_INIT_COMPLSTACK_SIZE, S, _, _, _ ,_,_,_ ).

/* ==================================================================  */

/* private predicate that runs a thread */

'_$thread_run'( Goal ) :-
	(catch(call(Goal),Ball,(default_error_handler(Ball))), xsb_thread_exit
	 ;
	 xsb_thread_exit
	).

/* store thread flag predicate in THREAD_RUN flag */

:- init_multi_threading.

init_multi_threading:- 
	term_psc('_$thread_run'(_), PSC), 
	stat_set_flag(THREAD_RUN, PSC).

/**************************************************************/

/** Higher level stuff **/

par_execute( GoalList ) :-
	par_spawn( GoalList, ThreadList ),
	par_wait( ThreadList ).

n_par_execute( Goal, N ) :-
	n_list( Goal, N, GoalList ),
	par_execute( GoalList ).

n_list( _, 0, [] ) :- !.
n_list( X, N, [X|L] ) :- N1 is N - 1, n_list( X, N1, L ).


par_spawn( [], [] ).
par_spawn( [G|GL], [T|TL] ) :- 
	xsb_thread_create( G, T ), par_spawn( GL, TL ).

par_wait( [] ).
par_wait( [T|L] ) :- xsb_thread_join(T), par_wait(L).

exmut_execute( G, M ) :-
	xsb_user_mutex_lock(M), G, !, xsb_user_mutex_unlock(M).
exmut_execute( _, M ) :- xsb_user_mutex_unlock(M).


console_exmut( G ) :- 
	xsb_user_mutex_lock(MUTEX_CONSOLE), 
	G, !, xsb_user_mutex_unlock(MUTEX_CONSOLE).
console_exmut( _ ) :- 
	xsb_user_mutex_unlock(MUTEX_CONSOLE).

end_of_file.

xsb_thread_exit( ExitCode, ErrorVal ) :-
	thread_request( XSB_THREAD_EXIT, ExitCode,_, _,_,_,_,_).

xsb_thread_join( ThreadId, ExitCode, ErrorVal ) :-
	thread_request( XSB_THREAD_JOIN, ThreadId, ExitCode, _, _,_,_,_ ).

%xsb_thread_create( Goal )	    :- xsb_thread_create( Goal, _, _ ).

