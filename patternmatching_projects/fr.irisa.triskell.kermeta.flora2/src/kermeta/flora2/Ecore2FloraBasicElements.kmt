/* $Id: Ecore2FloraBasicElements.kmt,v 1.5 2007-07-26 12:40:07 bmorin Exp $
 * Creation date: October 12, 2006
 * License:
 * Copyright:
 * Authors: Rodrigo Ramos
 */

package kermeta::flora2;

require "http://www.eclipse.org/emf/2002/Ecore"
require "platform:/lookup/fr.irisa.triskell.kermeta.flora2/src/flora2/Flora2wVisitor.kmt"
 
require kermeta

using ecore  
using kermeta::standard

class Ecore2FloraBasicElements
{ 
   
	operation createClauseForClassDeclaration(eclass : EClass) : flora2::Clause is do 
	  var formulas : flora2::CompoundedFormula init flora2::CompoundedFormula.new
	  formulas.operator := flora2::ConnectiveOp.conjunctionOp
      if not  eclass.eSuperTypes.empty then   
	      eclass.eSuperTypes.collect{ ec | createsSubclassClause(eclass, ec)}.
	           each{e | formulas.elements.add (e)}
	  end 	  
	  //stdio.writeln("Clause of the declartion of "+eclass.name)    
	  // FIX: Correct later a problem with ENUM
//      eclass.eAttributes.collect{ ec | createsSignatureForAttr(eclass, ec)}.
//               each{e | formulas.elements.add (e)}	  
      eclass.eStructuralFeatures.select{ec|  /*stdio.writeln("test1")*/    EReference.isInstance(ec)}.collect{ ec1 | 
      var ec2 : EReference
      ec2?=ec1
      createsSignatureForRef(eclass, ec2)}.
               each{e | formulas.elements.add (e)}	 
                /*stdio.writeln("test")*/       
	  
	  var clause : flora2::Fact init flora2::Fact.new
	  clause.expression := formulas
	  result := clause
	end
	
	operation createsSubclassClause (eclass : EClass, esuper : EClass) : flora2::ISASubclass is do
          var isa_subclass : flora2::ISASubclass init flora2::ISASubclass.new 
          isa_subclass.element := createConstantTerm (eclass)    
          isa_subclass.superclass := createConstantTerm (esuper)
          result := isa_subclass
	end
	
	operation createsSignatureForRef (eclass : EClass, eattr : EReference) : flora2::SignatureAtom is do
          var sigfeature : flora2::SignatureAtom init flora2::SignatureAtom.new 
          sigfeature.host := createConstantTerm(eclass)
          sigfeature.feature := createConstantTerm( eattr)
          /*stdio.writeln("test2")*/
          
          sigfeature.~class := createConstantTerm(eattr.eType)
            /*stdio.writeln("test3")*/
         
          result := sigfeature          
	end	
		
	operation createsSignatureForAttr (eclass : EClass, eattr : EAttribute) : flora2::SignatureAtom is do
          var sigfeature : flora2::SignatureAtom init flora2::SignatureAtom.new 
          sigfeature.host := createConstantTerm(eclass)
          
          sigfeature.feature := createConstantTerm( eattr)
          sigfeature.~class := createConstantTerm(eattr.eAttributeType)
          
          
          result := sigfeature          
	end	
	
	operation createConstantTerm (elementName: ENamedElement) : flora2::Term is do	
          var oid : flora2::Constant init flora2::Constant.new
          
          oid.symbolName := elementName.name
           
          
          result := oid
	end	  
	
	/* Diferent of the other operations in this class, this operation is used 
	   specificly in the transformation of instances
	*/
	operation createsDataClause (host: flora2::Term,  proName : String, val : flora2::Term) : flora2::DataAtom is do
          var dataeature : flora2::DataAtom init flora2::DataAtom.new 
          dataeature.host := host
          
          var feature : flora2::Constant init flora2::Constant.new
          feature.symbolName := proName
          dataeature.feature :=  feature
          dataeature.~value := val
          result := dataeature          
	end
	
	operation createsInstanceClause (term: flora2::Term,  className : String) : flora2::ISAInstance is do
          var isa_instance : flora2::ISAInstance init flora2::ISAInstance.new 
            isa_instance.element := term
            
            var ~class : flora2::Constant init flora2::Constant.new
            ~class.symbolName := className
            isa_instance.~class := ~class
          result := isa_instance          
	end		
}