/*
 * Creation : February 22, 2010
 * Licence  : EPL 
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package kermeta::ki::malai::interaction;

require kermeta
require "platform:/resource/org.kermeta.ki.malai/kermeta/interaction/StateMachine.kmt"
require "platform:/resource/org.kermeta.ki.malai/kermeta/interaction/InteractionHandler.kmt"
require "platform:/resource/org.kermeta.ki.malai/kermeta/picking/Picker.kmt"
require "platform:/resource/org.kermeta.ki.malai/kermeta/interaction/Eventable.kmt"

using kermeta::ki::malai::picking
using kermeta::standard

/**
 * Defines an interaction as defined in the Malai model. An interaction is a state machine and a class.
 * @author Arnaud BLOUIN
 */
abstract class Interaction inherits StateMachine {
	/**
	 * The handlers that want to be notified when the state machine of the
	 * interaction changed.
	 */
	reference handlers : InteractionHandler[0..*]
	
	

	/**
	 * Links the interaction to an eventable object (e.g. a MPanel or a MButton).
	 * @param eventable The Eventable object.
	 */
	operation linkToEventable(eventable : Eventable) : Void is do
		if(not eventable.isVoid and eventable.hasEventManager()) then
			eventable.getEventManager().handlers.add(self)
		end
	end
	
	
	
	/**
	 * Notifies handlers that the interaction starts.
	 */
	operation notifyHandlersOnStart() : Void is do
		do
			handlers.each{handler | handler.interactionStarts(self)}
		rescue(ex : kermeta::exceptions::Exception)
			stdio.writeln(ex.toString + " " + ex.message.toString)
			notifyHandlersOnAborting()
			raise ex
		end
	end
	

	
	/**
	 * Notifies handlers that the interaction updates.
	 */
	operation notifyHandlersOnUpdate() : Void is do
		do
			handlers.each{handler | handler.interactionUpdates(self)}
		rescue(ex : kermeta::exceptions::Exception)
			stdio.writeln(ex.toString + " " + ex.message.toString)
			notifyHandlersOnAborting()
			raise ex
		end
	end
	
	
	
	/**
	 * Notifies handlers that the interaction stops.
	 */
	operation notifyHandlersOnStop() : Void is do
		do
			handlers.each{handler | handler.interactionStops(self)}
		rescue(ex : kermeta::exceptions::Exception)
			stdio.writeln(ex.toString + " " + ex.message.toString)
			notifyHandlersOnAborting()
			raise ex
		end
	end
	
	
	
	/**
	 * Notifies handlers that the interaction stops.
	 */
	operation notifyHandlersOnAborting() : Void is do
		handlers.each{handler | handler.interactionAborts(self)}
	end


	
	/**
	 * Gets the pickable object at the given position.
	 * @param px : the X-coordinate of the position.
	 * @param py : the Y-coordinate of the position.
	 * @param source : The source object in which the function will search. 
	 * @return null if nothing is found. Otherwise a pickable object.
	 */
	operation getPickableAt(px : Real, py : Real, source : Object) : Pickable is do
		if(not source.isVoid) then
			if(source.isInstanceOf(Picker)) then
				result := source.asType(Picker).getPickableAt(px, py)
			else
				if(source.isInstanceOf(Pickable)) then
					var pickable : Pickable init source.asType(Pickable)
					
					if(pickable.contains(px, py)) then
						result := pickable
					else
						result := pickable.getPicker().getPickableAt(px, py)
					end
				else
					result := void
				end
			end
		else
			result := void
		end
	end
}
