/*
 * Creation : February 22, 2010
 * Licence  : EPL 
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package kermeta::ki::malai::instrument;

require kermeta
require "platform:/resource/org.kermeta.ki.malai/kermeta/instrument/Instrument.kmt"
require "platform:/resource/org.kermeta.ki.malai/kermeta/interaction/InteractionHandler.kmt"

using kermeta::standard
using kermeta::language::structure
using kermeta::ki::malai::action
using kermeta::ki::malai::interaction
using kermeta::ki::malai::undo


/**
* In the Malai interaction model, an instrument links interactions to actions.
* Thus, an instrument is composed of Link definitions: each Link links an interaction
* to an action. A Link manages the life cycle of an action following the life cycle
* of the interaction (started, aborted, etc.).
*/
abstract class Link inherits InteractionHandler
{
	/** The source interaction. */
	attribute interaction : Interaction
	
	/** The target action. */
	attribute action : Action
	
	/** The instrument that contains the link. */
	reference instrument : Instrument
	
	/** Specifies if the action must be execute or update
	 * on each evolution of the interaction. */
	attribute execute : Boolean
	
	

	
	/**
	 * Initialises a link. This constructor must initialise the interaction.
	 * @param instrument The instrument that contains the link.
	 * @param exec Specifies if the action must be execute or update on each evolution of the interaction.
	 */
	operation initialise(instrument : Instrument, execute : Boolean) : Void is do
		self.instrument := instrument
		self.execute    := execute
		
		interaction := createInteraction()
		interaction.initialise()
		interaction.handlers.add(self)
	end


	/**
	 * Binds the interaction of the link to a Eventable object that produces
	 * events used by the interaction.
	 * @param eventable The eventable object that gathers event used by the interaction.
	 */
	operation addEventable(eventable : Eventable) : Void is do
		if(not eventable.isVoid and not interaction.isVoid) then
			interaction.linkToEventable(eventable)
		end
	end

	
	/**
	* Returns the Class of the action that produces the link.
	* Notably called into method isRunnable.
	*/
	operation getActionClass() : Class is abstract
	
	
	
	
	/**
	* Indicates if the link can be run. To be run, no link, of the instrument, that produces the 
	* same type of action must be running.
	*/
	operation isRunnable() : Boolean is do
		result := true
		
		instrument.links.exists{link |
			if((link!=self).andThen{b| link.isRunning.andThen{b| link.getActionClass==getActionClass}}) then
				result := false
			end
			result
		}
	end




	/**
	* Returns true if the link is currently in use.
	*/
	operation isRunning() : Boolean is do
		result := interaction.isRunning()
	end



	/**
	* Instanciates and returns the interaction corresponding to the link, but must not initialise the interaction.
	*/
	operation createInteraction() : Interaction is abstract

	

	/**
	 * Initialises the action of the link. If the attribute 'action' is
	 * not null, nothing will be done.
	 */
	operation createAction() : Void is abstract
	
	
	/**
	 * Updates the current action.
	 */
	operation updateAction() : Void is abstract
		
		
	/**
	 * @return True if the condition of the link is respected.
	 */
	operation isConditionRespected() : Boolean is abstract
	
	
	operation setIsActivated(activated : Boolean) : Void is do
		interaction.setIsActivated(activated)
	end
	
	
	
	method interactionUpdates(inter : Interaction) : Void is do
		if(inter==interaction) then
			if(isConditionRespected) then
				if(action.isVoid) then createAction end
				updateAction
    			if(execute and action.canDo) then action.doIt end
				interimFeedback
			end
		end
	end
	
	
	method interactionStops(inter : Interaction) : Void is do
		if(not action.isVoid and interaction==inter) then
			if(isConditionRespected) then
    			if(not execute) then updateAction end
    			if(action.doIt) then action.setDone end

    			if(action.hadEffect) then
    				if(action.isRegisterable) then
    					 instrument.actionRegistry.addAction(action)
    				else 
    					instrument.actionRegistry.cancelActions(action)
    				end
    				
    				// The instrument is notified about the end of the action.
    				instrument.onActionDone(self, action)
    			end
   			
    			action := void
			else
				action.abort()
				action := void
			end
			instrument.interimFeedback
		end
	end
	
	
	method interactionStarts(inter : Interaction) : Void is do
		if(isRunnable and action.isVoid and inter==interaction and instrument.activated) then
			if(isConditionRespected) then
				createAction
				interimFeedback
			end
		end
	end
	
	
	method interactionAborts(inter : Interaction) : Void is do
		if(not action.isVoid and inter==interaction) then
			action.abort()
			
			// The instrument is notified about the aborting of the action.
			instrument.onActionAborted(self, action)
			
			if(execute) then
				if(action.isInstanceOf(Undoable)) then
					action.asType(Undoable).undo()
				else
					var ex : kermeta::exceptions::Exception init kermeta::exceptions::Exception.new
					ex.message := "MustAbortStateMachineException: " + action.toString
					raise ex
				end
			end
			
			action := void
			instrument.interimFeedback()
		end
	end
	
	
	
	/**
	 * Defines the interim feedback of the link. If overridden, the interim
	 * feedback of its instrument should be define too.
	 */
	operation interimFeedback() : Void is do end
}
