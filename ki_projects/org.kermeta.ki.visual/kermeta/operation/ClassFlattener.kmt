/*
 * Creation : April 9, 2010
 * Licence  : EPL 
 * Copyright: INRIA Rennes, Triskell
 * Authors  :  Arnaud
 */
package kermeta::ki::visual;


require "platform:/resource/org.kermeta.ki.visual/kermeta/ModelExtension.kmt"

using kermeta::language::structure
using kermeta::standard



class ClassFlattener
{
	reference metamodel : ModelingUnit
	
	reference addedProperties : PropertyBackup[0..*]
	
	reference addedOperations : OperationBackup[0..*]
	
	reference addedInheritances : InheritanceBackup[0..*]
	
	attribute removedInheritances : InheritanceBackup[0..*]
	
	attribute removedProperties : PropertyBackup[0..*]
	
	reference removedClasses : ClassDefinition[0..*]
	
	reference classToFlat : ClassDefinition
	
	
	operation flat(classToFlat : ClassDefinition) : Void is do
		var superType	: Type
		var inheritance : InheritanceBackup
		var prop		: PropertyBackup
		var cd 			: ClassDefinition
		var cd2			: ClassDefinition
		
		self.classToFlat := classToFlat
		
		from true
		until classToFlat.superType.empty
		loop
			superType := classToFlat.superType.one

			if(superType.isInstanceOf(Class).andThen{b | metamodel.isClassDefined(superType.asType(Class).typeDefinition)}) then
				cd 						:= superType.asType(Class).classDefinition
				inheritance 			:= InheritanceBackup.new
				inheritance.source 		:= classToFlat
				inheritance.sourceType 	:= superType
				inheritance.target 		:= cd
				removedInheritances.add(inheritance)
				
				classToFlat.superType.remove(superType)
				extern org::kermeta::ki::visual::view::MetamodelViewExtern.onInheritanceRemoved(metamodel, classToFlat, cd)
				flatClass(cd, classToFlat)
			else
				classToFlat.superType.remove(superType)
			end
		end
		
		// Removing attributes which type is a removed class.
		metamodel.packages.each{p |
			p.ownedTypeDefinition.each{td |
				if(classToFlat!=td and td.isInstanceOf(ClassDefinition)) then
					cd := td.asType(ClassDefinition)
					
					cd.ownedAttribute.each{attr |
						if(attr.type.isInstanceOf(ParameterizedType)) then
							cd2 := attr.type.asType(ParameterizedType).typeDefinition.asType(ClassDefinition)
							
							removedClasses.each{cl |
								if((cl==cd2).andThen{b | attr.opposite.isVoid.orElse{b | removedClasses.exists{clazz | clazz==attr.opposite.owningClass}}}) then
									prop := PropertyBackup.new
									prop.prop := attr
									prop.owningClass := cd
									removedProperties.add(prop)
																		
									cd.ownedAttribute.remove(attr)
									extern org::kermeta::ki::visual::view::MetamodelViewExtern.onLinkRemoved(metamodel, attr)
								end
							}
						end 
					}
				end
			}
		}
	end
	
	
	
	operation flatClass(currentClass : ClassDefinition, upperClass : ClassDefinition) : Void is do
		if(currentClass.name!="Object" or not currentClass.superType.empty) then
			var propBackUp : PropertyBackup
			var opBackUp   : OperationBackup
			var inBackup   : InheritanceBackup
				
			// Moving properties
			currentClass.ownedAttribute.each{prop |
				currentClass.movePropertyTo(prop, classToFlat, metamodel)
				propBackUp := PropertyBackup.new
				propBackUp.prop := prop
				propBackUp.owningClass := currentClass
				addedProperties.add(propBackUp)
			}
			
			// Moving operations
			currentClass.ownedOperation.each{op |
				if(op.isVisible) then
					opBackUp 			 := OperationBackup.new
					opBackUp.op 		 := op
					opBackUp.owningClass := currentClass
					
					currentClass.moveOperationTo(op, classToFlat)
					addedOperations.add(opBackUp)
				end
			}
			
			// Changing inheritance: sub-types of this class inherit now of the flattened class.
			var subTypes : Set<ClassDefinition> init currentClass.getSubTypes
			var inheritance : InheritanceBackup
			
			subTypes.each{st |
				inBackup := InheritanceBackup.new
				inBackup.source := st
				inBackup.target := currentClass
				inBackup.sourceType := st.superType.detect{st2 | (st2.isInstanceOf(ParameterizedType)).andThen{b | st2.asType(ParameterizedType).typeDefinition==currentClass }}

				removedInheritances.add(inBackup)
				if(not inBackup.sourceType.isVoid) then
					st.superType.remove(inBackup.sourceType)
				end
				
				extern org::kermeta::ki::visual::view::MetamodelViewExtern.onInheritanceRemoved(metamodel, st, currentClass)
				
				// A link must not be created if the class st is the class to flat or the previous class in the hierarchy.
				if(st!=classToFlat and st!=upperClass) then
					inBackup := InheritanceBackup.new
					inBackup.source := st
					inBackup.target := classToFlat
					addedInheritances.add(inBackup)
					extern org::kermeta::ki::visual::view::MetamodelViewExtern.onInheritanceAdded(metamodel, st, classToFlat, -1)
				end
				
				// Removing the class from its sub-type
				st.superType.detect{type |
					if(type.isInstanceOf(ParameterizedType)) then
						if(type.asType(ParameterizedType).typeDefinition==currentClass) then
							inheritance 			:= InheritanceBackup.new
							inheritance.source 		:= st
							inheritance.sourceType 	:= type
							inheritance.target 		:= currentClass
							removedInheritances.add(inheritance)
							
							st.superType.remove(type)
							true
						else false end
					else false end
				}
			}
			
			// Contining on the super types of the current class.
			currentClass.superType.each{st |
				if(st.isInstanceOf(Class).andThen{b | metamodel.isClassDefined(st.asType(Class).typeDefinition)}) then
					flatClass(st.asType(Class).classDefinition, currentClass)
				end
			}
			
			// Removing the class.
			removedClasses.add(currentClass)
			extern org::kermeta::ki::visual::view::MetamodelViewExtern.onEntityRemoved(metamodel, currentClass)
		end
	end
}




class OperationBackup {
	reference op : Operation
	
	reference owningClass : ClassDefinition
}



class PropertyBackup {
	reference prop : Property
	
	reference owningClass : ClassDefinition
}



class InheritanceBackup {
	reference source : ClassDefinition
	
	reference target : ClassDefinition
	
	reference sourceType : Type
}
