/*
 * Creation : March 11, 2010
 * Licence  : EPL 
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin 
 */

package kermeta::ki::visual;

require "platform:/resource/org.kermeta.ki.visual/kermeta/ModelExtension.kmt"
//require "platform:/resource/org.kermeta.static_analysis/src/kermeta/pruning/MetamodelPruning.kmt"
//require "platform:/resource/org.kermeta.static_analysis/src/kermeta/main/AutomaticMetamodelPruning.kmt"
//require "platform:/resource/org.kermeta.static_analysis/src/kermeta/visitor/VisitableKermeta.km"

using kermeta
using kermeta::standard
using kermeta::language::structure
using kermeta::language::behavior
using kermeta::persistence
//using ch::uzh::ifi::rerg::amp
using kermeta::utils


class MetamodelPruningDisplayer { // inherits MetamodelPruning {
/*	method pruneObject<T : Object>(object : T, parent : Set<T>) : Void is do
		stdio.writeln("in prunObject")
		stdio.writeln("object=" + object.toString)
		extern org::kermeta::ki::visual::view::ComponentView.onPruning(object)
		stdio.writeln("after onPruning")
	end*/
}



class PruningOperation
{/*
attribute qClassNameRegistry: Hashtable<String, ClassDefinition>

	operation preparatoryPhase(mu: ModelingUnit): Void is do
		var tpv: TransformationPreparation init TransformationPreparation.new
		tpv.classes := qClassNameRegistry
		mu.accept(tpv)
	end
	
	operation findMainOperation(mu: ModelingUnit): Operation is do
		var qMainClassName: String init mu.tag.select{t| t.name=="mainClass"}.one.~value
		var mainOpName: String init mu.tag.select{t| t.name=="mainOperation"}.one.~value
		result := qClassNameRegistry.getValue(qMainClassName).findOperation(mainOpName)
	end
	
	operation usageAnalysisPhase(op: Operation): Void is do
		var uav: UsageAnalysis init UsageAnalysis.new
		op.accept(uav)
	end
	
	operation printUsageAnalysisResults(mu: ModelingUnit): Void is do
		var urv: AnalysisReport init AnalysisReport.new
		mu.accept(urv)
	end
	
	operation requirementPropagationPhase(mu: ModelingUnit): Void is do
		var rpv: RequirementPropagation init RequirementPropagation.new
		mu.accept(rpv)
		mu.referencedModelingUnits.each{m | m.accept(rpv)}
	end
	
	operation metamodelPruningPhase(mu: ModelingUnit): Void is do
		var mpv: MetamodelPruning init MetamodelPruningDisplayer.new
		mu.accept(mpv)
	end
	
	operation metamodelFlattenPhase(mu: ModelingUnit): Void is do
		var mfp: MetamodelFlatten init MetamodelFlatten.new
		mu.accept(mfp)
	end
	*/
	
//	operation pruneWithTransformation(transformationUnit : ModelingUnit, metamodel : ModelingUnit) : Void is do
//		qClassNameRegistry := Hashtable<String, ClassDefinition>.new
		
		// Prepare Transformation for Analysis
//		preparatoryPhase(transformationUnit)
		
		// Find main operation
//		var mainOperation: Operation init findMainOperation(transformationUnit)
		
		// Analyze it for class/op/prop usage
//		usageAnalysisPhase(mainOperation)
				
		// Mark elements for deletion
//		requirementPropagationPhase(transformationUnit)
		
//		// Print analysis result
//		printUsageAnalysisResults(metamodel)
		
		// Prune Metamodel
//		metamodelPruningPhase(metamodel)
//	end
/*
	operation pruneWithClass(classDef : ClassDefinition, metamodel : ModelingUnit) : Void is do
	stdio.writeln("1111")
		var transfo : ModelingUnit init ModelingUnit.new
		var pkg : Package init Package.new
		var clazzMain : ClassDefinition init ClassDefinition.new
		var opMain : Operation init Operation.new
		var exp : VariableDecl init VariableDecl.new
		var typeRef : TypeReference init TypeReference.new
		var clazz : Class init Class.new
		stdio.writeln("2222")
		clazz.typeDefinition := classDef
		typeRef.lower :=1
		typeRef.upper :=1
		typeRef.type := clazz
		stdio.writeln("3333")
		exp.identifier := "myVar"
		stdio.writeln("5555")
		exp.type := typeRef
 
		transfo.referencedModelingUnits.add(metamodel)		
		clazzMain.name := "Main"
		opMain.name := "main"
		pkg.name := "pkg"
		opMain.body := exp
		
		qClassNameRegistry := Hashtable<String, ClassDefinition>.new
		
		// Prepare Transformation for Analysis
//		preparatoryPhaseClass(clazz)
		
//		var mainOperation: Operation init Operation.new
//		clazz.usedIn(mainOperation)
		stdio.writeln("6666")
		// Analyze it for class/op/prop usage
		usageAnalysisPhase(opMain)
				stdio.writeln("7777")
		// Mark elements for deletion
		requirementPropagationPhase(transfo)
//		requirementPropagationPhaseClass(classDef, metamodel)
		stdio.writeln("8888")
		// Print analysis result
		printUsageAnalysisResults(metamodel)
		stdio.writeln("9999")
		// Prune Metamodel
		metamodelPruningPhase(metamodel)
		stdio.writeln("10101010")*/
/*		var transfo : ModelingUnit init ModelingUnit.new
		var pkg : Package init Package.new
		var clazzMain : ClassDefinition init ClassDefinition.new
		var opMain : Operation init Operation.new		
//		var exp : 
		clazzMain.name := "Main"
		opMain.name := "main"
//		opMain.body.add(exp)
		pkg.name := "pkg"

		//transfo.
		transfo.allNestedPackages.add(pkg)
		pkg.allNestedClassDefinitions.add(clazzMain)
		clazzMain.allOperation.add(opMain)
*/
	
/*		var initReq : InitialiserRequirement init InitialiserRequirement.new
		metamodel.accept(initReq)
		usageAnalysisPhase(clazz)
		
		var opMain : Operation init Operation.new
		clazz.usedBy.add(opMain)
		requirementPropagationPhase(metamodel)
		metamodelPruningPhase(metamodel)
*/
	
		// Prepare Transformation for Analysis
		//preparatoryPhase(clazz)
		
		// Analyze it for class/op/prop usage
//		usageAnalysisPhase(clazz)
				
		// Mark elements for deletion
//		requirementPropagationPhase(metamodel)
		
		// Print analysis result
//		printUsageAnalysisResults(metamodel)
		
		// Prune Metamodel
//		metamodelPruningPhase(metamodel)
/*	end
	
	operation requirementPropagationPhaseClass(clazz: ClassDefinition, metamodel : ModelingUnit): Void is do
		var rpv: RequirementPropagation init RequirementPropagation.new
		clazz.accept(rpv)
		metamodel.accept(rpv)
	end
	*/
	/*
	operation preparatoryPhase(mu: ClassDefinition): Void is do
		var tpv: TransformationPreparation init TransformationPreparation.new
		tpv.classes := qClassNameRegistry
		mu.accept(tpv)
	end
	*/
	/*
	operation printUsageAnalysisResults(mu: ModelingUnit): Void is do
		var urv: AnalysisReport init AnalysisReport.new
		mu.accept(urv)
	end
	
	
	operation requirementPropagationPhase(clazz: ModelingUnit): Void is do
		var rpv: RequirementPropagation init RequirementPropagation.new
		clazz.accept(rpv)
	end
	
	operation metamodelPruningPhase(mu: ModelingUnit): Void is do
		var mpv: MetamodelPruning init MetamodelPruningDisplayer.new
		stdio.writeln("before accept:" + mu.toString)
		mu.accept(mpv)
	end
	*/
	/*
	operation usageAnalysisPhase(clazz: ClassDefinition): Void is do
		var uav: UsageAnalysis init UsageAnalysis.new
		clazz.accept(uav)
	end*/
}





class InitialiserRequirement // inherits KermetaVisitor
{
/*	method visitModelingUnit(mu: ModelingUnit): Void is do
		mu.packages.each{p | p.accept(self)}
		mu.usings.each{u | u.accept(self)}
		mu.requires.each{r | r.accept(self)}
		mu.isRequired := true
	end
	
	method visitUsing(u: Using): Void is do
		u.isRequired := true
	end
	
	method visitRequire(r: Require): Void is do
		r.isRequired := true
	end
	
	method visitPackage(p: Package) : Void is do
		p.nestedPackage.each{x | x.accept(self)}
		p.ownedTypeDefinition.each{td | td.accept(self) }
		p.isRequired := true
	end
	
	method visitOperation(o: Operation) : Void is do
		o.isRequired := o.isUsed
		o.ownedParameter.each{p | p.isRequired := false }
	end	
	
	method visitProperty(p: Property): Void is do
		p.isRequired := false
	end
	
	method visitClassDefinition(c: ClassDefinition) : Void is do
		c.ownedOperation.each{o | o.accept(self)}
		c.ownedAttribute.each{p | p.accept(self)}
		c.isRequired := false
	end
	
	method visitEnumeration(e: Enumeration): Void is do
		e.isRequired := false
		e.ownedLiteral.each{l | l.isRequired := false }
	end
	
	method visitEnumerationLiteral(e: EnumerationLiteral): Void is do
		// Nothing to do
	end
	
	method visitPrimitiveType(t: PrimitiveType): Void is do
		t.isRequired := false
	end*/
}

