/*
 * Creation : March 16, 2009
 * Licence  : EPL 
 * Copyright: INRIA Rennes, Triskell
 * Authors  : 
 *            Sagar Sen
 *            Arnaud Blouin
 */
package kermeta::ki::visual;


require kermeta
require "platform:/resource/org.kermeta.ki.visual/kermeta/ModelExtension.kmt"

using kermeta::standard
using kermeta::utils
using kermeta::language::structure

class RequiredProperty
{
	attribute name: String
	attribute owningClassName: String
}

class RequiredClass
{
	attribute name: String
}

class RequiredEnumeration
{
	attribute name: String
}



class MetamodelPruner
{
	/* Input Kermeta Meta-model */
	reference inputKermetaMetamodel : ModelingUnit
	/* Kermeta Objects */
	reference inputKermetaObjects : Object[0..*]
	/* Required Meta-classes */
	reference requiredMetaClasses : RequiredClass[0..*]
	reference requiredMetaProperties : RequiredProperty[0..*]
	reference requiredMetaEnumerations : RequiredEnumeration[0..*]
	
	/* Required Kermeta Meta-concepts*/
	reference requiredKermetaMetaClasses :  ClassDefinition[0..*]
	reference requiredKermetaMetaProperties :  Property[0..*]
	reference requiredKermetaMetaEnumerations:  Enumeration[0..*]
	reference requiredKermetaMetaPrimitiveTypes :  PrimitiveType[0..*]

	/* Bag of all Kermeta objects in Meta-model */ 
	reference kermetaObjects : Object[0..*]
	
	/*Removed Meta-concepts*/
	reference removedKermetaMetaClasses : ClassDefinition[0..*]
	reference removedKermetaMetaProperties : Property[0..*]
	reference removedKermetaMetaEnumerations : Enumeration[0..*]
	/*number of passes*/
	reference numberOfPasses: Integer
	attribute emptyPackages: Package[0..*]
	
	
	
	
	operation initialize(requiredClasses : bag RequiredClass[0..*], requiredProperties : bag RequiredProperty[0..*], 
						requiredEnumerations : bag RequiredEnumeration[0..*], numberOfPasses : Integer) : Void is do
		self.requiredMetaClasses.addAll(requiredClasses)
		self.requiredMetaProperties.addAll(requiredProperties)
		self.requiredMetaEnumerations.addAll(requiredEnumerations)
		self.requiredMetaProperties.addAll(requiredProperties)
		self.requiredMetaEnumerations.addAll(requiredEnumerations)
		self.numberOfPasses := numberOfPasses
	end
	
	

	
	operation preprocess(): Boolean is do
		getKermetaObjects
		
		var isExisting : Boolean
		
		//Check if all required classes exist in the input metamodel
		result := not requiredMetaClasses.exists{ c | 
			isExisting := false
			
			kermetaObjects.each{ o | 	
				if o.isInstanceOf(ClassDefinition) then 
					if o.asType(TypeDefinition).name==c.name then
						isExisting := true
						requiredKermetaMetaClasses.add(o.asType(ClassDefinition))
					end
				end
				
				isExisting
			}
			
			not isExisting
		}
		
		if(result) then
			//Check if all required enumerations exist in the input metamodel
			result := not requiredMetaEnumerations.exists{ e |
				isExisting := false
				
				kermetaObjects.exists{ o | 
					if o.isInstanceOf(Enumeration) then 
						if o.asType(Enumeration).name==e.name then
							isExisting := true
							requiredKermetaMetaEnumerations.add(o.asType(Enumeration))
						end
					end
					
					isExisting
				}	
				
				not isExisting
			}
		end
		
		if(result) then
			//Check if all required properties exist in the input metamodel
			result := not requiredMetaProperties.exists{ p |
				isExisting := false
				
				kermetaObjects.exists{ o | 
					if o.isInstanceOf(ClassDefinition) then 
						o.asType(ClassDefinition).ownedAttribute.each {a | 
							if a.name==p.name and a.owningClass.name==p.owningClassName then
								isExisting := true
								requiredKermetaMetaProperties.add(a.asType(Property))
							end
						}
					end
					
					isExisting
				}
				
				not isExisting
			}
		end
	end
	
	
	
	
	
	/* Transform Kermeta input meta-model to pruned output meta-model */
	operation transform(): Void is do
		getRequiredConcepts
		TagRemoval
		OperationRemoval
		PropertyRemoval
		ClassRemoval
		EnumerationRemoval
		PrimitiveTypeRemoval
		EmptyPackageRemoval
		stdio.writeln("metamodel pruned.")
	end
	



	operation includeClassesInPackage(aPackage : Package) : Bag<ClassDefinition> is do
		var cd : ClassDefinition
		result := Bag<ClassDefinition>.new
		
		if (not aPackage.isVoid) then
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each{object | 
				if object.isInstanceOf(ClassDefinition) then
					cd := object.asType(ClassDefinition)
					
					requiredMetaClasses.each{ c | 
						if c.name==cd.name then
							result.add(cd)
						end
					}	
				end
			}
			
			if not aPackage.nestedPackage.isEmpty then
				aPackage.nestedPackage.each{p |
					result.addAll(includeClassesInPackage(p))			
				}
			end
		end
	end
	
	
	
	
	operation includeInitialClasses():Void is do
		inputKermetaMetamodel.packages.each{p | 
			requiredKermetaMetaClasses.addAll(includeClassesInPackage(p))
		}	
	end
	
	
	
	
	operation includeEnumsInPackage(aPackage : Package) : Bag<Enumeration> is do
		var en : Enumeration
		result := Bag<Enumeration>.new
		
		if(not aPackage.isVoid) then
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each{object | 
				if object.isInstanceOf(Enumeration) then
					en := object.asType(Enumeration)
					
					requiredMetaEnumerations.each{ c | 
						if c.name==en.name then
							result.add(en)
						end
					}	
				end
				
			}
			
			if not aPackage.nestedPackage.isEmpty then
				aPackage.nestedPackage.each{p |
					result.addAll(includeEnumsInPackage(p))			
				}
			end
		end
	end
	
	
	
	
	operation includeInitialEnumerations():Void is do
		inputKermetaMetamodel.packages.each{p | 
			requiredKermetaMetaEnumerations.addAll(includeEnumsInPackage(p))
		}	
	end
	
	
	

	operation includePropertiesInPackage(aPackage : Package) : Bag<Property> is do
		result := Bag<Property>.new
		
		if(not aPackage.isVoid) then
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each{object |
				if object.isInstanceOf(ClassDefinition) then
					object.asType(ClassDefinition).ownedAttribute.each{prop |
						requiredMetaProperties.each{rprop |
							if rprop.name==prop.name then
								result.add(prop.asType(Property))
							end
						}
					}
				end
			}
		end
		
		if not aPackage.nestedPackage.isEmpty then
			aPackage.nestedPackage.each{p |
				result.addAll(includePropertiesInPackage(p))			
			}
		end
	end
	
	
	
	
	operation includeInitialProperties():Void is do
		inputKermetaMetamodel.packages.each{p | 
			requiredKermetaMetaProperties.addAll(includePropertiesInPackage(p))
		}	
	end
	
	
	
	
	operation includeAllObligatoryPropertiesAndTheirTypes():Void is do
//		var option : Integer init Integer.new
		var propLower0 : Boolean
		var propClass  : Boolean
		var propEnum   : Boolean
		var propPrim   : Boolean
		var oppVoid    : Boolean
		
		self.requiredKermetaMetaClasses.each{c |
			c.ownedAttribute.each{ prop |
			 	propLower0 := prop.lower == 0
			 	propClass  := prop.type.isInstanceOf(Class)
			 	propEnum   := prop.type.isInstanceOf(Enumeration)
			 	propPrim   := prop.type.isInstanceOf(PrimitiveType)
			 	oppVoid    := prop.opposite.isVoid
			 	
				//Option 1
				if propLower0 and  propClass then
					self.requiredKermetaMetaProperties.add(prop)
					self.requiredKermetaMetaClasses.add(prop.type.asType(Class).classDefinition)
					self.requiredKermetaMetaClasses.add(prop.owningClass)
					
					if not oppVoid then
						self.requiredKermetaMetaProperties.add(prop.opposite)
						self.requiredKermetaMetaClasses.add(prop.opposite.type.asType(Class).classDefinition)
						self.requiredKermetaMetaClasses.add(prop.opposite.owningClass)
					end
				end
				
				//Option 2
				if propLower0 and propEnum then
					self.requiredKermetaMetaProperties.add(prop)
					self.requiredKermetaMetaEnumerations.add(prop.type.asType(Enumeration))
				end
				
				//Option 3
				if propPrim then
					if(propLower0) then
						self.requiredKermetaMetaProperties.add(prop)
						self.requiredKermetaMetaPrimitiveTypes.add(prop.type.asType(PrimitiveType))
						self.requiredKermetaMetaClasses.add(prop.owningClass)
					else
						//Add all properties with opposite property that are composite
						//Which means that we add all potential containers for a class
						//Since, opposite properties caputre important relationships such as multiple possible containers
						self.requiredKermetaMetaProperties.add(prop)
						self.requiredKermetaMetaPrimitiveTypes.add(prop.type.asType(PrimitiveType))
						self.requiredKermetaMetaClasses.add(prop.owningClass)
					end
				end
				
				if not oppVoid then
					if prop.opposite.isComposite then
						self.requiredKermetaMetaProperties.add(prop)
						self.requiredKermetaMetaClasses.add(prop.type.asType(Class).classDefinition)
						self.requiredKermetaMetaClasses.add(prop.owningClass)
						
						self.requiredKermetaMetaProperties.add(prop.opposite)
						self.requiredKermetaMetaClasses.add(prop.opposite.type.asType(Class).classDefinition)
						self.requiredKermetaMetaClasses.add(prop.opposite.owningClass)
					end
				end 
				
				if not propLower0 and propClass then
					self.requiredKermetaMetaProperties.add(prop)
					self.requiredKermetaMetaClasses.add(prop.type.asType(Class).classDefinition)
					self.requiredKermetaMetaClasses.add(prop.owningClass)
					
					if not oppVoid then
						self.requiredKermetaMetaProperties.add(prop.opposite)
						self.requiredKermetaMetaClasses.add(prop.opposite.type.asType(Class).classDefinition)
						self.requiredKermetaMetaClasses.add(prop.opposite.owningClass)
					end
				end
				
				if not propLower0 and propEnum then
					self.requiredKermetaMetaProperties.add(prop)
					self.requiredKermetaMetaEnumerations.add(prop.type.asType(Enumeration))
				end
			
				//Add all required properties and their type
				self.requiredMetaProperties.each{ p |
					if p.name==prop.name and p.owningClassName == prop.owningClass.name then
						if propEnum then
							self.requiredKermetaMetaProperties.add(prop)
							self.requiredKermetaMetaClasses.add(prop.owningClass)
							self.requiredKermetaMetaEnumerations.add(prop.type.asType(Enumeration))
						end
						
						if propClass then
							self.requiredKermetaMetaProperties.add(prop)
							self.requiredKermetaMetaClasses.add(prop.type.asType(Class).classDefinition)
							self.requiredKermetaMetaClasses.add(prop.owningClass)
							
							if not oppVoid then
								self.requiredKermetaMetaProperties.add(prop.opposite)
								self.requiredKermetaMetaClasses.add(prop.opposite.type.asType(Class).classDefinition)
								self.requiredKermetaMetaClasses.add(prop.opposite.owningClass)
							end
						end
						
						if propPrim then
							self.requiredKermetaMetaProperties.add(prop)
							self.requiredKermetaMetaPrimitiveTypes.add(prop.type.asType(PrimitiveType))
							self.requiredKermetaMetaClasses.add(prop.owningClass)
						end
					end
				}
				
				//Option 4
				/*
				if prop.isComposite and propClass and propLower0 then
					if self.isInRequriedSetOfMetaClasses(prop.type.asType(Class).classDefinition) then
						self.requiredKermetaMetaProperties.add(prop)
						self.requiredKermetaMetaClasses.add(prop.type.asType(Class).classDefinition)
						self.requiredKermetaMetaClasses.add(prop.owningClass)
						
						if not oppVoid then
							self.requiredKermetaMetaProperties.add(prop.opposite)
							self.requiredKermetaMetaClasses.add(prop.opposite.type.asType(Class).classDefinition)
							self.requiredKermetaMetaClasses.add(prop.opposite.owningClass)
						end
					end 
				end
				*/
				
				if prop.isComposite and propClass and not propLower0 then
					if self.isInRequriedSetOfMetaClasses(prop.type.asType(Class).classDefinition) then
						self.requiredKermetaMetaProperties.add(prop)
						self.requiredKermetaMetaClasses.add(prop.type.asType(Class).classDefinition)
						self.requiredKermetaMetaClasses.add(prop.owningClass)
						
						if not oppVoid then
							self.requiredKermetaMetaProperties.add(prop.opposite)
							self.requiredKermetaMetaClasses.add(prop.opposite.type.asType(Class).classDefinition)
							self.requiredKermetaMetaClasses.add(prop.opposite.owningClass)
						end
					end 
				end
				
				//Option 5
				/*
				if prop.isComposite and prop.type.isInstanceOf(Enumeration) and prop.lower==0 then
					if self.isInRequriedSetOfMetaEnumerations(prop.type.asType(Enumeration)) then
						//stdio.writeln("Property added="+prop.name)
						self.requiredKermetaMetaEnumerations.add(prop.type.asType(Enumeration))
						self.requiredKermetaMetaProperties.add(prop)
					end 
				end
				*/
				
				if prop.isComposite and propEnum and not propLower0 then
					if self.isInRequriedSetOfMetaEnumerations(prop.type.asType(Enumeration)) then
						self.requiredKermetaMetaEnumerations.add(prop.type.asType(Enumeration))
						self.requiredKermetaMetaProperties.add(prop)
					end 
				end
				
				if propClass then
					if self.isInRequriedSetOfMetaClasses(prop.type.asType(Class).classDefinition) then
						self.requiredKermetaMetaProperties.add(prop)
						self.requiredKermetaMetaClasses.add(prop.owningClass)
						
						if not oppVoid then
							self.requiredKermetaMetaProperties.add(prop.opposite)
							self.requiredKermetaMetaClasses.add(prop.opposite.type.asType(Class).classDefinition)
							self.requiredKermetaMetaClasses.add(prop.opposite.owningClass)
						end
					end 
				end
				
				if propEnum then
					if self.isInRequriedSetOfMetaEnumerations(prop.type.asType(Enumeration)) then
						self.requiredKermetaMetaEnumerations.add(prop.type.asType(Enumeration))
						self.requiredKermetaMetaProperties.add(prop)
					end 
				end
			}
		}
		
		//Add all owning classes
		requiredKermetaMetaProperties.each{prop |
			requiredKermetaMetaClasses.add(prop.owningClass)
		}
	end
	
	
	
	

	operation includeAllMultiLevelSuperClasses():Void is do
		self.requiredKermetaMetaClasses.each { c |
			c.allSuperTypes.each { t | 
				if t.isInstanceOf(Class)   then
					if self.isClassInMM(t.asType(Class).classDefinition) then
						self.requiredKermetaMetaClasses.add(t.asType(Class).classDefinition)
					end
				end
			}
		}
	end
	
	

	
	operation isInRequriedSetOfMetaClasses(tempClass: ClassDefinition) : Boolean is do
		result := requiredKermetaMetaClasses.exists{c | c == tempClass }
	end
	
	
	
	
	operation isInRequriedSetOfMetaEnumerations(tempEnum: Enumeration) : Boolean is do
		result := requiredKermetaMetaEnumerations.exists{e | e ==tempEnum }
	end
		
		
		
		
	operation getRequiredConcepts():Void is do
		//Phase 1: Adding all required types
		//Add initial set of required kermeta meta-classes
		self.includeInitialClasses
		//Add initial set of required kermeta meta-enumerations
		self.includeInitialEnumerations
		//Add initial set of required kermeta meta-properties
		self.includeInitialProperties
		
		//Add all multilevel superclasses
		self.includeAllMultiLevelSuperClasses
	
		//Phase 2: Adding all required properties
		//Pass 1
		self.includeAllObligatoryPropertiesAndTheirTypes
		//Add all multilevel superclasses
		self.includeAllMultiLevelSuperClasses
	
		self.includeAllObligatoryPropertiesAndTheirTypes
		//Add all multilevel superclasses
		self.includeAllMultiLevelSuperClasses

		//Pass 3
		self.includeAllObligatoryPropertiesAndTheirTypes
		//Add all multilevel superclasses
		self.includeAllMultiLevelSuperClasses
	end



	operation OperationRemovalInPackage(aPackage : Package) : Void is do
		if (not aPackage.isVoid) then
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each { 
				object | 
					if object.isInstanceOf(ClassDefinition) then
						object.asType(ClassDefinition).ownedOperation.each {
							 op |  extern org::kermeta::ki::visual::view::ComponentView.onPruning(op)
						}
				end
			}
		end
		
		if not aPackage.nestedPackage.isEmpty then
			aPackage.nestedPackage.each{ p | OperationRemovalInPackage(p) }
		end
	end
	
	
	
	
	
	operation OperationRemoval() : Void is do
		inputKermetaMetamodel.packages.each { p | OperationRemovalInPackage(p)}
	end
	
	
	
	
	operation TagRemovalInPackage(aPackage : Package):Void is do
		if (not aPackage.isVoid) then
			aPackage.tag.each{ t | extern org::kermeta::ki::visual::view::ComponentView.onPruning(t) }
			aPackage.asType(TypeDefinitionContainer).ownedTags.each { 
				object | extern org::kermeta::ki::visual::view::ComponentView.onPruning(object)
			}
		end
		
		if not aPackage.nestedPackage.isEmpty then
			aPackage.nestedPackage.each{ p | TagRemovalInPackage(p) }
		end
	end



	operation TagRemoval() : Void is do
		//Remove all Tags for Modelling Unit
		inputKermetaMetamodel.ownedTags.each { 
			tag | extern org::kermeta::ki::visual::view::ComponentView.onPruning(tag)
		}
		
		//Remove all Tags from packages
		inputKermetaMetamodel.packages.each { p | TagRemovalInPackage(p) }
	end
	
	
	
	operation PropertyRemovalInPackage(aPackage : Package) : Void is do
		var removeProperty : Boolean
		
		if not aPackage.isVoid then
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each {object | 
				if object.isInstanceOf(ClassDefinition) then
					object.asType(ClassDefinition).ownedAttribute.each {prop | 	
			 			removeProperty := requiredKermetaMetaProperties.exists{reqProp |
				 			reqProp == prop
			 			}
			 								
			 			if removeProperty then								
			 				extern org::kermeta::ki::visual::view::ComponentView.onPruning(prop)
			 					
			 				if not prop.opposite.isVoid  then
			 					if not prop.opposite.owningClass.isVoid then
			 						extern org::kermeta::ki::visual::view::ComponentView.onPruning(prop.opposite)
			 					end
			 				end
			 			end
					}	
				end	
			}
		end
			
		if not aPackage.nestedPackage.isEmpty then
			aPackage.nestedPackage.each { p | PropertyRemovalInPackage(p)}
		end
	end
	
	
	
	operation PropertyRemoval(): Void is do
		inputKermetaMetamodel.packages.each{ p | PropertyRemovalInPackage(p)}
	end
	
	
	
	operation ClassRemovalInPackage(aPackage : Package):Void is do
		if not aPackage.isVoid then
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each{object | 
				if object.isInstanceOf(ClassDefinition) then
					//If the class is in the set of required classes
					if not requiredKermetaMetaClasses.contains(object.asType(ClassDefinition)) then								
				 		extern org::kermeta::ki::visual::view::ComponentView.onPruning(object)
					end
				end
			}
		end
		
		if not aPackage.nestedPackage.isEmpty then
			aPackage.nestedPackage.each{ p | ClassRemovalInPackage(p) }
		end
	end
	
	
	
	operation ClassRemoval():Void is do
		inputKermetaMetamodel.packages.each { p | ClassRemovalInPackage(p) }
	end
	
	

	operation PrimitiveTypeRemovalInPackage(aPackage : Package) : Void is do
		if not aPackage.isVoid then				 			
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each{object | 
				if object.isInstanceOf(PrimitiveType) then
					//If the class is in the set of required classes
					if not requiredKermetaMetaPrimitiveTypes.contains(object.asType(PrimitiveType)) then								
				 		extern org::kermeta::ki::visual::view::ComponentView.onPruning(object)
					end
				end
			}
		end
		
		if not aPackage.nestedPackage.isEmpty then
			aPackage.nestedPackage.each{ p | PrimitiveTypeRemovalInPackage(p) }
		end
	end
	 
	 
	 
	operation PrimitiveTypeRemoval():Void is do
		inputKermetaMetamodel.packages.each{ p | PrimitiveTypeRemovalInPackage(p)}
	end
	
	
	
	operation EnumerationRemovalInPackage(aPackage: Package):Void is do
		var removeEnum : Boolean
		
		if not aPackage.isVoid then 
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each{ object | 
				if object.isInstanceOf(Enumeration) then
					removeEnum := not requiredKermetaMetaEnumerations.exists{ e |
					 	e==object.asType(Enumeration)
				 	}
				 
					if removeEnum then 
						extern org::kermeta::ki::visual::view::ComponentView.onPruning(object)
					end
				end
			}
		end
		
		if not aPackage.nestedPackage.isEmpty then
			aPackage.nestedPackage.each{p | EnumerationRemovalInPackage(p) }
		end
	end
	
	
	
	
	operation EnumerationRemoval():Void is do
		self.inputKermetaMetamodel.packages.each{ p | EnumerationRemovalInPackage(p) }
	end




	operation isPackageEmpty(aPackage : Package) : Boolean is do
	//FIXME this operation does not work at all.
		var ownedTypeDefEmpty : Boolean init aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.isEmpty
		result := false
				
		if(aPackage.nestedPackage.isEmpty) then
			if ownedTypeDefEmpty then
				extern org::kermeta::ki::visual::view::ComponentView.onPruning(aPackage)
			end
		else
			aPackage.nestedPackage.each{p |//TODO does it really work?
				result := result and isPackageEmpty(p) 
			}
				
			if ownedTypeDefEmpty and result then
				extern org::kermeta::ki::visual::view::ComponentView.onPruning(aPackage)
			end
		end
	end
	
	
	
	
	operation EmptyPackageRemoval():Void is do
		self.inputKermetaMetamodel.packages.each{ p |
			if self.isPackageEmpty(p) then
				extern org::kermeta::ki::visual::view::ComponentView.onPruning(p)
			end
		}
	end
	


	
	operation getPackageObjects(aPackage:Package) : Bag<Object> is do
		var pkg : TypeDefinitionContainer init aPackage.asType(TypeDefinitionContainer)
		var cd : ClassDefinition
		result := Bag<Object>.new
		
		if not pkg.ownedTypeDefinition.isEmpty  then
			pkg.ownedTypeDefinition.each {object |
				if object.isInstanceOf(Package) then result.add(object)
				else if object.isInstanceOf(ClassDefinition) then
					cd := object.asType(ClassDefinition)
					result.add(object)
					cd.ownedAttribute.each{prop | result.add(prop)}
					cd.~inv.each{constraint | result.add(constraint)}
				else if object.isInstanceOf(PrimitiveType)   then result.add(object)
				else if object.isInstanceOf(Enumeration)     then result.add(object)
				end end end end
			}
		end
		
		if not aPackage.nestedPackage.isEmpty then
			aPackage.nestedPackage.each{p | result.addAll(getPackageObjects(p))}
		end
	end
	
	
	
	
	operation getKermetaObjects():Void is do
		inputKermetaMetamodel.packages.each { p | kermetaObjects.addAll(getPackageObjects(p)) }
	end
	
	
	
	operation isClassInPackage(c : ClassDefinition, aPackage : Package) : Boolean is do
		result := false
		
		if(not aPackage.isVoid) then
			aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.each{ 
				object | 
				if object.isInstanceOf(ClassDefinition) then
					if c==object.asType(ClassDefinition) then
						result := true
					end
				end	
			}
			
			if(not aPackage.nestedPackage.isEmpty) then
				aPackage.nestedPackage.each{p |
					if not result then
						result := isClassInPackage(c, p)
					end
				}
			end
		end
	end
	
	
	
	
	operation isClassInMM(c : ClassDefinition) : Boolean is do
		result := inputKermetaMetamodel.packages.exists{p | isClassInPackage(c, p) }
	end
	
	
	
	
	operation packageContainsPropertyOfType(c : ClassDefinition, aPackage : Package) : Boolean is do
		if aPackage.isVoid then
			result := false
		else
			result := aPackage.asType(TypeDefinitionContainer).ownedTypeDefinition.exists{object |
				if object.isInstanceOf(ClassDefinition) then
					var aClass : ClassDefinition init object.asType(ClassDefinition)
					
					aClass.ownedAttribute.exists{oA |
						if oA.type.isInstanceOf(Class) then
							if oA.type.asType(Class).classDefinition == c then
								result := true
							end
						end
						
						result
					}
				end
				
				result
			}
		end
		
		if not aPackage.nestedPackage.isEmpty and not result then
			result := aPackage.nestedPackage.exists{p |
						packageContainsPropertyOfType(c, p)
					}
		end
	end




	
	operation isUseLess(c : ClassDefinition): Boolean is do
		var isUsed : Boolean init inputKermetaMetamodel.packages.exists{p | 
									packageContainsPropertyOfType(c, p)
								}
		
		result := c.isAbstract and c.ownedAttribute.empty and (not isUsed)
	end
}
