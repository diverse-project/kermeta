/*
 * Creation : March 16, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin 
 */
package kermeta::language::structure;

require "platform:/resource/org.kermeta.ki.malai/kermeta/picking/Picker.kmt"
require "platform:/resource/org.kermeta.ki.visual/kermeta/action/Prune.kmt"
require kermeta


using kermeta::standard
using kermeta::ki::malai::picking
using kermeta::ki::visual


aspect class ClassDefinition inherits Pickable {
	operation entity2ViewMapping() : Void is do
		extern org::kermeta::ki::visual::view::EntityView.name2name(self, self.name)
	end
	
	
	method contains(px : Real, py : Real) : Boolean is do
		result ?= extern org::kermeta::ki::visual::view::EntityView.contains(self, px, py)
	end
	
	
	operation unprune() : Void is do
		extern org::kermeta::ki::visual::view::EntityView.unprune(self)
	end
	
	
	operation prune(viewPolicy : PrunerViewPolicy) : Void is do
		extern org::kermeta::ki::visual::view::ComponentView.onPruning(viewPolicy==PrunerViewPolicy.hide, self)
	end
	
	
	operation isPruned() : Boolean is do
		result ?= extern org::kermeta::ki::visual::view::ComponentView.isPruned(self)
	end
	
	

	operation isVisible() : Boolean is do
		result ?= extern org::kermeta::ki::visual::view::ComponentView.isVisible(self)
	end
}




aspect class ModelingUnit inherits Picker {
	operation reinitView() : Void is do
		packages.each{p | p.allNestedClassDefinitions.each{cd | cd.unprune }}
	end


	method getPickableAt(px : Real, py : Real) : Pickable is do
		var pickable : Pickable

		packages.exists{p |
			result := p.allNestedClassDefinitions.detect{cd | cd.contains(px, py) }
			not result.isVoid
		}
	end
	
	
	method containsObject(obj : Object) : Boolean is do
		packages.exists{p |
			result := p.allNestedClassDefinitions.exists{cd | cd==obj }
			result
		}
	end
}





aspect class Package
{
	property readonly allNestedPackages: set Package [0..*]
		getter is do
			result := Set<Package>.new
			result.add(self)
			nestedPackage.each{p | result.addAll(p.allNestedPackages)} 
		end

	property readonly allNestedClassDefinitions: set ClassDefinition [0..*]
		getter is do
			result := Set<ClassDefinition>.new
			ownedTypeDefinition.select{td | td.isInstanceOf(ClassDefinition)}.each{cd | result.add(cd.asType(ClassDefinition))}
			nestedPackage.each{p | result.addAll(p.allNestedClassDefinitions)} 
		end
		
	property readonly allNestedAttributes: set Property [0..*]
		getter is do
			result := Set<Property>.new
			allNestedClassDefinitions.each{cd | result.addAll(cd.ownedAttribute)}
		end
		
	property readonly numberOfPackages: Integer
		getter is do
			result := 1
			nestedPackage.each{p | result := result + p.numberOfPackages}
		end
			
	property readonly numberOfClasses: Integer
		getter is do
			result := ownedTypeDefinition.select{td | td.isInstanceOf(ClassDefinition)}.size
			nestedPackage.each{p | result := result + p.numberOfClasses}
		end
}


aspect class Operation {
}


aspect class Property {
}
