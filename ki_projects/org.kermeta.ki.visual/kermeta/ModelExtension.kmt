/*
 * Creation : March 16, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin 
 */
package kermeta::language::structure;

require "platform:/resource/org.kermeta.ki.malai/kermeta/picking/Picker.kmt"
require "platform:/resource/org.kermeta.ki.visual/kermeta/action/Prune.kmt"
require kermeta


using kermeta::standard
using kermeta::ki::malai::picking
using kermeta::ki::visual


aspect class Object {
	operation isVisible() : Boolean is do
		result ?= extern org::kermeta::ki::visual::view::ComponentView.isVisible(self)
	end
	
	
	operation getModelingUnit() : ModelingUnit is do
		var obj : Object init container()
		
		result := if(obj.isInstanceOf(ModelingUnit)) then obj.asType(ModelingUnit)
					else if(obj.isInstanceOf(Object)) then obj.asType(Object).getModelingUnit()
					else void end end
	end
}


aspect class ClassDefinition inherits Pickable {
	operation isKermetaPrimitiveType() : Boolean is do
		result := name=="String" or name=="Boolean" or name=="Real" or name=="Integer"
	end


	operation entity2ViewMapping() : Void is do
		extern org::kermeta::ki::visual::view::EntityView.update(self, self.name, self.isAbstract)
	end
	
	
	method contains(px : Real, py : Real) : Boolean is do
		result ?= extern org::kermeta::ki::visual::view::EntityView.contains(self, px, py)
	end
	
	
	operation unprune() : Void is do
		extern org::kermeta::ki::visual::view::EntityView.unprune(self)
	end
	
	
	operation prune(viewPolicy : PrunerViewPolicy) : Void is do
		extern org::kermeta::ki::visual::view::ComponentView.onPruning(viewPolicy==PrunerViewPolicy.hide, self)
	end
	
	
	operation isPruned() : Boolean is do
		result ?= extern org::kermeta::ki::visual::view::ComponentView.isPruned(self)
	end
	
	
	
	
	operation movePropertyTo(p : Property, srcClass : ClassDefinition, metamodel : ModelingUnit) : Void is do
		self.ownedAttribute.remove(p)
		srcClass.ownedAttribute.add(p)
		
		if(p.type.isInstanceOf(PrimitiveType)) then
			extern org::kermeta::ki::visual::view::EntityView.onAttributeRemoved(self, p)
			extern org::kermeta::ki::visual::view::EntityView.onAttributeAdded(srcClass, p, p.name, p.type.asType(PrimitiveType).name)
		else 
			if(p.type.isInstanceOf(Class)) then
				var cd : ClassDefinition init p.type.asType(Class).classDefinition
				
				if(cd.isKermetaPrimitiveType) then
					extern org::kermeta::ki::visual::view::EntityView.onAttributeRemoved(self, p)
					extern org::kermeta::ki::visual::view::EntityView.onAttributeAdded(srcClass, p, p.name, cd.name)
				else
					if(cd==self) then
						cd := srcClass
					end
					
					extern org::kermeta::ki::visual::view::MetamodelView.onLinkRemoved(metamodel, p)
					if(not p.opposite.isVoid) then
						extern org::kermeta::ki::visual::view::MetamodelView.onLinkRemoved(metamodel, p.opposite)
					end
					extern org::kermeta::ki::visual::view::MetamodelView.onLinkAdded(metamodel, p, p.isComposite, srcClass, cd, 
							p.name, p.getCardinalityString, if(not p.opposite.isVoid) then p.opposite.name end, 
							if(not p.opposite.isVoid) then p.opposite.getCardinalityString end, -1)
				end
			end
		end
	end
	
	
	
	operation moveOperationTo(op : Operation, srcClass : ClassDefinition) : Void is do
		var typeName : String init if(op.type.isInstanceOf(NamedElement)) then op.type.asType(NamedElement).name else "" end
		
		srcClass.ownedOperation.add(op)
		self.ownedOperation.remove(op)

		extern org::kermeta::ki::visual::view::EntityView.onOperationRemoved(self, op)
		extern org::kermeta::ki::visual::view::EntityView.onOperationAdded(srcClass, op, op.name, typeName, op.isAbstract)
	end
	
	
	
	operation getSubTypes() : Set<ClassDefinition> is do
		var modelingUnit : ModelingUnit init getModelingUnit
		var cd : ClassDefinition
		result := Set<ClassDefinition>.new
		
		modelingUnit.packages.each{p |
			p.ownedTypeDefinition.each{td |
				if(self!=td and td.isInstanceOf(ClassDefinition)) then
					cd := td.asType(ClassDefinition)
					cd.superType.each{st | 
						if(not st.isVoid and st.isInstanceOf(ParameterizedType).andThen{b | st.asType(ParameterizedType).typeDefinition==self}) 
						then result.add(cd) end 
					}
				end
			}
		}
	end
}




aspect class ModelingUnit inherits Picker {
	operation isClassDefined(classDef : GenericTypeDefinition) : Boolean is do
		result := (not classDef.isVoid).andThen{b | packages.exists{p | p.ownedTypeDefinition.exists{td | classDef==td }}}
	end


	operation reinitView() : Void is do//TODO see if ownedTypeDefinition works
		packages.each{p | p.allNestedClassDefinitions.each{cd | cd.unprune }}
		extern org::kermeta::ki::visual::view::MetamodelView.update(self)
	end


	method getPickableAt(px : Real, py : Real) : Pickable is do
		var pickable : Pickable

		packages.exists{p |//TODO see if ownedTypeDefinition works
			result := p.allNestedClassDefinitions.detect{cd | cd.contains(px, py) }
			not result.isVoid
		}
	end
	
	
	method containsObject(obj : Object) : Boolean is do
		if((obj.isVoid).orElse{b | not obj.isInstanceOf(ClassDefinition) and not obj.isInstanceOf(Operation)
				and not obj.isInstanceOf(Property)}) then
			result := false
		else
			packages.exists{p |//TODO see if ownedTypeDefinition works
				result := p.allNestedClassDefinitions.exists{cd | cd==obj }
				result
			}
		end
	end
}





aspect class Package
{
	property readonly allNestedPackages: set Package [0..*]
		getter is do
			result := Set<Package>.new
			result.add(self)
			nestedPackage.each{p | result.addAll(p.allNestedPackages)} 
		end

	property readonly allNestedClassDefinitions: set ClassDefinition [0..*]
		getter is do
			result := Set<ClassDefinition>.new
			ownedTypeDefinition.select{td | td.isInstanceOf(ClassDefinition)}.each{cd | result.add(cd.asType(ClassDefinition))}
			nestedPackage.each{p | result.addAll(p.allNestedClassDefinitions)} 
		end
		
	property readonly allNestedAttributes: set Property [0..*]
		getter is do
			result := Set<Property>.new
			allNestedClassDefinitions.each{cd | result.addAll(cd.ownedAttribute)}
		end
		
	property readonly numberOfPackages: Integer
		getter is do
			result := 1
			nestedPackage.each{p | result := result + p.numberOfPackages}
		end
			
	property readonly numberOfClasses: Integer
		getter is do
			result := ownedTypeDefinition.select{td | td.isInstanceOf(ClassDefinition)}.size
			nestedPackage.each{p | result := result + p.numberOfClasses}
		end
}


aspect class Operation {
}


aspect class Property {
	operation getCardinalityString() : String is do
		if(upper==lower) then
			result := if(upper==-1) then "*" else upper.toString end
		else
			result := lower.toString + ".." + if(upper==-1) then "*" else upper.toString end
		end
	end
}
