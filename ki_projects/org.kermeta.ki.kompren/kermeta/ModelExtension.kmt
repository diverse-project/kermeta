/*
 * Creation : March 16, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin 
 */
package kermeta::language::structure;

require "platform:/resource/org.kermeta.ki.malai/kermeta/picking/Picker.kmt"
require "platform:/resource/org.kermeta.ki.kompren/kermeta/action/Prune.kmt"
require "platform:/resource/org.kermeta.ki.malai/kermeta/interaction/Eventable.kmt"
require kermeta


using kermeta::standard
using kermeta::ki::malai::picking
using kermeta::ki::kompren
using kermeta::ki::malai::interaction::event
using kermeta::ki::malai::interaction


aspect class NamedElement {
	operation isVisible() : Boolean is do
		result ?= extern org::kermeta::ki::kompren::view::EntityViewExtern.isVisible(self)
	end
	
	
	operation getModelingUnit() : ModelingUnit is do
		var obj : Object init container()
		
		result := if(obj.isInstanceOf(ModelingUnit)) then obj.asType(ModelingUnit)
					else if(obj.isInstanceOf(NamedElement)) then obj.asType(NamedElement).getModelingUnit()
					else void end end
	end
	
	operation getPackageName() : String is do
		var pkg : Package
		result := ""
		
		from var obj : Object init container()
		until not obj.isInstanceOf(Package)
		loop
			pkg := obj.asType(Package)
			result := result + if(result.size>0) then ":" else "" end +  pkg.name
			obj := pkg.container
		end
	end
}


aspect class ClassDefinition inherits Pickable {
	operation isKermetaPrimitiveType() : Boolean is do
		result := name=="String" or name=="Boolean" or name=="Real" or name=="Integer"
	end


	operation entity2ViewMapping() : Void is do
		extern org::kermeta::ki::kompren::view::ClassViewExtern.update(self, self.name, self.isAbstract)
	end
	
	
	method contains(px : Real, py : Real) : Boolean is do
		result ?= extern org::kermeta::ki::kompren::view::EntityViewExtern.contains(self, px, py)
	end
	
	
	operation unprune() : Void is do
		extern org::kermeta::ki::kompren::view::EntityViewExtern.unprune(self)
	end
	
	
	operation prune(viewPolicy : PrunerViewPolicy) : Void is do
		extern org::kermeta::ki::kompren::view::EntityViewExtern.onPruning(viewPolicy==PrunerViewPolicy.hide, self)
	end
	
	
	operation isPruned() : Boolean is do
		result ?= extern org::kermeta::ki::kompren::view::EntityViewExtern.isPruned(self)
	end
	
	
	
	
	operation movePropertyTo(p : Property, srcClass : ClassDefinition, metamodel : ModelingUnit) : Void is do
		self.ownedAttribute.remove(p)
		srcClass.ownedAttribute.add(p)
		
		if(p.type.isInstanceOf(PrimitiveType)) then
			extern org::kermeta::ki::kompren::view::ClassViewExtern.onAttributeRemoved(self, p)
			extern org::kermeta::ki::kompren::view::ClassViewExtern.onAttributeAdded(srcClass, p, p.name, p.type.asType(PrimitiveType).name)
		else 
			if(p.type.isInstanceOf(Class)) then
				var cd : ClassDefinition init p.type.asType(Class).classDefinition
				
				if(cd.isKermetaPrimitiveType) then
					extern org::kermeta::ki::kompren::view::ClassViewExtern.onAttributeRemoved(self, p)
					extern org::kermeta::ki::kompren::view::ClassViewExtern.onAttributeAdded(srcClass, p, p.name, cd.name)
				else
					if(cd==self) then
						cd := srcClass
					end
					
					extern org::kermeta::ki::kompren::view::DiagramViewExtern.onRelationRemoved(metamodel, p)
					if(not p.opposite.isVoid) then
						extern org::kermeta::ki::kompren::view::DiagramViewExtern.onRelationRemoved(metamodel, p.opposite)
					end
					
					var oppositeName : String init ""
					var oppositeCompo : Boolean init false
					var oppositeCardString : String init ""
					
					if(not p.opposite.isVoid) then 
						oppositeName  := p.opposite.name 
						oppositeCompo := p.opposite.isComposite
						oppositeCardString := p.opposite.getCardinalityString
					end
			
					extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.onRelationAdded(metamodel, p, p.isComposite, srcClass, cd, 
											p.name, p.getCardinalityString, oppositeName, oppositeCardString, -1, oppositeCompo)
				end
			end
		end
	end
	
	
	
	operation moveOperationTo(op : Operation, srcClass : ClassDefinition) : Void is do
		var typeName : String init if(op.type.isInstanceOf(NamedElement)) then op.type.asType(NamedElement).name else "" end
		
		srcClass.ownedOperation.add(op)
		self.ownedOperation.remove(op)

		extern org::kermeta::ki::kompren::view::ClassViewExtern.onOperationRemoved(self, op)
		extern org::kermeta::ki::kompren::view::ClassViewExtern.onOperationAdded(srcClass, op, op.name, typeName, op.isAbstract)
	end
	
	
	
	operation getSubTypes() : Set<ClassDefinition> is do
		var modelingUnit : ModelingUnit init getModelingUnit
		var cd : ClassDefinition
		result := Set<ClassDefinition>.new
		
		modelingUnit.packages.each{p |
			p.ownedTypeDefinition.each{td |
				if(self!=td and td.isInstanceOf(ClassDefinition)) then
					cd := td.asType(ClassDefinition)
					cd.superType.each{st | 
						if(not st.isVoid and st.isInstanceOf(ParameterizedType).andThen{b | st.asType(ParameterizedType).typeDefinition==self}) 
						then result.add(cd) end 
					}
				end
			}
		}
	end
}




aspect class ModelingUnit inherits Picker, Eventable {
	attribute eventManager : EventManager
	
	
	operation update() : Void is do
		extern org::kermeta::ki::kompren::view::DiagramViewExtern.update(self)
	end
	
	operation focusOnTypeDefinition(typeDef : TypeDefinition) : Void is do
		extern org::kermeta::ki::kompren::view::DiagramViewExtern.focusOnEntity(self, typeDef)
	end
	
	
	
	operation setEventManager(eventManager : EventManager) : Void is do
		self.eventManager := eventManager
		extern org::kermeta::ki::malai::interaction::eventWrapper::EventManagerWrapperExtern.attachTo(self, eventManager)
	end
	
	
	operation isClassDefined(classDef : GenericTypeDefinition) : Boolean is do
		result := (not classDef.isVoid).andThen{b | packages.exists{p | p.ownedTypeDefinition.exists{td | classDef==td }}}
	end


	operation organise() : Void is do
		extern org::kermeta::ki::kompren::view::DiagramViewExtern.organise(self)
	end

	
	operation reinitView() : Void is do//TODO see if ownedTypeDefinition works
		packages.each{p | p.allNestedClassDefinitions.each{cd | cd.unprune }}
		extern org::kermeta::ki::kompren::view::DiagramViewExtern.update(self)
	end


	method getPickableAt(px : Real, py : Real) : Pickable is do
		var pickable : Pickable

		packages.exists{p |//TODO see if ownedTypeDefinition works
			result := p.allNestedClassDefinitions.detect{cd | cd.contains(px, py) }
			not result.isVoid
		}
	end
	
	
	method containsObject(obj : Object) : Boolean is do
		if((obj.isVoid).orElse{b | not obj.isInstanceOf(ClassDefinition) and not obj.isInstanceOf(Operation)
				and not obj.isInstanceOf(Property)}) then
			result := false
		else
			packages.exists{p |//TODO see if ownedTypeDefinition works
				result := p.allNestedClassDefinitions.exists{cd | cd==obj }
				result
			}
		end
	end
	
	
	operation isOperationsVisible() : Boolean is do
		result ?= extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.isOperationsVisible(self)
	end
	
	
	operation isPropertiesVisible() : Boolean is do
		result ?= extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.isPropertiesVisible(self)
	end
	
	
	operation setOperationsVisible(visible : Boolean) : Void is do
		extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.setOperationsVisible(self, visible)
	end
	
	
	operation setPropertiesVisible(visible : Boolean) : Void is do
		extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.setPropertiesVisible(self, visible)
	end
	
	
	method hasEventManager() : Boolean is do
		result := not eventManager.isVoid
	end
	
	
	method getEventManager() : EventManager is do
		result := eventManager
	end
}





aspect class Package
{
	property readonly allNestedPackages: set Package [0..*]
		getter is do
			result := Set<Package>.new
			result.add(self)
			nestedPackage.each{p | result.addAll(p.allNestedPackages)} 
		end

	property readonly allNestedClassDefinitions: set ClassDefinition [0..*]
		getter is do
			result := Set<ClassDefinition>.new
			ownedTypeDefinition.select{td | td.isInstanceOf(ClassDefinition)}.each{cd | result.add(cd.asType(ClassDefinition))}
			nestedPackage.each{p | result.addAll(p.allNestedClassDefinitions)} 
		end
		
	property readonly allNestedAttributes: set Property [0..*]
		getter is do
			result := Set<Property>.new
			allNestedClassDefinitions.each{cd | result.addAll(cd.ownedAttribute)}
		end
		
	property readonly numberOfPackages: Integer
		getter is do
			result := 1
			nestedPackage.each{p | result := result + p.numberOfPackages}
		end
			
	property readonly numberOfClasses: Integer
		getter is do
			result := ownedTypeDefinition.select{td | td.isInstanceOf(ClassDefinition)}.size
			nestedPackage.each{p | result := result + p.numberOfClasses}
		end
}



aspect class Property {
	operation getCardinalityString() : String is do
		if(upper==lower) then
			result := if(upper==-1) then "*" else upper.toString end
		else
			result := lower.toString + ".." + if(upper==-1) then "*" else upper.toString end
		end
	end
}
