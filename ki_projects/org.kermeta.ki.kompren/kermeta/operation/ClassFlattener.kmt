/*
 * Creation : April 9, 2010
 * Licence  : EPL 
 * Copyright: INRIA Rennes, Triskell
 * Authors  :  Arnaud
 */
package kermeta::ki::kompren;


require "platform:/resource/org.kermeta.ki.kompren/kermeta/ModelExtension.kmt"

using kermeta::language::structure
using kermeta::standard

//FIXME with UML.ecore, prune with radius=1 Class Class. Relation <code>redefinedOperation</code> of Classifier not visible because of the radius.
// But if you flat Class Class, redefinedOperation is then added to Class. Undo the flattening and this relation will appear in Class Classifier 

class ClassFlattener
{
	reference metamodel : ModelingUnit
	
	reference addedProperties : PropertyBackup[0..*]
	
	reference addedOperations : OperationBackup[0..*]
	
	reference addedInheritances : InheritanceBackup[0..*]
	
	attribute removedInheritances : InheritanceBackup[0..*]
	
	reference removedClasses : ClassBackup[0..*]
	
	reference classToFlat : ClassDefinition
	
	reference changedProperties : PropertyChangedBackup[0..*]
	
	
	operation flat(classToFlat : ClassDefinition) : Void is do
		var superType	: Type
		var inheritance : InheritanceBackup
		var prop		: PropertyBackup
		var cd 			: ClassDefinition
		var cd2			: ClassDefinition
		
		self.classToFlat := classToFlat
		
		from true
		until classToFlat.superType.empty
		loop
			superType := classToFlat.superType.one

			if(superType.isInstanceOf(Class).andThen{b | metamodel.isClassDefined(superType.asType(Class).typeDefinition)}) then
				cd := superType.asType(Class).classDefinition
				
				if(not cd.isPruned) then
					inheritance 			:= InheritanceBackup.new
					inheritance.source 		:= classToFlat
					inheritance.sourceType 	:= superType
					inheritance.target 		:= cd
					removedInheritances.add(inheritance)
					
					classToFlat.superType.remove(superType)
					extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.onInheritanceRemoved(metamodel, classToFlat, cd)
					flatClass(cd, classToFlat)
				end
			else
				classToFlat.superType.remove(superType)
			end
		end
		
		// Each property which source class is ClassToFlat and which target class is no more visible must be
		// modified: the target type of the property must be ClassToFlat.
		classToFlat.ownedAttribute.each{attr |
			if(attr.type.isInstanceOf(ParameterizedType)) then
				cd2 := attr.type.asType(ParameterizedType).typeDefinition.asType(ClassDefinition)
				
				if((cd2.isPruned).andThen{b | removedClasses.exists{clazz | clazz==cd2}}) then
					var backup : PropertyChangedBackup init PropertyChangedBackup.new
					var oppositeName : String init ""
					var oppositeCompo : Boolean init false
					var oppositeCardString : String init ""
					
					backup.prop := attr
					backup.type := attr.type
					changedProperties.add(backup)
					
					if(not attr.opposite.isVoid) then 
						oppositeName  := attr.opposite.name 
						oppositeCompo := attr.opposite.isComposite
						oppositeCardString := attr.opposite.getCardinalityString
					end
					
					extern org::kermeta::ki::kompren::view::DiagramViewExtern.onRelationRemoved(metamodel, attr)
					var clazz : Class init Class.new
					clazz.typeDefinition := classToFlat
					attr.type := clazz
					extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.onRelationAdded(metamodel, attr, attr.isComposite, classToFlat, classToFlat, 
											attr.name, attr.getCardinalityString, oppositeName, oppositeCardString, -1, oppositeCompo)
				end
			end	
		}
	end
	
	
	
	operation flatClass(currentClass : ClassDefinition, upperClass : ClassDefinition) : Void is do
		if(currentClass.name!="Object" or not currentClass.superType.empty) then
			var propBackUp : PropertyBackup
			var opBackUp   : OperationBackup
			var inBackup   : InheritanceBackup
				
			// Moving properties
			currentClass.ownedAttribute.each{prop |
				currentClass.movePropertyTo(prop, classToFlat, metamodel)
				propBackUp := PropertyBackup.new
				propBackUp.prop := prop
				propBackUp.owningClass := currentClass
				addedProperties.add(propBackUp)
			}
			
			// Moving operations
			currentClass.ownedOperation.each{op |
				if(op.isVisible) then
					opBackUp 			 := OperationBackup.new
					opBackUp.op 		 := op
					opBackUp.owningClass := currentClass
					
					currentClass.moveOperationTo(op, classToFlat)
					addedOperations.add(opBackUp)
				end
			}
			
			// Changing inheritance: sub-types of this class inherit now of the flattened class.
			var subTypes : Set<ClassDefinition> init currentClass.getSubTypes
			var inheritance : InheritanceBackup
			var cd : ClassDefinition
			
			subTypes.each{st |
				if(not st.isPruned) then
					inBackup := InheritanceBackup.new
					inBackup.source := st
					inBackup.target := currentClass
					inBackup.sourceType := st.superType.detect{st2 | (st2.isInstanceOf(ParameterizedType)).andThen{b | st2.asType(ParameterizedType).typeDefinition==currentClass }}
	
					removedInheritances.add(inBackup)
					extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.onInheritanceRemoved(metamodel, st, currentClass)
					
					if((not inBackup.sourceType.isVoid)) then
						st.superType.remove(inBackup.sourceType)
					end
					
					// A link must not be created if the class st is the class to flat or the previous class in the hierarchy.
					if((st!=classToFlat and st!=upperClass and not st.isPruned).andThen{b | 
							not st.superType.exists{st2 | st2.isInstanceOf(ParameterizedType).andThen{b2 | st2.asType(ParameterizedType).typeDefinition==classToFlat}}}) then
						inBackup := InheritanceBackup.new
						inBackup.source := st
						inBackup.target := classToFlat
						addedInheritances.add(inBackup)
						var clazz : Class init Class.new
						clazz.typeDefinition := classToFlat
						st.superType.add(clazz)
						extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.onInheritanceAdded(metamodel, st, classToFlat, -1)
					end
				end
				
				// Removing the class from its sub-type
				st.superType.detect{type |
					if(type.isInstanceOf(ParameterizedType)) then
						if(type.asType(ParameterizedType).typeDefinition==currentClass) then
							inheritance 			:= InheritanceBackup.new
							inheritance.source 		:= st
							inheritance.sourceType 	:= type
							inheritance.target 		:= currentClass
							removedInheritances.add(inheritance)
							
							st.superType.remove(type)
							true
						else false end
					else false end
				}
			}
			
			// Contining on the super types of the current class.
			currentClass.superType.each{st |
				if(st.isInstanceOf(Class)) then
					var clazz : Class init st.asType(Class)
					cd := st.asType(Class).classDefinition
					
					if(not cd.isPruned) then
						inheritance 			:= InheritanceBackup.new
						inheritance.source 		:= currentClass
						inheritance.sourceType 	:= st
						inheritance.target 		:= cd
						removedInheritances.add(inheritance)
						currentClass.superType.remove(st)
						extern org::kermeta::ki::kompren::view::ClassDiagramViewExtern.onInheritanceRemoved(metamodel, currentClass, cd)
						
						if((clazz.typeDefinition!=classToFlat).andThen{b |
							metamodel.isClassDefined(st.asType(Class).typeDefinition)}) then
							flatClass(st.asType(Class).classDefinition, currentClass)
						end
					end
				end
			}
			
			// Removing the class.
			var classBackup : ClassBackup init ClassBackup.new
			classBackup.clazz   := currentClass
			classBackup.visible := currentClass.isVisible
			classBackup.pruned  := currentClass.isPruned
			removedClasses.add(classBackup)
			extern org::kermeta::ki::kompren::view::EntityViewExtern.onPruning(true, currentClass)
		end
	end
}


class ClassBackup {
	reference clazz : ClassDefinition
	reference visible : Boolean
	reference pruned : Boolean
}



class PropertyChangedBackup {
	reference prop : Property
	reference type : Type
}



class OperationBackup {
	reference op : Operation
	
	reference owningClass : ClassDefinition
}



class PropertyBackup {
	reference prop : Property
	
	reference owningClass : ClassDefinition
}



class InheritanceBackup {
	reference source : ClassDefinition
	
	reference target : ClassDefinition
	
	reference sourceType : Type
}
