/*
 * Creation : February 17, 2010
 * Licence  : EPL 
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package kermeta::ki::kompren;


require "platform:/resource/org.kermeta.ki.kompren/kermeta/ModelExtension.kmt"
require "platform:/resource/org.kermeta.ki.kompren/kermeta/operation/VisualMetamodelPruner.kmt"
require "platform:/resource/org.kermeta.pruning/kermeta/metamodelPruner.kmt"
require "platform:/resource/org.kermeta.ki.malai/kermeta/action/Action.kmt"

using kermeta::pruning
using kermeta::standard
using kermeta::language::structure
using kermeta::ki::malai::action
using kermeta::ki::malai::undo


enumeration PrunerViewPolicy { hide; gray; }


class Prune inherits Action, Undoable {
	reference selection : ClassDefinition[0..*]
	
	reference metamodel : ModelingUnit
	
	attribute viewPolicy : PrunerViewPolicy
	
	attribute radiusEffect : Integer
	
	attribute arePruned : Sequence<Boolean>
	
	attribute oldViewPolicy : PrunerViewPolicy
	
	attribute card0 : Boolean
	
	
	
	operation setPruningParameters(pruningOperation : VisualMetamodelPruner) : Void is do
		pruningOperation.isHierarchicalPruning := false
	end
	
	
	
	method doActionBody() : Void is do
		// Saving the current visible values.
		var i : Integer init 0
		var pruned : Boolean
		arePruned := Sequence<Boolean>.new

		metamodel.packages.each{pkg |
			pkg.allNestedClassDefinitions.each{cd |
				if(not cd.isAspect) then
					pruned := cd.isPruned
					arePruned.add(pruned)
	
					if(oldViewPolicy.isVoid and pruned) then
						if(cd.isVisible) then
							oldViewPolicy := PrunerViewPolicy.gray
						else
							oldViewPolicy := PrunerViewPolicy.hide
						end
					end
					
					i := i + 1
				end
			}
		}
		
		metamodel.reinitView
		
		var pruningOp  : VisualMetamodelPruner init VisualMetamodelPruner.new
		var reqClasses : Bag<RequiredClass> init Bag<RequiredClass>.new
		var reqClass   : RequiredClass
		
		selection.each{cd |
			reqClass      := RequiredClass.new
	        reqClass.name := cd.name
			reqClasses.add(reqClass)
		}
		
		pruningOp.inputKermetaMetamodel := metamodel
		pruningOp.initializeVisualPruning(reqClasses, Bag<RequiredProperty>.new, Bag<RequiredEnumeration>.new, 3, viewPolicy, radiusEffect, card0)
		setPruningParameters(pruningOp)
		
		if pruningOp.preprocess then
			pruningOp.transform
		end
		
		metamodel.organise()
		metamodel.focusOnTypeDefinition(selection.at(0))
		done()
	end
	
	
	method hadEffect() : Boolean is do
		result := isDone
	end
	
	
	method canDo() : Boolean is do
		result := not metamodel.isVoid and selection.size>0 and not viewPolicy.isVoid and not radiusEffect.isVoid and not card0.isVoid
	end
	
	
	method cancelledBy(action : Class) : Boolean is do
		result := false
	end
	
	
	method isRegisterable() : Boolean is do
		result := true
	end
	
	
	method undo() : Void is do
		changeVisibility(oldViewPolicy)
	end
	
	
	method redo() : Void is do
		changeVisibility(viewPolicy)
	end
	
	
	operation changeVisibility(policy : PrunerViewPolicy) : Void is do
		var arePruned2 : Sequence<Boolean> init Sequence<Boolean>.new
		var i : Integer init 0
		
		metamodel.packages.each{pkg |
			pkg.allNestedClassDefinitions.each{cd |
				if(not cd.isAspect) then
					arePruned2.add(cd.isPruned)
					if(arePruned.at(i)) then 
						cd.prune(policy)
					else
						cd.unprune
					end		
					i := i + 1
				end
			}
		}
		
		arePruned := arePruned2
		metamodel.organise()
		metamodel.focusOnTypeDefinition(selection.at(0))
	end
}
