package ex::stateMachine;
require kermeta
require "platform:/resource/org.kermeta.ki.pruning.examples/src/kermeta/SM/StateMachine.ecore"
require "StateMachinePruningAspect.kmt"

using kermeta::standard

abstract class StateMachinePruning {
	reference theStateMachine : StateMachine

	attribute radius : Integer

	reference requiredOutputStates : OutputState[0..*]

	reference addedStates : Bag<State>

	reference addedTransitions : Bag<Transition>

	operation initialise(theStateMachine : StateMachine, requiredOutputStates : bag OutputState[0..*], radius : Integer) : StateMachinePruning is do
		result := self
		self.addedStates := Bag<State>.new
		self.addedTransitions := Bag<Transition>.new
		self.theStateMachine := theStateMachine
		self.radius := radius
		self.requiredOutputStates.addAll(requiredOutputStates)
	end

	operation launch() : Void is do
		preparePruning()

		var theStates  : Bag<State> init Bag<State>.new
		var theStates2 : Bag<State> init Bag<State>.new
		var currentRadius : Integer init 0

		requiredOutputStates.each{theOutputState | theStates.add(theOutputState) }

		from true
		until (theStates.empty()) or (currentRadius>radius and radius!=0)
		loop
			theStates.each{theState |
				if(not theState.visited) then
					theState.visit(self, theStates2)
				end
			}

			theStates.clear()
			theStates2.each{theState | theStates.add(theState) }
			theStates2.clear()
			currentRadius := currentRadius + 1
		end

		addedStates.each{theState | theState.addTransitions(self) }
	end

	operation preparePruning() : Void is do
		self.theStateMachine.states.each{theState | theState.preparePruning() }
		self.theStateMachine.transitions.each{theTransition | theTransition.preparePruning() }
	end

	operation onStateAdded(theState : State) : Void is abstract
	operation onTransitionAdded(theTransition : Transition) : Void is abstract
}
