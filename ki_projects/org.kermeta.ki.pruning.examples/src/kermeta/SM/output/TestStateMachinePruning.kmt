/*
 * Creation : November 24, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell Team
 * Authors  : Arnaud Blouin
 */
@mainClass "ex::stateMachine::Test"
@mainOperation "main"


package ex::stateMachine;

require kermeta
require "StateMachinePruning.kmt"

using kermeta::standard


class PrintStateMachinePruning inherits StateMachinePruning {
	method onStateAdded(state : State) : Void is do
		stdio.writeln("State: " + state.name)
	end
	
	method onTransitionAdded(transition : Transition) : Void is do
		stdio.writeln("Transition: " + transition.source.name + "->" + transition.target.name)
	end
}



class Test {
	operation main() : Void is do
		var requiredStates : Bag<OutputState> init Bag<OutputState>.new
		var sm : StateMachine init createStateMachineModel(requiredStates)
		
		var pruning : PrintStateMachinePruning init PrintStateMachinePruning.new.initialise(sm, requiredStates, 2).asType(PrintStateMachinePruning)
		
		pruning.launch()
	end
	
	
	operation createStateMachineModel(requiredStates : Bag<OutputState>) : StateMachine is do
		result := StateMachine.new
		
		var initState : InitState init InitState.new
		var s1 : StandardState init StandardState.new
		var s2 : StandardState init StandardState.new
		var terminal : TerminalState init TerminalState.new
		var transition : Transition init Transition.new
		
		initState.name := "init"
		s1.name := "s1"
		s2.name := "s2"
		terminal.name := "end"
		
		result.initState := initState
		result.states.add(initState)
		result.states.add(s1)
		result.states.add(s2)
		result.states.add(terminal)
		
		transition.source := initState
		transition.target := s1
		result.transitions.add(transition)
		initState.outgoingTransitions.add(transition)
		s1.ingoingTransitions.add(transition)
		
		transition := Transition.new
		transition.source := s1
		transition.target := s2
		result.transitions.add(transition)
		s1.outgoingTransitions.add(transition)
		s2.ingoingTransitions.add(transition)
		
		transition := Transition.new
		transition.source := s2
		transition.target := s1
		result.transitions.add(transition)
		s2.outgoingTransitions.add(transition)
		s1.ingoingTransitions.add(transition)
		
		transition := Transition.new
		transition.source := s2
		transition.target := s2
		result.transitions.add(transition)
		s2.outgoingTransitions.add(transition)
		s2.ingoingTransitions.add(transition)
		
		transition := Transition.new
		transition.source := s2
		transition.target := terminal
		result.transitions.add(transition)
		s2.outgoingTransitions.add(transition)
		terminal.ingoingTransitions.add(transition)
		
		requiredStates.add(initState)
	end 
}
