@mainClass "ex::stateMachine::Test"
@mainOperation "main"
package ex::stateMachine;
require kermeta
require "StateMachinePruningAspect.kmt"

using kermeta::standard

abstract class StateMachinePruning {
	reference theStateMachine : StateMachine

	attribute radius : Integer

	reference requiredOutputStates : OutputState[0..*]

	reference addedStates : Bag<State>

	reference addedTransitions : Bag<Transition>

	operation initialise(theStateMachine : StateMachine, requiredOutputStates : bag OutputState[0..*], radius : Integer) : StateMachinePruning is do
		result := self
		self.addedStates := Bag<State>.new
		self.addedTransitions := Bag<Transition>.new
		self.theStateMachine := theStateMachine
		self.radius := radius
		self.requiredOutputStates.addAll(requiredOutputStates)
	end

	operation launch() : Void is do
		preparePruning()

		var theStates  : Bag<State> init Bag<State>.new
		var theStates2 : Bag<State> init Bag<State>.new
		var currentRadius : Integer init 0

		requiredOutputStates.each{theOutputState | theStates.add(theOutputState) }

		from true
		until (theStates.empty()) or (currentRadius>radius and radius!=0)
		loop
			theStates.each{theState |
				if(not theState.visited) then
					theState.visit(self, theStates2)
				end
			}

			theStates.clear()
			theStates2.each{theState | theStates.add(theState) }
			theStates2.clear()
			currentRadius := currentRadius + 1
		end

		addedStates.each{theState | theState.addTransitions(self) }
	end

	operation preparePruning() : Void is do
		theStateMachine.states.each{theState | theState.visited := false }
		theStateMachine.transitions.each{theTransition | theTransition.visited := false }
	end

	operation onStateAdded(theState : State) : Void is abstract
	operation onTransitionAdded(theTransition : Transition) : Void is abstract
}



class PrintStateMachinePruning inherits StateMachinePruning {
	method onStateAdded(state : State) : Void is do
		stdio.writeln("State: " + state.name)
	end
	
	method onTransitionAdded(transition : Transition) : Void is do
		stdio.writeln("Transition: " + transition.source.name + "->" + transition.target.name)
	end
}



class Test {
	operation main() : Void is do
		var sm : StateMachine init StateMachine.new
		var initState : InitState init InitState.new.initialise("init").asType(InitState)
		var s1 : StandardState init StandardState.new.initialise("s1").asType(StandardState)
		var s2 : StandardState init StandardState.new.initialise("s2").asType(StandardState)
		var terminal : TerminalState init TerminalState.new.initialise("end").asType(TerminalState)
		
		sm.initState := initState
		sm.states.add(initState)
		sm.states.add(s1)
		sm.states.add(s2)
		sm.states.add(terminal)
		sm.transitions.add(Transition.new.initialise(initState, s1))
		sm.transitions.add(Transition.new.initialise(s1, s2))
		sm.transitions.add(Transition.new.initialise(s2, s1))
		sm.transitions.add(Transition.new.initialise(s2, s2))
		sm.transitions.add(Transition.new.initialise(s2, terminal))
		
		var requiredStates : Bag<OutputState> init Bag<OutputState>.new
		requiredStates.add(initState)
		var pruning : PrintStateMachinePruning init PrintStateMachinePruning.new.initialise(sm, requiredStates, 0).asType(PrintStateMachinePruning)
		
		pruning.launch()
	end
}
