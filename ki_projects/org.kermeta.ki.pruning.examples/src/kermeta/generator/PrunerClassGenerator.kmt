/*
 * Creation : November 23, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package prunerGenerator;

require kermeta
require "PrunerGenerator.kmt"

using ecore
using kermeta::standard


class PrunerClassGenerator inherits Generator {
	reference classContainer : EClass[0..*]

	reference classRequired : EClass[0..*]

	reference classAdded : EClass[0..*]


	operation initialise(pruner : PrunerGenerator) : PrunerClassGenerator is do
		self.prunerGenerator := pruner
		result := self
	end


	method generateCode() : Void is do
		generatedCode := prunerGenerator.getPackageFromClasses(prunerGenerator.mainClasses)
		generatedCode := generatedCode + "require kermeta\nrequire \"" + prunerGenerator.modelURI + "\"\nrequire \"" +
						 prunerGenerator.prunerClass.name + "Aspect.kmt\"\n" +
   					     prunerGenerator.getRequiresFromClasses(prunerGenerator.mainClasses) + "\nusing kermeta::standard\n\n" +
						 prunerGenerator.getUsingsFromClasses(prunerGenerator.mainClasses)
		generatedCode := generatedCode + "abstract class " + prunerGenerator.prunerClass.name + " {\n"
		generatedCode := generatedCode + generateContainers() + "\n"

		if(not prunerGenerator.radius.isVoid) then
			generatedCode := generatedCode + "\tattribute radius : Integer\n\n"
		end

		generatedCode := generatedCode + generateRequiredAttributes() + generateAddedAttributes() + 
						 generateIntialiseOperation() + generateLaunchOperation() + generatePreparePruningOperation() +
						 "\n" + generateAddOperations + "}\n"
	end


	operation generatePreparePruningOperation() : String is do
		result := "\toperation preparePruning() : Void is do\n"

		var paths : Bag<String> init Bag<String>.new
		var path : String
		
		// Initialisation of the "visited" attribute to false.
		prunerGenerator.pruningData.requiredElements.each{elt |
			elt.origins.each{origin |
				origin.path.each{rel |
					if(classContainer.contains(rel.eContainingClass)) then
						if(rel.upperBound==1) then
							path := "\t\tif(not self." + rel.eContainingClass.getVarNameClassifier() + "." + rel.name + ".isVoid) then" + 
									"self." + rel.eContainingClass.getVarNameClassifier() + "." + rel.name + ".preparePruning() end\n"
						else
							var nameVar : String init rel.eType.asType(EClass).getVarNameClassifier()
							path := "\t\tself." + rel.eContainingClass.getVarNameClassifier() + "." + rel.name + 
									".each{" + nameVar + " | " + nameVar + ".preparePruning() }\n"
						end
						
						if(not paths.contains(path)) then
							paths.add(path)
							result := result + path
						end
					end
				}
			}
		
			// Generating of the calls that initialise the opposite relations.
			elt.srcRelations.each{source |
				if(source.createOpposite) then// If the opposite is created.
					elt.origins.each{origin |
						var rel : EReference init origin.path.first()
						
						if(classContainer.contains(rel.eContainingClass)) then
							if(rel.upperBound==1) then
								path := "\t\tif(not self." + rel.eContainingClass.getVarNameClassifier() + "." + rel.name + ".isVoid) then " + 
										"self." + rel.eContainingClass.getVarNameClassifier() + "." + rel.name + ".initialise" + source.relation.name + "() end\n"
							else
								var nameVar : String init rel.eType.asType(EClass).getVarNameClassifier()
								path := "\t\tself." + rel.eContainingClass.getVarNameClassifier() + "." + rel.name + 
										".each{" + nameVar + " | " + nameVar + ".initialise" + source.relation.name + "() }\n"
							end
							
							if(not paths.contains(path)) then
								paths.add(path)
								result := result + path
							end
						end
					}
				end
			}
		}

		result := result + "\tend\n"
	end


	operation generateAddOperations() : String is do
		result := ""

		classAdded.each{clazz |
			result := result + "\toperation on" + clazz.name + "Added(" + clazz.getVarNameClassifier() + " : " + clazz.name + ") : Void is abstract\n"
		}

		var addedOperationsName : Bag<String> init Bag<String>.new

		prunerGenerator.pruningData.requiredElements.each{elt |
			elt.srcRelations.each{rel |
				if(rel.relation.eType==rel.relation.eContainingClass and not addedOperationsName.contains(rel.relation.name)) then
					result := result + "\toperation on" + rel.relation.name + "Added(" + 
					rel.relation.eContainingClass.getVarNameClassifier() + "Src : " + rel.relation.eContainingClass.name + ", " +
					rel.relation.eContainingClass.getVarNameClassifier() + "Tar : " + rel.relation.eContainingClass.name + ") : Void is abstract\n"
				end
			}
		}
	end


	// Generates the "launch" operation.
	operation generateLaunchOperation() : String is do
		result := "\toperation launch() : Void is do\n\t\tpreparePruning()\n\n"
		
		// The type of the variable to generate
		var classVarLoop : Sequence<EClass> init prunerGenerator.radius.focusedClasses.collect{cl | cl.getUpperClass(classAdded)}
		
		// Creation of the variables used into the loop.
		classVarLoop.each{cl |
			result := result + "\t\tvar " + cl.getVarNameSet() + "  : Bag<" + cl.name + "> init Bag<" + cl.name + ">.new\n"
			result := result + "\t\tvar " + cl.getVarNameSet() + "2 : Bag<" + cl.name + "> init Bag<" + cl.name + ">.new\n"
		}

		// Creation of the variable that will count the radius level.
		if(not prunerGenerator.radius.isVoid) then
			result := result + "\t\tvar currentRadius : Integer init 0\n\n" 
		end

		// Initialisation of the variables using the given required objects.
		classRequired.each{cl |
			var clazz : EClass init classVarLoop.detect{c | c==cl or c.isSuperTypeOf(cl) }
			if(clazz.isVoid) then clazz := cl end
			var clazz2 : EClass init prunerGenerator.radius.focusedClasses.detect{cl | cl==clazz or cl.isSuperTypeOf(clazz) or clazz.isSuperTypeOf(cl) }

			result := result + "\t\t" + cl.getRequiredAttributeName() + ".each{" + cl.getVarNameClassifier() + " | "

			if(clazz2.isVoid) then
				result := result + cl.getVarNameClassifier() + ".visit(self"
				classVarLoop.each{cl | result := result + ", " + cl.getVarNameSet() }
				result := result + ") }\n"
			else
				result := result + clazz.getVarNameSet() + ".add(" + cl.getVarNameClassifier() + ") }\n"
			end
		}

		// Creation of the loop
		result := result + "\n\t\tfrom true\n\t\tuntil ("

		// Creation of the loop condition
		var i : Integer init 0
		classVarLoop.each{clazz | 
			if(i>0) then result := result + " and " end
			result := result + clazz.getVarNameSet() + ".empty()"
			i := i + 1
		}

		result := result + ")"

		if(not prunerGenerator.radius.isVoid) then
			result := result + " or (currentRadius>radius and radius!=0)"
		end

		// Body of the loop
		result := result + "\n\t\tloop\n"

		classVarLoop.each{clazz |
			var name  : String init clazz.getVarNameClassifier()
			result := result + "\t\t\t" + clazz.getVarNameSet() + ".each{" + name + " |\n\t\t\t\tif(not " +
					  name + ".visited) then\n\t\t\t\t\t" + name + ".visit(self" 
			// Adding the parameters to method "visit". These parameters are in fact all the classes of "varClasses"
			classVarLoop.each{clazz2 | result := result + ", " + clazz2.getVarNameSet() + "2" }
			result := result + ")\n\t\t\t\tend\n\t\t\t}\n"
		}

		result := result + "\n"

		classVarLoop.each{clazz |
			var name  : String init clazz.getVarNameSet()
			result := result + "\t\t\t" + name + ".clear()\n"
			result := result + "\t\t\t" + name + "2.each{" + clazz.getVarNameClassifier() + " | " + name + ".add(" + clazz.getVarNameClassifier() + ") }\n"
			result := result + "\t\t\t" + name + "2.clear()\n"
		}

		if(not prunerGenerator.radius.isVoid) then
			result := result + "\t\t\tcurrentRadius := currentRadius + 1\n"
		end

		result := result + "\t\tend\n\n"

		// Relations are now added using the added classes.
		classVarLoop.each{clazz |
			result := result + "\t\t" + clazz.getAddedAttributeName() + ".each{" + clazz.getVarNameClassifier() + " | " + clazz.getVarNameClassifier() +
						"." + clazz.addOperation.name + "(self) }\n"
		}

		result := result + "\tend\n\n"
	end



	operation generateIntialiseOperation() : String is do
		var i : Integer init 0
		result := "\toperation initialise("

		classContainer.each{clazz |
			if(i>0) then result := result + ", " end
			result := result + clazz.getVarNameClassifier() + " : " + clazz.name
			i := i + 1
		}

		classRequired.each{clazz |
			if(i>0) then result := result + ", " end
			result := result + clazz.getRequiredAttributeName() + " : bag " + clazz.name + "[0..*]"
			i := i + 1
		}

		if(not prunerGenerator.radius.isVoid) then
			result := result + ", radius : Integer"
		end

		result := result + ") : " + prunerGenerator.prunerClass.name + " is do\n"
		result := result + "\t\tresult := self\n"

		classAdded.each{clazz |
			result := result + "\t\tself." + clazz.getAddedAttributeName() + " := Bag<" + clazz.name + ">.new\n"
		}

		classContainer.each{clazz |
			result := result + "\t\tself." + clazz.getVarNameClassifier() + " := " + clazz.getVarNameClassifier() + "\n"
		}

		if(not prunerGenerator.radius.isVoid) then
			result := result + "\t\tself.radius := radius\n"
		end

		classRequired.each{clazz |
			result := result + "\t\tself." + clazz.getRequiredAttributeName() + ".addAll(" + clazz.getRequiredAttributeName() + ")\n"
		}

		result := result + "\tend\n\n"
	end



	operation generateAddedAttributes() : String is do
		result := ""

		prunerGenerator.pruningData.requiredElements.each{req |
			req.origins.each{origin |
				var rel : EReference init origin.path.last()
				var clazz : EClass

				if(rel.eType.isKindOf(EClass)) then clazz := rel.eType.asType(EClass)
				else clazz := void end

				if(not clazz.isVoid and not classAdded.contains(clazz)) then
					result := result + "\treference " + clazz.getAddedAttributeName() + " : Bag<" + clazz.name + ">\n\n"
					classAdded.add(clazz)
				end
			}
		}
	end


	operation generateRequiredAttributes() : String is do
		result := ""

		var required : Sequence<EReference> init Sequence<EReference>.new

		// Gathering all the source relations.
		prunerGenerator.pruningData.requiredElements.each{req |
			req.srcRelations.each{rel | required.add(rel.relation) }
		}
		// Selecting the relations: required attributes are class containers of the source relations, but if two classes A and B are sources and
		// A inherits from B, then only B will be keep.
		required := required.select{rel | not required.exists{rel2 | rel.eContainingClass.isSuperTypeOf(rel2.eContainingClass) } }
		required.each{rel |
			if(not classRequired.contains(rel.eContainingClass)) then
				result := result + "\treference " + rel.eContainingClass.getRequiredAttributeName() +
							" : " + rel.eContainingClass.name + "[0..*]\n\n"
				classRequired.add(rel.eContainingClass)
			end
		}
	end


	operation generateContainers() : String is do
		result := ""

		prunerGenerator.pruningData.requiredElements.each{req |
			req.origins.each{origin |
				var ref : EReference init origin.path.first()

				if(not classContainer.contains(ref.eContainingClass)) then
					result := result + "\treference " +  ref.eContainingClass.getVarNameClassifier() + " : " + ref.eContainingClass.name + "\n"
					classContainer.add(ref.eContainingClass)
				end
			}
		}
	end
}
