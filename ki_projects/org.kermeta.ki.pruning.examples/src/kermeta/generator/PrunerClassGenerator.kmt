/*
 * Creation : November 23, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package prunerGenerator;

require kermeta
require "PrunerGenerator.kmt"

using ecore
using kermeta::standard


class PrunerClassGenerator inherits Generator {
	reference classContainer : EClass[0..*]
	
	reference classRequired : EClass[0..*]

	reference classAdded : EClass[0..*]


	operation initialise(pruner : PrunerGenerator) : PrunerClassGenerator is do
		self.prunerGenerator := pruner
		result := self
	end


	method generateCode() : Void is do
		generatedCode := prunerGenerator.getPackageFromClasses(prunerGenerator.mainClasses)
		generatedCode := generatedCode + "require kermeta\nrequire \"" + prunerGenerator.modelURI + "\"\nrequire \"" +
						 prunerGenerator.prunerClass.name + "Aspect.kmt\"\n\nusing kermeta::standard\n\n"
		generatedCode := generatedCode + "abstract class " + prunerGenerator.prunerClass.name + " {\n"
		generatedCode := generatedCode + generateContainers() + "\n"
		
		if(not prunerGenerator.radius.isVoid) then
			generatedCode := generatedCode + "\tattribute radius : Integer\n\n"
		end
		
		generatedCode := generatedCode + generateRequiredAttributes() + generateAddedAttributes() + 
						 generateIntialiseOperation() + generateLaunchOperation() + generatePreparePruningOperation() +
						 "\n" + generateAddOperations + "}\n"
	end


	operation generatePreparePruningOperation() : String is do
		result := "\toperation preparePruning() : Void is do\n"

		// Initialisation of the "visited" attribute to false.
		prunerGenerator.pruningData.requiredElements.each{elt |
			elt.origins.each{origin |
				// Adding the name of the root element of the metamodel.
				if(origin.path.size()>0) then
					result := result + "\t\t" + origin.path.first().eContainingClass.getVarNameClassifier()
				end

				// The brackets variable will be used to close the "each" closures used to explore the metamodel
				// in order to initialise the "visited" attribute.
				var brackets : String init ""

				// For each relations of the path, a "each" closure is created to navigate into the metamodel.
				origin.path.each{ref |
					var name : String init ref.eType.asType(EClass).getVarNameClassifier()
					result := result + "." + ref.name + ".each{" + name + " | " + name
					brackets := brackets + " }"
				}

				// setting attribute "visited" and closing the closures.
				result := result + ".visited := false" + brackets + "\n"
			}

			// Generating of the calls that initialise the opposite relations.
			elt.srcRelations.each{source |
				if(source.createOpposite) then// If the opposite is created.
					elt.origins.each{origin |
						var rel : EReference init origin.path.last()
						var clazz : EClass init rel.eType.asType(EClass)
						
						// If the current origin matches the source.
						if(clazz==source.relation.eContainingClass or
						   clazz.isSuperTypeOf(source.relation.eContainingClass)) then
						  var name : String init clazz.getVarNameClassifier()
						   
						   result := result + "\t\t" + rel.eContainingClass.getVarNameClassifier() + "." + rel.name + 
							".each{" + name + " | " + name +".initialise" + source.relation.name + "()}\n"
						end
					}
				end
			}
		}
		
		result := result + "\tend\n"
	end


	operation generateAddOperations() : String is do
		result := ""

		classAdded.each{clazz |
			result := result + "\toperation on" + clazz.name + "Added(" + clazz.getVarNameClassifier() + " : " + clazz.name + ") : Void is abstract\n"
		}

		var addedOperationsName : Bag<String> init Bag<String>.new

		prunerGenerator.pruningData.requiredElements.each{elt |
			elt.srcRelations.each{rel |
				if(rel.relation.eType==rel.relation.eContainingClass and not addedOperationsName.contains(rel.relation.name)) then
					result := result + "\toperation on" + rel.relation.name + "Added(" + 
					rel.relation.eContainingClass.getVarNameClassifier() + "Src : " + rel.relation.eContainingClass.name + ", " +
					rel.relation.eContainingClass.getVarNameClassifier() + "Tar : " + rel.relation.eContainingClass.name + ") : Void is abstract\n"
				end
			}
		}
	end


	operation generateLaunchOperation() : String is do
		result := "\toperation launch() : Void is do\n\t\tpreparePruning()\n\n"

		prunerGenerator.radius.focusedClasses.each{clazz |
			result := result + "\t\tvar " + clazz.getVarNameSet() + "  : Bag<" + clazz.name + "> init Bag<" + clazz.name + ">.new\n"
			result := result + "\t\tvar " + clazz.getVarNameSet() + "2 : Bag<" + clazz.name + "> init Bag<" + clazz.name + ">.new\n"
		}

		// Creation of the variable that will count the radius level.
		if(not prunerGenerator.radius.isVoid) then
			result := result + "\t\tvar currentRadius : Integer init 0\n\n" 
		end

		// Initialisation of the variables using the given required objects.
		classRequired.each{clazz |
			var clazz2 : EClass init prunerGenerator.radius.focusedClasses.detect{cl | cl==clazz or cl.isSuperTypeOf(clazz) }

			result := result + "\t\t" + clazz.getRequiredAttributeName() + ".each{" + clazz.getVarNameClassifier() + " | "

			if(clazz2.isVoid) then
				result := result + clazz.getVarNameClassifier() + ".visit(self"
				prunerGenerator.radius.focusedClasses.each{cl | result := result + ", " + cl.getVarNameSet() }
				result := result + ") }\n"
			else
				result := result + clazz2.getVarNameSet() + ".add(" + clazz.getVarNameClassifier() + ") }\n"
			end
		}

		// Creation of the loop
		result := result + "\n\t\tfrom true\n\t\tuntil ("

		// Creation of the loop condition
		var i : Integer init 0
		prunerGenerator.radius.focusedClasses.each{clazz | 
			if(i>0) then result := result + " and " end
			result := result + clazz.getVarNameSet() + ".empty()"
			i := i + 1
		}

		result := result + ")"

		if(not prunerGenerator.radius.isVoid) then
			result := result + " or currentRadius>radius"
		end

		// Body of the loop
		result := result + "\n\t\tloop\n"

		prunerGenerator.radius.focusedClasses.each{clazz |
			var name  : String init clazz.getVarNameClassifier()
			result := result + "\t\t\t" + clazz.getVarNameSet() + ".each{" + name + " |\n\t\t\t\tif(not " +
					  name + ".visited) then\n\t\t\t\t\t" + name + ".visit(self" 
			// Adding the parameters to method "visit". These parameters are in fact all the classes of "varClasses"
			prunerGenerator.radius.focusedClasses.each{clazz2 | result := result + ", " + clazz2.getVarNameSet() + "2" }
			result := result + ")\n\t\t\t\tend\n\t\t\t}\n"
		}

		result := result + "\n"

		prunerGenerator.radius.focusedClasses.each{clazz |
			var name  : String init clazz.getVarNameSet()
			result := result + "\t\t\t" + name + ".clear()\n"
			result := result + "\t\t\t" + name + "2.each{" + clazz.getVarNameClassifier() + " | " + name + ".add(" + clazz.getVarNameClassifier() + ") }\n"
			result := result + "\t\t\t" + name + "2.clear()\n"
		}

		if(not prunerGenerator.radius.isVoid) then
			result := result + "\t\t\tcurrentRadius := currentRadius + 1\n"
		end

		result := result + "\t\tend\n\n"

		prunerGenerator.radius.focusedClasses.each{clazz |
			if(not clazz.main.isVoid and clazz.main) then
				result := result + "\t\t" + clazz.getAddedAttributeName() + ".each{" + clazz.getVarNameClassifier() + " | " + clazz.getVarNameClassifier() +
							"." + clazz.addOperation.name + "(self) }\n"
			end
		}

		result := result + "\tend\n\n"
	end



	operation generateIntialiseOperation() : String is do
		var i : Integer init 0
		result := "\toperation initialise("

		classContainer.each{clazz |
			if(i>0) then result := result + ", " end
			result := result + clazz.getVarNameClassifier() + " : " + clazz.name
			i := i + 1
		}

		classRequired.each{clazz |
			if(i>0) then result := result + ", " end
			result := result + clazz.getRequiredAttributeName() + " : bag " + clazz.name + "[0..*]"
			i := i + 1
		}

		if(not prunerGenerator.radius.isVoid) then
			result := result + ", radius : Integer"
		end

		result := result + ") : " + prunerGenerator.prunerClass.name + " is do\n"
		result := result + "\t\tresult := self\n"

		classAdded.each{clazz |
			result := result + "\t\tself." + clazz.getAddedAttributeName() + " := Bag<" + clazz.name + ">.new\n"
		}

		classContainer.each{clazz |
			result := result + "\t\tself." + clazz.getVarNameClassifier() + " := " + clazz.getVarNameClassifier() + "\n"
		}

		if(not prunerGenerator.radius.isVoid) then
			result := result + "\t\tself.radius := radius\n"
		end

		classRequired.each{clazz |
			result := result + "\t\tself." + clazz.getRequiredAttributeName() + ".addAll(" + clazz.getRequiredAttributeName() + ")\n"
		}

		result := result + "\tend\n\n"
	end



	operation generateAddedAttributes() : String is do
		result := ""

		prunerGenerator.pruningData.requiredElements.each{req |
			req.origins.each{origin |
				var rel : EReference init origin.path.last()
				var clazz : EClass

				if(rel.eType.isKindOf(EClass)) then clazz := rel.eType.asType(EClass)
				else clazz := void end

				if(not clazz.isVoid and not classAdded.contains(clazz)) then
					result := result + "\treference " + clazz.getAddedAttributeName() + " : Bag<" + clazz.name + ">\n\n"
					classAdded.add(clazz)
				end
			}
		}
	end


	operation generateRequiredAttributes() : String is do
		result := ""

		prunerGenerator.pruningData.requiredElements.each{req |
			req.srcRelations.each{rel |
				if(not classRequired.contains(rel.relation.eContainingClass)) then
					result := result + "\treference " + rel.relation.eContainingClass.getRequiredAttributeName() +
								" : " + rel.relation.eContainingClass.name + "[0..*]\n\n"
					classRequired.add(rel.relation.eContainingClass)
				end
			}
		}
	end


	operation generateContainers() : String is do
		result := ""

		prunerGenerator.pruningData.requiredElements.each{req |
			req.origins.each{origin |
				var ref : EReference init origin.path.first()

				if(not classContainer.contains(ref.eContainingClass)) then
					result := result + "\treference " +  ref.eContainingClass.getVarNameClassifier() + " : " + ref.eContainingClass.name + "\n"
					classContainer.add(ref.eContainingClass)
				end
			}
		}
	end
}
