/*
 * Creation : November 23, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package prunerGenerator;

require kermeta
require "PrunerGenerator.kmt"

using ecore
using kermeta::standard


class ModelAspectGenerator inherits Generator {
	operation initialise(pruner : PrunerGenerator) : ModelAspectGenerator is do
		self.prunerGenerator := pruner
		result := self
	end


	method generateCode() : Void is do
		var mainPackageName : String init prunerGenerator.mainClasses.last().ePackage.getQualifiedName("::")
		// "packages" contains the packages correspondeing to the all the packages used by the pruner.
		// These packages will be used to add "using" and "require" elements into files.
		var packages : Bag<String> init Bag<String>.new
		
		// Getting the different packages of the pruner.
		prunerGenerator.mainClasses.each{cl |
			var packageName : String init cl.ePackage.getQualifiedName("::")
			if(not packages.contains(packageName) and mainPackageName!=packageName) then
				packages.add(packageName)
			end
		}

		var codeUsing : String init ""
		// Adding the header of the main aspect class.
		generatedCode := prunerGenerator.getPackageFromClasses(prunerGenerator.mainClasses) + 
						"require kermeta\nrequire \"" + prunerGenerator.modelURI + "\"\nrequire \"" + 
						prunerGenerator.prunerClass.name + ".kmt\"\n"
		packages.each{pkg | 
			var subPkgs : Sequence<String> init pkg.split("::")
			generatedCode := generatedCode + "require \"" + subPkgs.last() + "PruningAspect.kmt\"\n"
			// Adding the "using" elements that refers to the other packages.
			codeUsing := codeUsing + "using " + pkg + "\n"
		}

		generatedCode := generatedCode + codeUsing + "using kermeta::standard\n\n"
		
		// Creation of ECore operations linked to the class.						
		prunerGenerator.mainClasses.each{cl |
			cl.createVisitOperation(prunerGenerator)
			cl.createAddOperation(prunerGenerator)
		}
		
		packages.add(mainPackageName)
		
		prunerGenerator.mainClasses.each{cl |
			// Caching the code of method "prepare"
			cl.createPrepareOperation(prunerGenerator)
			var packageName : String init cl.ePackage.getQualifiedName("::")
			// If it is the same package, we write the code in the same file.
			if(packageName==mainPackageName) then
				generatedCode := generatedCode + generateClassAspect(cl)
			else
				packages.add(packageName)
				// Otherwise, the code of the aspect must be write into another file dedicated to its package.
				generateExternAspect(cl, mainPackageName, packages)
			end
		}
	end


	operation generateExternAspect(clazz : EClass, mainPackageName : String, packages : Bag<String>) : Void is do
		var namePackage : String init clazz.ePackage.getQualifiedName("::")
		var codeAspect : String
		
		// If no code has been already created for this package.
		if(prunerGenerator.requiredAspectFiles.getValue(namePackage).isVoid) then
			var codeUsing : String init ""
			// Adding headers of the file.
			codeAspect := "package " + namePackage + ";\n" + "require kermeta\n" + 
							"require \"" + prunerGenerator.prunerClass.name + "Aspect.kmt\"\n"
	
			// Adding the "require" elements that refer to the other created aspect files.
	 		packages.each{pkg |
	 			if(pkg!=namePackage and pkg!=mainPackageName) then
					var subPkgs : Sequence<String> init pkg.split("::")
					codeAspect := codeAspect + "require \"" + subPkgs.last() + "PruningAspect.kmt\"\n"
					// Adding the "using" elements that refers to the other packages.
					codeUsing := codeUsing + "using " + pkg + "\n"
				end
			}

			// Adding the "using" elements.
			codeAspect := codeAspect + "using kermeta::standard\nusing " + mainPackageName + "\n" + codeUsing + "\n"
		else
			// If the file already exists, the code is extracted and removed from the hashmap.
			codeAspect := prunerGenerator.requiredAspectFiles.getValue(namePackage)
			prunerGenerator.requiredAspectFiles.remove(namePackage)
		end
		
		// Adding the class code of the apsect.
		codeAspect := codeAspect + generateClassAspect(clazz)
		// Adding the new code to the hashmap with as key the qualified name of the package.
		prunerGenerator.requiredAspectFiles.put(namePackage, codeAspect)
	end


	// Generation of the aspect class.
	operation generateClassAspect(clazz : EClass) : String is do
		var isChild : Boolean init prunerGenerator.mainClasses.exists{cl |
			if(cl.isSuperTypeOf(clazz)) then
				cl.main := true
				true
			else
				false
			end
		}

		// Creating the headers of the aspect.		
		result := "aspect class " + clazz.name + " {\n"

		if(not isChild) then
			result := result + "\tattribute visited : Boolean\n\n"
		end

		// Generating the opposite attributes or initialisation methods.
		prunerGenerator.pruningData.requiredElements.each{elt |
			elt.srcRelations.each{source |
				if(source.createOpposite) then
					var cl : EClass init source.relation.eContainingClass
					var etype : EClass init source.relation.eType.asType(EClass)

					// Attributes corresponding to the opposites to create are now added to the aspect class.
					if(cl==clazz or cl.isSuperTypeOf(clazz)) then
						result := result + "\treference " + source.relation.name +
								  " : " + source.relation.eType.asType(EClass).name + "[" + source.relation.lowerBound.toString + ".."
						if(source.relation.upperBound==-1) then
							result := result + "*"
						else
							result := result + source.relation.upperBound.toString
						end

						result := result + "]\n\n"
					end

					// Initialisation methods must be added to the aspect clazz that contains the attributes which opposites are created.
					if(etype==clazz or etype.isSuperTypeOf(clazz)) then
						result := result + 	generateInitialiseOppositeOperation(source.relation)
					end
				end
			}
		}

		result := result + generateVisitOperation(clazz, isChild)
		if(prunerGenerator.radius.focusedClasses.exists{cl | cl==clazz or clazz.isSuperTypeOf(cl) or cl.isSuperTypeOf(clazz) }) then
			result := result + "\n" + generateAddRelations(clazz, isChild)
		end
		result := result + "\n" + clazz.prepareOperationCode + "}\n"
	end


	// Generates the operation that initialises a created opposite.
	operation generateInitialiseOppositeOperation(relation : EReference) : String is do
		var name : String init relation.eContainingClass.getVarNameClassifier()
		result := "\toperation initialise" + relation.name + "() : Void is do\n\t\tself." +
					relation.name.split("Opposite").first() + ".each{" + name + " | " + name + "." +  relation.name + ".add(self) }\n\tend\n\n"
	end


	operation generateAddRelations(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		result := "\t" + opDeclaration + " " + clazz.addOperation.getDeclarationHeader() + " : Void is do\n" +
				  generateAddBodyRelations(clazz.sourceRelations) + generateAddBodyRelations(clazz.targetRelations) + "\tend\n"
	end


	// This operation adds code that explores objects of the model that must be added.
	operation generateAddBodyRelations(refs : EReference[0..*]) : String is do
		result := ""
		
		// Exploring the relations.
		refs.each{rel |
			var clazzRel : EClass init rel.eType.asType(EClass)
			var varName : String init clazzRel.getVarNameClassifier()

			// For recursive relations.
			if(rel.eType==rel.eContainingClass) then
				result := result + "\t\tself." + rel.name + ".each{" + varName + " |\n\t\t\tif(" + varName + 
						  ".visited) then\n\t\t\t\t" + prunerGenerator.getPrunerVarName() + ".on" + rel.name + 
						  "Added(self, " + rel.eContainingClass.getVarNameClassifier() + ")\n\t\t\tend\n\t\t}\n"
			else
			// For not recursive relations.
				result := result + "\t\tself." + rel.name + ".each{" + varName + " |\n\t\t\tif(not " + varName + ".visited"
				result := result + generateCodeExists(clazzRel.targetRelations, varName) + generateCodeExists(clazzRel.sourceRelations, varName)
				// Relations of super types of the current clazz must be tested too.
				prunerGenerator.mainClasses.each{cl |
					if(cl.isSuperTypeOf(clazzRel)) then
						result := result + generateCodeExists(cl.targetRelations, varName) + generateCodeExists(cl.sourceRelations, varName)
					end
				}
				result := result + ") then\n\t\t\t\t" + varName + ".visited := true\n\t\t\t\t" + prunerGenerator.getPrunerVarName() +
							".on" + clazzRel.name + "Added(" + varName + ")\n\t\t\t\t" + prunerGenerator.getPrunerVarName() +
							".added" + clazzRel.name + "s.add(" + varName + ")\n\t\t\tend\n\t\t}\n"
			end
		}		
	end
	
	
	operation generateCodeExists(references : EReference[0..*], varName : String) : String is do
		result := ""
		references.each{ref |
			if(ref.upperBound==1) then
				if(ref.lowerBound==0) then
					result := result + " and (" + varName + "." + ref.name + ".isVoid or " + varName + "." + ref.name + ".visited)"
				else
					result := result + " and " + varName + "." + ref.name + ".visited"
				end
			else //card *
				var nameRel : String init ref.eType.asType(EClass).getVarNameClassifier()
				result := result + " and not " + varName + "." + ref.name + ".exists{" + nameRel + " | not " + nameRel + ".visited }"
			end
		}
	end


	operation generateVisitOperationFocusedClass(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		// Definition of the type of the operation.
		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		// Adding the declaration of method visit
		result := "\t" + opDeclaration + " " + clazz.visitOperation.getDeclarationHeader() + " : Void is do\n" 

		// If the current clazz is the sub class of a class that defines method visit, the super call must be performed.
		if(isChild) then 
			result := result + "\t\t" + clazz.visitOperation.getSuperCall() + "\n"
		else
			// Adding the body of method visit
			var prunerName : String init prunerGenerator.getPrunerVarName()
			// Setting the class as visited.
			result := result + "\t\tself.visited := true\n"
			// Adding a call to the method that notify the pruner that an object of a given type has been added.
			result := result + "\t\t" + prunerName + "." + clazz.getOnSomethingAddedMethodName() + "(self)\n"
			// Adding the added object to its container in the pruner.
			result := result + "\t\t" + prunerName + "." + clazz.getAddedSomethingAttributeName() + ".add(self)\n"
		end

		result := result + generateVisitBodyRelationsExploration(clazz, clazz.sourceRelations) +
					generateVisitBodyRelationsExploration(clazz, clazz.targetRelations) + "\tend\n"
	end



	operation generateVisitBodyRelationsExploration(currentClazz : EClass, refs : EReference[0..*]) : String is do
		result := ""
		
		refs.each{rel |
			var clazzCalled : EClass init rel.eType.asType(EClass)
			var varName : String init clazzCalled.getVarNameClassifier()
			var cl : EClass init getVariableTypeFromOperationParameters(currentClazz.visitOperation, clazzCalled)

			if(not cl.isVoid) then
				clazzCalled := cl
			end

			if(rel.upperBound==-1 or rel.upperBound>1) then
				result := result + "\t\tself." + rel.name + ".each{" + varName + " | "

				if(rel.eType==rel.eContainingClass) then
					result := result + clazzCalled.getVarNameSet() + ".add(" + varName + ") }\n" 
				else
					result := result + varName + "." + clazzCalled.visitOperation.getCallHeader() + " }\n"
				end
			else
				result := result + "if(not self." + varName + ".isVoid()) then self." + varName + "."
				
				if(rel.eType==rel.eContainingClass) then
					result := result + clazzCalled.addOperation.getCallHeader() + " end\n"
				else
					result := result + clazzCalled.visitOperation.getCallHeader() + " end\n"
				end
			end
		}
	end



	operation generateVisitOperationNotFocusedClass(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		// Definition of the type of the operation.
		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		// Adding the declaration of method visit
		result := "\t" + opDeclaration + " " + clazz.visitOperation.getDeclarationHeader() + " : Void is do\n" 

		// If the current clazz is the sub class of a class that defines method visit, the super call must be performed.
		if(isChild) then 
			result := result + "\t\t" + clazz.visitOperation.getSuperCall() + "\n"
		end

		result := result + generateVisitNotFocusedBody(clazz, clazz.targetRelations) + generateVisitNotFocusedBody(clazz, clazz.sourceRelations) + "\tend\n"
	end


	// returns the type of a parameter of the given operation which corresponds to the given class or is a super class of the given class.
	// In fact, only generic types of parameters are checked and not the type of the parameter.
	operation getVariableTypeFromOperationParameters(op : EOperation, clazz : EClass) : EClass is do
		var param : EParameter init op.eParameters.detect{param |
			(not param.eType.genericType.isVoid).andThen{b |
				param.eType.genericType==clazz or
				(param.eType.genericType.isKindOf(EClass) and param.eType.genericType.asType(EClass).isSuperTypeOf(clazz)) }
		}

		if(param.isVoid) then
			result := void
		else
			result := param.eType.genericType.asType(EClass)
		end
	end


	operation generateVisitNotFocusedBody(currentClazz : EClass, refs : EReference[0..*]) : String is do
		result := ""

		refs.each{rel |
			var clazzCalled : EClass init rel.eType.asType(EClass)
			var varName : String init clazzCalled.getVarNameClassifier()
			var cl : EClass init getVariableTypeFromOperationParameters(currentClazz.visitOperation, clazzCalled)
			if(not cl.isVoid) then
				clazzCalled := cl
			end

			if(rel.upperBound==-1 or rel.upperBound>1) then
				result := result + "\t\tself." + rel.name + ".each{" + varName + " | if(not " + varName + ".visited) then " +
						  clazzCalled.getVarNameSet() + ".add(" + varName + ") end }\n"
			else
				result := result + "\t\tif(not self." + rel.name + ".visited) then " + clazzCalled.getVarNameSet() + ".add(self." + rel.name + ") end\n"
			end
		}
	end


	operation generateVisitOperation(clazz : EClass, isChild : Boolean) : String is do
		if(prunerGenerator.radius.focusedClasses.exists{cl | cl==clazz or cl.isSuperTypeOf(clazz) or clazz.isSuperTypeOf(cl) } ) then
			result := generateVisitOperationFocusedClass(clazz, isChild)
		else
			result := generateVisitOperationNotFocusedClass(clazz, isChild)
		end
	end
}
