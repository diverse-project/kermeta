/*
 * Creation : November 23, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package prunerGenerator;

require kermeta
require "PrunerGenerator.kmt"

using ecore
using kermeta::standard


class ModelAspectGenerator inherits Generator {
	operation initialise(pruner : PrunerGenerator) : ModelAspectGenerator is do
		self.prunerGenerator := pruner
		result := self
	end


	method generateCode() : Void is do
		generatedCode := prunerGenerator.getPackageFromClasses(prunerGenerator.mainClasses) + 
						"require kermeta\nrequire \"" + prunerGenerator.modelURI + "\"\nrequire \"" + 
						prunerGenerator.prunerClass.name + ".kmt\"\n\nusing kermeta::standard\n\n"
		prunerGenerator.mainClasses.each{cl |
			// Creation of ECore operations linked to the class.
			cl.createVisitOperation(prunerGenerator)
			cl.createAddOperation(prunerGenerator)
		}
		prunerGenerator.mainClasses.each{cl | generatedCode := generatedCode + generateClassAspect(cl) }
	end




	operation generateClassAspect(clazz : EClass) : String is do
		var isChild : Boolean init prunerGenerator.mainClasses.exists{cl |
			if(cl.isSuperTypeOf(clazz)) then
				cl.main := true
				true
			else
				false
			end
		}

		result := "aspect class " + clazz.name + " {\n"

		if(not isChild) then
			result := result + "\tattribute visited : Boolean\n\n" 
		end

		prunerGenerator.pruningData.requiredElements.each{elt |
			elt.srcRelations.each{source |
				if(source.createOpposite) then
					var cl : EClass init source.relation.eType.asType(EClass)
					
					if(cl==clazz or cl.isSuperTypeOf(clazz)) then
						result := result + "\treference " + source.relation.getOppositeReferenceName() +
								  " : " + cl.name + "[" + source.relation.lowerBound.toString + ".."
						if(source.relation.upperBound==-1) then
							result := result + "*"
						else
							result := result + source.relation.upperBound.toString
						end
						
						result := result + "]\n\n" + generateInitialiseOppositeOperation(source.relation)
					end
					
					// We change the pruning data to use of the opposite.
					var ref : EReference init EReference.new
					ref.name := source.relation.getOppositeReferenceName()
					ref.eType:= source.relation.eContainingClass
					source.relation.eContainingClass.eStructuralFeatures.add(ref)
					ref.lowerBound := source.relation.lowerBound
					ref.upperBound := source.relation.upperBound
					ref.containment := false
					clazz.sourceRelations.remove(source.relation)
					clazz.sourceRelations.add(ref)
					source.relation := ref
				end
			}
		}

		result := result + generateVisitOperation(clazz, isChild)
		if(prunerGenerator.radius.focusedClasses.exists{cl | cl==clazz or cl.isSuperTypeOf(clazz)}) then
			result := result + "\n" + generateAddRelations(clazz, isChild)
		end
		result := result + "}\n"
	end


	operation generateInitialiseOppositeOperation(relation : EReference) : String is do
		var name : String init relation.eType.asType(EClass).getVarNameClassifier()
		result := "\toperation initialise" + relation.getOppositeReferenceName() + "() : Void is do\n\t\tself." +
					relation.name + ".each{" + name + " | " + name + "." +  relation.getOppositeReferenceName() +
					".add(self) }\n\tend\n\n"
	end


	operation generateAddRelations(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		result := "\t" + opDeclaration + " " + clazz.addOperation.getDeclarationHeader() + " : Void is do\n"

		clazz.sourceRelations.each{rel |
			var clazzRel : EClass init rel.eType.asType(EClass)
			var varName : String init clazzRel.getVarNameClassifier()

			if(rel.eType==rel.eContainingClass) then
				result := result + "\t\tself." + rel.name + ".each{" + varName + " |\n\t\t\tif(" + varName + 
						  ".visited) then\n\t\t\t\t" + prunerGenerator.getPrunerVarName() + ".on" + rel.name + 
						  "Added(self, " + rel.eContainingClass.getVarNameClassifier() + ")\n\t\t\tend\n\t\t}\n"
			else
				result := result + "\t\tself." + rel.name + ".each{" + varName + " |\n\t\t\tif(not " + varName + ".visited"
				
				clazzRel.targetRelations.each{tar |
					result := result + " and " + varName + "." + tar.name + ".visited"
				}
				
				result := result + ") then\n\t\t\t\t" + varName + ".visited := true\n\t\t\t\t" + prunerGenerator.getPrunerVarName() +
							".on" + clazzRel.name + "Added(" + varName + ")\n\t\t\t\t" + prunerGenerator.getPrunerVarName() +
							".added" + clazzRel.name + "s.add(" + varName + ")\n\t\t\tend\n\t\t}\n"
			end
		}

		// This code must be generated only when there exists at least one target relation which type is different from its container.
		if(clazz.targetRelations.exists{rel | rel.eType!=rel.eContainingClass }) then
			result := result + "\t\tif(not self.visited) then\n"
			
			clazz.targetRelations.each{rel |
				if(rel.eType!=rel.eContainingClass) then
					var clazzRel : EClass init rel.eType.asType(EClass)
					var varName : String init clazzRel.getVarNameSet()
					
					result := result + "\t\t\tif(not self." + rel.name + ".visited) then " + varName + ".add(self." + rel.name + ") end\n"
				end
			}

			result := result + "\t\tend\n"
		end

		result := result + "\tend\n"
	end



	operation generateVisitOperationFocusedClass(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		// Definition of the type of the operation.
		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		// Adding the declaration of method visit
		result := "\t" + opDeclaration + " " + clazz.visitOperation.getDeclarationHeader() + " : Void is do\n" 

		// If the current clazz is the sub class of a class that defines method visit, the super call must be performed.
		if(isChild) then 
			result := result + "\t\t" + clazz.visitOperation.getSuperCall() + "\n"
		else
			// Adding the body of method visit
			var prunerName : String init prunerGenerator.getPrunerVarName()
			// Setting the class as visited.
			result := result + "\t\tself.visited := true\n"
			// Adding a call to the method that notify the pruner that an object of a given type has been added.
			result := result + "\t\t" + prunerName + "." + clazz.getOnSomethingAddedMethodName() + "(self)\n"
			// Adding the added object to its container in the pruner.
			result := result + "\t\t" + prunerName + "." + clazz.getAddedSomethingAttributeName() + ".add(self)\n"
		end

		clazz.sourceRelations.each{rel |
			var clazzCalled : EClass init rel.eType.asType(EClass)
			var varName : String init clazzCalled.getVarNameClassifier()

			if(rel.upperBound==-1 or rel.upperBound>1) then
				result := result + "\t\tself." + rel.name + ".each{" + varName + " | "

				if(rel.eType==rel.eContainingClass) then
					result := result + clazzCalled.getVarNameSet() + ".add(" + varName + ") }\n" 
				else
					result := result + varName + "." + clazzCalled.visitOperation.getCallHeader() + " }\n"
				end
			else
				result := result + "if(not self." + varName + ".isVoid()) then self." + varName + "."
				
				if(rel.eType==rel.eContainingClass) then
					result := result + clazzCalled.addOperation.getCallHeader() + " end\n"
				else
					result := result + clazzCalled.visitOperation.getCallHeader() + " end\n"
				end
			end
		}

		result := result + "\tend\n"
	end



	operation generateVisitOperationNotFocusedClass(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		// Definition of the type of the operation.
		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		// Adding the declaration of method visit
		result := "\t" + opDeclaration + " " + clazz.visitOperation.getDeclarationHeader() + " : Void is do\n" 

		// If the current clazz is the sub class of a class that defines method visit, the super call must be performed.
		if(isChild) then 
			result := result + "\t\t" + clazz.visitOperation.getSuperCall() + "\n"
		end

		clazz.targetRelations.each{rel |
			var clazzCalled : EClass init rel.eType.asType(EClass)

			if(rel.upperBound==-1 or rel.upperBound>1) then
				var varName : String init clazzCalled.getVarNameClassifier()
				result := result + "\t\tself." + rel.name + ".each{" + varName + " | if(not " + varName + ".visited) then " +
						  clazzCalled.getVarNameSet() + ".add(" + varName + ") end }\n"
			else
				result := result + "\t\tif(not self." + rel.name + ".visited) then " + clazzCalled.getVarNameSet() + ".add(self." + rel.name + ") end\n"
			end
		}

		result := result + "\tend\n"
	end



	operation generateVisitOperation(clazz : EClass, isChild : Boolean) : String is do
		if(prunerGenerator.radius.focusedClasses.exists{cl | cl==clazz or cl.isSuperTypeOf(clazz) } ) then
			result := generateVisitOperationFocusedClass(clazz, isChild)
		else
			result := generateVisitOperationNotFocusedClass(clazz, isChild)
		end
	end
}
