/*
 * Creation : November 23, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package prunerGenerator;

require kermeta
require "PrunerGenerator.kmt"

using ecore
using kermeta::standard


class ModelAspectGenerator inherits Generator {
	operation initialise(pruner : PrunerGenerator) : ModelAspectGenerator is do
		self.prunerGenerator := pruner
		pruner.pruningData.requiredElements.each{elt | elt.srcRelations.each{src | src.transformed := false } }
		result := self
	end


	method generateCode() : Void is do
		var mainPackageName : String init prunerGenerator.mainClasses.first().ePackage.getQualifiedName("::")
		
		generatedCode := prunerGenerator.getPackageFromClasses(prunerGenerator.mainClasses) + 
						"require kermeta\nrequire \"" + prunerGenerator.modelURI + "\"\nrequire \"" + 
						prunerGenerator.prunerClass.name + ".kmt\"\n\nusing kermeta::standard\n\n"
		prunerGenerator.mainClasses.each{cl |
			// Creation of ECore operations linked to the class.
			cl.createVisitOperation(prunerGenerator)
			cl.createAddOperation(prunerGenerator)
		}
		prunerGenerator.mainClasses.each{cl |
			var packageName : String init cl.ePackage.getQualifiedName("::")
			// If it is the same package, we write the code in the same file.
			if(packageName==mainPackageName) then
				generatedCode := generatedCode + generateClassAspect(cl)
			else
				// Otherwise, the code of the aspect must be write into another file dedicated to its package.
				generateExternAspect(cl, mainPackageName)
			end
		}
	end


	operation generateExternAspect(clazz : EClass, mainPackageName : String) : Void is do
		var namePackage : String init clazz.ePackage.getQualifiedName("::")
		var codeAspect : String
		
		// If no code has been already created for this package.
		if(prunerGenerator.requiredAspectFiles.getValue(namePackage).isVoid) then
			var codeUsing : String init ""
			// Adding headers of the file.
			codeAspect := "package " + namePackage + ";\n" + "require kermeta\n" + 
							"require \"" + prunerGenerator.prunerClass.name + "Aspect.kmt\"\n"
	
			// Adding the "require" elements that refer to the other created aspect files.
			prunerGenerator.requiredAspectFiles.keys.each{key |
				var subPkgs : Sequence<String> init key.split("::")
				codeAspect := codeAspect + "require \"" + subPkgs.last() + "PruningAspect.kmt\"\n"
				// Adding the "using" elements that refers to the other packages.
				codeUsing := codeUsing + "using " + key + "\n"
			}

			// Adding the "using" elements.
			codeAspect := codeAspect + "using kermeta::standard\nusing " + mainPackageName + "\n" + codeUsing + "\n"
		else
			// If the file already exists, the code is extracted and removed from the hashmap.
			codeAspect := prunerGenerator.requiredAspectFiles.getValue(namePackage)
			prunerGenerator.requiredAspectFiles.remove(namePackage)
		end
		
		// Adding the class code of the apsect.
		codeAspect := codeAspect + generateClassAspect(clazz)
		// Adding the new code to the hashmap with as key the qualified name of the package.
		prunerGenerator.requiredAspectFiles.put(namePackage, codeAspect)
	end



	operation generateClassAspect(clazz : EClass) : String is do
		var isChild : Boolean init prunerGenerator.mainClasses.exists{cl |
			if(cl.isSuperTypeOf(clazz)) then
				cl.main := true
				true
			else
				false
			end
		}

		result := "aspect class " + clazz.name + " {\n"

		if(not isChild) then
			result := result + "\tattribute visited : Boolean\n\n" 
		end

		prunerGenerator.pruningData.requiredElements.each{elt |
			elt.srcRelations.each{source |
				if(source.createOpposite and not source.transformed) then
					var cl : EClass init source.relation.eType.asType(EClass)
					
					if(cl==clazz or cl.isSuperTypeOf(clazz)) then
						result := result + "\treference " + source.relation.getOppositeReferenceName() +
								  " : " + cl.name + "[" + source.relation.lowerBound.toString + ".."
						if(source.relation.upperBound==-1) then
							result := result + "*"
						else
							result := result + source.relation.upperBound.toString
						end
						
						result := result + "]\n\n" + generateInitialiseOppositeOperation(source.relation)
					end
					
					// We change the pruning data to use of the opposite.
					var ref : EReference init EReference.new
					ref.name := source.relation.getOppositeReferenceName()
					ref.eType:= source.relation.eContainingClass
					source.relation.eType.asType(EClass).eStructuralFeatures.add(ref)
					ref.lowerBound := source.relation.lowerBound
					ref.upperBound := source.relation.upperBound
					ref.containment := false
					clazz.sourceRelations.remove(source.relation)
					clazz.sourceRelations.add(ref)
					source.relation := ref
					source.transformed := true
				end
			}
		}

		result := result + generateVisitOperation(clazz, isChild)
		if(prunerGenerator.radius.focusedClasses.exists{cl | cl==clazz or cl.isSuperTypeOf(clazz)}) then
			result := result + "\n" + generateAddRelations(clazz, isChild)
		end
		result := result + "}\n"
	end


	operation generateInitialiseOppositeOperation(relation : EReference) : String is do
		var name : String init relation.eType.asType(EClass).getVarNameClassifier()
		result := "\toperation initialise" + relation.getOppositeReferenceName() + "() : Void is do\n\t\tself." +
					relation.name + ".each{" + name + " | " + name + "." +  relation.getOppositeReferenceName() +
					".add(self) }\n\tend\n\n"
	end


	operation generateAddRelations(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		result := "\t" + opDeclaration + " " + clazz.addOperation.getDeclarationHeader() + " : Void is do\n" +
				  generateAddBodyRelations(clazz.sourceRelations) + generateAddBodyRelations(clazz.targetRelations) + "\tend\n"
	end



	operation generateAddBodyRelations(refs : EReference[0..*]) : String is do
		result := ""
		
		refs.each{rel |
			var clazzRel : EClass init rel.eType.asType(EClass)
			var varName : String init clazzRel.getVarNameClassifier()

			if(rel.eType==rel.eContainingClass) then
				result := result + "\t\tself." + rel.name + ".each{" + varName + " |\n\t\t\tif(" + varName + 
						  ".visited) then\n\t\t\t\t" + prunerGenerator.getPrunerVarName() + ".on" + rel.name + 
						  "Added(self, " + rel.eContainingClass.getVarNameClassifier() + ")\n\t\t\tend\n\t\t}\n"
			else
				result := result + "\t\tself." + rel.name + ".each{" + varName + " |\n\t\t\tif(not " + varName + ".visited"
				
				clazzRel.targetRelations.each{tar | result := result + " and " + varName + "." + tar.name + ".visited" }
				clazzRel.sourceRelations.each{src | result := result + " and " + varName + "." + src.name + ".visited" }
				
				result := result + ") then\n\t\t\t\t" + varName + ".visited := true\n\t\t\t\t" + prunerGenerator.getPrunerVarName() +
							".on" + clazzRel.name + "Added(" + varName + ")\n\t\t\t\t" + prunerGenerator.getPrunerVarName() +
							".added" + clazzRel.name + "s.add(" + varName + ")\n\t\t\tend\n\t\t}\n"
			end
		}		
	end


	operation generateVisitOperationFocusedClass(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		// Definition of the type of the operation.
		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		// Adding the declaration of method visit
		result := "\t" + opDeclaration + " " + clazz.visitOperation.getDeclarationHeader() + " : Void is do\n" 

		// If the current clazz is the sub class of a class that defines method visit, the super call must be performed.
		if(isChild) then 
			result := result + "\t\t" + clazz.visitOperation.getSuperCall() + "\n"
		else
			// Adding the body of method visit
			var prunerName : String init prunerGenerator.getPrunerVarName()
			// Setting the class as visited.
			result := result + "\t\tself.visited := true\n"
			// Adding a call to the method that notify the pruner that an object of a given type has been added.
			result := result + "\t\t" + prunerName + "." + clazz.getOnSomethingAddedMethodName() + "(self)\n"
			// Adding the added object to its container in the pruner.
			result := result + "\t\t" + prunerName + "." + clazz.getAddedSomethingAttributeName() + ".add(self)\n"
		end

		result := result + generateVisitBodyRelationsExploration(clazz.sourceRelations) +
					generateVisitBodyRelationsExploration(clazz.targetRelations) + "\tend\n"
	end



	operation generateVisitBodyRelationsExploration(refs : EReference[0..*]) : String is do
		result := ""
		
		refs.each{rel |
			var clazzCalled : EClass init rel.eType.asType(EClass)
			var varName : String init clazzCalled.getVarNameClassifier()

			if(rel.upperBound==-1 or rel.upperBound>1) then
				result := result + "\t\tself." + rel.name + ".each{" + varName + " | "

				if(rel.eType==rel.eContainingClass) then
					result := result + clazzCalled.getVarNameSet() + ".add(" + varName + ") }\n" 
				else
					result := result + varName + "." + clazzCalled.visitOperation.getCallHeader() + " }\n"
				end
			else
				result := result + "if(not self." + varName + ".isVoid()) then self." + varName + "."
				
				if(rel.eType==rel.eContainingClass) then
					result := result + clazzCalled.addOperation.getCallHeader() + " end\n"
				else
					result := result + clazzCalled.visitOperation.getCallHeader() + " end\n"
				end
			end
		}
	end



	operation generateVisitOperationNotFocusedClass(clazz : EClass, isChild : Boolean) : String is do
		var opDeclaration : String

		// Definition of the type of the operation.
		if(isChild) then 	opDeclaration := "method"
		else 				opDeclaration := "operation" end

		// Adding the declaration of method visit
		result := "\t" + opDeclaration + " " + clazz.visitOperation.getDeclarationHeader() + " : Void is do\n" 

		// If the current clazz is the sub class of a class that defines method visit, the super call must be performed.
		if(isChild) then 
			result := result + "\t\t" + clazz.visitOperation.getSuperCall() + "\n"
		end

		result := result + generateVisitNotFocusedBody(clazz.targetRelations) + generateVisitNotFocusedBody(clazz.sourceRelations) + "\tend\n"
	end


	operation generateVisitNotFocusedBody(refs : EReference[0..*]) : String is do
		result := ""

		refs.each{rel |
			var clazzCalled : EClass init rel.eType.asType(EClass)

			if(rel.upperBound==-1 or rel.upperBound>1) then
				var varName : String init clazzCalled.getVarNameClassifier()
				result := result + "\t\tself." + rel.name + ".each{" + varName + " | if(not " + varName + ".visited) then " +
						  clazzCalled.getVarNameSet() + ".add(" + varName + ") end }\n"
			else
				result := result + "\t\tif(not self." + rel.name + ".visited) then " + clazzCalled.getVarNameSet() + ".add(self." + rel.name + ") end\n"
			end
		}
	end


	operation generateVisitOperation(clazz : EClass, isChild : Boolean) : String is do
		if(prunerGenerator.radius.focusedClasses.exists{cl | cl==clazz or cl.isSuperTypeOf(clazz) } ) then
			result := generateVisitOperationFocusedClass(clazz, isChild)
		else
			result := generateVisitOperationNotFocusedClass(clazz, isChild)
		end
	end
}


/**
 * This aspect is used during the conversion of a source element which opposite must be create.
 * When the creation of the opposite is over, the source relation is tagged with transformed=true to not be transformed anymore.
*/
aspect class SourceRelation {
	attribute transformed : Boolean
}

