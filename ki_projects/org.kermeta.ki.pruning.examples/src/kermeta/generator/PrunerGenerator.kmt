/*
 * Creation : November 19, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
package prunerGenerator;

require kermeta
require "ECorePruningAspect.kmt"
require "Pruning.ecore"
require "platform:/resource/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EClassHelper.kmt"
require "platform:/resource/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EPackageHelper.kmt"
require "ModelAspectGenerator.kmt"
require "PrunerClassGenerator.kmt"

using kermeta::standard
using ecore


class PrunerGenerator {
	reference pruningData : Pruning	
	
	reference metamodel : EPackage
	
	attribute modelURI : String
	
	attribute prunerClass : EClass
	
	attribute aspectGenerator : ModelAspectGenerator
	
	attribute prunerClassGenerator : PrunerClassGenerator
	
	reference mainClasses : EClass[0..*]
	

	operation initialise(pruningData : Pruning, metamodel : EPackage, modelURI : String) : PrunerGenerator is do
		result := self
		self.pruningData := pruningData
		self.metamodel   := metamodel
		self.modelURI 	 := modelURI
		aspectGenerator  := ModelAspectGenerator.new.initialise(self)
		prunerClassGenerator := PrunerClassGenerator.new.initialise(self)
	
		self.prunerClass := EClass.new
		self.prunerClass.name := pruningData.name
		
		self.pruningData.requiredElements.each{elt |
			elt.srcRelations.each{src | src.relation.eContainingClass.sourceRelations.add(src.relation) }
			elt.targetRelations.each{target | target.eContainingClass.targetRelations.add(target) }
		}
		
		defineClassesToAspectise()
	end
	

	operation getPrunerVarName() : String is do
		result := "the" + prunerClass.name
	end
	
	
	
	operation defineClassesToAspectise() : Void is do
		pruningData.requiredElements.each{elt | 
			elt.srcRelations.each{src | addReferenceClass(src.relation, true) }
			elt.origins.each{origins | addReferenceClass(origins.path.last(), false) }
		}
	end
	
	
	operation addReferenceClass(ref : EReference, withContainingClass : Boolean) : Void is do
		if(withContainingClass and not mainClasses.contains(ref.eContainingClass)) then
			mainClasses.add(ref.eContainingClass)
			ref.eContainingClass.main := true
		end
		if(ref.eType.isKindOf(EClass)) then
			var clazz : EClass init ref.eType.asType(EClass)
			
			if(not mainClasses.contains(clazz)) then
				mainClasses.add(clazz)
				clazz.main := false
			end
		end
	end
	
	
	operation generatePruner() : Void is do
		aspectGenerator.generateCode()
		prunerClassGenerator.generateCode()
	end
	
	
	
	operation getPackageFromClasses(classes : EClass[0..*]) : String is do
		var packagesName : Bag<String> init Bag<String>.new
		var name : String
		
		result := ""
		
		classes.each{clazz | 
			name := clazz.ePackage.getQualifiedName("::")
			if(not packagesName.contains(name)) then
				packagesName.add(name)
				result := result + "package " + name + ";\n"
			end 
		}
		
		if(packagesName.size()>1) then
			stdio.writeln("FIXME: aspects from several packages is not managed yet.")
		end
	end
}


abstract class Generator {
	reference prunerGenerator : PrunerGenerator

	attribute generatedCode : String
	
	operation generateCode() : Void is abstract
}
