/*
 * Creation : November 19, 2010
 * Licence  : EPL
 * Copyright: INRIA Rennes, Triskell
 * Authors  : Arnaud Blouin
 */
@mainClass "prunerGenerator::Test"
@mainOperation "main"

package prunerGenerator;

require kermeta
require "Pruning.ecore"
require "platform:/resource/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EClassHelper.kmt"

using kermeta::standard
using ecore
using kermeta::persistence


class PrunerGenerator {
	reference pruningData : Pruning	
	
	reference metamodel : EPackage
	
	attribute pathPruner : String
	
	attribute prunerName : String
	
	attribute modelURI : String
	

	operation initialise(pruningData : Pruning, metamodel : EPackage, pathPruner : String, 
						prunerName : String, modelURI : String) : PrunerGenerator is do
		result := self
		self.pruningData := pruningData
		self.metamodel   := metamodel
		self.pathPruner  := pathPruner
		self.prunerName	 := prunerName
		self.modelURI 	 := modelURI
	end
	
	operation getVarName(name : String, withS : Boolean) : String is do
		result := "the" + name
		
		if(withS) then result := result + "s" end
	end
	
	operation getPrunerVarName() : String is do
		result := getVarName(prunerName, false)
	end
	
	operation getVarNameClassifier(classifier : EClassifier) : String is do
		result := getVarName(classifier.name, false)
	end
	
	operation getVarNameSet(classifier : EClassifier) : String is do
		result := getVarName(classifier.name, true)
	end
	
	
	operation getClassesToAspectise() : Bag<EClass> is do
		result := Bag<EClass>.new
		
		pruningData.requiredElements.each{elt | 
			elt.srcRelations.each{src | addReferenceClass(src.relation, result, true) }
			elt.origins.each{origin | addReferenceClass(origin, result, false) }
		}
	end
	
	
	operation addReferenceClass(ref : EReference, classes : Bag<EClass>, withContainingClass : Boolean) : Void is do
		if(withContainingClass and not classes.contains(ref.eContainingClass)) then
			classes.add(ref.eContainingClass)
		end
		if(ref.eType.isKindOf(EClass)) then
			var clazz : EClass init ref.eType.asType(EClass)
			
			if(not classes.contains(clazz)) then
				classes.add(clazz)
			end
		end
	end
	
	
	operation generatePruner() : Void is do
		saveFile(generatePruningCode())
		saveFile(generateModelAspectCode())
	end
	
	
	operation generatePruningCode() : String is do
		result := ""
	end
	
	
	operation generateModelAspectCode() : String is do
		result := "require kermeta\nrequire \"" + modelURI + "\"\nrequire \"" + pathPruner + prunerName + ".kmt\"\n\nusing kermeta::standard\n\n"
		
		var classes : Bag<EClass> init getClassesToAspectise()
		classes.each{cl | result := result + generateClassAspect(cl, classes) }
	end
	
	
	
	operation generateClassAspect(clazz : EClass, classes : Bag<EClass>) : String is do
		var isChild : Boolean init classes.exists{cl | cl.isSuperTypeOf(clazz) }
		var opDeclaration : String
		
		if(isChild) then opDeclaration := "method" else opDeclaration := "operation" end
	
		result := "aspect class " + clazz.name + " {\n"
		result := result + "\t" + opDeclaration + " visit(" + getPrunerVarName() + " : " + prunerName + ") : void is do\n"
		result := result + "\tend\n"
		result := result + "}\n"
	end
	
	
	
	operation saveFile(code : String) : Void is do
		stdio.writeln(code)
	end
}




class Test {
	operation main() : Void is do
		var modelURI	: String init "platform:/resource/org.kermeta.ki.pruning.examples/src/kermeta/SM/StateMachine.ecore"
		var pruningSM 	: Pruning init getPruningModel("platform:/resource/org.kermeta.ki.pruning.examples/src/kermeta/SM/SM.prunergenerator")
		var pkg 		: EPackage init getEcoreModel(modelURI).one()
		var pruner 		: PrunerGenerator init PrunerGenerator.new.initialise(pruningSM, pkg, "", "StateMachinePruning", modelURI)
		
		pruner.generatePruner()
	end
	
	
	operation getEcoreModel(uriEcoreModel : String) : Bag<EPackage> is do
		var uriMM : String init "http://www.eclipse.org/emf/2002/Ecore"
   		var repository : EMFRepository init EMFRepository.new
   		repository.registerEcoreFile(uriMM)          
   		var resource : Resource init repository.createResource(uriEcoreModel, uriMM)
       	resource.load()
		
		result := Bag<EPackage>.new
		
		resource.contents.each{obj |
			if(EPackage.isInstance(obj)) then
				result.add(obj.asType(EPackage))        
			end
		}
	end
	/* 
	operation createStateMachineModel(requiredStates : Bag<OutputState>) : StateMachine is do
		result := StateMachine.new
		
		var initState : InitState init InitState.new
		var s1 : StandardState init StandardState.new
		var s2 : StandardState init StandardState.new
		var terminal : TerminalState init TerminalState.new
		var transition : Transition init Transition.new
		
		initState.name := "init"
		s1.name := "s1"
		s2.name := "s2"
		terminal.name := "end"
		
		result.initState := initState
		result.states.add(initState)
		result.states.add(s1)
		result.states.add(s2)
		result.states.add(terminal)
		
		transition.source := initState
		transition.target := s1
		result.transitions.add(transition)
		
		transition := Transition.new
		transition.source := s1
		transition.target := s2
		result.transitions.add(transition)
		
		transition := Transition.new
		transition.source := s2
		transition.target := s1
		result.transitions.add(transition)
		
		transition := Transition.new
		transition.source := s2
		transition.target := s2
		result.transitions.add(transition)
		
		transition := Transition.new
		transition.source := s2
		transition.target := terminal
		result.transitions.add(transition)
		
		requiredStates.add(initState)
	end */
	
	
	operation getPruningModel(uriPruningModel : String) : Pruning is do
		var uriPruningMM : String init "platform:/resource/org.kermeta.ki.pruning.examples/src/kermeta/generator/Pruning.ecore"
   		var repository : EMFRepository init EMFRepository.new
   		repository.registerEcoreFile(uriPruningMM)          
   		var resource : Resource init repository.createResource(uriPruningModel, uriPruningMM)
       	resource.load()
		
		from var it : Iterator<Object> init resource.instances.iterator
		until it.isOff
		loop
			var next : Object init it.next
			if(Pruning.isInstance(next)) then                 
				result ?= next
			end
		end
	end
}





