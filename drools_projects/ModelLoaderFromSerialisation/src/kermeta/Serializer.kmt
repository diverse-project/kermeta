/* $Id:$ 
 * Creation : February 9, 2010
 * Licence  : EPL  
 * Copyright:
 * Authors  : 
 *            barais
 */
@mainClass "ecore::Main"
@mainOperation "main"


package ecore;


require kermeta
//require "http://www.eclipse.org/emf/2002/Ecore"
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/ecore_behavior.kmt"

require "./strategy/DeclareElement.kmt"
require "./strategy/Global.kmt"
require "./strategy/perElementMatch.kmt"
require "./strategy/perRoleMatch.kmt"
require "./strategy/perJoinPoint.kmt"

require "./advice/Header.kmt"  
require "./advice/HeaderLink.kmt"  
require "./advice/Pass1.kmt" 
require "./advice/PropertyCardinalityOne.kmt" 
require "./advice/PropertyCardinalityMany.kmt" 
require "./advice/ReferenceCardinalityMany.kmt" 
require "./advice/ReferenceCardinalityOne.kmt" 

require "./pointcut/Pass1.kmt"
require "./pointcut/Pass2.kmt"
require "./pointcut/PropertyCardinalityOne.kmt" 
require "./pointcut/PropertyCardinalityMany.kmt" 
require "./pointcut/ReferenceCardinalityMany.kmt" 
require "./pointcut/ReferenceCardinalityOne.kmt"



using kermeta::standard
using kermeta::persistence
using ecore

class Main {
	
	operation main() : Void is do
		var uriecore : String init "platform:/resource/org.kermeta.art.model/model/metamodel@runtime.ecore"
		//var uriecore : String init "platform:/resource/GenericComposition/SequenceDiagram-Example/metamodel/SequenceDiagram.ecore"
		//var uriecore : String init "platform:/resource/java/model/java.ecore"
		
		
		var ctx : Context init Context.new
		ctx.res := kermeta::utils::StringBuffer.new
		ctx.cache := kermeta::utils::Hashtable<Object,String>.new		
		
		ctx.declarationTemplate := smart::DeclareElement.new
		ctx.globalTemplate := smart::GlobalStrategy.new
		ctx.perElemTemplate := smart::PerElementMatch.new
		ctx.perRoleTemplate := smart::PerRoleStrategy.new
		ctx.perJoinPoint := smart::PerJoinPoint.new
		
		//ctx.pass1template := Pass1Template.new
		ctx.propertytemplate := PropertyTemplate.new
		ctx.propertytemplatemany := PropertyTemplateMany.new
		ctx.referencetemplate := ReferenceTemplate.new
		ctx.referencetemplatemany := ReferenceTemplateMany.new
		
		ctx.pass1templatePC := Pass1TemplatePC.new
		ctx.pass2templatePC := Pass2TemplatePC.new
		ctx.propertytemplatePC := PropertyPCTemplate.new
		ctx.propertytemplatemanyPC := PropertyPCTemplateMany.new
		ctx.referencetemplatePC := ReferencePCTemplate.new
		ctx.referencetemplatemanyPC := ReferencePCTemplateMany.new  
	
	
		
		var rep : EMFRepository  init EMFRepository.new
		var res : EMFResource 
		res ?= rep.getResource(uriecore)
		res.load
		var root : EPackage
		
		root ?= res.one
			
		var h : Header init Header.new 			
		ctx.res.append(h.generate(uriecore,root.name))	
		//stdio.writeln("root.name= "+root.name)
		//root.toGenerate(ctx)
		
		
		root.eSubpackages.each{p| stdio.writeln("p1.name= "+p.name) p.toGenerate(ctx)}
		root.eClassifiers.each{c| stdio.writeln("c1.name= "+c.name) c.toGenerate(ctx)}			
		
		//saving kmt file
		var f : kermeta::io::FileIO		init 	kermeta::io::FileIO.new
		var fileName : String init ctx.getGenerateName
		stdio.writeln("saving kmt file to: "+"/model/"+fileName+".kmt")
		f.writeTextFile("/model/"+fileName+".kmt",ctx.res.toString)
		
		
		
		ctx.res := kermeta::utils::StringBuffer.new
		
		res.dependentResources.each{res|
		res.each{e|
			root ?= e
			var hl : HeaderLink init HeaderLink.new 			
			ctx.res.append(hl.generate(uriecore,root.name))	
			
			//stdio.writeln("root2.name= "+root.name)
			//root.toGenerate(ctx)
			
			root.eSubpackages.each{p| stdio.writeln("p2.name= "+p.name) p.toGenerate(ctx)}
			root.eClassifiers.each{c| stdio.writeln("c2.name= "+c.name) c.toGenerate(ctx)}			
			
			f :=	kermeta::io::FileIO.new
			fileName := ctx.getGenerateName
			stdio.writeln("saving kmt file to: "+"/model/"+fileName+".kmt")
			f.writeTextFile("/model/"+fileName+".kmt",ctx.res.toString)
			ctx.res := kermeta::utils::StringBuffer.new
			
		}
		
		
		
		}
		
				
		//root.toGenerate(ctx)		
		
			
			stdio.writeln(ctx.res.toString)		 
	end
	
	

}
class Context{
	/*
	Strategy-related references
	*/
	reference declarationTemplate :smart::DeclareElement
	reference globalTemplate : smart::GlobalStrategy
	reference perElemTemplate : smart::PerElementMatch
	reference perRoleTemplate : smart::PerRoleStrategy
	reference perJoinPoint : smart::PerJoinPoint

	/*
	Advice-related references
	*/
	//reference pass1template : Pass1Template
	reference propertytemplate : PropertyTemplate
	reference propertytemplatemany : PropertyTemplateMany
	reference referencetemplate : ReferenceTemplate  
	reference referencetemplatemany : ReferenceTemplateMany
	
	/*
	Pointcut-related references
	*/
	reference pass1templatePC : Pass1TemplatePC
	reference pass2templatePC : Pass2TemplatePC
	reference propertytemplatePC : PropertyPCTemplate
	reference propertytemplatemanyPC : PropertyPCTemplateMany
	reference referencetemplatePC : ReferencePCTemplate  
	reference referencetemplatemanyPC : ReferencePCTemplateMany  
	
	reference res : kermeta::utils::StringBuffer
	reference cache : kermeta::utils::Hashtable<Object,String>
	reference i : Integer
	
	operation getGenerateName():String is do
		/*var metaClass : kermeta::language::structure::Class init obj.getMetaClass
		var prop : kermeta::language::structure::Property init metaClass.classDefinition.allAttribute.select{p | p.name == "aspectID"}.one
		if prop != void then
			result := obj.get(prop).asType(String)
		else*/
			if (i.isVoid) then i:= 0 end
			result :="s"+ i.toString()
			i:=i+1
		//end
	end
		
}


aspect class EPackage{
		
	method toGenerate(ctx:Context) : Void is do 
		stdio.writeln(self.name+".toGenerate")
		ctx.res.append("package " + self.name + " {\n")
		self.eClassifiers.each{c| c.toGenerate(ctx)}
		self.eSubpackages.each{p| p.toGenerate(ctx)}			
		ctx.res.append("}\n")		
	end
	
	method getQualifiedNameGen(): String is do
		result:=""
		if (not self.eSuperPackage.isVoid) then
			result := self.eSuperPackage.getQualifiedNameGen() + "."
		end
		result :=result + self.name		
	end
	

}

aspect class EClass{
		
	method toGenerate(ctx:Context) : Void is do 
	stdio.writeln(self.name+".toGenerate")
	
		ctx.res.append("aspect class " + self.name + " {\n")
				
		ctx.res.append("method  ")	
		ctx.res.append("pass2set(ctx:Context):Void")
		if (self.eSuperTypes.size>1) then
			ctx.res.append(" from " + self.eSuperTypes.one.name) 
		end
		ctx.res.append(" is do \n \t")
		if (not self.~abstract) then
			self.eAllAttributes().each{a|a.toGenerate(ctx)}
			self.eAllReferences().each{a|a.toGenerate(ctx)}
			self.eAllReferences().each{a|a.generateTraverse(ctx,"pass2set")}
		end
		
		
		
		ctx.res.append("end\n")
		
		
		
		ctx.res.append("\tmethod ")		
		ctx.res.append("pointcut2droolsPass1(ctx:Context):Void")
		if (self.eSuperTypes.size>1) then
			ctx.res.append(" from " + self.eSuperTypes.one.name) 
		end
		ctx.res.append(" is do \n")
		
		//appeler le template pointcut.Pass1
		ctx.res.append(ctx.pass1templatePC.generate(self.getQualifiedNameGen.replace("pattern.","")))
		
		if (not self.~abstract) then
			self.eAllAttributes.each{a | a.pointcutToDrools(ctx)}			
		end
		
		ctx.res.append("ctx.res.append(\")\\n\")\n")
		
		self.eAllReferences.each{a|
				stdio.writeln(self.name.toUpperCase)
				a.generateTraversePC(ctx,"pointcut2droolsPass1")
		}
		
		
		ctx.res.append("\tend\n")
		
		
		
		
		ctx.res.append("method  ")
		ctx.res.append("pointcut2droolsPass2(ctx:Context):Void")
		if (self.eSuperTypes.size>1) then
			ctx.res.append(" from " + self.eSuperTypes.one.name) 
		end
		ctx.res.append(" is do \n \t")
		//appeler le template pointcut.Pass2
		ctx.res.append(ctx.pass2templatePC.generate(self.getQualifiedNameGen.replace("pattern.","")))
		
		if (not self.~abstract) then
			//self.eReferences.each{a | a.pointcutToDrools(ctx)}
			self.eAllReferences.each{a | a.pointcutToDrools(ctx)}			
		end
		
		ctx.res.append("ctx.res.append(\")\\n\")\n")
		
		self.eAllReferences.each{a|
				stdio.writeln(self.name.toUpperCase)
				a.generateTraversePC(ctx,"pointcut2droolsPass2")
		}
		
		ctx.res.append("end\n")
		
		
		ctx.res.append("method  ")
		ctx.res.append("generateDeclare(ctx:Context):Void")
		if (self.eSuperTypes.size>1) then
			ctx.res.append(" from " + self.eSuperTypes.one.name) 
		end
		ctx.res.append(" is do \n \t")
		//appeler le template global strategy
		ctx.res.append(ctx.declarationTemplate.generate(self.getQualifiedNameGen.replace("pattern.","")))
		self.eAllReferences.each{a|
			stdio.writeln(self.name.toUpperCase)
			a.generateTraverse(ctx,"generateDeclare")
		}
		ctx.res.append("end\n")
		
		ctx.res.append("method  ")
		ctx.res.append("generateGlobalStrategy(ctx:Context):Void")
		if (self.eSuperTypes.size>1) then
			ctx.res.append(" from " + self.eSuperTypes.one.name) 
		end
		ctx.res.append(" is do \n \t")
		//appeler le template global strategy
		var packNameUpper : String init self.ePackage.name.substring(0,1).toUpperCase + self.ePackage.name.substring(1,self.ePackage.name.size)
		ctx.res.append(ctx.globalTemplate.generate(self.getQualifiedNameGen.replace("pattern.",""),self.ePackage.getQualifiedNameGen().replace("pattern.",""), self.name , packNameUpper))
				
		ctx.res.append("end\n")
		
		
		
		ctx.res.append("method  ")
		ctx.res.append("generatePerElementStrategy(ctx:Context, baseIDs:Set<String>):Void")
		if (self.eSuperTypes.size>1) then
			ctx.res.append(" from " + self.eSuperTypes.one.name) 
		end
		ctx.res.append(" is do \n \t")
		//appeler le template global strategy
		ctx.res.append(ctx.perElemTemplate.generate(self.getQualifiedNameGen.replace("pattern.",""),self.ePackage.getQualifiedNameGen().replace("pattern.",""), self.name , packNameUpper))
				
		ctx.res.append("end\n")
		
		
		
		
		ctx.res.append("method  ")
		ctx.res.append("generatePerRoleStrategy(ctx:Context, baseIDs:Set<String>):Void")
		if (self.eSuperTypes.size>1) then
			ctx.res.append(" from " + self.eSuperTypes.one.name) 
		end
		ctx.res.append(" is do \n \t")
		//appeler le template global strategy
		ctx.res.append(ctx.perRoleTemplate.generate(self.getQualifiedNameGen.replace("pattern.",""),self.ePackage.getQualifiedNameGen().replace("pattern.",""), self.name , packNameUpper))
				
		ctx.res.append("end\n")
		
		
		
		ctx.res.append("method  ")
		ctx.res.append("generatePerJoinPointStrategy(ctx:Context):Void")
		if (self.eSuperTypes.size>1) then
			ctx.res.append(" from " + self.eSuperTypes.one.name) 
		end
		ctx.res.append(" is do \n \t")
		//appeler le template global strategy
		ctx.res.append(ctx.perJoinPoint.generate(self.getQualifiedNameGen.replace("pattern.",""),self.ePackage.getQualifiedNameGen().replace("pattern.",""), self.name , packNameUpper))
		self.eAllReferences.each{a|
			stdio.writeln(self.name.toUpperCase)
			a.generateTraverse(ctx,"generatePerJoinPointStrategy")
		}
		ctx.res.append("end\n")
		
		
		ctx.res.append("\n}")
		
	end
	
	method getQualifiedNameGen(): String is do
		result := self.ePackage.getQualifiedNameGen() + "." +self.name
			
	end
}  



aspect class EAttribute{
		
	method toGenerate(ctx:Context) : Void is do 
	if self.name != "aspectID" then
		var propertyUpper : String init self.name.substring(0,1).toUpperCase + self.name.substring(1,self.name.size)
		if (self.many) then
			//ropertyNameUpper:String,PropertyName:String,str:Boolean
			
			ctx.res.append(ctx.propertytemplatemany.generateMany(propertyUpper,self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property"),isString(self.eType)))
		else
			ctx.res.append(ctx.propertytemplate.generateOne(propertyUpper,self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property"),isString(self.eType))  )
		end
	end	
	end
	
	
	operation isString(type : EClassifier ):Boolean is do
		var t  : EDataType 
		t?=type
		if (t.isVoid) then
			result:=false
		else
			result := t.name.equals("EString") or t.instanceClassName.equals("java.lang.String")
		end		
	end
	
	operation pointcutToDrools(ctx : Context) : Void is
	do
		if self.name != "aspectID" then
			if (self.many) then
				ctx.res.append(ctx.propertytemplatemanyPC.generateMany(self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property"),isString(self.eType)))
			else
				ctx.res.append(ctx.propertytemplatePC.generateOne(self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property"),isString(self.eType)))
			end
		end
	end

}

aspect class EReference{
		
	method toGenerate(ctx:Context) : Void is do 
		var propertyUpper : String init self.name.substring(0,1).toUpperCase + self.name.substring(1,self.name.size)
		if (self.many) then
			//ropertyNameUpper:String,PropertyName:String,str:Boolean
			ctx.res.append(ctx.referencetemplatemany.generateMany(propertyUpper,self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")))
		else
			ctx.res.append(ctx.referencetemplate.generateOne(propertyUpper,self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property"))  )
		end
		 
		
	end
 
 
 	operation generateTraverse(ctx:Context,methodName:String):Void is do
 		stdio.writeln(self.name+".generateTraverse"+ methodName)
		if (self.containment) then
			if (self.many) then
				ctx.res.append("\nif self."+ self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")+".size >0 then\n")
				ctx.res.append("\n\t"+ "self."+ self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")+".each{c|c."+methodName+"(ctx)}\n")
				ctx.res.append("end\n")
			else
				ctx.res.append("\nif not self."+ self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")+".isVoid then\n")
				ctx.res.append("\n\t"+ "self."+ self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")+"."+methodName+"(ctx)\n")			
				ctx.res.append("end\n")
			end
			
		end	
	end
	
	operation generateTraversePC(ctx:Context,methodName:String):Void is 
	do
		if (self.containment) then
			if (self.many) then
				ctx.res.append("\nif self."+ self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")+".size >0 then\n")
				ctx.res.append("\n\t"+ "self."+ self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")+".each{c|c."+methodName+"(ctx)}\n")
				ctx.res.append("end\n")
			else
				ctx.res.append("\nif not self."+ self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")+".isVoid then\n")
				ctx.res.append("\n\t"+ "self."+ self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")+"."+methodName+"(ctx)\n")			
				ctx.res.append("end\n")
			end
			
		end	
	end
	
	operation pointcutToDrools(ctx : Context) : Void is
	do
		if (self.many) then
			ctx.res.append(ctx.referencetemplatemanyPC.generateMany(self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")))
		else
			ctx.res.append(ctx.referencetemplatePC.generateOne(self.name.replace("value","~value").replace("operation","~operation").replace("attribute","~attribute").replace("property","~property")))
		end	
	end
} 

aspect class EModelElement inherits EObject{}

aspect class EObject{
		
	operation toGenerate(ctx:Context) : Void is do 
		
		
	end
	
	operation getQualifiedNameGen(): String is do
		result :=""	
	end
 	
}
