package ecore;
require kermeta
using kermeta::standard
using kermeta::utils
class Header{
operation generate(uriecore:String, packagename:String):String is do
var _res: StringBuffer init StringBuffer.new
_res.append("\n/* $Id:$ \n * Creation : February 9, 2010\n * Licence  : EPL \n * Copyright:\n * Authors  : \n *            barais\n */\n@mainClass \"")
_res.append(packagename)
_res.append("::Main\"\n@mainOperation \"main\"\n\n\npackage ")
_res.append(packagename)
_res.append(";\n\n\nrequire kermeta\nrequire \"")
_res.append(uriecore)
_res.append("\"\nrequire \"s1.kmt\"\n\nusing kermeta::standard\nusing kermeta::persistence\n\nclass Context{\n\treference res : kermeta::utils::StringBuffer\n\treference cache : kermeta::utils::Hashtable<Object,String>\n\t\t\n\treference lastgenerateName : String\n\treference i : Integer\n\t\n\toperation getGenerateName(obj:Object):String is do\n\t\tvar res : String\n\t\n\t\tres := cache.getValue(obj)\n\t\tif res == void then\n\t\t\tvar metaClass : kermeta::language::structure::Class init obj.getMetaClass\n\t\t\tvar prop : kermeta::language::structure::Property init metaClass.classDefinition.allAttribute.select{p | p.name == \"aspectID\"}.one\n\t\t\t\n\t\t\tif prop != void then\n\t\t\t\tres := obj.get(prop).asType(String)\n\t\t\tend\n\t\t\t\n\t\t\tif res == void then\n\t\t\t\tif (i.isVoid) then i:= 0 end\n\t\t\t\tres :=\"s\"+ i.toString()\n\t\t\t\ti:=i+1\t\n\t\t\tend\n\t\t\tres := res.replace(\"_\", \"__\").replace(\".\", \"_\")\n\t\t\tlastgenerateName := res\n\t\tend\n\t\tresult := res\n\tend\n\t\n\toperation convert(val : String) : String is \n\tdo \n\t\tresult := \" == \"+\"\\\"\"+val+\"\\\"\"\n\t\tif val.contains(\"*\") then\n\t\t\tresult := \" matches \"+\"\\\"\"+val.replace(\"*\",\".*\")+\"\\\"\"\n\t\tend\n\tend\n}\n\naspect class AspectModelElement {\n\toperation pointcut2droolsPass1(ctx:Context):Void is \n\t\tabstract \n\t\t\n\toperation pointcut2droolsPass2(ctx:Context):Void is \n\t\tabstract\n\n\toperation  pass1create(ctx:Context):Void is\n\t\tabstract\n\t\t\n\toperation  pass2set(ctx:Context):Void is\n\t\tabstract\t\n\t\n\toperation generateGlobalStrategy(ctx:Context) is\n\t\tabstract\n\t\t\n\toperation generatePerElementStrategy(ctx:Context, ids:Set<String>) is\n\t\tabstract\n\t\t\n\toperation generatePerRoleStrategy(ctx:Context, ids:Set<String>) is\n\t\tabstract\n\t\n\toperation generateDeclare(ctx:Context):Void is\n\t\tabstract\n\t\t\n\toperation generatePerJoinPointStrategy(ctx:Context):Void is\n\t\tabstract\t\t\t\t\t\n}\n")
result := _res.toString
end
}
