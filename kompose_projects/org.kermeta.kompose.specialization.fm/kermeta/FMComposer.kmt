/*
 * Code generated by Kompose Specialization wizard v0.1
 * Kompose 2008 - http://www.kermeta.org/mdk/kompose
 * 
 * author: Freddy Munoz - fmunoz(at)irisa.fr - Triskell Team
 * author: Mickael Clavreul - mclavreu(at)irit.fr - Triskell Team
 * 
 */
 @mainClass "featureDiagram::Main"
 @mainOperation "main"
 
package featureDiagram;

require kermeta
require "http://www.kermeta.org/featureDiagram"

require "platform:/lookup/org.kermeta.kompose.core.model/kermeta/kompose.kmt"

using kermeta::language::structure
using kermeta::standard
using kermeta::utils
using kermeta::persistence

// 1) Definition of the specific composer

class FMModelComposer inherits kompose::Composer
{   
	method saveModel(model : kompose::Mergeable, uri : kermeta::standard::String) is do
		// FIXME Metamodel URI to be changed by the one dedicated
   		self.saveModelByUri(model, uri, "http://www.kermeta.org/featureDiagram")
   end
   
   /**
    * For a dedicated model, declare an available context for the directive engine
    * to work
   	*/
   method createContext(model : kompose::Mergeable) : kompose::Context is do
   		result := super(model)
   		// FIXME Objects from dedicated metamodel have to be added
   		
   		// Main concepts from metamodel have to be declared
   		// for the directives engine to be able to work on them
   		//result.classes.put("ContextObject", ContextObjectClass)
   		
   		/*
   		 * example ecore
   		 */
   		/*
   		result.classes.put("Package", EPackage)
		result.classes.put("Class", EClass)
		result.classes.put("Attribute", EAttribute)
		result.classes.put("Reference", EReference)
		result.classes.put("Operation", EOperation)
		result.classes.put("Parameter", EParameter)
		*/ 
   end
   
   method resolveConflict(selfValue : Object, otherValue : Object, prop : Object) : Object is do
   		if self.mode.name.equals("UNION") then
	   		var inputOp : Operator
	   		var outputOp : Operator
	   		inputOp ?= selfValue
	   		outputOp ?= otherValue
	   		if (inputOp != void).andThen{e|outputOp != void} then
	   			if (inputOp.isKindOf(Xor)).andThen{e|outputOp.isKindOf(Or)} then
	   				result := outputOp
	   			else
	   				result := inputOp
	   			end
	   		else
	   			result := selfValue
	   		end
	   	else
	   	end
   end
}

// 2) Definition of specific signature classes

/*
 * These signatures are specific to the Ecore metamodel. 
 * Please redefine your own composition strategy.
 */

class FeatureDiagramSignature inherits kompose::Signature
{
	reference op : FeatureDiagram
	
	method equals(other : Object ) : kermeta::standard::Boolean is do
		//var othersign : FeatureDiagramSignature
		//othersign ?= other
		result := true
	end	
}

class FeatureSignature inherits kompose::Signature
{
	reference feature : Feature 
	
	method equals(other : Object ) : kermeta::standard::Boolean is do
		var othersign : FeatureSignature
		othersign ?= other
		if othersign != void then
			result := self.feature.name == othersign.feature.name 
			// and
			//self.param.eType.getSignature.equals(othersign.param.eType.getSignature)
		else
			result := false
		end
	end	
}

class EdgeSignature inherits kompose::Signature
{
	reference edge : Edge 
	
	method equals(other : Object ) : kermeta::standard::Boolean is do
		var othersign : EdgeSignature
		othersign ?= other
		if othersign != void then
			if (self.edge.child != void) and (othersign.edge.child != void) then
				//stdio.writeln(othersign.edge.child.name.toString)
			//	stdio.write(self.edge.child.name) stdio.writeln(" from "+self.edge.child.owningFeatureDiagram.name.toString)
				//stdio.write(" compared with "+othersign.edge.child.name) stdio.writeln(" from "+othersign.edge.child.owningFeatureDiagram.name.toString)
				//stdio.write("\n")
				result := self.edge.parent.getSignature() == othersign.edge.parent.getSignature() and self.edge.child.getSignature()==othersign.edge.child.getSignature()
			else
				result := false
			end
			// and
			//self.param.eType.getSignature.equals(othersign.param.eType.getSignature)
		else
			result := false
		end
	end	
}

// 3) Extentions to the metamodel

/*
 * Following code is specific to the Ecore metamodel. 
 * Please make your own concept "Mergeable" if necessary
 */

aspect class FeatureDiagram inherits kompose::Mergeable {}
aspect class Feature inherits kompose::Mergeable {}
aspect class Edge inherits kompose::Mergeable{}


aspect class FeatureDiagram
{
	method getSignature() : kompose::Signature is do
		var s : FeatureDiagramSignature init 
			FeatureDiagramSignature.new
		//s.sign := name
		result := s
	end
	
	//method getStringID() : kermeta::standard::String is do
	//	result := name
	//end
}

aspect class Feature
{
	method getSignature() : kompose::Signature is do
	// one can use StringSignature
		var s : FeatureSignature init 
			FeatureSignature.new
		s.feature := self
		result := s
	end
}

aspect class Edge
{
	method getSignature() : kompose::Signature is do
	// one can use StringSignature
		var s : EdgeSignature init 
			EdgeSignature.new
		s.edge := self
		result := s
	end
}



// 4) the Main
/*
 * This code must not be modified.
 */
class Main inherits kompose::KomposeMain
{
	operation main(uri : kermeta::standard::String) is do
	//operation main() is do
	//	var uri : String init "platform:/resource/org.kermeta.kompose.specialization.fm.samples/models/blp.kompose"
		var c : kompose::Composer init loadComposer(uri,FMModelComposer.new,false)
		c.compose
	end
}




