/*
 * Kompose 2008 - http://www.kermeta.org/mdk/kompose
 * 
 * author: Freddy Munoz - fmunoz(at)irisa.fr - Triskell Team
 * author: Mickael Clavreul - mclavreu(at)irisa.fr - Triskell Team
 * 
 */
package kompose;

require kermeta
require "platform:/lookup/org.kermeta.kompose.core.model/model/kompose.ecore"
require "platform:/plugin/fr.irisa.triskell.traceability.model/model/kmt/Traceability_Behavior.kmt"
require "kompose.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/extension/SingletonSupport.kmt"

using kermeta::language::structure
using kermeta::standard
using kermeta::utils 
using traceability

/** Any class that owns instances to merge should inherit 
 from this class and define operation getSignature */
aspect abstract class Mergeable
{
	/**
	 * Get a sequence of matching elements compared with a collection
	 * param elements : the collection in which we look for matching elements
	 * returns a sequence of matching elements
	 */
	operation getmatchingElements(elements : Collection<Mergeable>) : seq Mergeable[0..*] is do
		var e1 : Mergeable init self
		if e1 == void then
			result := Sequence<Mergeable>.new
		else
			result := elements.select{ e2 | 
				if e2 == void then false else e1.getSignature ==  e2.getSignature end
			}
		end
	end
	
	/**
	 * Generic merge method that tries to merge current Mergeable element with other
	 * given a context ctx
	 * param other : second element to be merged with the current one
	 * param ctx : context provided by a specialization
	 * returns a merged element
	 */
	operation merge(other : Mergeable, ctx : MergeContext, composer : Composer) : Mergeable
	pre same_type is self.getMetaClass == other.getMetaClass
	is do
		var type : Class init self.getMetaClass
		result ?= type.new
		ctx.addObjectComposedTrace(self,other,result)
		
		var props : Collection<Property> init self.getMetaClass.classDefinition.allAttribute.select{p|
			not p.isDerived
		}
		/* Merging properties */
		props.each{p|
			KLogger.getDefault().asType(KLogger).printDebug(self.toString)
			var mergeable : Boolean init Mergeable.isSuperTypeOf(p.type)
			var selfValue : Object init self.get(p)
			var otherValue : Object init other.get(p)

			if p.upper == 1 then
				/* Property only exists in one object */
				if selfValue == void then
					TraceModel.getDefault().asType(TraceModel).addTrace(KTrace.new.newModelTrace(void,other))
					result.~set(p, otherValue)
				else
					if other.get(p) == void then
						TraceModel.getDefault().asType(TraceModel).addTrace(KTrace.new.newModelTrace(self,void))
						result.~set(p, selfValue)
					else
						if mergeable then
							var me1 : Mergeable		me1 ?= selfValue
							var me2 : Mergeable		me2 ?= otherValue								
							if me1 == void or me2 == void then
								KLogger.getDefault().asType(KLogger).printError("Elements are not mergeable")
							else						
								if me1.getSignature == me2.getSignature then
									/* p is a relation */
									if p.isComposite then
										result.~set(p, me1.merge(me2, ctx, composer))
									else
										TraceModel.getDefault().asType(TraceModel).addTrace(KTrace.new.newModelTrace(me1,me2))
										result.~set(p, me1)
									end
								else
									KLogger.getDefault().asType(KLogger).printError("Elements signature do not match: m1="+me1.toString+"/m2="+me2.toString)
								end
							end
						else
							if selfValue == otherValue then
								TraceModel.getDefault().asType(TraceModel).addTrace(KTrace.new.newModelTrace(self,other))
								result.~set(p, selfValue)
							else
								KLogger.getDefault().asType(KLogger).printError("conflicting value for property " + p.name + " picking the first value")
								// look for method to resolve conflict into the specialization
								result.~set(p,composer.resolveConflict(selfValue,otherValue,p))
								//result.~set(p, selfValue)
							end
						end
					end
				end
			else
			/* Merging collections */
			/* Test on collection size because on compiled mode, collection are
				initialized as empty ones and not null ones */
				if selfValue == void then
					TraceModel.getDefault().asType(TraceModel).addTrace(KTrace.new.newModelTrace(void,other))
					result.~set(p, otherValue)
				else
					if otherValue == void then
						TraceModel.getDefault().asType(TraceModel).addTrace(KTrace.new.newModelTrace(self,void))
						result.~set(p, selfValue)
					else
						TraceModel.getDefault().asType(TraceModel).addTrace(KTrace.new.newModelTrace(self,other))
						result := mergeCollections(self,other,result,p,ctx,composer)
					end
				end
			end
		}
	end

	/**
	 * Generic merge method that tries to merge elements from two different collections
	 * param m1 : first mergeable element
	 * param m2 : second mergeable element
	 * param out : merged collection
	 * param p : the property that correspond to a collection
	 * param ctx : context provided by a specialization
	 * returns a merged collection
	 */
	operation mergeCollections(m1 : Mergeable, m2 : Mergeable, out : Mergeable, p : Property, ctx : MergeContext, composer : Composer) : Mergeable is do
		result := out
		var ocol1 : Collection<Object> 	ocol1 ?= m1.get(p) 
		var col1 : Collection<Mergeable> init Sequence<Mergeable>.new
		ocol1.each{ k | 
			var m : Mergeable	m ?= k
			col1.add(m)
		}
		var ocol2 : Collection<Object> 	ocol2 ?= m2.get(p) 
		var col2 : Collection<Mergeable> init Sequence<Mergeable>.new
		ocol2.each{ k | 
			var m : Mergeable	m ?= k
			col2.add(m)
		}
		col1.each{ me |
			if not me.isVoid() then
				var matching : Collection<Mergeable> init me.getmatchingElements(col2)
				var col : Collection<Object>
				col ?= result.get(p)
				if (matching.size == 0) then
					if not composer.mode.equals(Modes.INTERSECTION) then
						col.add(me)
					end
				else
					matching.each{ me2 |
						if p.isComposite then
							col.add(me.merge(me2, ctx, composer))
						else
							TraceModel.getDefault().asType(TraceModel).addTrace(KTrace.new.newModelTrace(me,me2))
							col.add(me)
						end
					}
				end
			end
		}
		col2.each{ me | 
			if not me.isVoid() then
				var matching : Collection<Mergeable> init me.getmatchingElements(col1)
				var col : Collection<Object>
				col ?= result.get(p)
				if matching.size == 0 then
					if not composer.mode.equals(Modes.INTERSECTION) then
						col.add(me)
						//stdio.writeln("We should hide "+me.getStringID)
					end
				/*else
					matching.each{ me2 | 
						if p.isComposite then
							col.add(me.merge(me2, ctx))
						else
							ctx.trace.addTrace(KTrace.new.newModelTrace(me,me2))
							col.add(me)
						end
					}*/
				end
			end
		}
	end
	
	/**
	 * Abstract method getSignature that returns the signature of current element
	 * returns a signature
	 */
	operation getSignature() : kompose::Signature is abstract
	
	/**
	 * Gets the string representation of an element
	 * returns a string
	 */
	operation getStringID() : kermeta::standard::String is abstract
}

/** this class is used to store the traceability between composed models */
class MergeContext {
	attribute left : Hashtable<kermeta::standard::Integer, Mergeable>
	attribute right : Hashtable<kermeta::standard::Integer, Mergeable>
	attribute any : Hashtable<kermeta::standard::Integer, Mergeable>
	attribute reverse : Hashtable<kermeta::standard::Integer, Mergeable>
	attribute processed : Hashtable<kermeta::standard::Integer, kermeta::standard::Boolean>
	attribute comp : Hashtable<kermeta::standard::Integer, kermeta::standard::Boolean>
	reference resources: kermeta::persistence::EMFResource[0..*]
	attribute objectIndex : Hashtable<kermeta::standard::Integer,kermeta::standard::Object>
	
	/**
	 * Initialization of context information containers
	 * param logger : a KLogger object to be able to log informations
	 */
	operation initialize() is do
		left := Hashtable<kermeta::standard::Integer, Mergeable>.new
		right := Hashtable<kermeta::standard::Integer, Mergeable>.new
		any := Hashtable<kermeta::standard::Integer, Mergeable>.new
		reverse := Hashtable<kermeta::standard::Integer, Mergeable>.new
		processed := Hashtable<kermeta::standard::Integer, kermeta::standard::Boolean>.new
		comp := Hashtable<kermeta::standard::Integer, kermeta::standard::Boolean>.new
		objectIndex := Hashtable<kermeta::standard::Integer,kermeta::standard::Object>.new
	end
	
	/**
	 * Test if an element comes from a resource already loaded
	 * param element : element to test
	 * returns true if element comes from one of the resources loaded, false otherwise
	 */
	operation resourceContains(element : Object) : kermeta::standard::Boolean is do
		result:=false
		self.resources.each{resource|
			if not element.containingResource().isVoid then
				if element.containingResource()==resource then
					result:=true
				end
			end
		}
	end
	
	/**
	 * Creates a context to be able to get back references from elements once merge process
	 * is done
	 * param element : element to indexate
	 */
	operation indexate(element : Object) : Void is do
		KLogger.getDefault().asType(KLogger).printDebug("indexate : test "+element.toString+" : "+element.isInstanceOf(kermeta::language::behavior::Expression).toString)
		if not element.isInstanceOf(kermeta::language::behavior::Expression) and not element.isInstanceOf(kermeta::language::structure::Tag) then
			KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : resouceContains "+element.toString)
			if self.resourceContains(element) then
				KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : contains "+element.toString)
				if not self.objectIndex.containsKey(element.oid) then
					KLogger.getDefault().asType(KLogger).printDebug("indexate merge.kmt : add "+element.toString)
					self.objectIndex.put(element.oid,element)
					KLogger.getDefault().asType(KLogger).printDebug("indexate merge.kmt : properties "+element.toString)
					var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
					KLogger.getDefault().asType(KLogger).printDebug("indexate merge.kmt : each "+properties.toString)
					properties.each{ p |
						if p.upper != 1 then
							KLogger.getDefault().asType(KLogger).printDebug("indexate merge.kmt : get "+p.toString)
							var objects : Collection<Object> objects?=element.~get(p)
							objects.each{obj|
								if not obj.isKindOf(kermeta::language::behavior::Expression) then
									self.indexate(obj)
								end
							}
						else
							KLogger.getDefault().asType(KLogger).printDebug("indexate merge.kmt : indexate recursive "+element.~get(p).toString)
							if not p.isKindOf(kermeta::language::behavior::Expression) then
								self.indexate(element.~get(p))
							end
						end
					}
				end
			end
		end
	end
	
	/**
	 * Creates a trace for composed objects
	 * param l : element from base model
	 * param r : element from aspect model
	 * param composed : result of the composition of l and r
	 */
	operation addObjectComposedTrace(l : Mergeable, r : Mergeable, composed : Mergeable) is do
		left.put(l.oid(), composed)
		right.put(r.oid(), composed)
		reverse.put(composed.oid(), l)
		comp.put(composed.oid(), true)
	end
	
	/**
	 * Test if an object is a composed one
	 * param composed : element to test
	 * returns true if the element has already been composed, false otherwise
	 */
	operation isComposedObject(composed : Mergeable) : kermeta::standard::Boolean is do
		result := comp.getValue(composed.oid()) != void
	end
	
	/**
	 * Gets a composed object
	 * param o : element from base or aspect models
	 * returns a composed element if found, void otherwise
	 */
	operation getComposedObject(o : Mergeable) : Mergeable is do
		result := left.getValue(o.oid())
		if result == void then 
			result := right.getValue(o.oid())
		end
		if result == void then 
			result := any.getValue(o.oid())
		end
	end
	
	/**
	 * Adds a simple trace to be able to retrieve ancestor for an element
	 * param o : element from base model
	 * param r : element from aspect model
	 */
	operation addSimpleTrace(o : Mergeable, r : Mergeable) is do
		any.put(o.oid(), r)
		reverse.put(r.oid(), o)
	end
	
	/**
	 * Gets the source of a composed object
	 * param r : element created through the process of composition
	 * returns the predecessor of r if found, void otherwise
	 */
	operation getAncestor(r : Mergeable) : Mergeable is do
		result := reverse.getValue(r.oid())
	end
	
	/**
	 * Give the information that an object has been processed in fixReferences
	 * param e : element processed
	 */
	operation addProcessedElement(e : Mergeable) is do
		processed.put(e.oid(), true)
	end
	
	/**
	 * Tests if an object has been processed in fixReferences
	 * param e : element to test
	 * returns true if e has been processed, false otherwise
	 */
	operation isProcessed(e : Mergeable) : kermeta::standard::Boolean is do
		result := processed.getValue(e.oid()) != void
	end
}

/** This class contain the "compose" operation that should be used to recusively merge two models from their roots */
class ModelElementComposer
{
	reference resources: kermeta::persistence::EMFResource [0..*]
	
	/**
	 * Global method of composition
	 * param m1 : root element from base model
	 * param m2 : root element from aspect model
	 * param logger : KLogger object
	 * returns a mergeable object
	 */
	operation compose(m1 : Mergeable, m2 : Mergeable, composer : Composer) : Mergeable is do
		var ctx : MergeContext init MergeContext.new.initialize
		KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : initialize")
		KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : addAll")
		ctx.resources.addAll(self.resources)
		KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : indexate m1")
		ctx.indexate(m1)
		KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : indexate m2")
		ctx.indexate(m2)
		KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : end indexate")
		if m1 == void or m2 == void then
			var ex : kermeta::exceptions::Exception init kermeta::exceptions::Exception.new
			ex.message := "Model elements are not mergeable"
			raise ex
		end
		KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : trying to compose "+m1.toString+" / "+m2.toString)
		KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : signatures "+(m1.getSignature==m2.getSignature).toString)
		if m1.getSignature == m2.getSignature then
			KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : merging")
			result := m1.merge(m2, ctx, composer)
			KLogger.getDefault().asType(KLogger).printDebug("compose merge.kmt : fixReferences")
			result := fixReferences(result, ctx)			
		else
			KLogger.getDefault().asType(KLogger).printInfo("Models not mergeable")
		end
	end	
	
	/**
	 * Restore broken links between elements or between resource and elements
	 * param e : an object result of the composition
	 * param ctx : index context
	 * returns a restored mergeable object
	 */
	operation fixReferences(e1 : Mergeable, ctx : MergeContext) : Mergeable is do
		var e : Mergeable init e1
		// the object is already processed
		if ctx.isProcessed(e) then
			result := e
		else 
			if ctx.isComposedObject(e) then	
				result := e
			else	
				// Get the composed object
				result := ctx.getComposedObject(e)				
				// if no composed object the it has to be created
				if result == void then 
					result ?= e.getMetaClass.new
					ctx.addSimpleTrace(e, result)
				else 
					// if it is a composed object we should process it
					// and not only one of its ancestors
					e := result
				end
			end
			if not ctx.isProcessed(result) then
				ctx.addProcessedElement(result)				
				// Process the properties of the object
				var me : Mergeable
				var mcls : ClassDefinition 
				var objs : Collection<Object>
				var objres : Hashtable<Object, Object>
				mcls ?= e.getMetaClass.typeDefinition
				mcls.allAttribute.select{ k | not k.isDerived }.each{ p | 
					if p.upper == 1 then 
						me ?= e.get(p)
						if me != void then
							if ctx.isProcessed(me).orElse{e|ctx.isComposedObject(me)}.orElse{e|ctx.objectIndex.containsKey(me.oid())} then
								result.~set(p, fixReferences(me, ctx))
							else								
									result.~set(p, e.get(p))
							end
						else
								result.~set(p, e.get(p))
						end
					else
						objs ?= e.get(p)
						objres := Hashtable<Object, Object>.new
						objs.each{ o |
							me ?= o
							if me != void then
								objres.put(me, fixReferences(me, ctx))
							end
						}
						objs ?= result.get(p)
						objres.keys.each{ k |
							objs.remove(k)
							objs.add(objres.getValue(k))
							KLogger.getDefault().asType(KLogger).printDebug("OBJRES = "+result.toString + "." + p.name + " + " + objres.getValue(k).toString)
						}
						objs ?= result.get(p)
					end
				}
			end
		end
	end
}
/** The superclass for signature the equals operation has to be 
    defined for each type of signature */
abstract class Signature
{
}

/** Example of signature based on a String */
class StringSignature inherits Signature
{
	attribute sign : kermeta::standard::String
	
	method equals(other : Object ) : kermeta::standard::Boolean is do
		var othersign : StringSignature
		othersign ?= other
		if othersign != void then
			result := sign == othersign.sign
		else
			result := false
		end
	end	
}

/**
 * Kompose logging class
 */
class KLogger
{
	attribute tracingEnabled : Boolean
	attribute error : String
	attribute debug : String
	attribute info : String
	
	/**
	 * Initializes static information
	 */
	operation initialize() is do
		error := "-ERROR: "
		info := "-INFO: "
		debug := "-DEBUG: "
	end
	
	/**
	 * Prints an error message in the console view
	 * param message : the message to print
	 */
	operation printError(message : String) : Void is do
		stdio.writeln("KOMPOSE"+error+ message)
	end
	
	/**
	 * Prints a debug message in the console view
	 * param message : the message to print
	 */
	operation printDebug(message : String) : Void is do
		if tracingEnabled then
			stdio.writeln("KOMPOSE"+debug+ message)
		end
	end
	
	/**
	 * Prints an information message in the console view
	 * param message : the message to print
	 */
	operation printInfo(message : String) : Void is do
		stdio.writeln("KOMPOSE"+info+ message)
	end
	
	/**
	 * Enables the debugging messages
	 * param b : true to activate logging, false otherwise
	 */
	operation enableLog(b: Boolean): Void is do
		tracingEnabled := b
	end
}

class KTrace {

	operation newModelTrace(o1 : kermeta::standard::Object, o2 : kermeta::standard::Object) : Trace is do
		var traceElement : Trace init Trace.new
		var message : Message init Message.new
		var src_ref : ModelReference
		var target_ref : ModelReference
		message.~value := "diff"
		if o1.isVoid() then
			if o2.isVoid() then
			else
				target_ref := ModelReference.new
				target_ref.refObject := o2
				traceElement.targetReferences.add(target_ref)
			end
		else
			src_ref := ModelReference.new
			src_ref.refObject := o1
			traceElement.sourceReferences.add(src_ref)
			if o2.isVoid() then
			else
				target_ref := ModelReference.new
				target_ref.refObject := o2
				traceElement.targetReferences.add(target_ref)
				message.~value := "match"
			end
		end
		traceElement.description.add(message)
		result := traceElement
	end
	
	/*operation newDataTrace(o1 : kermeta::standard::Object, o2 : kermeta::standard::Object) : Trace is do
		var traceElement : Trace init Trace.new
		var message : Message init Message.new
		var src_ref : DataReference
		var target_ref : DataReference
		message.~value := "diff"
		if o1.isVoid() then
			if o2.isVoid() then
			else
				target_ref := DataReference.new
				target_ref.refData := o2
				traceElement.targetReferences.add(target_ref)
			end
		else
			src_ref := DataReference.new
			src_ref.refData := o1
			traceElement.sourceReferences.add(src_ref)
			if o2.isVoid() then
			else
				target_ref := DataReference.new
				target_ref.refData := o2
				traceElement.targetReferences.add(target_ref)
				message.~value := "match"
			end
		end
		traceElement.description.add(message)
		result := traceElement
	end*/
}