/*
 * Kompose 2008 - http://www.kermeta.org/mdk/kompose
 * 
 * author: Freddy Munoz - fmunoz(at)irisa.fr - Triskell Team
 * author: Mickael Clavreul - mclavreu(at)irisa.fr - Triskell Team
 * 
 */
 package kompose;

require "merge.kmt" 

using kermeta::language::structure
using kermeta::utils
using kermeta::persistence

/** 
 * Main class of the Kompose process
 */
class KomposeMain {

	/**
	 * Constructs a composer with full information of the elements to compose
	 * and pre-loading of directives
	 * param path : path of the komposition model (*.kompose)
	 * param composer : Specific composer to initialize
	 * param logging : boolean to enable debugging informations or not
	 * returns a composer
	 */
	operation loadComposer(path : String, composer : kompose::Composer, logging : Boolean) : kompose::Composer is do
		var resource : kermeta::persistence::EMFResource             
   		var repository : EMFRepository init EMFRepository.new             
       	resource ?= repository.createResource(path, "http://www.kermeta.org/kompose")
        resource.load
        var c : kompose::Composer
        c ?= resource.instances.one
        // Convert the loaded composer to a custom composer
        result := composer
        result.predirectivesPM.addAll(c.predirectivesPM)
        result.predirectivesAM.addAll(c.predirectivesAM)
        result.postdirectives.addAll(c.postdirectives)
        result.primaryModelURI := c.primaryModelURI
        result.aspectModelURI := c.aspectModelURI
        result.composedModelURI := c.composedModelURI
        result.logger := KLogger.new
        result.logger.initialize
        result.logger.enableLog(logging)
	end
}

/** 
 * Abstract class Composer
 */
aspect abstract class Composer {

	reference resources: kermeta::persistence::EMFResource [0..*]   
	reference logger : KLogger
	
	/**
	 * Loads a specific model from uri
	 * param path : path of the model to load
	 * returns the root of the model as a Mergeable element
	 */
	operation loadModel(path : String) : kompose::Mergeable is do
    	var resource : kermeta::persistence::EMFResource             
   		var repository : EMFRepository init EMFRepository.new             
       	resource ?= repository.getResource(path)
        resource.load
        self.resources.add(resource)
    	result ?= resource.instances.one
   end
   
   /**
	 * Saves a specific model to uri
	 * param model : root element of the model
	 * param uri : uri to save the model in
	 * param metamodelUri : the metamodel's identifier
	 */
   operation saveModelByUri(model : kompose::Mergeable, uri : String, metamodelUri : String) is do
   		var resource : kermeta::persistence::EMFResource             
   		var repository : EMFRepository init EMFRepository.new
   		resource ?= repository.createResource(uri, metamodelUri)
        resource.instances.add(model)
      //  repository.findDanglingModelElements().each{e|stdio.writeln(e.toString)}
      	resource.save
   end
   
   /**
	 * Abstract save of a specific model to uri
	 * Should be redefined for each specialization
	 * param model : root element of the model
	 * param uri : uri to save the model in
	 */
    operation saveModel(model : Mergeable, uri : String) : Void is abstract
    
    /**
	 * Initialize the context of the generic directives engine
	 * param model : root element of the model
	 * returns a new context
	 */
    // Can be extended for a specific meta-model
    // If the Create directive is to be used, the "classes" property of the context
    // should be populated with the classes that might be instanciated using the
    // create directive
    operation createContext(model : Mergeable) : Context is do
    	result := Context.new
    	result.initialize(model)
    end
	
	/**
	 * Executes directives on a model
	 * param model : root element of the model
	 * param directives : set of directives to be applied
	 */
	operation executeDirectives(model : Mergeable, directives : oset ElementDirective[*]) is do
		// create the context
		var context : Context init createContext(model)

		directives.each{ d | 
			d.context := context
			d.execute
		}
	end
	
	/**
	 * Global composition operation that realizes the whole process of composition
	 * returns the root of the composed model
	 */
	operation compose() : Mergeable is do
		// load models to compose
		self.logger.printInfo("Loading models...")
		var pm : Mergeable init loadModel(primaryModelURI)
		var am : Mergeable init loadModel(aspectModelURI)
		var cm : Mergeable
		self.logger.printInfo("OK")
		
		// execute pre-directives
		self.logger.printInfo("Executing predirectives on primary model...")
		executeDirectives(pm, predirectivesPM)
		self.logger.printInfo("OK")
		self.logger.printInfo("Executing predirectives on aspect model...")
		executeDirectives(am, predirectivesAM)
		self.logger.printInfo("OK")
		
		// perform the composition
		self.logger.printInfo("Composing models...")
		var composer : ModelElementComposer init ModelElementComposer.new
		composer.resources.addAll(self.resources)
		cm := composer.compose(pm, am,self.logger)
		
		// execute post-directives
		self.logger.printInfo("Executing postdirectives on composed model...")
		executeDirectives(cm, postdirectives)
		self.logger.printInfo("OK")
		
		// save the result
		self.logger.printInfo("Saving composed model...")
		saveModel(cm, composedModelURI)
        self.logger.printInfo("OK")
        result := cm
        
    rescue (ex : DirectiveRuntimeException)
   		self.logger.printError("\n" + ex.toString)
   		self.logger.printInfo("composition aborded.")
	end
	
}

/** 
 * Directive class
 */
aspect class ElementDirective {
	
	/**
	 * Abstract method to get the symbol of a directive
	 */
	operation getSymb() : String is abstract
}

/** 
 * Remove class : directive that deletes a value of a property
 */
aspect class Remove
{
	method execute() is do
		// resolve the target object
		var targetObj : Mergeable init resolveTarget
		// find the property
		var prop : Property init getProperty(targetObj)
		// get value
		var val : Object init resolveValue
		
		//TODO: check that the type of the value is correct
		// remove the value
		var c : kermeta::standard::Collection<Object> 
		c ?= targetObj.get(prop)
		c.remove(val)
	end
	
	method getSymb() : String is do
		result := "-"
	end
}

/** 
 * Add class : directive that adds a new value to a property
 */
aspect class Add
{
	method execute() is do
		// resolve the target object
		var targetObj : Mergeable init resolveTarget
		// find the property
		var prop : Property init getProperty(targetObj)
		// get value
		var val : Object init resolveValue
		
		//TODO: check that the type of the value is correct
		// add the value
		var c : kermeta::standard::Collection<Object> 
		c ?= targetObj.get(prop)
		c.add(val)
	end
	
	method getSymb() : String is do
		result := "+"
	end
	
}

/** 
 * Create class : directive that creates a new element in a model
 */
aspect class Create
{	
	method toString() : String is do
		result := 	"create " + className + " as " + "$" + identifier
	end
	
	method execute() is do
		// get the class
		var cls : Class init context.classes.getValue(className)
		// raise an exception if the class was not found
		if cls == void then 
			var ex : ClassNotFoundException init ClassNotFoundException.new
			ex.createDirective := self
			raise ex
		end
		// create the object
		var obj : Object init cls.new
		// add the object to the context
		context.setVariable(identifier, obj)
	end
} 

/** 
 * Set class : directive that sets he value of a property
 */
aspect class Set
{
	method execute() is do
		// resolve the target object
		var targetObj : Mergeable init resolveTarget
		// find the property
		var prop : Property init getProperty(targetObj)
		// get value
		var val : Object init resolveValue
		
		//TODO: check that the type of the value is correct
		//if val.isInstanceOf(prop.type.asType(Class)) then
		// set the value
			targetObj.~set(prop, val)
		//else
		//	stdio.writeln("TYPE ERROR : The type of property " + prop.name + " is " + prop.type.toString)
		//end
	end
	
	method getSymb() : String is do
		result := "="
	end
}

/** 
 * ElementRef class
 */
aspect class ElementRef
{
	operation getElement(c: Context) : Object is abstract
}

/** 
 * NameRef class : represents a reference by name
 */
aspect class NameRef
{
	method toString() : String is do
		result := qname
	end
	
	method getElement(c: Context) : Object is do
		// Splits the qualified name 
		var names : kermeta::standard::Sequence<String> init kermeta::standard::Sequence<String>.new
		var str : String
		from  str := qname
		until str.indexOf("::") < 0
		loop
			names.add(str.substring(0, str.indexOf("::")))
			str := str.substring(str.indexOf("::")+2, str.size)
		end
		names.add(str)
		
		// checks the name of the first package
		if names.elementAt(0) != c.model.getStringID then
		 	var ex : ElementNotResolvedException init ElementNotResolvedException.new
			ex.elementRef := self
			raise ex
		end
		// removes the root of the model
		names.removeAt(0)
		
		// iterates on names
		var ne : Mergeable 
		var cur : Mergeable init c.model
		var found : Boolean
		
		// iterates on each name and contained resources
		names.each{ n |
			found := false
			getContents(cur).each{ e | 
				ne ?= e
				if ne != void then
					//stdio.writeln(" --found |" +  ne.getStringID + "| (looking for |"+ n +"|)" )
					if n == ne.getStringID then 
						cur := ne
						found := true						
					end
				end
			}
			if not found then
				var ex : ElementNotResolvedException init ElementNotResolvedException.new
				ex.elementRef := self
				raise ex
			end
		}
		result := cur
	rescue (e : kermeta::exceptions::Exception)
		stdio.writeln(e.message)
		result := void	
	end
	
	/** get all the objects containes by the object c */
	operation getContents(c : Object) : kermeta::standard::Collection<Object> is do
		result := kermeta::standard::Sequence<Object>.new 
		// get the meta class
		var mclass : ClassDefinition
		mclass ?= c.getMetaClass.typeDefinition
		//select composite properties
		var props : seq Property[*] init 
			mclass.allAttribute.select{ p | 
		    	p.isComposite and Mergeable.isSuperTypeOf(p.type)
			}
		var objs : kermeta::standard::Collection<Object>
		props.each{ p | 
			if p.upper == 1 then 
				result.add(c.get(p))
			else
				objs ?= c.get(p)
				objs.each{ o | result.add(o) }
			end	
		}
	end
}

/** 
 * IDRef class : represents a variable
 */
aspect class IDRef
{	
	method toString() : String is do
		result := "$" + identifier
	end
	
	method getElement(c: Context) : Object is do
		result := c.getVariable(identifier)
	end
}

/** 
 * Change class : represents a modification of a property
 */
aspect abstract class Change
{	
	method toString() : String is do
		result := 	target.toString+"." +propertyName+ " " + 
					getSymb +" " + ~value.toString
	end
	
	/* resolve the target models element */
	operation resolveTarget() : Mergeable is do
		result ?= target.getElement(context)
		if result == void then 
			var ex : TargetNotFoundException init TargetNotFoundException.new
			ex.changeDirective := self
			raise ex
		end 
	end
	
	/* resolve the value */
	operation resolveValue() : Object is do
		result := ~value.getElement(context)
		if result == void then 
			var ex : ValueNotFoundException init ValueNotFoundException.new
			ex.changeDirective := self
			raise ex
		end 
	end
	
	/* Get the property in the targetObject */
	operation getProperty(targetObj : Mergeable) : Property is do
		// get the meta class
		var mclass : ClassDefinition
		mclass ?= targetObj.getMetaClass.typeDefinition
		//select the property
		var prop : seq Property[*] init 
			mclass.allAttribute.select{ p | 
		    	p.name == propertyName 
			}
		// check that it exists
		if prop.size == 0 then
			var ex : PropertyNotFoundException init PropertyNotFoundException.new
			ex.changeDirective := self 
			raise ex
		end
		result := prop.one
	end

}

/** 
 * StringLiteral class
 */
aspect class StringLiteral
{	
	method toString() : String is do
		result := "\"" + ~value.toString + "\""
	end
	
	method getElement(c: Context) : Object is do
		result := ~value
	end
}

/** 
 * BooleanLiteral class
 */
aspect class BooleanLiteral
{	
	method toString() : String is do
		result := ~value.toString
	end
	
	method getElement(c: Context) : Object is do
		result := ~value
	end
}

/** 
 * IntegerLiteral class
 */
aspect class IntegerLiteral
{	
	method toString() : String is do
		result := ~value.toString
	end
	
	method getElement(c: Context) : Object is do
		result := ~value
	end
}

/** 
 * VoidLiteral class
 */
aspect class VoidLiteral
{
	method toString() : String is do
		result := "void"
	end
}

/** 
 * Context class
 */
aspect class Context
{
	reference model : Mergeable
	reference variables : Hashtable<String, Object>
	reference classes : Hashtable<String, Class>
	
	operation initialize(model : Mergeable) is do
		self.model := model
		variables := Hashtable<String, Object>.new
		classes := Hashtable<String, Class>.new
	end
	
	operation getVariable(name : String) : Object is do
		result := variables.getValue(name)
	end
	
	operation setVariable(name : String, val : Object) is do
		variables.put(name, val)
	end
}

/* Exception that can be raised when directives are executed */
abstract class DirectiveRuntimeException inherits kermeta::exceptions::Exception {
	reference directive : CompositionDirective
	
	method toString() : String is do
		result := "An exception was raised while executing directive " + directive.toString
	end
}

/* Eception raised if and element cannot be resolved */
class ElementNotResolvedException inherits DirectiveRuntimeException {
	reference elementRef : ElementRef
}

/* The target for a Change directive was not found */
class TargetNotFoundException inherits ElementNotResolvedException {
	property changeDirective : Change 
		getter is do result ?= directive end
		setter is do directive := value elementRef := value.target end
	
	method toString() : String from DirectiveRuntimeException is do
		result := super + "\nTarget object "+ elementRef.toString +" could not be resolved"
	end
}

/* The value for a Change directive was not found */
class ValueNotFoundException inherits ElementNotResolvedException {
	property changeDirective : Change 
		getter is do result ?= directive end
		setter is do directive := value elementRef := value.~value end
		
	method toString() : String from DirectiveRuntimeException is do
		result := super + "\nValue object "+ elementRef.toString +" could not be resolved"
	end
}

/* The property could not be found */
class PropertyNotFoundException inherits DirectiveRuntimeException {
	property changeDirective : Change 
		getter is do result ?= directive end
		setter is do directive := value end
		
		method toString() : String from DirectiveRuntimeException is do
			result := super + "\nProperty "+ changeDirective.propertyName +" could not be found"
		end
}

/* The metaclass could not be found */
class ClassNotFoundException inherits DirectiveRuntimeException {
	property createDirective : Create 
		getter is do result ?= directive end
		setter is do directive := value end

	method toString() : String from DirectiveRuntimeException is do
		 result := super + "\nMeta-Class "+ createDirective.className +" could not be found"
	end
}