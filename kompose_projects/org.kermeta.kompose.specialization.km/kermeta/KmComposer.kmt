/*
 * Code generated by Kompose Specialization wizard v0.1
 * Kompose 2007 - http://www.kermeta.org/kompose
 * 
 * author: Freddy Munoz - fmunoz(at)irisa.fr - Triskell Team
 * author: Mickael Clavreul - mclavreu(at)irit.fr - Triskell Team
 * 
 */
package kermeta::language::structure;

require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "platform:/plugin/org.kermeta.kompose.core.model/kermeta/kompose.kmt"
//require "platform:/resource/org.kermeta.kompose.core.model/kermeta/kompose.kmt"
using kermeta::standard
using kermeta::utils
using kermeta::persistence

// 1) Definition of the specific composer

class KMComposer inherits kompose::Composer
{   
	method saveModel(model : kompose::Mergeable, uri : String) is do
   		self.saveModelByUri(model, uri, "http://www.kermeta.org/kermeta/1_2_0//kermeta")
   end
   
   method createContext(model : kompose::Mergeable) : kompose::Context is do
   		result := super(model)
   		// FIXME Objects from dedicated metamodel have to be added
   		//result.classes.put("ContextObject", ContextObjectClass)
   		
   		result.classes.put("Object", Object)
   			/*result.classes.put("Type",Type)
   				result.classes.put("VoidType",VoidType)
   				result.classes.put("ProductType",ProductType)
   				result.classes.put("FunctionType",FunctionType)*/
   				result.classes.put("ParameterizedType",ParameterizedType)
   				/*	result.classes.put("ModelType",ModelType)
   					result.classes.put("Class",Class)
   				result.classes.put("TypeVariable",TypeVariable)*/
   				result.classes.put("DataType",DataType)
   					/*result.classes.put("Enumeration",Enumeration)*/
   			result.classes.put("NamedElement",NamedElement)
   			result.classes.put("ModelingUnit",ModelingUnit)
   				/*result.classes.put("TypeDefinitionContainer",TypeDefinitionContainer)
   					result.classes.put("ModelTypeDefinition",ModelTypeDefinition)
   				result.classes.put("EnumerationLiteral",EnumerationLiteral)*/
   				result.classes.put("Package",Package)
   				/*result.classes.put("TypeDefinition",TypeDefinition)
   					result.classes.put("GenericTypeDefinition",GenericTypeDefinition)
   				result.classes.put("TypedElement",TypedElement)
   					result.classes.put("MultiplicityElement",MultiplicityElement)
   						result.classes.put("Property",Property)
   						result.classes.put("Parameter",Parameter)
   						result.classes.put("Operation",Operation)
   			result.classes.put("TypeContainer",TypeContainer)*/
   				result.classes.put("ClassDefinition",ClassDefinition)
   				/*result.classes.put("PrimitiveType",PrimitiveType)*/
   			//result.classes.put("TypeVariableBinding",TypeVariableBinding)
   			//result.classes.put("Tag",Tag)
   			//result.classes.put("VirtualType",VirtualType)
   		
		/*result.classes.put("Class", EClass)
		result.classes.put("Attribute", EAttribute)
		result.classes.put("Reference", EReference)
		result.classes.put("Operation", EOperation)
		result.classes.put("Parameter", EParameter)
		*/
 
   end
}

// 2) Definition of specific signature classes

/*
 * this lines of code are specific to the Ecore metamodel. Other specializations may mimic this code
 */
class PackageSignature inherits kompose::Signature
{
	reference pack : Package 
	
	method equals(other : Object ) : Boolean is do
		var othersign : PackageSignature
		othersign ?= other
		if othersign != void then
			//stdio.write("**** DEBUG Equals Package "+self.pack.name+" / "+othersign.pack.name)
			result := self.pack.name == othersign.pack.name 
			
			/*self.op.eParameters.each{ p1 | 
				if result then
					result := othersign.op.eParameters.select{ p2 | p1.getSignature.equals((p2.getSignature)) }.size == 1
				end
			}*/
		else
			result := false
		end
		//stdio.write(" : "+result.toString+"\n")
		//stdio.writeln("**** DEBUG End Equals Package ")
	end
	
}

class ModelingUnitSignature inherits kompose::Signature
{
	reference mu : ModelingUnit 
	
	method equals(other : Object ) : Boolean is do
		var othersign : ModelingUnitSignature
		othersign ?= other
		if othersign != void then
			//stdio.write("**** DEBUG Equals MU "+self.mu.toString+" / "+othersign.mu.toString)
			//result := self.mu.packages == othersign.mu.name 
			
			self.mu.packages.each{ p1 | 
				//if result then
					result := othersign.mu.packages.select{ p2 | p1.getSignature.equals((p2.getSignature)) }.size == 1
				//end
			}
		else
			result := false
		end
		//stdio.write(" : "+result.toString+"\n")
		//stdio.writeln("**** DEBUG End Equals MU ")
	end
	
}
class ParameterizedTypeSignature inherits kompose::Signature
{
	reference type : ParameterizedType 
	
	method equals(other : Object ) : Boolean is do
		var othersign : ParameterizedTypeSignature
		othersign ?= other
		if othersign != void then
			//stdio.write("**** DEBUG Equals ParameterizedType "+self.type.toString+" / "+othersign.type.toString)
			//stdio.writeln(othersign.type.typeDefinition.toString)
			/* Case test for Parameterized type definition as class */
			var otherType : ClassDefinition
			if othersign.type.typeDefinition.isKindOf(ClassDefinition) then
				otherType ?= othersign.type.typeDefinition
			end
			var selfType : ClassDefinition
			if self.type.typeDefinition.isKindOf(ClassDefinition) then
				selfType ?= self.type.typeDefinition
			end
			if (otherType != void).andThen{e|selfType != void} then
				/*stdio.writeln("ClassDefinitions")
				stdio.writeln("otherType.qualifiedName() = "+otherType.qualifiedName())
				stdio.writeln("selfType.qualifiedName() = "+selfType.qualifiedName())*/
				result := otherType.qualifiedName().equals(selfType.qualifiedName())
			else
				result := false
			end
		else
			result := false
		end
		//stdio.write(" : "+result.toString+"\n")
		//stdio.writeln("**** DEBUG End Equals ParameterizedType ")
	end
	
}

class ClassDefinitionSignature inherits kompose::Signature
{
	reference cd : ClassDefinition 
	
	method equals(other : Object ) : Boolean is do
		var othersign : ClassDefinitionSignature
		othersign ?= other
		if othersign != void then
			//stdio.write("**** DEBUG Equals CD "+self.cd.toString+" / "+othersign.cd.toString)
			result := othersign.cd.name.equals(self.cd.name)
		else
			result := false
		end
		//stdio.write(" : "+result.toString+"\n")
		//stdio.writeln("**** DEBUG End Equals CD ")
	end
	
}

/*class TypeVariableBindingSignature inherits kompose::Signature
{
	reference tvb : TypeVariableBinding 
	
	method equals(other : Object ) : Boolean is do
		var othersign : TypeVariableBindingSignature
		othersign ?= other
		if othersign != void then
			stdio.write("**** DEBUG Equals TVB "+self.tvb.toString+" / "+othersign.tvb.toString)
			result := othersign.tvb.type.equals(self.tvb.type)// and othersign.tvb.variable.getSignature == self.tvb.variable.getSignature
			//result := true
		else
			result := false
		end
		stdio.write(" : "+result.toString+"\n")
		stdio.writeln("**** DEBUG End Equals TVB ")
	end
	
}*/

/*class VirtualTypeSignature inherits kompose::Signature
{
	reference vt : VirtualType 
	
	method equals(other : Object ) : Boolean is do
		/*var othersign : VirtualTypeSignature
		othersign ?= other
		if othersign != void then
			stdio.write("**** DEBUG Equals VT "+self.vt.toString+" / "+othersign.vt.toString)
			result := self.vt.classDefinition.equals(othersign.vt.classDefinition).andThen{e|}
		else
			result := false
		end
		stdio.write(" : "+result.toString+"\n")
		stdio.writeln("**** DEBUG End Equals VT ")
		result:=true
	end
	
}

class GenericTypeDefinitionSignature inherits kompose::Signature
{
	reference gtd : GenericTypeDefinition 
	
	method equals(other : Object ) : Boolean is do
		var othersign : GenericTypeDefinitionSignature
		othersign ?= other
		if othersign != void then
			stdio.write("**** DEBUG Equals VT "+self.gtd.toString+" / "+othersign.gtd.toString)
			result := self.gtd.typeParameter.equals(othersign.gtd.typeParameter)
		else
			result := false
		end
		stdio.write(" : "+result.toString+"\n")
		stdio.writeln("**** DEBUG End Equals VT ")
	end
	
}*/

/*class PrimitiveTypeSignature inherits kompose::Signature
{
	reference pt : PrimitiveType 
	
	method equals(other : Object ) : Boolean is do
		var othersign : PrimitiveTypeSignature
		othersign ?= other
		if othersign != void then
			stdio.write("**** DEBUG Equals PT "+self.pt.toString+" / "+othersign.pt.toString)
			result := self.pt.instanceType.equals(othersign.pt.instanceType)
		else
			result := false
		end
		stdio.write(" : "+result.toString+"\n")
		stdio.writeln("**** DEBUG End Equals PT ")
	end
	
}*/

/*class TypeSignature inherits kompose::Signature
{
	reference type : Type 
	
	method equals(other : Object ) : Boolean is do
		var othersign : TypeSignature
		othersign ?= other
		if othersign != void then
			stdio.write("**** DEBUG Equals Type "+self.type.toString+" / "+othersign.type.toString)
			result := othersign.type.typeContainer.equals(self.type.typeContainer)
		else
			result := false
		end
		stdio.write(" : "+result.toString+"\n")
		stdio.writeln("**** DEBUG End Equals Type ")
	end
	
}*/

/*class PropertySignature inherits kompose::Signature
{
	reference ~property : Property 
	
	method equals(other : Object ) : Boolean is do
		var othersign : PropertySignature
		othersign ?= other
		if othersign != void then
			stdio.writeln("**** DEBUG Equals Property "+self.~property.toString+" / "+othersign.~property.toString+" : "+result.toString)
			//result := self.mu.packages == othersign.mu.name 
			/*if self.~property.isComposite() then
				result := othersign.~property.getSignature.equals((self.~property.getSignature))
			else*/
			//	result := othersign.~property.name.equals(self.~property.name)
			//end
			/*self.~property.packages.each{ p1 | 
				//if result then
					result := othersign.~property.packages.select{ p2 | p1.getSignature.equals((p2.getSignature)) }.size == 1
				//end
			}*/
		/*else
			result := false
		end
		stdio.writeln("**** DEBUG End Equals Property ")
	end
	
}*/
/*
class OperationSignature inherits kompose::Signature
{
	reference op : EOperation 
	
	method equals(other : Object ) : Boolean is do
		var othersign : OperationSignature
		othersign ?= other
		if othersign != void then
			result := self.op.name == othersign.op.name 
			
			self.op.eParameters.each{ p1 | 
				if result then
					result := othersign.op.eParameters.select{ p2 | p1.getSignature.equals((p2.getSignature)) }.size == 1
				end
			}
		else
			result := false
		end
	end
	
}

class ParameterSignature inherits kompose::Signature
{
	reference param : EParameter 
	
	method equals(other : Object ) : Boolean is do
		var othersign : ParameterSignature
		othersign ?= other
		if othersign != void then
			result := self.param.name == othersign.param.name and
				self.param.eType.getSignature.equals(othersign.param.eType.getSignature)
		else
			result := false
		end
	end
	
}*/

// 3) Extentions to the metamodel

/*@aspect "true"
class Object inherits kompose::Mergeable {}
@aspect "true"
class Type inherits kompose::Mergeable {}
/*@aspect "true"
class VoidType inherits kompose::Mergeable {}
@aspect "true"
class ProductType inherits kompose::Mergeable {}
@aspect "true"
class FunctionType inherits kompose::Mergeable {}*/
@aspect "true"
class ParameterizedType inherits kompose::Mergeable {}
/*@aspect "true"
class ModelType inherits kompose::Mergeable {}
@aspect "true"
class Class inherits kompose::Mergeable {}
@aspect "true"
class TypeVariable inherits kompose::Mergeable {}
@aspect "true"
class DataType inherits kompose::Mergeable {}
@aspect "true"
class Enumeration inherits kompose::Mergeable {}*/
@aspect "true"
class NamedElement inherits kompose::Mergeable {}
@aspect "true"
class ModelingUnit inherits kompose::Mergeable {}
/*@aspect "true"
class TypeDefinitionContainer inherits kompose::Mergeable {}
@aspect "true"
class ModelTypeDefinition inherits kompose::Mergeable {}
@aspect "true"
class EnumerationLiteral inherits kompose::Mergeable {}*/
@aspect "true"
class Package inherits kompose::Mergeable {}
/*@aspect "true"
class TypeDefinition inherits kompose::Mergeable {}
@aspect "true"
class GenericTypeDefinition inherits kompose::Mergeable {}
@aspect "true"
class TypedElement inherits kompose::Mergeable {}
@aspect "true"
class MultiplicityElement inherits kompose::Mergeable {}
@aspect "true"
class Property inherits kompose::Mergeable {}
@aspect "true"
class Parameter inherits kompose::Mergeable {}
@aspect "true"
class Operation inherits kompose::Mergeable {}
@aspect "true"
class TypeContainer inherits kompose::Mergeable {}*/
@aspect "true"
class ClassDefinition inherits kompose::Mergeable {}
/*@aspect "true"
class PrimitiveType inherits kompose::Mergeable {}
@aspect "true"
class TypeVariableBinding inherits kompose::Mergeable {}
@aspect "true"
class Tag inherits kompose::Mergeable {}*/
/*@aspect "true"
class VirtualType inherits kompose::Mergeable{}*/

@aspect "true"
class NamedElement
{
	method getSignature() : kompose::Signature is do
		var s : kompose::StringSignature init 
			kompose::StringSignature.new
		s.sign := name
		result := s
	end
	
	method getStringID() : String is do
		result := name
	end
}

@aspect "true"
class Package
{
	method getSignature() : kompose::Signature is do
		var s : PackageSignature init 
			PackageSignature.new
		s.pack := self
		result := s
	end
	
	/*method getStringID() : String is do
		result := name
	end*/
}

@aspect "true"
class ModelingUnit
{
	method getSignature() : kompose::Signature is do
		var s : ModelingUnitSignature init ModelingUnitSignature.new
		s.mu := self
		result := s
	end
}

/*@aspect "true"
class Type
{
	method getSignature() : kompose::Signature is do
		var s : TypeSignature init TypeSignature.new
		s.type := self
		result := s
	end
}*/

@aspect "true"
class ParameterizedType
{
	method getSignature() : kompose::Signature is do
		var s : ParameterizedTypeSignature init ParameterizedTypeSignature.new
		s.type := self
		result := s
	end
}

@aspect "true"
class ClassDefinition
{
	method getSignature() : kompose::Signature is do
		var s : ClassDefinitionSignature init ClassDefinitionSignature.new
		s.cd := self
		result := s
	end
}

/*@aspect "true"
class VirtualType
{
	method getSignature() : kompose::Signature is do
		var s : VirtualTypeSignature init VirtualTypeSignature.new
		s.vt := self
		result := s
	end
}

@aspect "true"
class GenericTypeDefinition
{
	method getSignature() : kompose::Signature is do
		var s : GenericTypeDefinitionSignature init GenericTypeDefinitionSignature.new
		s.gtd := self
		result := s
	end
}*/

/*@aspect "true"
class PrimitiveType
{
	method getSignature() : kompose::Signature is do
		var s : PrimitiveTypeSignature init PrimitiveTypeSignature.new
		s.pt := self
		result := s
	end
}*/

/*@aspect "true"
class Property
{
	method getSignature() : kompose::Signature is do
		var s : PropertySignature init 
			PropertySignature.new
		s.~property := self
		result := s
	end
	
	method getStringID() : String is do
		result := name
	end
}*/

/*@aspect "true"
class EOperation
{
	method getSignature() : kompose::Signature is do
		var s : OperationSignature init OperationSignature.new
		s.op := self
		result := s
	end
}

@aspect "true"
class EParameter
{
	method getSignature() : kompose::Signature is do
		var s : ParameterSignature init ParameterSignature.new
		s.param := self
		result := s
	end
}
*/

// 4) the Main
/*
 * This code must not be modified.
 */
class Main inherits kompose::KomposeMain
{
	operation main(uri : String) is do
		var c : kompose::Composer init loadComposer(uri,KMComposer.new)
		c.compose
	end
}

