/* $Id: LogoInterpreter.kmt,v 1.5 2007-05-31 12:07:40 ffleurey Exp $
 * Creation date: May 30, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "kmLogo::Interpreter"
@mainOperation "main"


package kmLogo;

require kermeta
require "ASMLogo.ecore"
require "VMLogo.ecore"


using kermeta::standard
using kermeta::utils
using kermeta::persistence
using kermeta::io


class Interpreter 
{
	attribute context : Context
	
	reference root : ASM::Instruction
	
	operation main() is
	do
		var root : ASM::Instruction
		context := Context.new()
		context.reset()
		root := loadProgram("tests/test1.xmi")
		root.eval(context)
	end
	
	operation loadProgram(uri : String) : ASM::Instruction is do
		var res : EMFRepository init EMFRepository.new
        var resource : Resource init res.createResource(uri, "http://kmLogo.ecore/ASM")
        resource.load()
        result ?= resource.instances.one  
	end
}

class Bindings inherits Hashtable<String,Integer> {}

class Context  {
	attribute stack : Stack<Bindings> 
	reference turtle : VM::Turtle 
	
	operation reset() is do
		stack := Stack<Bindings>.new()
		turtle := VM::Turtle.new()	
		turtle.PI := "3.14".toReal
	end
	
	operation pushFrame (frame : Bindings) is do
		stack.push(frame)
	end
	
	operation popFrame() : Bindings is do
		result := stack.pop
	end
	
	operation peekFrame() : Bindings is do
		result := stack.peek
	end
}

/**
 * Implementation of the Logo Virtual Machine
 */
package VM {

@aspect "true"

	class Turtle
	{
	
	attribute PI : Real
	

		operation reset() is do
			position := Point.new
			position.x := 0
			position.y := 0
			heading := 0
			drawings.clear
		end
				
		operation setPenUp(b : Boolean) is do
			penUp := b
		end
		
		operation rotate(angle : Integer)  is do
			heading := (heading + angle).mod(360)
		end
	
		operation move(dx : Integer, dy : Integer)  is do
			var newPos : Point
			newPos := position.getDelta(dx,dy)
			if penUp then
				stdio.writeln("Tortue se deplace en "+ newPos.toString)
			else
				stdio.writeln("Tortue trace vers "+ newPos.toString)
				var trace : Segment init Segment.new
				trace.make(position,newPos)
				drawings.add(trace)
			end
			position := newPos
		end
			
		operation forward(steps : Integer)  is do
			// move(Math.sin(heading)*steps,Math.cos(heading)*steps)
			// let's approximate sin/cos for square moves only
			if heading == 0 then move (0, steps) end
			if heading == 90 then move (steps,0) end
			if heading == 180 then move (0,-steps) end
			if heading == 270 then move (-steps,0) end
		end
	
	}

	
	@aspect "true"
	class Point
	{
		operation getDelta(dx : Integer, dy : Integer) : Point is do
			result := Point.new
			result.x := x + dx
			result.y := y + dy			
		end
		method toString() : String is do
			result := "[" + x.toString + "," + y.toString + "]"
		end
	}
	@aspect "true"
	class Segment
	{
		operation make (orig : Point, dest : Point) is do
			origin := orig
			destination := dest
		end
	}
}



/**
 * Implementation of the Abstract Syntactic Model
 */
package ASM {

	@aspect "true"
	class Instruction 
	{
		operation eval(context : Context) : Integer is do
			result := 0
		end
	}
	
	@aspect "true"
	class Constant
	{
		operation eval(context : Context) : Integer is do 
			result := integerValue
		end 
	}
	
	@aspect "true"
	class ParameterCall
	{
		operation eval(context : Context) : Integer is do 
			result := context.peekFrame.getValue(parameter.name)
		end 
	}
	
	@aspect "true"
	class Plus
	{
		operation eval(context : Context) : Integer is do 
			result := lhs.eval(context) + rhs.eval(context)
		end
	}
	
	@aspect "true"
	class Minus
	{
		operation eval(context : Context) : Integer is do 
			result := lhs.eval(context) - rhs.eval(context)
		end
	}
	
	@aspect "true"
	class Mult
	{
		operation eval(context : Context) : Integer is do 
			result := lhs.eval(context) * rhs.eval(context)
		end
	}
	
	@aspect "true"
	class Div
	{
		operation eval(context : Context) : Integer is do 
			result := lhs.eval(context) / rhs.eval(context)
		end
	}
	
	@aspect "true"
	class Equals
	{
		operation eval(context : Context) : Integer is do 
			result := if lhs.eval(context) == rhs.eval(context) then 1 else 0 end
		end
	}
	
	@aspect "true"
	class Greater
	{
		operation eval(context : Context) : Integer is do 
			result := if lhs.eval(context) > rhs.eval(context) then 1 else 0 end
		end
	}
	
	@aspect "true"
	class Lower
	{
		operation eval(context : Context) : Integer is do 
			result := if lhs.eval(context) < rhs.eval(context) then 1 else 0 end
		end
	}
	
	@aspect "true"
	class Block
	{
		operation eval(context : Context) : Integer is do 
			instructions.each{instruction  | result := instruction.eval(context)}
		end 
	}
	
	
	@aspect "true"
	class ProcCall
	{
		operation eval(context : Context) : Integer is do 
			// create a new stack frame
			var frame : Bindings init Bindings.new
			// push it on the stack
			context.pushFrame(frame)
			// for each formal arg, create a binding with actual value
			from var i : Integer init 0
			until i >= actualArgs.size
			loop			
				var actualValue : Integer init actualArgs.elementAt(i).eval(context) 
				frame.put(declaration.args.elementAt(i).name, actualValue)
				i := i + 1
			end
			// transfert control to procedure body
			result := declaration.block.eval(context)
			// pop stack frame
			context.popFrame
		end
	
	}
	
	
	@aspect "true"
	class If
	{
		operation eval(context : Context) : Integer is do 
			if condition.eval(context) != 0 then
				result := thenPart.eval(context)
			else
				result := elsePart.eval(context)
			end						
		end 
	}
	
	@aspect "true"
	class While
	{
		operation eval(context : Context) : Integer is do 
			var cond : Integer
			from cond := condition.eval(context)
			until cond == 0
			loop
				result := block.eval(context)
				cond := condition.eval(context)
			end			
		end 
	}
	@aspect "true"
	class Repeat
	{
		operation eval(context : Context) : Integer is do 
			from var i : Integer init condition.eval(context)
			until i < 1
			loop
				result := block.eval(context)
				i := i - 1
			end
		end 
	}
	
	/*
	* The semantics of the primitive constructs
	*/
	@aspect "true"
	class Back
	{
		operation eval(context : Context) : Integer is do 
			context.turtle.forward(-steps.eval(context))
		end
	}
	@aspect "true"
	class Forward
	{
		operation eval(context : Context) : Integer is do 
			context.turtle.forward(steps.eval(context))
		end
	}
	@aspect "true"
	class Left
	{
		operation eval(context : Context) : Integer is do 
			context.turtle.rotate(-angle.eval(context))
		end
	}
	@aspect "true"
	class Right
	{
		operation eval(context : Context) : Integer is do 
			context.turtle.rotate(angle.eval(context))
		end
	}
	@aspect "true"
	class PenDown
	{
		operation eval(context : Context) : Integer is do 
			context.turtle.setPenUp(false)
		end
	}
	@aspect "true"
	class PenUp
	{
		operation eval(context : Context) : Integer is do 
			context.turtle.setPenUp(true)
		end
	}
	@aspect "true"
	class Clear
	{
		operation eval(context : Context) : Integer is do 
			context.turtle.reset()
		end
	}
	
}
