/* $Id: LogoNXCCompiler.kmt,v 1.3 2007-10-24 15:25:54 dvojtise Exp $
 * Creation datresult.append("e: May 30, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "kmLogo::NXCCompiler"
@mainOperation "main"


package kmLogo;

require kermeta
require "ASMLogo.ecore"

using kermeta::standard
using kermeta::utils
using kermeta::persistence
using kermeta::io


/**
 * Implementation of the Abstract Syntactic Model
 */
package ASM {

	@aspect "true"
	class Instruction 
	{
		operation compileToNXC(context : NXCCompiler) : String is do
			result := "// NOT IMPLEMENTED"
		end
	}
	
	@aspect "true"
	class ProcDeclaration
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "// Declaration of " + name + " function"
			var proc : String init "sub " + name + "("
			from var i : Integer init 0
			until i >= args.size
			loop
				proc.append("int " + args.elementAt(i).name)
				if i < args.size - 1 then proc.append(", ") end
				i := i + 1
			end
			proc.append(")\n")
			var depth : Integer init context.depth
			context.depth := 0
			proc.append(block.compileToNXC(context))
			context.subs.add(proc)
			context.depth := depth
		end
	}
	
	@aspect "true"
	class Constant
	{
		method compileToNXC(context : NXCCompiler) : String is do
			if integerValue >= 0 then
				result := integerValue.toString
			else 
				result := "(" + integerValue.toString + ")"
			end
		end 
	}
	
	@aspect "true"
	class ParameterCall
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := parameter.name
		end 
	}
	
	@aspect "true"
	class Plus
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := lhs.compileToNXC(context) + " + " + rhs.compileToNXC(context)
		end
	}
	
	@aspect "true"
	class Minus
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := lhs.compileToNXC(context) + " - " + rhs.compileToNXC(context)
		end
	}
	
	@aspect "true"
	class Mult
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := lhs.compileToNXC(context) + " * " + rhs.compileToNXC(context)
		end
	}
	
	@aspect "true"
	class Div
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := lhs.compileToNXC(context) + " / " + rhs.compileToNXC(context)
		end
	}
	
	@aspect "true"
	class Equals
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := lhs.compileToNXC(context) + " == " + rhs.compileToNXC(context)
		end
	}
	
	@aspect "true"
	class Greater
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := lhs.compileToNXC(context) + " > " + rhs.compileToNXC(context)
		end
	}
	
	@aspect "true"
	class Lower
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := lhs.compileToNXC(context) + " < " + rhs.compileToNXC(context)
		end
	}
	
	@aspect "true"
	class Block
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := context.prefix + "{\n"
			context.incDepth
			instructions.each{ instruction  | 
				result.append(context.prefix + instruction.compileToNXC(context) + "\n") 
			}
			context.decDepth
			result.append(context.prefix + "}")
		end 
	}
	
	
	@aspect "true"
	class ProcCall
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := declaration.name + "("
			from var i : Integer init 0
			until i >= actualArgs.size
			loop
				result.append(actualArgs.elementAt(i).compileToNXC(context))
				if i < actualArgs.size - 1 then result.append(", ") end
				i := i+1
			end
			result.append(");")
		end
	
	}
	
	
	@aspect "true"
	class If
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "if (" + condition.compileToNXC(context) + ")\n"
			result.append(thenPart.compileToNXC(context))
			result.append("\n" + context.prefix + "else\n")
			result.append(elsePart.compileToNXC(context))
		end 
	}
	
	@aspect "true"
	class While
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := context.prefix + "while (" + condition.compileToNXC(context) + ")\n"
			result.append(block.compileToNXC(context))	
		end 
	}
	@aspect "true"
	class Repeat
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "repeat (" + condition.compileToNXC(context) + ")\n"
			result.append(block.compileToNXC(context))	
		end 
	}
	
	/*
	* The semantics of the primitive constructs 
	*/
	@aspect "true"
	class Back
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "forward(-(" + steps.compileToNXC(context) + "));"
		end
	}
	@aspect "true"
	class Forward
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "forward(" + steps.compileToNXC(context) + ");"
		end
	}
	@aspect "true"
	class Left
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "turn(" + angle.compileToNXC(context) + ");"
		end
	}
	@aspect "true"
	class Right
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "turn(-(" + angle.compileToNXC(context) + "));"
		end
	}
	@aspect "true"
	class PenDown
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "penDown();"
		end
	}
	@aspect "true"
	class PenUp
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "penUp();"
		end
	}
	
	@aspect "true"
	class Clear
	{
		method compileToNXC(context : NXCCompiler) : String is do
			result := "// RESET NOT IMPLEMENTED"
		end
	}
	
}

class NXCCompiler 
{	
	reference root : ASM::Instruction
	
	reference subs : String[*]
	reference depth : Integer
	property readonly prefix : String 
		getter is do
			result := ""
			depth.times{i | result.append("\t")}
		end 
	operation incDepth() is do depth := depth + 1 end
	operation decDepth() is do depth := depth - 1 end
	
	operation main() is
	do
		compile("tests/snowflake.xmi", "tests/test2.nxc", void)
	end
	
	operation compile(uri : String, out : String, api : String) : String is
	do
		
		var io : FileIO init FileIO.new
		depth := 0
		root := loadProgram(uri)
		var nxc : String init root.compileToNXC(self)
		// We shoudl read API from the file but right now it is hard codded
		result := getAPI
		subs.each{ s |
			result.append(s + "\n")
		}
		result.append("task main()")
		result.append(nxc)
		io.writeTextFile(out, result)
	end
	
	operation loadProgram(uri : String) : ASM::Instruction is do
		var res : EMFRepository init EMFRepository.new
        var resource : Resource init res.createResource(uri, "http://kmLogo.ecore/ASM")
        resource.load()
        result ?= resource.instances.one  
	end
	
	operation getAPI() : String is do
		result := ""
		result.append("/**\n")
		result.append(" * This is the implementation of a LOGO Turtle for NXT\n")
		result.append(" * Author : Franck FLEUREY\n")
		result.append(" * License : GPL\n")
		result.append(" *\n")
		result.append(" * The robot is suposed to have two wheels controled \n")
		result.append(" * by two separate motors. The distance between the two\n")
		result.append(" * wheels is D and the diameter of the wheel is d.\n")
		result.append(" * For this implementation to work D/d must be an integer.\n")
		result.append(" * A third motor controls a pen up and down. The Pen should\n")
		result.append(" * touch the paper right in the middle of the two wheels.\n")
		result.append(" *\n")
		result.append(" */\n")
		result.append("\n")
		result.append("#include \"NXCDefs.h\"\n")
		result.append("\n")
		result.append("// Correponds to D/d\n")
		result.append("#define ANGLE_FACTOR 9\n")
		result.append("\n")
		result.append("// The Motors connections\n")
		result.append("#define PEN_MOTOR OUT_A\n")
		result.append("#define RIGHT_MOTOR OUT_B\n")
		result.append("#define LEFT_MOTOR OUT_C\n")
		result.append("#define MOVE_MOTORS OUT_BC\n")
		result.append("\n")
		result.append("// define step lenght in wheel rotation (degree)\n")
		result.append("#define STEP 10\n")
		result.append("\n")
		result.append("// define the angle of which the pen motor has to move\n")
		result.append("#define PEN_ANGLE 45\n")
		result.append("\n")
		result.append("// The motor spped to use (not two fast to avoid drifting)\n")
		result.append("#define SPEED 40\n")
		result.append("\n")
		result.append("/**\n")
		result.append(" * The Robot will move straight forward for d steps\n")
		result.append(" */\n")
		result.append("sub forward(int d)\n")
		result.append("{\n")
		result.append("	int angle = d * STEP;\n")
		result.append("	  ResetTachoCount(MOVE_MOTORS);\n")
		result.append("	// RotateMotorEx(ports, pwr, angle, turnpct, bSync, bStop)\n")
		result.append("	RotateMotorEx(MOVE_MOTORS, SPEED, angle, 0, true, true);\n")
		result.append("	Off(MOVE_MOTORS);\n")
		result.append("}\n")
		result.append("\n")
		result.append("/**\n")
		result.append(" * The Robot will turn by n degree around the pen (hopefuly)\n")
		result.append(" */\n")
		result.append("sub turn(int n)\n")
		result.append("{\n")
		result.append("	//RotateMotorEx(MOVE_MOTORS, SPEED, n * ANGLE_FACTOR, -100, false, false);\n")
		result.append("	\n")
		result.append("	\n")
		result.append("	if (n>0) {\n")
		result.append("		OnRev(LEFT_MOTOR, SPEED);\n")
		result.append("		OnFwd(RIGHT_MOTOR, SPEED);\n")
		result.append("		Wait(n*ANGLE_FACTOR);\n")
		result.append("	}\n")
		result.append("	else {\n")
		result.append("		OnRev(RIGHT_MOTOR, SPEED);\n")
		result.append("		OnFwd(LEFT_MOTOR, SPEED);\n")
		result.append("		Wait((-n)*ANGLE_FACTOR);\n")
		result.append("	}\n")
		result.append("	Off(MOVE_MOTORS);\n")
  		result.append("	Wait(150);\n")
		result.append("}\n")
		result.append("\n")
		result.append("/**\n")
		result.append(" * The Pen goes up\n")
		result.append(" */\n")
		result.append("sub penUp()\n")
		result.append("{\n")
		result.append("	RotateMotor(PEN_MOTOR, SPEED, -PEN_ANGLE);\n")
		result.append("	// SetSensorType(IN_1, IN_TYPE_LIGHT_INACTIVE);\n")
		result.append("}\n")
		result.append("\n")
		result.append("/**\n")
		result.append(" * The Pen goes down\n")
		result.append(" */\n")
		result.append("sub penDown()\n")
		result.append("{\n")
		result.append("	RotateMotor(PEN_MOTOR, SPEED, PEN_ANGLE);\n")
		result.append("	// SetSensorType(IN_1, IN_TYPE_LIGHT_ACTIVE);\n")
		result.append("}\n")
		result.append("/************************************************************/\n")
		result.append("/*  END OF THE API, THE COMPILED CODE GOES BELOW THIS LINE  */\n")
		result.append("/************************************************************/\n")
	end
}

