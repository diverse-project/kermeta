<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>Chapter&nbsp;7.&nbsp;Behaviour</title><link rel="stylesheet" href="css/docbook.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"><meta name="keywords" content="Kermeta, metamodeling, language, kmLogo"><link rel="home" href="index.html" title="Logo Tutorial : Building kmLogo DSL using Kermeta"><link rel="up" href="index.html" title="Logo Tutorial : Building kmLogo DSL using Kermeta"><link rel="prev" href="ch06.html" title="Chapter&nbsp;6.&nbsp;Contract"><link rel="next" href="ch08.html" title="Chapter&nbsp;8.&nbsp;Model transformation - Compilation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;7.&nbsp;Behaviour</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch08.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a name="chapter_behaviour.link"></a>Chapter&nbsp;7.&nbsp;Behaviour<a name="chapter_behaviour"></a></h2></div></div></div><p>Let us now add some <span class="bold"><strong>operational semantics</strong></span> to our
      metamodel. To do so, we are going to add the actions we wish to implement thanks to the
      weaving mechanism in Kermeta.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e853"></a>7.1.&nbsp;Preparation of the environnement<span></span></h2></div></div></div><p>First of all let's prepare the appropriate environnement needed for this implementation.
        The concerned project during this chapter will be <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta</strong></span>.</p><div class="procedure"><ol type="1"><li><p>Copy the folders and its content inside <span class="bold"><strong>org.kermeta.kmlogo.logoasm.tutorial/parts/3.behaviour/...</strong></span> into <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/kermeta/</strong></span> i.e.: </p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>1.Models</strong></span> where there is the models we are
                  going to simulate;</p></li><li><p><span class="bold"><strong>3.JavaInterfaces</strong></span> where we ca see the needed
                  java program for this tutorial;</p></li><li><p><span class="bold"><strong>4.VirtualMachine</strong></span> where are defined the
                  application domain;</p></li><li><p><span class="bold"><strong>5.Simulator</strong></span> where the execution program are
                  provided.</p></li></ul></div></li><li><p>Inside the <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/src</strong></span> create two packages <span class="bold"><strong>org.kermeta.kmLogo.gui</strong></span> and <span class="bold"><strong>org.kermeta.kmLogo.wrapper</strong></span>.</p><p>Move the files from :</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>3.JavaInterfaces/gui/</strong></span> into the package
                    <span class="bold"><strong>org.kermeta.kmLogo.gui</strong></span>;</p></li><li><p><span class="bold"><strong>3.JavaInterfaces/wrapper/</strong></span> into the package
                    <span class="bold"><strong>org.kermeta.kmLogowrapper</strong></span> (you may delete the
                  folder <span class="bold"><strong>3.JavaInterfaces/gui/</strong></span> and <span class="bold"><strong>3.JavaInterfaces/wrapper/</strong></span> after).</p></li></ul></div></li><li><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="gfx/admonitions/caution.gif"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top"><p>At this point, you should have errors on your wrapper package. It is normal, we
              haven't set up the plugin yet. Though these next steps are not really part of Kermeta
              processing, we have to fix these errors to keep on.</p></td></tr></table></div><p>Replace the file <span class="bold"><strong>META-INF/MANIFEST.MF</strong></span> by the one
            you can find in <span class="bold"><strong>3.JavaInterfaces/plugin</strong></span>. The manifest
            tell the project about its configuration (dependencies, exported package, runtime, ...).
            Have a look at its content and observe how to solve the problem (If errors still
            persist, continue next step).</p><p>Copy the file <span class="bold"><strong>plugin.xml</strong></span> in <span class="bold"><strong>3.JavaInterfaces/plugin</strong></span> and paste it on the root of your project. This is
            the file which handle the plug-in nature of the project. Observe its content (extension,
            ..). (you may delete the folder <span class="bold"><strong>3.JavaInterfaces/plugin</strong></span>
            and the package <span class="bold"><strong>src/org.kermeta.kmlogo.logoasm.srckermeta
            </strong></span> since we don't use it.</p></li><li><p>At this point your project<span class="bold"><strong>
              org.kermeta.kmlogo.logoasm.srcKermeta</strong></span> should have no error and present the
            structure illustrated below:</p><div class="figure"><a name="d0e962"></a><div class="figure-contents"><div class="mediaobject"><img src="Kermeta-Tutorial-Logo_figures/KermetaSrcStructure.png" alt="org.kermeta.kmlogo.logoasm.srcKermeta project structure"></div></div><p class="title"><b>Figure&nbsp;7.1.&nbsp;org.kermeta.kmlogo.logoasm.srcKermeta project structure</b></p></div><br class="figure-break"></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section_dynamic_semantic.link"></a>7.2.&nbsp;Dynamic semantic<span></span></h2></div></div></div><p>Thanks to the weaving, we are going to add some operations and properties to the
        ASMLogo.ecore in order to provide an operational semantics to Logo. </p><p>We will weave an interpreter to the ASM by adding "eval" operations to the ASM
        metaclasses. This eval operation will pass the actual context of the program.</p><div class="procedure"><ol type="1"><li><p>Open <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/kermeta/5.Simulator/LogoDynSemantics.kmt</strong></span>
            and observe how the weaving (obtained through the require statement at the beginning of
            the LogoDynSemantics.kmt) adds some operations and properties to the
            ASMLogo.ecore.</p></li><li><p>In the top right corner of the <span class="bold"><strong>outline view</strong></span>, unfold
              <span class="bold"><strong>kmlogo::ASM package</strong></span>. Then use the red/blue package
            icon to see what comes from the opened kmt file (ine <span class="bold"><strong>red</strong></span>) and what comes from the imported files (in <span class="bold"><strong>blue</strong></span>). So the "blue-red-mix" colored icon tell you that the class has an
            aspect weaved into it.</p></li><li><p>Find the class <span class="bold"><strong>Repeat</strong></span> and observe that it only has
            a Block property imported from the ecore.</p><p>Inside this class, let's now simply add operational behavior in the eval operation
            as following:</p><pre class="programlisting">aspect class Repeat
	{
		method eval(context : Context) : Integer is do 
			from var i : Integer init condition.eval(context)
			until i &lt; 1
			loop
				result := block.eval(context)
				i := i - 1
			end
		end 
	}</pre><p>Save the file and observe that the method eval was added in the outline view of the
            class Repeat. And because this aspect comes from this opened kmt file it is colored in
            red (see figure below).</p><div class="figure"><a name="d0e1010"></a><div class="figure-contents"><div class="mediaobject"><img src="Kermeta-Tutorial-Logo_figures/KermetaAspectOutlineView.png" alt="Outline view"></div></div><p class="title"><b>Figure&nbsp;7.2.&nbsp;Outline view</b></p></div><p><br class="figure-break"></p></li><li><p>Finally, find the class <span class="bold"><strong>Context</strong></span>, and observe what
            is passed between eval() calls.</p></li></ol></div><p>At this point, you know how to weave operational semantic to Kermeta and rapidly
        identify them from the imported one inside the Outline view. Aspected classes are
        represented in Red/Blue color.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section_virtual_machine.link"></a>7.3.&nbsp;Virtual machine<span></span></h2></div></div></div><p>In order to provide the behavior, the interpreter needs an application domain. In this
        sample we call it Virtual Machine (VM).</p><div class="procedure"><ol type="1"><li><p>Open the file <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/kermeta/4.VirtualMachine/VMLogo.ecore</strong></span>,
            initialise its ecore diagram file to see its representation. </p><p>In this ecore file you'll notice the various notions needed for this VM : turtle,
            segment and points. </p></li><li><p>Open <span class="bold"><strong>4.VirtualMachine/LogoVMSemantics.kmt</strong></span> and
            observe how the weaving (obtained through the require statement at the beginning of the
            LogoVMSemantics.kmt) adds some operations and properties to the VMLogo.ecore. Those
            operations have some impacts on the GUI through command like stdio.writeln. </p></li><li><p>Like in the section before, use the outline view to identify what has been added (in
            red) to the structure (in bue).</p></li><li><p>Find the operation <span class="bold"><strong>move</strong></span> in the class <span class="bold"><strong>Turtle</strong></span> and observe some interactions with the UI
            (stdio.out).</p></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="gfx/admonitions/important.gif"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>As you may have noticed inside <span class="bold"><strong>LogoVMSemantics.kmt</strong></span>,
          there is a call (require to the beginning of the file) to <span class="bold"><strong>Math.kmt</strong></span> which is a Java interface needed to properly execute the simulator.
            So<span class="bold"><strong> before moving onto the testing the simulator</strong></span>, let's
          have a look at how to set up this interface into the next section.</p></td></tr></table></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1069"></a>7.4.&nbsp;Operational semantics extra<span></span></h2></div></div></div><p>In this step, we will see how some extra feature has been implemented in the operational
        sematics. It will explain how to call some java code to implement extra features.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="section_call_javaMath.link"></a>7.4.1.&nbsp;Call to java.Math</h3></div></div></div><p>This step will show you how a call to java may workaround some missing feature in
          Kermeta. It will explain how how to call java.lang.Math from Kermeta. This is useful since
          the Kermeta doesn't provides sin, cos, tan operator by default. This may also be useful in
          case of major performance issue for a specific task.</p><div class="procedure"><ol type="1"><li><p>Open <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/kermeta/3.JavaInterfaces/Math.kmt</strong></span>
              which is the Kermeta wrapper. It defines the operations as seen by a kermeta code. The
              calls to java are done using the <span class="bold"><strong>extern</strong></span> keyword. It
              will call the static java operation with the given qualified name.</p></li><li><p>Then, open the file <span class="bold"><strong>src/org.kermeta.kmlogo.wrapper/Math.java</strong></span> the Java wrapper. It defines
              the static operations that the interpreter can call. All parameters must be of type
              RuntimeObject. This class is in charge of:</p><div class="itemizedlist"><ul type="disc"><li><p>translating the RuntimeObject to and from classical java object (here
                    java.lang.Real);</p></li><li><p>calling the appropriate java code </p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="gfx/admonitions/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>Remember that the objects in java side must implement a RuntimeObject in order
                to be manipulated with Kermeta. This is why all static method contains Runtimeobject
                parameters which is the Kermeta object kept in memory at runtime, and at last, must
                return a RuntimeObject. </p><p>Also notice that the conversion to java types is done by the <span class="bold"><strong>TYPE.create()</strong></span> method.</p></td></tr></table></div></li><li><p>So in order to use these wrapper, simply <span class="bold"><strong>import</strong></span>
              the Math.kmt file where you need it (here in <span class="bold"><strong>LogoVMSemantics.kmt</strong></span>). And use it as a normal kermeta class. Since both
              java code is contained by the same plugin, there is no need of classpath declaration.
              If you need to use java code from another plugin, make sure that your plugin has a
              dependency to it. </p></li><li><p>To test this section, open the kermeta file <span class="bold"><strong>3.JavaInterfaces/test/testMath.kmt</strong></span> which contains the main operation to
              launch the java wrapper. Observe how a main class is defined in Kermeta and the use of
              Math.kmt.</p><p>Right-click on <span class="bold"><strong>testMath.kmt</strong></span> and choose <span class="bold"><strong>Run &gt; Run as Kermeta Application</strong></span>, you should obtain the
              results illustrated below :</p><div class="figure"><a name="d0e1134"></a><div class="figure-contents"><div class="mediaobject"><img src="Kermeta-Tutorial-Logo_figures/KermetaCallJava.png" alt="Call to java Math results"></div></div><p class="title"><b>Figure&nbsp;7.3.&nbsp;Call to java Math results</b></p></div><p><br class="figure-break"></p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="section_implementing_graphical_output.link"></a>7.4.2.&nbsp;Implementing a graphical
          output<span></span></h3></div></div></div><p>This section will guide you through the code of the implementation of a graphical
          interface for the logo turtle. It is similiar to the call to Java.Math previously
          seen.</p><div class="procedure"><ol type="1"><li><p>Open the file <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/kermeta/3.JavaInterfaces/TurtleGUI.kmt</strong></span>.
              Like the java call that we have previously seen, it correspond to the kermeta wrapper.
              It defines the classes as seen by kermeta programs. For this application, it provides
              operations like drawLine, drawTurtle or clearDrawing. Note that it need an
              "initialize" operation in order to correctly create the object. </p></li><li><p>Then open the file<span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/src/org.kermeta.kmlogo.wrapper/TurtleGUIWrapper.java</strong></span>.
              It defines the static operations that the interpreter can call. All parameters must be
              of type RuntimeObject. This class is in charge of :</p><div class="itemizedlist"><ul type="disc"><li><p>translating the RuntimeObject to and from classical java object;</p></li><li><p>calling the appropriate java code. The associated java object (here a
                    ITurtleGUI) is stored into the UserData of the RuntimeObject. </p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="gfx/admonitions/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>Again, remember that the objects in java side must implement a RuntimeObject in
                order to be manipulated with Kermeta. This is why all static method contains
                Runtimeobject parameters which is the Kermeta object kept in memory at runtime, and
                at last, must return a RuntimeObject. </p><p>Also notice that the <span class="bold"><strong>initialize()</strong></span> method allow
                the "conversion" into java side i.e.: it creates a java object from the given name
                so as to represent the GUI (turtleGUI). Then it sets this object inside the
                RuntimeObject by the method <span class="bold"><strong>setUserData()</strong></span> to store
                it for later re-use which is done with <span class="bold"><strong>getUserData()</strong></span>. The conversion to java types is done by the <span class="bold"><strong>TYPE.getValue()</strong></span> method in this direction. </p><p>So if you want to implement yours, be sure that all your java object are not
                external to the Kermeta (RuntimeObject) domain, otherwise you must implement an
                internal controller to set up the glue (i.e.: the mapping).</p></td></tr></table></div></li><li><p>Then, the extra step here is implementing the graphical user interface. This is
              done by the classes in <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/src/org.kermeta.kmlogo.gui/</strong></span>. In
              order to allow some extensibility, it has been splitted in 2, an interface <span class="bold"><strong>ITurtleGUI</strong></span> and a simple concrete AWT implementation <span class="bold"><strong>TurtleSimpleAWTGUI</strong></span>.</p></li><li><p>The last step before testing is to provide a simple controler that ask to the GUI
              to update the graphical view of a given Turtle. This is done by the file: <span class="bold"><strong>4.VirtualMachine/TurtleControler.kmt</strong></span> which implement
                <span class="bold"><strong>4.VirtualMachine/MoveListener.kmt</strong></span> (merely a turtle
              movement listener).</p></li><li><p>After succesfully testing the call to Java.Math, let's now test the virtual
              machine that we saw in section 7.3. To do so, open <span class="bold"><strong>4.VirtualMachine/tests/testVM.kmt</strong></span>. This file will initiate a turtle and
              draw a square using the kermeta wrappers and the java wrappers that we saw before
              (look at the required files define at the beginning of the kmt to see the interaction
              between the files). Right-click on this file an <span class="bold"><strong>run it as a
                Kermeta application</strong></span> to see the graphical representation illustred below
              (notice by the way the console output that illustrate the impact of the GUI as
              mentioned in the step 2 of section 7.3): </p><div class="figure"><a name="d0e1215"></a><div class="figure-contents"><div class="mediaobject"><img src="Kermeta-Tutorial-Logo_figures/KermetaLogoOutput.png" alt="VM testing output"></div></div><p class="title"><b>Figure&nbsp;7.4.&nbsp;VM testing output</b></p></div><p><br class="figure-break"></p></li><li><p>Open <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/5.Simulator/
                LogoSimulator.kmt</strong></span>. This class provides an execute operation. This
              operation allows to load a model that conforms to the ASMLogo.ecore and start the
              evaluation of the logo instructions. Finally, it asks to the controler to update the
              graphical view. This is the main entry and the loader for a logo model
              instance.</p><p>Now that we are sure that the VM is working correctly, let's test the interpreter
              that we have set up. To do so, open the file <span class="bold"><strong>5.Simulator/tests/carre.kmt</strong></span>. It will instanciate a simulator, load a
              model from <span class="bold"><strong>1.Models/carre.logoasm</strong></span> and execute the
              interpreter. Right-click the file and<span class="bold"><strong> run as kermeta
                application</strong></span>, you should obtain the same illustration as before. </p></li><li><p>Let's have another test. Remember the "dots.xmi" that you created before inside
                <span class="bold"><strong>org.kermeta.kmlogo.logoasm.model/model</strong></span> (if not a
              copy is available at "org.kermeta.kmlogo.logoasm.tutorial/parts/1.metamodel/model").
              Move it to the folder <span class="bold"><strong>org.kermeta.kmlogo.logoasm.srcKermeta/kermeta/1.Models/</strong></span>. Open it and
              save it as <span class="bold"><strong>dots.logoasm</strong></span> so as to convert it as a
              model instance understandable by our interpreter. Now, open the file <span class="bold"><strong>5.Simulator/tests/dots.kmt</strong></span> and see that it calls the model
              we've just renamed. Run it as a Kermeta application to see the results (you can test
              the other models (*.logoasm) in the folder <span class="bold"><strong>1.Model</strong></span>).</p></li></ol></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;6.&nbsp;Contract&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;8.&nbsp;Model transformation -
        Compilation</td></tr></table></div></body></html>