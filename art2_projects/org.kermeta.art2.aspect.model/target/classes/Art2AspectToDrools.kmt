/* $Id:$ 
 * Creation : June 24, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            bmorin
 */
@mainClass "Art2Aspect::Main"
@mainOperation "main"


package Art2Aspect;


require kermeta
require "./artAspect.ecore"
require "./Art2ToDrools.kmt"
//require "http://ArtAspect/2.0"

using kermeta::standard
using kermeta::persistence
using kermeta::utils

using art2

class Main
{
	operation main() : Void is 
	do 
		var ctx : Context init Context.new
		ctx.cache := Hashtable<Object, String>.new
		ctx.res := StringBuffer.new
		
		var aspectRoot : AspectRoot init loadAspect
		aspectRoot.generateAspect(ctx)
		stdio.writeln(ctx.res.toString)
	end
	
	operation loadAspect() : AspectRoot is 
	do
		var aspectURI : String init "file:/home/entimid2/workspace2/art2.aspect.model/src/main/resources/AspectRoot.xmi"
		var aspectMetamodelURI : String init "platform:/resource/art2.aspect.model/src/main/resources/artAspect.ecore"
		var rep : Repository init EMFRepository.new
		var res : Resource
		res ?= rep.createResource(aspectURI, aspectMetamodelURI)
		res.load
		result ?= res.one
	end
}

aspect class AspectRoot
{
	operation generateAspect(ctx : Context) : Void is
	do
		self.aspects.each{a |
			var ruleName : String init if a.name!=void then a.name else ctx.generateName(a) end
			ctx.res.append("rule \""+ruleName+"\"\n")
			a.pointcutToDrools(ctx)
			
			a.generateAdvice(ctx)
			a.generateBindings(ctx)
		}
	end
}
		
aspect class AspectDefinition
{
	operation pointcutToDrools(ctx : Context) : Void is
	do
		if self.pointcut != void then
			ctx.res.append("when\n")
			self.pointcut.pointcutToDrools(ctx)
		end
	end
	
	operation generateAdvice(ctx : Context) : Void is
	do
		if self.pointcut != void then
			ctx.res.append("then\n")
			self.advice.generateAdvice(ctx)
		end		
	end
	
	operation generateBindings(ctx : Context) : Void is
	do
		self.bindings.each{b | b.generateBindings(ctx)}
	end
}

aspect class BindingPattern
{
	operation generateBindings(ctx : Context) : Void is
	do
	
		var varName : String init ctx.generateName(self)
		ctx.generateName(self.source)
		ctx.generateName(self.target)
		ctx.res.append("\t art2.Binding "+varName+" art2.Art2Factory.eInstance.createBinding();\n")
		ctx.res.append("\t "+varName+".getPorts().add($"+ctx.cache.getValue(self.source)+");\n")
		ctx.res.append("\t "+varName+".getPorts().add("+ctx.cache.getValue(self.target)+");\n")
	end
}

aspect class PointcutDefinition
{	
	operation pointcutToDrools(ctx : Context) : Void is
	do
		portTypePatterns.each{ptp | ptp.pointcutToDrools(ctx)}
		componentTypePatterns.each{ctp | ctp.pointcutToDrools(ctx)}
		nodePatterns.each{np | np.pointcutToDrools(ctx)}
	end		
}

aspect class NodePattern
{
	operation pointcutToDrools(ctx : Context) : Void is
	do
		componentPatterns.each{cp | cp.pointcutToDrools(ctx)}

		var i : Integer init 0
	
		var varName : String init "\t$"+ctx.generateName(self)
		ctx.res.append(varName)
		ctx.res.append(": art2.Node(")
		
		if(self.namePattern != void) then
			ctx.res.append("name == \""+namePattern+"\"")//TODO regex
			i := i+1
		end
		
		if(self.componentPatterns.size > 0) then
			var j : Integer init 0
			if i > 0 then
				ctx.res.append(", ")
			end
			self.componentPatterns.each{p |
				if j>0 then ctx.res.append(", ") end
				ctx.res.append("components contains $"+ctx.cache.getValue(p))
				j := j+1
			}
			i := i+1
		end
				
		ctx.res.append(")\n")
	end
}


aspect class ComponentTypePattern
{
	operation pointcutToDrools(ctx : Context) : Void is
	do
		if(type != void) then
			type.pointcutToDrools(ctx)
		else
			self.requiredPortTypeRefPatterns.each{pp | pp.pointcutToDrools(ctx)}
			self.providedPortTypeRefPatterns.each{pp | pp.pointcutToDrools(ctx)}
			
			var varName : String init "\t$"+ctx.generateName(self)		
			ctx.res.append(varName)
		    ctx.res.append(": art2.ComponentType(")
			
			if(self.requiredPortTypeRefPatterns.size > 0) then
				var j : Integer init 0
				self.requiredPortTypeRefPatterns.each{pp |
					if j>0 then ctx.res.append(", ") end
					ctx.res.append("required contains $"+ctx.cache.getValue(pp))
					j := j+1
				}
			end
			
			if(self.providedPortTypeRefPatterns.size > 0) then
				var j : Integer init 0
				self.providedPortTypeRefPatterns.each{pp |
					if j>0 then ctx.res.append(", ") end
					ctx.res.append("required contains $"+ctx.cache.getValue(pp))
					j := j+1
				}
			end
			ctx.res.append(")\n")
		end		
	end
}

aspect class PortTypePattern
{
	operation pointcutToDrools(ctx : Context) : Void is
	do
		if(type != void) then
			type.pointcutToDrools(ctx)
		else
			var varName : String init "\t$"+ctx.generateName(self)
		end
	end
}

aspect class PortTypeRefPattern
{
	operation pointcutToDrools(ctx : Context) : Void is
	do
		if(ref != void) then
			ref.pointcutToDrools(ctx)
			
		end
		
		var varName : String init "\t$"+ctx.generateName(self)
		var i : Integer init 0
		
		ctx.res.append(varName)
		ctx.res.append(": art2.PortTypeRef(")
		
		if(self.namePattern != void) then
			ctx.res.append("name == \""+namePattern+"\"")
			i := i+1
		end
		
		if(self.ref != void) then
			if(i>0) then
				ctx.res.append(", ")
			end
			
			if(self.ref.type != void) then
				ctx.res.append("ref == "+"$"+ctx.cache.getValue(self.ref.type))
			else
				ctx.res.append("ref == "+"$"+ctx.cache.getValue(self.ref))
			end
		end
		
		ctx.res.append(")\n")						
	end
}

aspect class ComponentPattern
{
	operation pointcutToDrools(ctx : Context) : Void is
	do
		portPatterns.each{pp | pp.pointcutToDrools(ctx)}
	
		var varName : String init "\t$"+ctx.generateName(self)
		ctx.res.append(varName)
		ctx.res.append(": art2.ComponentInstance(")
		
		if namePattern != void then
			ctx.res.append("name == \""+namePattern+"\"")//TODO regex
		end
	
		ctx.res.append(")\n")
	end
}

aspect class PortPattern
{
	operation pointcutToDrools(ctx : Context)
	 : Void is
	do
		var varName : String init "\t$"+ctx.generateName(self)
		ctx.res.append(varName)
		ctx.res.append(": art2.Port(")	
		if ref != void then
			ctx.res.append("portTypeRef contains $"+ctx.cache.getValue(self.ref)+"")
		end
		ctx.res.append(")\n")
	end	
}