/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package org.kermeta.art2.framework.generator.model2code

import java.io.File
import java.io.FileWriter
import org.kermeta.art2.ContainerRoot
import org.kermeta.art2.MessagePortType
import org.kermeta.art2.Operation
import org.kermeta.art2.ServicePortType
import org.kermeta.art2.framework.generator.model2code.sub.AnnotationsGenerator
import org.kermeta.art2.framework.generator.model2code.sub.MethodsGenerator
import org.kermeta.art2.{ComponentType => ART2ComponentType }
import scala.collection.JavaConversions._

trait ComponentTypeGenerator extends MethodsGenerator with AnnotationsGenerator {

  var componentPackage : String = null
  var componentName : String = null
  var ct : ART2ComponentType = null

  def generateComponentType(root:ContainerRoot, ctp: ART2ComponentType, location:String){
    ct = ctp;
    componentPackage = ct.getFactoryBean().substring(0, ct.getFactoryBean().lastIndexOf("."));
    componentName = ct.getName();

    var componentFile = new File(location + "/" + componentPackage.replace(".", "/")+"/"+componentName+".java")
    if(!componentFile.exists) {
      var dirs = new File(componentFile.getAbsolutePath.substring(0, componentFile.getAbsolutePath.lastIndexOf(componentName)))
      dirs.mkdirs
      componentFile.createNewFile
      generateNewComponentType(root, componentFile);
    } else {
      generateAndMergeComponentType(root, componentFile)
    }
    
  }


  def generateNewComponentType(root:ContainerRoot, file:File) {
    var wrapper = new FileWriter(file);

    wrapper.append("package "+componentPackage+";\n");

    wrapper.append(generateLicenseHeaders)
    wrapper.append("\n")
    wrapper.append(generateHeaders)
    wrapper.append("\n")
    wrapper.append("\n")
    wrapper.append(generateClass)

    wrapper.close();
  }



  def generateAndMergeComponentType(root:ContainerRoot, file:File) {
    printf("GenerateAndMergeComponentType :: NOT IMPLEMENTED YET !\n")
  }


  def generateLicenseHeaders = {
    var buffer = new StringBuffer()

    buffer.append("/*\n")
    buffer.append(" * File automatically generated by ART2 ComponentType Generator\n")
    buffer.append(" * \n")
    buffer.append(" * Last generation on ??/??/????\n")
    buffer.append(" * \n")
    buffer.append(" * Authors:   Gregory NAIN\n")
    buffer.append(" * Institute: IRISA / INRIA Centre Rennes Bretagne - Atlantique\n")
    buffer.append(" */\n")

    buffer.toString
  }

  def generateHeaders = {
    var buffer = new StringBuffer()

    buffer.append("import org.kermeta.art2.annotation.*;\n")

    //import provided service types
    ct.getProvided.find(portTypeRef => portTypeRef.getRef.isInstanceOf[ServicePortType]).foreach{portRef =>
      buffer.append("import " +portRef.getRef.getName+";\n")
    }
    ct.getRequired.find(portTypeRef => portTypeRef.getRef.isInstanceOf[ServicePortType]).foreach{portRef =>
      buffer.append("import " +portRef.getRef.getName+";\n")
    }

    buffer.toString
  }

  def generateClass = {
    var buffer = new StringBuffer()

    buffer.append(generateJavadoc)

    buffer.append("\n")
    buffer.append("\n")

    buffer.append(generateModelAnnotations(ct))
    buffer.append("public class " + ct.getName)

    buffer.append(" {\n")

    buffer.append(generateMethods(ct))

    buffer.append("}\n")

    buffer.toString
  }

  def generateJavadoc = {
    var buffer = new StringBuffer()

    buffer.append("/**\n")
    buffer.append(" * Generated Class for component "+ct.getName+"\n")
    buffer.append(" *\n")
    buffer.append(" * @author Gregory NAIN\n")
    buffer.append(" */\n")

    buffer.toString
  }

}



/*
 * RESOURCE
 *
 *
 * wrapper.append("import org.kermeta.art2.framework.port._\n");
 wrapper.append("import scala.{Unit=>void}\n")
 wrapper.append("class "+portName+"(component : "+ct.getName+") extends "+ref.getRef().getName()+" with Art2ProvidedPort {\n");

 wrapper.append("def getName : String = \""+ref.getName+"\"\n")

 ref.getRef match {
 case mPT : MessagePortType => {
 /* GENERATE METHOD MAPPING */
 wrapper.append("def process(o : Object) = {this ! o}\n")

 ref.getMappings.find(map=>{map.getServiceMethodName.equals(Constants.ART2_MESSAGEPORT_DEFAULTMETHOD)}) match {
 case Some(mapping)=>{
 /* GENERATE LOOP */
 wrapper.append("override def internal_process(msg : Any)=msg match {\n")
 /* CALL MAPPED METHOD */
 wrapper.append("case _ @ msg => component.")
 wrapper.append(mapping.getBeanMethodName+"(msg)\n")
 wrapper.append("}\n")
 }
 case None => {
 println("Art2ProvidedPortGenerator::No mapping found for method '"+Constants.ART2_MESSAGEPORT_DEFAULTMETHOD+"' of MessagePort '" + ref.getName + "' in component '" + ct.getName + "'")
 logger.error("No mapping found for method '"+Constants.ART2_MESSAGEPORT_DEFAULTMETHOD+"' of MessagePort '" + ref.getName + "' in component '" + ct.getName + "'")
 System.exit(1)
 }
 }
 }

 case sPT : ServicePortType=> {
 /* CREATE INTERFACE ACTOR MOK */
 sPT.getOperations.foreach{op=>
 /* GENERATE METHOD SIGNATURE */
 wrapper.append("def "+op.getName+"(")
 op.getParameters.foreach{param=>
 wrapper.append(param.getName+":"+param.getType.print('[',']'))
 if(op.getParameters.indexOf(param) != (op.getParameters.size-1)){wrapper.append(",")}
 }
 wrapper.append(") : "+op.getReturnType.print('[',']')+" ={\n");


 /* Generate method corpus */
 /* CREATE MSG OP CALL */
 wrapper.append("var msgcall = new org.kermeta.art2.framework.MethodCallMessage\n")
 wrapper.append("msgcall.setMethodName(\""+op.getName+"\");\n")
 op.getParameters.foreach{param=>
 wrapper.append("msgcall.getParams.put(\""+param.getName+"\","+param.getName+".asInstanceOf[AnyRef]);\n")
 }
 wrapper.append("(this !? msgcall).asInstanceOf["+op.getReturnType.print('[',']')+"]")
 wrapper.append("}\n")
 }
 /* CREATE ACTOR LOOP */
 wrapper.append("override def internal_process(msg : Any)=msg match {\n")
 wrapper.append("case opcall : org.kermeta.art2.framework.MethodCallMessage => reply(opcall.getMethodName match {\n")
 sPT.getOperations.foreach{op=>
 /* FOUND METHOD MAPPING */
 ref.getMappings.find(map=>{map.getServiceMethodName.equals(op.getName)}) match {
 case Some(mapping)=> {
 wrapper.append("case \""+op.getName+"\"=> component."+mapping.getBeanMethodName+"(")
 op.getParameters.foreach{param=>
 wrapper.append("opcall.getParams.get(\""+param.getName+"\").asInstanceOf["+param.getType.print('[',']')+"]")
 if(op.getParameters.indexOf(param) != (op.getParameters.size-1)){wrapper.append(",")}
 }
 wrapper.append(")\n")

 }
 case None => {
 println("No mapping found for method '"+op.getName+"' of ServicePort '" + ref.getName + "' in component '" + ct.getName + "'")
 logger.error("No mapping found for method '"+op.getName+"' of ServicePort '" + ref.getName + "' in component '" + ct.getName + "'")
 System.exit(1)
 }
 }
 }
 wrapper.append("case _ @ o => println(\"uncatch message , method not found in service declaration : \"+o);null \n")
 wrapper.append("})}\n")
 }

 }

 wrapper.append("}\n");
 wrapper.close();
 *
 *
 */