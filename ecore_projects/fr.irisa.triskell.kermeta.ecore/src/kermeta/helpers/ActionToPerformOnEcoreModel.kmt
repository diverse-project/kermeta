/* $Id: ActionToPerformOnEcoreModel.kmt,v 1.1 2008-03-14 10:57:56 cfaucher Exp $
 * Creation date: March 04, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 *
 */

package ecore;
 
require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "../ecore_behavior.kmt"
require "EcoreHelper.kmt"
require "EcoreHelper_aspect.kmt"
require "ContainmentBasedActionPerformer_Ecore.kmt"

using ecore
using kermeta::language::structure
using kermeta::standard
using kermeta::utils
using EcoreHelpers

aspect class EObject {
	operation kmtPrinter(highLevelModelElement : String) : String is do
		result := ""
	end
	
	operation getHighLevelModelElement(highLevelModelElement : Bag<String>) : Bag<String> is do
		result := highLevelModelElement
	end
}

aspect class EPackage {
	method kmtPrinter(highLevelModelElement : String) : String is do
		var content : StringBuffer init StringBuffer.new
		if not self.container.isVoid() then 
			content.append("package " + self.name + " {\n\n")
		end
		
		self.eachOwnedElement{ e |
			content.append(e.kmtPrinter(highLevelModelElement) + "\n")
			e
		}
		
		if not self.container.isVoid() then
			content.append("}\n")
		end
		result := content.toString()
	end
	
	method getHighLevelModelElement(highLevelModelElement : Bag<String>) : Bag<String> is do
		self.eachOwnedElement{ e |
			e.getHighLevelModelElement(highLevelModelElement)
			e
		}
		result := highLevelModelElement
	end
}

aspect class EClass {
	method kmtPrinter(highLevelModelElement : String) : String is do
		var content : StringBuffer init StringBuffer.new
		content.append("aspect class " + self.name + " {\n")
		
		if self.eSuperTypes.size()>0 then
			content.append("\tmethod")
		else
			content.append("\toperation")
		end
		
		content.append(" eachOwnedElement(func : <" + highLevelModelElement + " -> kermeta::standard::Object>) : Void")
		
		if self.eSuperTypes.size()>0 then
			 content.append(" from " + EcoreHelper.new.getClassifierQualifiedName(self.eSuperTypes.first))
		end
		
		content.append(" is do\n")
		
		if self.eSuperTypes.size()>0 then
			if(self.eSuperTypes.first().name == "Object")then
				content.append("\t\t// workaround compiler V2 bug, cannot call super on a Class named \"Object\" \n")
				content.append("\t\t// super(func)\n")
			else
				content.append("\t\tsuper(func)\n")
			end			
		end
		
		self.eachOwnedElement{ e |
			content.append(e.kmtPrinter(highLevelModelElement))
			e
		}
		if self.eSuperTypes.size()>=1 then
			// must deal with EReference that comes from the other inheritance branch			
			var allFirstSuperTypes : Set<EClass> init getAllFirstSuperTypes
			self.eAllSuperTypes.each{ s |
				if (not allFirstSuperTypes.contains(s)) then
					s.eachOwnedElement{ e |
						content.append(e.kmtPrinter(highLevelModelElement))
						e
					}
				else					
					if(self.eSuperTypes.first().name == "Object") then
						content.append("\t// workaround compiler V2 bug, embed code that should have been called via super \n")
						s.eachOwnedElement{ e |
							content.append(e.kmtPrinter(highLevelModelElement))
							e
						}
					end
				end
			}
		end	
		
		result := content.append("\tend\n}\n").toString()
	end
	
	method getHighLevelModelElement(highLevelModelElement : Bag<String>) : Bag<String> is do
		if self.eSuperTypes.size == 0 then
			highLevelModelElement.add(EcoreHelper.new.getClassifierQualifiedName(self))
		end
		result := highLevelModelElement
	end
}

aspect class EReference {
	method kmtPrinter(highLevelModelElement : String) : String is do
		var content : StringBuffer init StringBuffer.new
		
		if self.containment then
			content.append("\t\t")
			if self.upperBound==1 then
				content.append("if (not self."+ EcoreHelper.new.getMangledIdentifier(self.name)+".isVoid) then\n\t\t\t")
				content.append("func(")		
				content.append("self." + EcoreHelper.new.getMangledIdentifier(self.name))
				// force the cast if this point outside of the current metamodel
				// TODO find a more clever way to detect if we really need it or not : however this 
				// sound difficult since we cannot know if the pointed element will be correctly aspetized or not ...
				content.append(".asType("+highLevelModelElement+")")		
				content.append(")\n\t\t")
				content.append("end")
			else
				content.append("self." + EcoreHelper.new.getMangledIdentifier(self.name))
				content.append(".each{ e |\n")
				content.append("\t\t\tfunc(e)")
				content.append("\n\t\t}")
			end
			content.append("\n")
		end
		result := content.toString()
	end
}
