/* $Id: EcoreHelper.kmt,v 1.2 2007-03-07 09:59:37 dvojtise Exp $
 * File : EcoreHelper.kmt
 * License : EPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * ----------------------------------------------------------------------------
 * Creation date : Sep 08, 2005
 * Authors : 
 *  Didier Vojtisek <dvojtise@irisa.fr>
 *  Damien Pollet   <dpollet@irisa.fr>
 * 
 */
//@mainClass "EcoreHelper::Main"
//@mainOperation "main"


package EcoreHelpers;

require kermeta
require "../ecore.kmt"

using kermeta::standard
using kermeta::persistence
using ecore

/** This class provides some helper methods to load/save Ecore models
    Plus some other useful navigation methods
 */
class EcoreHelper
{
	attribute ecoreMetamodel : String

	operation initialize() is do
		ecoreMetamodel := "../../src/ecore/Ecore.ecore"
	end

	/** load an ECore model */
    operation loadEcoreModel(repository : EMFRepository, modelUri : String) : Sequence<EPackage> is do
    	var resource : Resource init repository.createResource(modelUri , ecoreMetamodel)
    	resource.load
    	var instances : Set<Object> init resource.instances
    	// retreives only the packages
    	var pack : EPackage
    	result := instances.select { e | EPackage.isInstance(e) }.collect{p | pack ?= p}
    	
    end
	
	/** retreives the qualified name of a class */
	operation getClassQualifiedName(c : EClass) : String is do
		if (c.ePackage != void) then
			result := getPackageQualifiedName(c.ePackage) + "::" + c.name			
		else
			result := c.name
		end
	end
	operation getEcoreClassifierByName(classifierName : String) : EClassifier is do
		var returnedClassifier : EClassifier init void
		
		result := returnedClassifier
	end
	
	/** retreives the qualified name of a Package */
	operation getPackageQualifiedName(p : EPackage) : String is do
		if (p.eSuperPackage != void) then
			result := getPackageQualifiedName(p.eSuperPackage) + "::" + p.name			
		else
			result := p.name
		end
	end
	
	/** save an ECore model */
    operation saveEcoreModel(repository : EMFRepository, m : EPackage, uri : String) is do
	    var resource : Resource init repository.createResource(uri , ecoreMetamodel)
	    resource.instances.add(m)
	    resource.save
    end

	operation askIfNecessary(prompt : String, currentValue : String) : String is do
		result := currentValue
		if result.isVoid then
			result := stdio.read(prompt)
		end
	end
    
    /** retreives a Class by its name */
    operation findClassByName(model : EPackage, className : String) : EClass is do
		result ?= model.eClassifiers.detect { ec |
			EClass.isInstance(ec) and (ec.name.equals(className))
		}
    end
    /** retreives a Package by its name  */
    operation findPackageByName(model : Sequence<EPackage>, packageName : String) : EPackage is do
		result := model.detect { ec |
			EPackage.isInstance(ec) and (ec.name.equals(packageName))
		}
    end
    
    /** tells if this class has a parent in the given package */
    operation hasParentInPackage(aClass : EClass, pack : EPackage) : Boolean is do
    	var boolResult : Boolean init false
    	result := aClass.eSuperTypes.exists{ ec |
    		pack.eClassifiers.exists { ec2 | ec == ec2}
    	}
    end
    
    /** add an annotation to the given model element
     *  ensures that there is only one EAnnotation instance
     */
    operation addAnnotation(aModelElement : EModelElement,
    	source : String, detailKey : String, detailValue : String) : EAnnotation is do
    	
		var theAnnotation : EAnnotation init
			aModelElement.eAnnotations.detect{annot | annot.source.equals(source)}
		if theAnnotation.isVoid then 
			theAnnotation := EAnnotation.new
			theAnnotation.source := source
			aModelElement.eAnnotations.add(theAnnotation)
		end
		var detail : EStringToStringMapEntry init EStringToStringMapEntry.new
		detail.key := detailKey
		detail.~value := detailValue
		theAnnotation.details.add(detail)
    end
	
        
}