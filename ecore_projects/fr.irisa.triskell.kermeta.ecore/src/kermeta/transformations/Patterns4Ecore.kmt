/* $Id: Patterns4Ecore.kmt,v 1.1 2006-03-12 13:10:21 dvojtise Exp $
 * File : Patterns4Ecore.kmt
 * License : EPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * ----------------------------------------------------------------------------
 * Creation date : Sep 08, 2005
 * Authors : 
 *  Didier Vojtisek <dvojtise@irisa.fr>
 *  Damien Pollet   <dpollet@irisa.fr>
 * 
 */
//@mainClass "EcorePattern::Patterns"
//@mainOperation "main"


package EcoreTransformations;

require kermeta
require "../ecore.kmt"
require "../helpers/EcoreHelper.kmt"

using kermeta::standard
using ecore

class Patterns4Ecore inherits kermeta::kunit::Assert
{
    
    reference helper : EcoreHelpers::EcoreHelper
    
    attribute generateJavaCode : Boolean
    attribute generateKermetaCode : Boolean
    
    operation initialize() is do
		helper := EcoreHelpers::EcoreHelper.new
    	helper.initialize
    	generateJavaCode := true
    	generateKermetaCode := true
    	
	end

	operation addCommand() is do
       	// need to be implemented ...
    end

	/* --------------- Visitor -------------------------------*/
	/** create a Visitor for each of the class of the package */    
    operation addVisitor(pack : EPackage) is do
    	assertTrue(pack != void)
    	
    	// create the visitable interface and the abstract class visitor
    	var visitableInterface : EClass init EClass.new
    	visitableInterface.name := "Visitable"
    	visitableInterface.interface := true
        visitableInterface.~abstract := true
        pack.eClassifiers.add(visitableInterface)
               
        var abstractVisitor : EClass init EClass.new
        abstractVisitor.name := "Visitor"
        abstractVisitor.interface := false
        abstractVisitor.~abstract := true
        pack.eClassifiers.add(abstractVisitor)
          
        addAcceptOperation( visitableInterface,  abstractVisitor)   		
		addVisitOperation(abstractVisitor, visitableInterface)
        
        // add the inheritance to all the classes of this package except for except for the abstractVisitor and the visitableInterface
        // only add it for classes without parent in the same package
        pack.eClassifiers.each{ eClassifier | 
            var eClass : EClass
            eClass ?= eClassifier
            if eClass != void then
            	if (eClass != visitableInterface ) and (eClass != abstractVisitor ) and
            		not helper.hasParentInPackage(eClass, pack)
            	then
            		eClass.eSuperTypes.add(visitableInterface)
    			end
        	end
        }
        
         //implements accepts methods on visitable classes
         pack.eClassifiers.each{ eClassifier | 
            var eClass : EClass
            eClass ?= eClassifier
            if eClass != void then
            	if(eClass.eAllSuperTypes.exists{e | e.equals(visitableInterface)}) then
            		var acceptOp : EOperation init addAcceptOperation(eClass, abstractVisitor)
            		if self.generateJavaCode then
						// add the java code for the implementation
						helper.addAnnotation(acceptOp,"http://www.eclipse.org/emf/2002/GenModel","body",
							"visitor.visit" + eClass.name + "(this);")
					end
					if self.generateKermetaCode then
						// add the kermeta code for the implementation
						helper.addAnnotation(acceptOp,"kermeta","body",
							"visitor.visit" + eClass.name + "(self);")
					end
					// the visitFoo methods in the visitor
            		addVisitFooOperation(abstractVisitor, eClass, eClass.name)
            	end
        	end
        }
    end
     
    operation addAcceptOperation(visitableClass : EClass, abstractVisitor : EClass) : EOperation is do
    	var acceptOp : EOperation init EOperation.new
        var vParam : EParameter init EParameter.new
		acceptOp.name := "accept"
		vParam.name := "visitor"
		vParam.eType := abstractVisitor
		acceptOp.eParameters.add(vParam)
		visitableClass.eOperations.add(acceptOp)
		result := acceptOp
    end
    
    operation addVisitFooOperation(visitingClass : EClass, visitableInterface : EClass, name : String) : EOperation is do
    	var visitOp : EOperation init EOperation.new
        var vParam : EParameter init EParameter.new
		visitOp.name := "visit" + name
		vParam.name := "visitable"
		vParam.eType := visitableInterface
		visitOp.eParameters.add(vParam)
		visitingClass.eOperations.add(visitOp)
		result := visitOp
    end
    operation addVisitOperation(visitingClass : EClass, visitableInterface : EClass) : EOperation is do
		result := addVisitFooOperation(visitingClass, visitableInterface, "")
    end
    
	/* --------------- Builder -------------------------------*/    
    /** create a Builder for each of the concrete class of the package*/
    operation addBuilder(pack : EPackage) is do
    	// create super classes/interfaces
        var abstractfactory : EClass init EClass.new
        abstractfactory.name := "AbstractFactory"
        abstractfactory.interface := false
        abstractfactory.~abstract := false
        pack.eClassifiers.add(abstractfactory)
        
        // for each of the concrete classes of this package except for the Factory
        pack.eClassifiers.each{ eClassifier | 
            var eClass : EClass
            eClass ?= eClassifier
            if eClass != void then
            	if eClass != abstractfactory then
            		if (eClass.interface == false) and (eClass.~abstract == false) then
            			
	            		stdio.writeln(" adding create for " + eClass.name)
            			var builOp : EOperation init EOperation.new
						builOp.name := "create" + eClass.name
						builOp.eType := eClass
						builOp.eType := helper.getEcoreClassifierByName("ecore::EObject")
						abstractfactory.eOperations.add(builOp)
					else
	            		stdio.writeln(" NOT adding create for " + eClass.name)					
            		end
        		end
        	end
        }
    end
    
    
    /* --------------- Observer -------------------------------*/    
   
    operation addObserver(pack : EPackage, concreteSubject : EClass, concreteObserver : EClass) is do
    	assertTrue(pack != void)
    	assertTrue(concreteSubject != void)
    	assertTrue(concreteObserver != void)
    
        // create super classes/interfaces
        var observer : EClass init EClass.new
        observer.name := "Observer"
        observer.interface := true
        //observer.~abstract := false
        pack.eClassifiers.add(observer)
        
        var subject : EClass init EClass.new
		subject.name := "Subject"
		subject.~abstract := true
        pack.eClassifiers.add(subject)
        
        // create and add Observer's operations
        var notify : EOperation init EOperation.new
        var s : EParameter init EParameter.new

		notify.name := "update"
		s.name := "s"
		s.eType := subject
		notify.eParameters.add(s)
		observer.eOperations.add(notify)
		
		// create and add Subject's operations
		var attach : EOperation init EOperation.new
		var o : EParameter init EParameter.new
		
        attach.name := "attach"
        o.name := "o" 
        o.eType := observer
        attach.eParameters.add(o)
        subject.eOperations.add(attach)
        
		var detach : EOperation init EOperation.new
		o := EParameter.clone(o)  
        o.name := "o" 
        o.eType := observer      
		detach.name := "detach"
		detach.eParameters.add(o)
		subject.eOperations.add(detach)
        
        var notifyAll : EOperation init EOperation.new

		notifyAll.name := "notifyall"
		subject.eOperations.add(notifyAll)
		
		if self.generateJavaCode then
			// add the java code for the implementation
			helper.addAnnotation(notifyAll,"http://www.eclipse.org/emf/2002/GenModel","body",
				"java.util.Iterator it = getObservers().iterator();\n" + 
				"while(it.hasNext()){\n" +
				"	((Observer)it.next()).update(this);\n" +
				"}")
		end
		if self.generateKermetaCode then
			// add the kermeta code for the implementation
			helper.addAnnotation(notifyAll,"kermeta","body",
				"observers.each{o| o.update}")
		end
		
		// create the association: Subject --> *Observer
		var observers : EReference init EReference.new
		observers.name := "observers"
		observers.eType := observer
		observers.lowerBound := 0
		observers.upperBound := -1
		subject.eStructuralFeatures.add(observers)
		
		// add Subject and Observer as supertypes
		concreteSubject.eSuperTypes.add(subject)
		concreteObserver.eSuperTypes.add(observer)
    end
}