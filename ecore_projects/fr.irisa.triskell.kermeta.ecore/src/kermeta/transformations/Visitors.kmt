/* $Id: Visitors.kmt,v 1.8 2008-09-05 14:42:21 dvojtise Exp $
 * File : Visitors.kmt
 * License : EPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * ----------------------------------------------------------------------------
 * Creation date : Mar 28, 2006
 * Authors : 
 *  Didier Vojtisek <dvojtise@irisa.fr>
 *  Damien Pollet   <dpollet@irisa.fr>
 *  Vincent Mahe	<vmahe@irisa.fr>
 * 
 */

/* This package contains operations code for Visitor Patterns
 You should use Patterns4Ecore.kmt operations for applying Patterns */
package EcoreVisitors;

require kermeta
require "../helpers/EcoreHelper.kmt"
require "../helpers/EcoreGenericsHelper.kmt"
require "Tools.kmt"

using kermeta::standard
using ecore

class VisitorPattern
{
    
    reference helper : EcoreHelpers::EcoreHelper
    
    attribute generateJavaCode : Boolean
    attribute generateKermetaCode : Boolean
    
   	attribute tools : EcoreTools::Tools
   	
   	reference specPack : EPackage
    	
    operation initialize() is do
		helper := EcoreHelpers::EcoreHelper.new
    	helper.initialize
    	generateJavaCode := false	// not implemented
    	generateKermetaCode := true	// default value, can be changed
    	
    	tools := EcoreTools::Tools.new
    	
	end

	/* --------------- Visitor -------------------------------*/
	/**
	 * create a Visitor for each of the class of the package
	 * and return a "visitors" package containing autogenerated new classes
	 */    
    operation addVisitor(pack : EPackage, visitReturnType : EClassifier) : EPackage is do
		
    	// create the specialized package for separate storage of pattern new classes
    	specPack := tools.getSpecializedPackage("visitors", pack)
    	
    	// create the visitable interface and the abstract class visitor
    	var visitableInterface : EClass init addVisitableClass()
        specPack.eClassifiers.add(visitableInterface)
               
        var abstractVisitor : EClass init addVisitorClass()
        specPack.eClassifiers.add(abstractVisitor)
        
        // basic method for each of the 2 abstract classes
        var acceptOp : ecore::EOperation
        acceptOp := addAcceptOperation( visitableInterface,  abstractVisitor, visitReturnType)
		if self.generateJavaCode then
			// add the java code for the implementation
			helper.addAnnotation(acceptOp,"http://www.eclipse.org/emf/2002/GenModel","body",
				"")
		end
		if self.generateKermetaCode then
			// add the kermeta code for the implementation
//        	helper.addAnnotation(acceptOp, "kermeta","isAbstract","true") // not instanciable in 0.4.0+ version
			helper.addAnnotation(acceptOp,"kermeta","body",
				"do end")
			helper.addAnnotation(acceptOp,"kermeta","isAbstract", "false")
		end
		
		var visitOp : ecore::EOperation
		// REM : abstract methods not instanciable in 0.4.0+ version of Kermeta => concrete method
        visitOp := addVisitOperation(abstractVisitor, visitableInterface, visitReturnType)
        
        // execute the pattern on the given package
        applyPattern(pack, visitableInterface, abstractVisitor, visitReturnType)
		
		result := specPack
    end
    
    operation applyPattern(pack : EPackage, visitableInterface : EClass, abstractVisitor : EClass,
			visitReturnType : EClassifier) is do
        // add the visitable interface to the package classes
        addVisitableSupertype(pack, visitableInterface, abstractVisitor)
        
         //implements 'accept' methods on visitable classes
        // and the corresponding 'visit' method in the abstract Visitor
		addAcceptMethods(pack, visitableInterface, abstractVisitor, visitReturnType)        
    end
     
    operation addAcceptOperation(visitableClass : EClass, abstractVisitor : EClass,
			visitReturnType : EClassifier) : EOperation is do
    	var acceptOp : EOperation init EOperation.new
        var vParam : EParameter init EParameter.new
		acceptOp.name := "accept"
		vParam.name := "visitor"
		vParam.setType( abstractVisitor)
		acceptOp.eParameters.add(vParam)
		acceptOp.setType( visitReturnType)
		visitableClass.eOperations.add(acceptOp)
		result := acceptOp
    end
    
    operation addVisitFooOperation(visitingClass : EClass, visitableInterface : EClass,
     		name : String, visitReturnType : EClassifier) : EOperation is do
    	var visitOp : EOperation init EOperation.new
        var vParam : EParameter init EParameter.new
		visitOp.name := "visit" + name
		vParam.name := "visitable"
		vParam.setType(visitableInterface)
		visitOp.eParameters.add(vParam)
		visitOp.setType( visitReturnType)
		visitingClass.eOperations.add(visitOp)
		if self.generateJavaCode then
			// add the java code for the implementation
			helper.addAnnotation(visitOp,"http://www.eclipse.org/emf/2002/GenModel","body",
				"")
		end
		if self.generateKermetaCode then
			// add the kermeta code for the implementation
			helper.addAnnotation(visitOp,"kermeta","body",
				"do end")
			helper.addAnnotation(visitOp,"kermeta","isAbstract", "false")
		end
		result := visitOp
    end
    
    operation addVisitOperation(visitingClass : EClass, 
    		visitableInterface : EClass, visitReturnType : EClassifier) : EOperation is do
		result := addVisitFooOperation(visitingClass, visitableInterface, "", visitReturnType)
    end
    
    operation addVisitableClass() : EClass is do
    	// create the visitable interface and the abstract class visitor
    	var visitableInterface : EClass init EClass.new
    	visitableInterface.name := "Visitable"
    	visitableInterface.interface := true
        visitableInterface.~abstract := true
        result := visitableInterface
    end
    
    operation addVisitorClass() : EClass is do
    	// create the abstract class visitor
        var abstractVisitor : EClass init EClass.new
        abstractVisitor.name := "Visitor"
        abstractVisitor.interface := false
        abstractVisitor.~abstract := true
        result := abstractVisitor
    end
    
    operation addVisitableSupertype(pack : EPackage, visitableInterface : EClass, abstractVisitor : EClass) is do
        // add the inheritance to all the classes of this package except for the abstractVisitor and the visitableInterface
        // only add it for classes without parent in the same package
        pack.eClassifiers.each{ eClassifier | 
            var eClass : EClass
            eClass ?= eClassifier
            if eClass != void then
            	if (eClass != visitableInterface ) and (eClass != abstractVisitor ) and
            		not helper.hasParentInPackage(eClass, pack)
            	then
            		eClass.addSuperType(visitableInterface)
    			end
        	end
        }
    end
    
    operation addAcceptMethods(pack : EPackage, visitableInterface : EClass,
    			abstractVisitor : EClass, visitReturnType : EClassifier) is do
	     //implements accepts methods on visitable classes in the main package
	     pack.eClassifiers.each{ eClassifier | 
	        var eClass : EClass
	        eClass ?= eClassifier
	        if eClass != void then
		
	        	if(eClass.eAllSuperTypes.exists{e | e.equals(visitableInterface)}) then
	        		
	        		var acceptOp : EOperation init addAcceptOperation(eClass, abstractVisitor, visitReturnType)
	        		if self.generateJavaCode then
	        			var returnCode : String init ""
	        			if not visitReturnType.isVoid then returnCode := "return " end
						// add the java code for the implementation
						helper.addAnnotation(acceptOp,"http://www.eclipse.org/emf/2002/GenModel","body",
							returnCode + "visitor.visit" + eClass.name + "(this);")
					end
					if self.generateKermetaCode then
						// add the kermeta code for the implementation
						helper.addAnnotation(acceptOp,"kermeta","body",
							"do\nresult := visitor.visit" + eClass.name + "(self)\nend")
						helper.addAnnotation(acceptOp,"kermeta","isAbstract", "false")
					end
					// the visitFoo methods in the visitor
	        		var visitFoo : EOperation init addVisitFooOperation(abstractVisitor, eClass, eClass.name, visitReturnType)
//    				helper.addAnnotation(visitFoo,"kermeta","isAbstract","false")
	        	end
	    	end
	    }
    end
}