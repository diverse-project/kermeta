/* $Id: TopDownVisitor.kmt,v 1.9 2008-09-05 14:42:21 dvojtise Exp $
 * File : TopDownVisitor.kmt
 * License : EPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * ----------------------------------------------------------------------------
 * Creation date : Apr 3, 2006
 * Authors : 
 *  Vincent Mahï¿½	<vmahe@irisa.fr>
 * 
 */

/* This package contains operations code for Visitor Pattern "top-down" strategy.
 You should use it through Patterns4Ecore.kmt 'addTopDownVisitor' operation */
package TopDownVisitor;


require kermeta
require "Visitors.kmt"
require "../helpers/EcoreHelper.kmt"
require "Tools.kmt"
require "../keyword_list.kmt" 
using kermeta::standard 
using ecore

using EcoreVisitors

class TopDownVisitorPattern inherits VisitorPattern
{
	reference mainVisitor : EClass
	reference keyWordList : kermeta::language::key::KeyWordList
	 
	method initialize() is do
		super()
		keyWordList := kermeta::language::key::KeyWordList.new
		keyWordList.initialize
	end
	
	// the main method to be rewrited from Visitor class
	/**
	 * the Top-Down approach consist in adding navigation code to the 'accept' methods
	 * for the elements which have sub-elements, in a "super" concrete visitor. This
	 * visitor would be inherited by the real visitors which can have only the specific
	 * code devoted to the targeted treatment.
	 * Use the "super.accept()" command to include the navigation behavior in your visitor.
	 */
    method applyPattern(pack : EPackage, visitableInterface : EClass, abstractVisitor : EClass,
			visitReturnType : EClassifier) is do
		
		// we reuse the Visitor.applyPattern()
        super(pack, visitableInterface, abstractVisitor, visitReturnType)
        
		mainVisitor := addMainVisitor(pack, abstractVisitor)
		
		// TODO : add the management of subPackages
		
        // we generate the code of MainVisitor 'visit' methods
        pack.eClassifiers.each{ eClassifier | 
            var eClass : EClass
            eClass ?= eClassifier
            if eClass != void then
            	if (eClass != visitableInterface ) and (eClass != abstractVisitor )
            	then
            		processClass(eClass, visitableInterface, abstractVisitor, visitReturnType)
    			end
        	end
        }
    end
    
    // add the main concrete visitor to the 'visitors' package
    operation addMainVisitor(pack : EPackage, abstractVisitor : EClass) : EClass is do
		var superVisitor : EClass init EClass.new
		superVisitor.name := "TopDownVisitor"
		superVisitor.addSuperType(abstractVisitor)
		superVisitor.~abstract := true
        specPack.eClassifiers.add(superVisitor)
        result := superVisitor
    end
    
    // processes package components and creates the package "visit" method
    operation processSubPackage(p : EPackage, visitableInterface : EClass, abstractVisitor : EClass,
			visitReturnType : EClassifier) is do
        // TODO : not yet implemented
    	
    end
    
    // TODO : Java code not yet generated ....
    // processes the class composition and creates the class 'visit' code in MainVisitor
    operation processClass(eClass : EClass, visitableInterface : EClass, abstractVisitor : EClass,
			visitReturnType : EClassifier) is do
		
    	if(eClass.eAllSuperTypes.exists{e | e.equals(visitableInterface)}) then
    		
			var kermetaBody : String init ""
			if self.generateKermetaCode then	// add the kermeta code for the implementation
				// superType references
				eClass.eAllReferences.each{ eRef |
					kermetaBody.append(processReference(eClass, eRef, visitableInterface,
						abstractVisitor, visitReturnType))
				}
				// current Type references
				eClass.eReferences.each{ eRef |
					kermetaBody.append(processReference(eClass, eRef, visitableInterface,
						abstractVisitor, visitReturnType))
				}
			end
			// the equivalent of the visitFoo methods in the visitor
	    	var visitFoo : EOperation init EOperation.new
	        var vParam : EParameter init EParameter.new
			visitFoo.name := "visit" + eClass.name
			vParam.name := "visitable"
			vParam.setType( eClass)
			visitFoo.eParameters.add(vParam)
			visitFoo.setType( visitReturnType)
			if self.generateKermetaCode then
				kermetaBody := "do\n" + kermetaBody + "end"
    			helper.addAnnotation(visitFoo, "kermeta", "body", kermetaBody)
        		helper.addAnnotation(visitFoo, "kermeta","isAbstract","false")
    		end
    		mainVisitor.eOperations.add(visitFoo)
    	end
    	
    end
    
    // write the specific code of compositions
    operation processReference(c : EClass, r : EReference, visitableInterface : EClass,
			abstractVisitor : EClass, visitReturnType : EClassifier) : String is do
    	
		var body : String init ""
		// we must avoid the annotations put in some classes by other processes
		if r.containment and r.name != "eAnnotations" then
			var refName : String init reservedName(r.name)
//			body.append("// Autogenerated Top-Down Visitor action for the \"" + r.name + "\" composition\n")
			if r.upperBound == 1 then
				// "r" references 0 or 1 object, implying direct access
				body.append("if visitable." + refName + " != void then visitable." + refName + ".accept(self) end\n")
			else
				// "r" references 0, 1 or * objects, implying collection browsing
				body.append("visitable." + refName + ".each{ e | e.accept(self) }\n")
			end
		end
		result := body
    end
    
    // references with a name corresponding to a Kermeta reserved word
    //  must be prefixed by a "~"
    operation reservedName(name : String) : String is do
    	if keyWordList.isKeyword(name)
			then name := "~" + name
		end
    	result := name
    end
}