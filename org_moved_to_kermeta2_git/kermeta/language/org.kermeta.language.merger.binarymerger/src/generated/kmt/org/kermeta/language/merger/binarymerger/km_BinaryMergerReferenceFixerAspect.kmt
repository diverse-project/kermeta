package org;

require kermeta
require "platform:/resource/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.ecore.binarymergergenerator/src/main/kermeta/org/kermeta/ecore/binarymerger/BinaryMergerContext.kmt"
require "platform:/lookup/org.kermeta.ecore.binarymergergenerator/src/main/kermeta/org/kermeta/ecore/binarymerger/Mergeable.kmt"
require "platform:/resource/org.kermeta.language.merger.binarymerger/src/generated/kmt/org/kermeta/language/merger/binarymerger/km_BinaryMergerAspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/eachOwnedElement_kermeta_aspect.kmt"
require "platform:/lookup/org.kermeta.language.merger.binarymerger/src/main/kmt/org/kermeta/language/merger/binarymerger/km_BinaryMergerSignatureAspect.kmt"
require "platform:/lookup/org.kermeta.language.merger.binarymerger/src/main/kmt/org/kermeta/language/merger/binarymerger/km_BinaryMergerPropertyResolverAspect.kmt"

using kermeta::language::structure
using org::kermeta::ecore::binarymerger

package kermeta {
	package language {
		package behavior {
			aspect class Assignment inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::Assignment
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Assignment
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Expression inherits org::kermeta::language::structure::KermetaModelElement, org::kermeta::language::structure::TypeContainer {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::behavior::Expression
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.staticType.isVoid then
						if not self.staticType.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.staticType := self.staticType.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::behavior::Expression
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.staticType ?= mergedModelElement.selectUnaryProperty("staticType", self.staticType, mergedModelElement.staticType)
					if (not mergedModelElement.staticType.isVoid) then
						mergedModelElement.staticType ?= mergedModelElement.staticType.getElementInMergedModel
					end
				end
			}

			aspect class CallExpression inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::CallExpression
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var staticTypeVariableBindingsToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.staticTypeVariableBindings.select{ o | not o.similarElementInMergedModel.isVoid }
					staticTypeVariableBindingsToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute staticTypeVariableBindings)")
						self.staticTypeVariableBindings.remove(o)
						self.staticTypeVariableBindings.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::CallExpression
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var staticTypeVariableBindingsToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					staticTypeVariableBindingsToAdd := self.staticTypeVariableBindings.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.staticTypeVariableBindings.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.staticTypeVariableBindings.addAll(staticTypeVariableBindingsToAdd)
				end
			}

			aspect class Block inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::Block
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Block
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class CallVariable inherits org::kermeta::language::behavior::CallExpression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallExpression is do
					var aspectModelElement : org::kermeta::language::behavior::CallVariable
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallExpression is do
					var mergedModelElement : org::kermeta::language::behavior::CallVariable
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class CallFeature inherits org::kermeta::language::behavior::CallExpression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallExpression is do
					var aspectModelElement : org::kermeta::language::behavior::CallFeature
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallExpression is do
					var mergedModelElement : org::kermeta::language::behavior::CallFeature
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class CallSuperOperation inherits org::kermeta::language::behavior::CallOperation {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallOperation is do
					var aspectModelElement : org::kermeta::language::behavior::CallSuperOperation
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.superType.isVoid then
						if not self.superType.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.superType := self.superType.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallOperation is do
					var mergedModelElement : org::kermeta::language::behavior::CallSuperOperation
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.superType ?= mergedModelElement.selectUnaryProperty("superType", self.superType, mergedModelElement.superType)
					if (not mergedModelElement.superType.isVoid) then
						mergedModelElement.superType ?= mergedModelElement.superType.getElementInMergedModel
					end
				end
			}

			aspect class CallResult inherits org::kermeta::language::behavior::CallVariable {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallVariable is do
					var aspectModelElement : org::kermeta::language::behavior::CallResult
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallVariable is do
					var mergedModelElement : org::kermeta::language::behavior::CallResult
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class CallValue inherits org::kermeta::language::behavior::CallExpression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallExpression is do
					var aspectModelElement : org::kermeta::language::behavior::CallValue
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallExpression is do
					var mergedModelElement : org::kermeta::language::behavior::CallValue
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Conditional inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::Conditional
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Conditional
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Raise inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::Raise
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Raise
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Rescue inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::behavior::Rescue
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::behavior::Rescue
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class TypeReference inherits org::kermeta::language::structure::MultiplicityElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var aspectModelElement : org::kermeta::language::behavior::TypeReference
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::behavior::TypeReference
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Literal inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::Literal
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Literal
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class EmptyExpression inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::EmptyExpression
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::EmptyExpression
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class JavaStaticCall inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::JavaStaticCall
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::JavaStaticCall
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class LambdaExpression inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::LambdaExpression
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::LambdaExpression
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class LambdaParameter inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::behavior::LambdaParameter
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::behavior::LambdaParameter
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class IntegerLiteral inherits org::kermeta::language::behavior::Literal {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Literal is do
					var aspectModelElement : org::kermeta::language::behavior::IntegerLiteral
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::IntegerLiteral
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class StringLiteral inherits org::kermeta::language::behavior::Literal {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Literal is do
					var aspectModelElement : org::kermeta::language::behavior::StringLiteral
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::StringLiteral
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class BooleanLiteral inherits org::kermeta::language::behavior::Literal {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Literal is do
					var aspectModelElement : org::kermeta::language::behavior::BooleanLiteral
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::BooleanLiteral
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class CallTypeLiteral inherits org::kermeta::language::behavior::Literal {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Literal is do
					var aspectModelElement : org::kermeta::language::behavior::CallTypeLiteral
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::CallTypeLiteral
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class VoidLiteral inherits org::kermeta::language::behavior::Literal {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Literal is do
					var aspectModelElement : org::kermeta::language::behavior::VoidLiteral
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::VoidLiteral
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Loop inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::Loop
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Loop
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class SelfExpression inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::SelfExpression
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::SelfExpression
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class VariableDecl inherits org::kermeta::language::behavior::Expression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::Expression is do
					var aspectModelElement : org::kermeta::language::behavior::VariableDecl
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::VariableDecl
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class UnresolvedCall inherits org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::behavior::CallExpression, org::kermeta::language::structure::TypeContainer {
				method fixReferences( ) : Void from org::kermeta::language::structure::UnresolvedReference is do
					var aspectModelElement : org::kermeta::language::behavior::UnresolvedCall
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.targetParent.isVoid then
						if not self.targetParent.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.targetParent := self.targetParent.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var genericsToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.generics.select{ o | not o.similarElementInMergedModel.isVoid }
					genericsToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute generics)")
						self.generics.remove(o)
						self.generics.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var staticTypeVariableBindingsToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.staticTypeVariableBindings.select{ o | not o.similarElementInMergedModel.isVoid }
					staticTypeVariableBindingsToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute staticTypeVariableBindings)")
						self.staticTypeVariableBindings.remove(o)
						self.staticTypeVariableBindings.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
					if not self.staticType.isVoid then
						if not self.staticType.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.staticType := self.staticType.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::UnresolvedReference is do
					var mergedModelElement : org::kermeta::language::behavior::UnresolvedCall
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.targetParent ?= mergedModelElement.selectUnaryProperty("targetParent", self.targetParent, mergedModelElement.targetParent)
					if (not mergedModelElement.targetParent.isVoid) then
						mergedModelElement.targetParent ?= mergedModelElement.targetParent.getElementInMergedModel
					end
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var genericsToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					genericsToAdd := self.generics.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.generics.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.generics.addAll(genericsToAdd)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var staticTypeVariableBindingsToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					staticTypeVariableBindingsToAdd := self.staticTypeVariableBindings.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.staticTypeVariableBindings.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.staticTypeVariableBindings.addAll(staticTypeVariableBindingsToAdd)
					// select value for unary reference (not involved in composition)
					mergedModelElement.staticType ?= mergedModelElement.selectUnaryProperty("staticType", self.staticType, mergedModelElement.staticType)
					if (not mergedModelElement.staticType.isVoid) then
						mergedModelElement.staticType ?= mergedModelElement.staticType.getElementInMergedModel
					end
				end
			}

			aspect class CallOperation inherits org::kermeta::language::behavior::CallFeature {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallFeature is do
					var aspectModelElement : org::kermeta::language::behavior::CallOperation
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.staticOperation.isVoid then
						if not self.staticOperation.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.staticOperation := self.staticOperation.similarElementInMergedModel.asType(org::kermeta::language::structure::Operation)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallFeature is do
					var mergedModelElement : org::kermeta::language::behavior::CallOperation
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.staticOperation ?= mergedModelElement.selectUnaryProperty("staticOperation", self.staticOperation, mergedModelElement.staticOperation)
					if (not mergedModelElement.staticOperation.isVoid) then
						mergedModelElement.staticOperation ?= mergedModelElement.staticOperation.getElementInMergedModel
					end
				end
			}

			aspect class CallProperty inherits org::kermeta::language::behavior::CallFeature {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallFeature is do
					var aspectModelElement : org::kermeta::language::behavior::CallProperty
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.staticProperty.isVoid then
						if not self.staticProperty.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.staticProperty := self.staticProperty.similarElementInMergedModel.asType(org::kermeta::language::structure::Property)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallFeature is do
					var mergedModelElement : org::kermeta::language::behavior::CallProperty
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.staticProperty ?= mergedModelElement.selectUnaryProperty("staticProperty", self.staticProperty, mergedModelElement.staticProperty)
					if (not mergedModelElement.staticProperty.isVoid) then
						mergedModelElement.staticProperty ?= mergedModelElement.staticProperty.getElementInMergedModel
					end
				end
			}

			aspect class CallEnumLiteral inherits org::kermeta::language::behavior::CallExpression {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallExpression is do
					var aspectModelElement : org::kermeta::language::behavior::CallEnumLiteral
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.staticEnumLiteral.isVoid then
						if not self.staticEnumLiteral.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.staticEnumLiteral := self.staticEnumLiteral.similarElementInMergedModel.asType(org::kermeta::language::structure::EnumerationLiteral)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallExpression is do
					var mergedModelElement : org::kermeta::language::behavior::CallEnumLiteral
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.staticEnumLiteral ?= mergedModelElement.selectUnaryProperty("staticEnumLiteral", self.staticEnumLiteral, mergedModelElement.staticEnumLiteral)
					if (not mergedModelElement.staticEnumLiteral.isVoid) then
						mergedModelElement.staticEnumLiteral ?= mergedModelElement.staticEnumLiteral.getElementInMergedModel
					end
				end
			}

			aspect class CallModelTransformation inherits org::kermeta::language::behavior::CallFeature {
				method fixReferences( ) : Void from org::kermeta::language::behavior::CallFeature is do
					var aspectModelElement : org::kermeta::language::behavior::CallModelTransformation
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.staticTransformation.isVoid then
						if not self.staticTransformation.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.staticTransformation := self.staticTransformation.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelTransformation)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::behavior::CallFeature is do
					var mergedModelElement : org::kermeta::language::behavior::CallModelTransformation
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.staticTransformation ?= mergedModelElement.selectUnaryProperty("staticTransformation", self.staticTransformation, mergedModelElement.staticTransformation)
					if (not mergedModelElement.staticTransformation.isVoid) then
						mergedModelElement.staticTransformation ?= mergedModelElement.staticTransformation.getElementInMergedModel
					end
				end
			}

		}


		package structure {


			aspect class KermetaModelElement inherits Mergeable  {
				method fixReferences( ) : Void is do
					var aspectModelElement : org::kermeta::language::structure::KermetaModelElement
					aspectModelElement ?= self.similarElementInAspectModel
					
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var kTagToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Tag> init self.kTag.select{ o | not o.similarElementInMergedModel.isVoid }
					kTagToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute kTag)")
						self.kTag.remove(o)
						self.kTag.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Tag))
					}
					
					// drill down into all contained elements
					self.eachOwnedElement{ e | e.asType(Mergeable).fixReferences()
						void
					}
				end
				operation mergeReferences( context : BinaryMergerContext ) : Void is do
					var mergedModelElement : org::kermeta::language::structure::KermetaModelElement
					mergedModelElement ?= self.similarElementInMergedModel
					
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var kTagToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Tag>
					kTagToAdd := self.kTag.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.kTag.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Tag)
						}
					mergedModelElement.kTag.addAll(kTagToAdd)
				end
			}


			aspect class Operation inherits org::kermeta::language::structure::MultiplicityElement, org::kermeta::language::structure::AbstractOperation {
				method fixReferences( ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var aspectModelElement : org::kermeta::language::structure::Operation
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var raisedExceptionToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.raisedException.select{ o | not o.similarElementInMergedModel.isVoid }
					raisedExceptionToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute raisedException)")
						self.raisedException.remove(o)
						self.raisedException.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var typeParameterToMove : kermeta::standard::Sequence<org::kermeta::language::structure::TypeVariable> init self.typeParameter.select{ o | not o.similarElementInMergedModel.isVoid }
					typeParameterToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute typeParameter)")
						self.typeParameter.remove(o)
						self.typeParameter.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::TypeVariable))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::structure::Operation
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var raisedExceptionToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					raisedExceptionToAdd := self.raisedException.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.raisedException.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.raisedException.addAll(raisedExceptionToAdd)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var typeParameterToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::TypeVariable>
					typeParameterToAdd := self.typeParameter.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.typeParameter.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::TypeVariable)
						}
					mergedModelElement.typeParameter.addAll(typeParameterToAdd)
				end
			}

			aspect class Property inherits org::kermeta::language::structure::MultiplicityElement, org::kermeta::language::structure::AbstractProperty {
				method fixReferences( ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var aspectModelElement : org::kermeta::language::structure::Property
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.opposite.isVoid then
						if not self.opposite.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.opposite := self.opposite.similarElementInMergedModel.asType(org::kermeta::language::structure::AbstractProperty)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::structure::Property
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.opposite ?= mergedModelElement.selectUnaryProperty("opposite", self.opposite, mergedModelElement.opposite)
					if (not mergedModelElement.opposite.isVoid) then
						mergedModelElement.opposite ?= mergedModelElement.opposite.getElementInMergedModel
					end
				end
			}

			aspect class Type inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::Type
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Type
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class TypeContainer inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::TypeContainer
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::TypeContainer
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class EnumerationLiteral inherits org::kermeta::language::structure::NamedElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::NamedElement is do
					var aspectModelElement : org::kermeta::language::structure::EnumerationLiteral
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::EnumerationLiteral
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class TypeVariableBinding inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeContainer is do
					var aspectModelElement : org::kermeta::language::structure::TypeVariableBinding
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.variable.isVoid then
						if not self.variable.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.variable := self.variable.similarElementInMergedModel.asType(org::kermeta::language::structure::TypeVariable)
						end
					end
					if not self.type.isVoid then
						if not self.type.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.type := self.type.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::TypeVariableBinding
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.variable ?= mergedModelElement.selectUnaryProperty("variable", self.variable, mergedModelElement.variable)
					if (not mergedModelElement.variable.isVoid) then
						mergedModelElement.variable ?= mergedModelElement.variable.getElementInMergedModel
					end
					// select value for unary reference (not involved in composition)
					mergedModelElement.type ?= mergedModelElement.selectUnaryProperty("type", self.type, mergedModelElement.type)
					if (not mergedModelElement.type.isVoid) then
						mergedModelElement.type ?= mergedModelElement.type.getElementInMergedModel
					end
				end
			}

			aspect class MultiplicityElement inherits org::kermeta::language::structure::TypedElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypedElement is do
					var aspectModelElement : org::kermeta::language::structure::MultiplicityElement
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypedElement is do
					var mergedModelElement : org::kermeta::language::structure::MultiplicityElement
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class TypeDefinition inherits org::kermeta::language::structure::NamedElement, org::kermeta::language::structure::TypeContainer {
				method fixReferences( ) : Void from org::kermeta::language::structure::NamedElement is do
					var aspectModelElement : org::kermeta::language::structure::TypeDefinition
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					var superTypeToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.superType.select{ o | not o.similarElementInMergedModel.isVoid }
					superTypeToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute superType)")
						self.superType.remove(o)
						self.superType.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::TypeDefinition
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					var superTypeToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					superTypeToAdd := self.superType.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.superType.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.superType.addAll(superTypeToAdd)
				end
			}

			aspect class Class inherits org::kermeta::language::structure::ParameterizedType {
				method fixReferences( ) : Void from org::kermeta::language::structure::ParameterizedType is do
					var aspectModelElement : org::kermeta::language::structure::Class
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::ParameterizedType is do
					var mergedModelElement : org::kermeta::language::structure::Class
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class DataType inherits org::kermeta::language::structure::Type, org::kermeta::language::structure::ModelElementTypeDefinition {
				method fixReferences( ) : Void from org::kermeta::language::structure::Type is do
					var aspectModelElement : org::kermeta::language::structure::DataType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					var superTypeToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.superType.select{ o | not o.similarElementInMergedModel.isVoid }
					superTypeToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute superType)")
						self.superType.remove(o)
						self.superType.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::DataType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					var superTypeToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					superTypeToAdd := self.superType.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.superType.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.superType.addAll(superTypeToAdd)
				end
			}

			aspect class Enumeration inherits org::kermeta::language::structure::DataType {
				method fixReferences( ) : Void from org::kermeta::language::structure::DataType is do
					var aspectModelElement : org::kermeta::language::structure::Enumeration
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					var superTypeToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.superType.select{ o | not o.similarElementInMergedModel.isVoid }
					superTypeToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute superType)")
						self.superType.remove(o)
						self.superType.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::DataType is do
					var mergedModelElement : org::kermeta::language::structure::Enumeration
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					var superTypeToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					superTypeToAdd := self.superType.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.superType.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.superType.addAll(superTypeToAdd)
				end
			}

			aspect class NamedElement inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::NamedElement
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::NamedElement
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Package inherits org::kermeta::language::structure::NamedElement, org::kermeta::language::structure::ModelElementTypeDefinitionContainer {
				method fixReferences( ) : Void from org::kermeta::language::structure::NamedElement is do
					var aspectModelElement : org::kermeta::language::structure::Package
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::Package
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Parameter inherits org::kermeta::language::structure::MultiplicityElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var aspectModelElement : org::kermeta::language::structure::Parameter
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::structure::Parameter
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class PrimitiveType inherits org::kermeta::language::structure::DataType {
				method fixReferences( ) : Void from org::kermeta::language::structure::DataType is do
					var aspectModelElement : org::kermeta::language::structure::PrimitiveType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.instanceType.isVoid then
						if not self.instanceType.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.instanceType := self.instanceType.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
					// find referenced elements not in merged model
					var superTypeToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.superType.select{ o | not o.similarElementInMergedModel.isVoid }
					superTypeToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute superType)")
						self.superType.remove(o)
						self.superType.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::DataType is do
					var mergedModelElement : org::kermeta::language::structure::PrimitiveType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.instanceType ?= mergedModelElement.selectUnaryProperty("instanceType", self.instanceType, mergedModelElement.instanceType)
					if (not mergedModelElement.instanceType.isVoid) then
						mergedModelElement.instanceType ?= mergedModelElement.instanceType.getElementInMergedModel
					end
					// merge references from aspect and primary model (not involved in composition)
					var superTypeToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					superTypeToAdd := self.superType.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.superType.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.superType.addAll(superTypeToAdd)
				end
			}

			aspect class TypedElement inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::NamedElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeContainer is do
					var aspectModelElement : org::kermeta::language::structure::TypedElement
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.type.isVoid then
						if not self.type.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.type := self.type.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::TypedElement
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.type ?= mergedModelElement.selectUnaryProperty("type", self.type, mergedModelElement.type)
					if (not mergedModelElement.type.isVoid) then
						mergedModelElement.type ?= mergedModelElement.type.getElementInMergedModel
					end
				end
			}


			aspect class Tag inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::Tag
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var objectToMove : kermeta::standard::Sequence<org::kermeta::language::structure::KermetaModelElement> init self.object.select{ o | not o.similarElementInMergedModel.isVoid }
					objectToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute object)")
						self.object.remove(o)
						self.object.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::KermetaModelElement))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Tag
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var objectToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::KermetaModelElement>
					objectToAdd := self.object.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.object.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::KermetaModelElement)
						}
					mergedModelElement.object.addAll(objectToAdd)
				end
			}

			aspect class AbstractProperty inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::AbstractProperty
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::AbstractProperty
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Constraint inherits org::kermeta::language::structure::NamedElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::NamedElement is do
					var aspectModelElement : org::kermeta::language::structure::Constraint
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::Constraint
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}


			aspect class ClassDefinition inherits org::kermeta::language::structure::GenericTypeDefinition {
				method fixReferences( ) : Void from org::kermeta::language::structure::GenericTypeDefinition is do
					var aspectModelElement : org::kermeta::language::structure::ClassDefinition
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::GenericTypeDefinition is do
					var mergedModelElement : org::kermeta::language::structure::ClassDefinition
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}


			aspect class Metamodel inherits org::kermeta::language::structure::KermetaModelElement, org::kermeta::language::structure::NamedElement, org::kermeta::language::structure::ModelTypeDefinitionContainer {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::Metamodel
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Metamodel
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class ModelElementTypeDefinitionContainer inherits org::kermeta::language::structure::NamedElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::NamedElement is do
					var aspectModelElement : org::kermeta::language::structure::ModelElementTypeDefinitionContainer
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::ModelElementTypeDefinitionContainer
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class GenericTypeDefinition inherits org::kermeta::language::structure::ModelElementTypeDefinition {
				method fixReferences( ) : Void from org::kermeta::language::structure::ModelElementTypeDefinition is do
					var aspectModelElement : org::kermeta::language::structure::GenericTypeDefinition
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var typeParameterToMove : kermeta::standard::Sequence<org::kermeta::language::structure::TypeVariable> init self.typeParameter.select{ o | not o.similarElementInMergedModel.isVoid }
					typeParameterToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute typeParameter)")
						self.typeParameter.remove(o)
						self.typeParameter.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::TypeVariable))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::ModelElementTypeDefinition is do
					var mergedModelElement : org::kermeta::language::structure::GenericTypeDefinition
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var typeParameterToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::TypeVariable>
					typeParameterToAdd := self.typeParameter.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.typeParameter.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::TypeVariable)
						}
					mergedModelElement.typeParameter.addAll(typeParameterToAdd)
				end
			}

			aspect class ParameterizedType inherits org::kermeta::language::structure::Type {
				method fixReferences( ) : Void from org::kermeta::language::structure::Type is do
					var aspectModelElement : org::kermeta::language::structure::ParameterizedType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.typeDefinition.isVoid then
						if not self.typeDefinition.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.typeDefinition := self.typeDefinition.similarElementInMergedModel.asType(org::kermeta::language::structure::GenericTypeDefinition)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::ParameterizedType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.typeDefinition ?= mergedModelElement.selectUnaryProperty("typeDefinition", self.typeDefinition, mergedModelElement.typeDefinition)
					if (not mergedModelElement.typeDefinition.isVoid) then
						mergedModelElement.typeDefinition ?= mergedModelElement.typeDefinition.getElementInMergedModel
					end
				end
			}

			aspect class TypeVariable inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::Type, org::kermeta::language::structure::NamedElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeContainer is do
					var aspectModelElement : org::kermeta::language::structure::TypeVariable
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.supertype.isVoid then
						if not self.supertype.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.supertype := self.supertype.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::TypeVariable
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.supertype ?= mergedModelElement.selectUnaryProperty("supertype", self.supertype, mergedModelElement.supertype)
					if (not mergedModelElement.supertype.isVoid) then
						mergedModelElement.supertype ?= mergedModelElement.supertype.getElementInMergedModel
					end
				end
			}

			aspect class ObjectTypeVariable inherits org::kermeta::language::structure::TypeVariable {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeVariable is do
					var aspectModelElement : org::kermeta::language::structure::ObjectTypeVariable
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeVariable is do
					var mergedModelElement : org::kermeta::language::structure::ObjectTypeVariable
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class ModelTypeVariable inherits org::kermeta::language::structure::TypeVariable {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeVariable is do
					var aspectModelElement : org::kermeta::language::structure::ModelTypeVariable
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var virtualTypeToMove : kermeta::standard::Sequence<org::kermeta::language::structure::VirtualType> init self.virtualType.select{ o | not o.similarElementInMergedModel.isVoid }
					virtualTypeToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute virtualType)")
						self.virtualType.remove(o)
						self.virtualType.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::VirtualType))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeVariable is do
					var mergedModelElement : org::kermeta::language::structure::ModelTypeVariable
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var virtualTypeToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::VirtualType>
					virtualTypeToAdd := self.virtualType.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.virtualType.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::VirtualType)
						}
					mergedModelElement.virtualType.addAll(virtualTypeToAdd)
				end
			}

			aspect class VirtualType inherits org::kermeta::language::structure::ObjectTypeVariable {
				method fixReferences( ) : Void from org::kermeta::language::structure::ObjectTypeVariable is do
					var aspectModelElement : org::kermeta::language::structure::VirtualType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.typeDefinition.isVoid then
						if not self.typeDefinition.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.typeDefinition := self.typeDefinition.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelElementTypeDefinition)
						end
					end
					if not self.modelTypeVariable.isVoid then
						if not self.modelTypeVariable.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.modelTypeVariable := self.modelTypeVariable.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelTypeVariable)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::ObjectTypeVariable is do
					var mergedModelElement : org::kermeta::language::structure::VirtualType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.typeDefinition ?= mergedModelElement.selectUnaryProperty("typeDefinition", self.typeDefinition, mergedModelElement.typeDefinition)
					if (not mergedModelElement.typeDefinition.isVoid) then
						mergedModelElement.typeDefinition ?= mergedModelElement.typeDefinition.getElementInMergedModel
					end
					// select value for unary reference (not involved in composition)
					mergedModelElement.modelTypeVariable ?= mergedModelElement.selectUnaryProperty("modelTypeVariable", self.modelTypeVariable, mergedModelElement.modelTypeVariable)
					if (not mergedModelElement.modelTypeVariable.isVoid) then
						mergedModelElement.modelTypeVariable ?= mergedModelElement.modelTypeVariable.getElementInMergedModel
					end
				end
			}

			aspect class Model inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::Model
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var contentsToMove : kermeta::standard::Sequence<org::kermeta::language::structure::KermetaModelElement> init self.contents.select{ o | not o.similarElementInMergedModel.isVoid }
					contentsToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute contents)")
						self.contents.remove(o)
						self.contents.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::KermetaModelElement))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Model
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var contentsToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::KermetaModelElement>
					contentsToAdd := self.contents.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.contents.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::KermetaModelElement)
						}
					mergedModelElement.contents.addAll(contentsToAdd)
				end
			}

			aspect class AbstractOperation inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::AbstractOperation
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::AbstractOperation
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class UnresolvedType inherits org::kermeta::language::structure::Type, org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::structure::TypeContainer {
				method fixReferences( ) : Void from org::kermeta::language::structure::Type is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var genericsToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.generics.select{ o | not o.similarElementInMergedModel.isVoid }
					genericsToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute generics)")
						self.generics.remove(o)
						self.generics.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var genericsToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					genericsToAdd := self.generics.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.generics.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.generics.addAll(genericsToAdd)
				end
			}

			aspect class UnresolvedReference inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedReference
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedReference
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class UnresolvedProperty inherits org::kermeta::language::structure::AbstractProperty, org::kermeta::language::structure::UnresolvedReference {
				method fixReferences( ) : Void from org::kermeta::language::structure::AbstractProperty is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedProperty
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::AbstractProperty is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedProperty
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class UnresolvedOperation inherits org::kermeta::language::structure::AbstractOperation, org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::structure::TypeContainer {
				method fixReferences( ) : Void from org::kermeta::language::structure::AbstractOperation is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedOperation
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::AbstractOperation is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedOperation
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class Using inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::Using
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Using
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class ProductType inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::Type {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeContainer is do
					var aspectModelElement : org::kermeta::language::structure::ProductType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var typeToMove : kermeta::standard::Sequence<org::kermeta::language::structure::Type> init self.type.select{ o | not o.similarElementInMergedModel.isVoid }
					typeToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute type)")
						self.type.remove(o)
						self.type.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::Type))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::ProductType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var typeToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::Type>
					typeToAdd := self.type.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.type.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::Type)
						}
					mergedModelElement.type.addAll(typeToAdd)
				end
			}

			aspect class FunctionType inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::Type {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeContainer is do
					var aspectModelElement : org::kermeta::language::structure::FunctionType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.left.isVoid then
						if not self.left.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.left := self.left.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
					if not self.right.isVoid then
						if not self.right.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.right := self.right.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::FunctionType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.left ?= mergedModelElement.selectUnaryProperty("left", self.left, mergedModelElement.left)
					if (not mergedModelElement.left.isVoid) then
						mergedModelElement.left ?= mergedModelElement.left.getElementInMergedModel
					end
					// select value for unary reference (not involved in composition)
					mergedModelElement.right ?= mergedModelElement.selectUnaryProperty("right", self.right, mergedModelElement.right)
					if (not mergedModelElement.right.isVoid) then
						mergedModelElement.right ?= mergedModelElement.right.getElementInMergedModel
					end
				end
			}

			aspect class VoidType inherits org::kermeta::language::structure::Type {
				method fixReferences( ) : Void from org::kermeta::language::structure::Type is do
					var aspectModelElement : org::kermeta::language::structure::VoidType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::VoidType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class UnresolvedInferredType inherits org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::structure::Type {
				method fixReferences( ) : Void from org::kermeta::language::structure::UnresolvedReference is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedInferredType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::UnresolvedReference is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedInferredType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class UnresolvedTypeVariable inherits org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::structure::TypeVariable {
				method fixReferences( ) : Void from org::kermeta::language::structure::UnresolvedReference is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedTypeVariable
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.supertype.isVoid then
						if not self.supertype.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.supertype := self.supertype.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::UnresolvedReference is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedTypeVariable
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.supertype ?= mergedModelElement.selectUnaryProperty("supertype", self.supertype, mergedModelElement.supertype)
					if (not mergedModelElement.supertype.isVoid) then
						mergedModelElement.supertype ?= mergedModelElement.supertype.getElementInMergedModel
					end
				end
			}

			aspect class ModelTypeDefinitionBinding inherits org::kermeta::language::structure::KermetaModelElement, org::kermeta::language::structure::ModelTypeDefinitionContainer {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::ModelTypeDefinitionBinding
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.boundModelTypeDefinition.isVoid then
						if not self.boundModelTypeDefinition.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.boundModelTypeDefinition := self.boundModelTypeDefinition.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelTypeDefinition)
						end
					end
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var targetedTransformationsToMove : kermeta::standard::Sequence<org::kermeta::language::structure::ModelTransformation> init self.targetedTransformations.select{ o | not o.similarElementInMergedModel.isVoid }
					targetedTransformationsToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute targetedTransformations)")
						self.targetedTransformations.remove(o)
						self.targetedTransformations.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelTransformation))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::ModelTypeDefinitionBinding
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.boundModelTypeDefinition ?= mergedModelElement.selectUnaryProperty("boundModelTypeDefinition", self.boundModelTypeDefinition, mergedModelElement.boundModelTypeDefinition)
					if (not mergedModelElement.boundModelTypeDefinition.isVoid) then
						mergedModelElement.boundModelTypeDefinition ?= mergedModelElement.boundModelTypeDefinition.getElementInMergedModel
					end
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var targetedTransformationsToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::ModelTransformation>
					targetedTransformationsToAdd := self.targetedTransformations.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.targetedTransformations.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::ModelTransformation)
						}
					mergedModelElement.targetedTransformations.addAll(targetedTransformationsToAdd)
				end
			}

			aspect class ClassDefinitionBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::ClassDefinitionBinding
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.source.isVoid then
						if not self.source.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.source := self.source.similarElementInMergedModel.asType(org::kermeta::language::structure::ClassDefinition)
						end
					end
					if not self.target.isVoid then
						if not self.target.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.target := self.target.similarElementInMergedModel.asType(org::kermeta::language::structure::ClassDefinition)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::ClassDefinitionBinding
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.source ?= mergedModelElement.selectUnaryProperty("source", self.source, mergedModelElement.source)
					if (not mergedModelElement.source.isVoid) then
						mergedModelElement.source ?= mergedModelElement.source.getElementInMergedModel
					end
					// select value for unary reference (not involved in composition)
					mergedModelElement.target ?= mergedModelElement.selectUnaryProperty("target", self.target, mergedModelElement.target)
					if (not mergedModelElement.target.isVoid) then
						mergedModelElement.target ?= mergedModelElement.target.getElementInMergedModel
					end
				end
			}

			aspect class EnumerationBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::EnumerationBinding
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.source.isVoid then
						if not self.source.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.source := self.source.similarElementInMergedModel.asType(org::kermeta::language::structure::Enumeration)
						end
					end
					if not self.target.isVoid then
						if not self.target.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.target := self.target.similarElementInMergedModel.asType(org::kermeta::language::structure::Enumeration)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::EnumerationBinding
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.source ?= mergedModelElement.selectUnaryProperty("source", self.source, mergedModelElement.source)
					if (not mergedModelElement.source.isVoid) then
						mergedModelElement.source ?= mergedModelElement.source.getElementInMergedModel
					end
					// select value for unary reference (not involved in composition)
					mergedModelElement.target ?= mergedModelElement.selectUnaryProperty("target", self.target, mergedModelElement.target)
					if (not mergedModelElement.target.isVoid) then
						mergedModelElement.target ?= mergedModelElement.target.getElementInMergedModel
					end
				end
			}

			aspect class PropertyBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::PropertyBinding
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.source.isVoid then
						if not self.source.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.source := self.source.similarElementInMergedModel.asType(org::kermeta::language::structure::Property)
						end
					end
					if not self.target.isVoid then
						if not self.target.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.target := self.target.similarElementInMergedModel.asType(org::kermeta::language::structure::Property)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::PropertyBinding
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.source ?= mergedModelElement.selectUnaryProperty("source", self.source, mergedModelElement.source)
					if (not mergedModelElement.source.isVoid) then
						mergedModelElement.source ?= mergedModelElement.source.getElementInMergedModel
					end
					// select value for unary reference (not involved in composition)
					mergedModelElement.target ?= mergedModelElement.selectUnaryProperty("target", self.target, mergedModelElement.target)
					if (not mergedModelElement.target.isVoid) then
						mergedModelElement.target ?= mergedModelElement.target.getElementInMergedModel
					end
				end
			}

			aspect class OperationBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::OperationBinding
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.source.isVoid then
						if not self.source.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.source := self.source.similarElementInMergedModel.asType(org::kermeta::language::structure::Operation)
						end
					end
					if not self.target.isVoid then
						if not self.target.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.target := self.target.similarElementInMergedModel.asType(org::kermeta::language::structure::Operation)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::OperationBinding
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.source ?= mergedModelElement.selectUnaryProperty("source", self.source, mergedModelElement.source)
					if (not mergedModelElement.source.isVoid) then
						mergedModelElement.source ?= mergedModelElement.source.getElementInMergedModel
					end
					// select value for unary reference (not involved in composition)
					mergedModelElement.target ?= mergedModelElement.selectUnaryProperty("target", self.target, mergedModelElement.target)
					if (not mergedModelElement.target.isVoid) then
						mergedModelElement.target ?= mergedModelElement.target.getElementInMergedModel
					end
				end
			}

			aspect class AdaptationOperator inherits org::kermeta::language::structure::NamedElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::NamedElement is do
					var aspectModelElement : org::kermeta::language::structure::AdaptationOperator
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var parametersToMove : kermeta::standard::Sequence<org::kermeta::language::structure::AdaptationParameter> init self.parameters.select{ o | not o.similarElementInMergedModel.isVoid }
					parametersToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute parameters)")
						self.parameters.remove(o)
						self.parameters.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::AdaptationParameter))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::AdaptationOperator
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var parametersToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::AdaptationParameter>
					parametersToAdd := self.parameters.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.parameters.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::AdaptationParameter)
						}
					mergedModelElement.parameters.addAll(parametersToAdd)
				end
			}

			aspect class UseAdaptationOperator inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::UseAdaptationOperator
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var parametersToMove : kermeta::standard::Sequence<org::kermeta::language::structure::KermetaModelElement> init self.parameters.select{ o | not o.similarElementInMergedModel.isVoid }
					parametersToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute parameters)")
						self.parameters.remove(o)
						self.parameters.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::KermetaModelElement))
					}
					
					if not self.usedOperator.isVoid then
						if not self.usedOperator.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.usedOperator := self.usedOperator.similarElementInMergedModel.asType(org::kermeta::language::structure::AdaptationOperator)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::UseAdaptationOperator
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var parametersToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::KermetaModelElement>
					parametersToAdd := self.parameters.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.parameters.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::KermetaModelElement)
						}
					mergedModelElement.parameters.addAll(parametersToAdd)
					// select value for unary reference (not involved in composition)
					mergedModelElement.usedOperator ?= mergedModelElement.selectUnaryProperty("usedOperator", self.usedOperator, mergedModelElement.usedOperator)
					if (not mergedModelElement.usedOperator.isVoid) then
						mergedModelElement.usedOperator ?= mergedModelElement.usedOperator.getElementInMergedModel
					end
				end
			}

			aspect class PropertyAdaptationOperator inherits org::kermeta::language::structure::AdaptationOperator {
				method fixReferences( ) : Void from org::kermeta::language::structure::AdaptationOperator is do
					var aspectModelElement : org::kermeta::language::structure::PropertyAdaptationOperator
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.target.isVoid then
						if not self.target.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.target := self.target.similarElementInMergedModel.asType(org::kermeta::language::structure::Property)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::AdaptationOperator is do
					var mergedModelElement : org::kermeta::language::structure::PropertyAdaptationOperator
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.target ?= mergedModelElement.selectUnaryProperty("target", self.target, mergedModelElement.target)
					if (not mergedModelElement.target.isVoid) then
						mergedModelElement.target ?= mergedModelElement.target.getElementInMergedModel
					end
				end
			}

			aspect class UnresolvedAdaptationOperator inherits org::kermeta::language::structure::AdaptationOperator, org::kermeta::language::structure::UnresolvedReference {
				method fixReferences( ) : Void from org::kermeta::language::structure::AdaptationOperator is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedAdaptationOperator
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::AdaptationOperator is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedAdaptationOperator
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class AdaptationParameter inherits org::kermeta::language::structure::TypedElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypedElement is do
					var aspectModelElement : org::kermeta::language::structure::AdaptationParameter
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypedElement is do
					var mergedModelElement : org::kermeta::language::structure::AdaptationParameter
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class OperationAdaptationOperator inherits org::kermeta::language::structure::AdaptationOperator {
				method fixReferences( ) : Void from org::kermeta::language::structure::AdaptationOperator is do
					var aspectModelElement : org::kermeta::language::structure::OperationAdaptationOperator
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.target.isVoid then
						if not self.target.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.target := self.target.similarElementInMergedModel.asType(org::kermeta::language::structure::Operation)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::AdaptationOperator is do
					var mergedModelElement : org::kermeta::language::structure::OperationAdaptationOperator
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.target ?= mergedModelElement.selectUnaryProperty("target", self.target, mergedModelElement.target)
					if (not mergedModelElement.target.isVoid) then
						mergedModelElement.target ?= mergedModelElement.target.getElementInMergedModel
					end
				end
			}

			aspect class ModelElementTypeDefinition inherits org::kermeta::language::structure::TypeDefinition {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeDefinition is do
					var aspectModelElement : org::kermeta::language::structure::ModelElementTypeDefinition
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeDefinition is do
					var mergedModelElement : org::kermeta::language::structure::ModelElementTypeDefinition
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class ModelType inherits org::kermeta::language::structure::Type {
				method fixReferences( ) : Void from org::kermeta::language::structure::Type is do
					var aspectModelElement : org::kermeta::language::structure::ModelType
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.typeDefinition.isVoid then
						if not self.typeDefinition.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.typeDefinition := self.typeDefinition.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelTypeDefinition)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::ModelType
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.typeDefinition ?= mergedModelElement.selectUnaryProperty("typeDefinition", self.typeDefinition, mergedModelElement.typeDefinition)
					if (not mergedModelElement.typeDefinition.isVoid) then
						mergedModelElement.typeDefinition ?= mergedModelElement.typeDefinition.getElementInMergedModel
					end
				end
			}

			aspect class FilteredMetamodelReference inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::FilteredMetamodelReference
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.metamodel.isVoid then
						if not self.metamodel.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.metamodel := self.metamodel.similarElementInMergedModel.asType(org::kermeta::language::structure::Metamodel)
						end
					end
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::FilteredMetamodelReference
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.metamodel ?= mergedModelElement.selectUnaryProperty("metamodel", self.metamodel, mergedModelElement.metamodel)
					if (not mergedModelElement.metamodel.isVoid) then
						mergedModelElement.metamodel ?= mergedModelElement.metamodel.getElementInMergedModel
					end
				end
			}

			aspect class ModelTypeDefinition inherits org::kermeta::language::structure::TypeDefinition {
				method fixReferences( ) : Void from org::kermeta::language::structure::TypeDefinition is do
					var aspectModelElement : org::kermeta::language::structure::ModelTypeDefinition
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					if not self.metamodel.isVoid then
						if not self.metamodel.similarElementInMergedModel.isVoid then
							// element pointed by this moved element is still in the unmoved model
							self.metamodel := self.metamodel.similarElementInMergedModel.asType(org::kermeta::language::structure::Metamodel)
						end
					end
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var typeDefinitionsToMove : kermeta::standard::Sequence<org::kermeta::language::structure::ModelElementTypeDefinition> init self.typeDefinitions.select{ o | not o.similarElementInMergedModel.isVoid }
					typeDefinitionsToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute typeDefinitions)")
						self.typeDefinitions.remove(o)
						self.typeDefinitions.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelElementTypeDefinition))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::TypeDefinition is do
					var mergedModelElement : org::kermeta::language::structure::ModelTypeDefinition
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// select value for unary reference (not involved in composition)
					mergedModelElement.metamodel ?= mergedModelElement.selectUnaryProperty("metamodel", self.metamodel, mergedModelElement.metamodel)
					if (not mergedModelElement.metamodel.isVoid) then
						mergedModelElement.metamodel ?= mergedModelElement.metamodel.getElementInMergedModel
					end
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var typeDefinitionsToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::ModelElementTypeDefinition>
					typeDefinitionsToAdd := self.typeDefinitions.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.typeDefinitions.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::ModelElementTypeDefinition)
						}
					mergedModelElement.typeDefinitions.addAll(typeDefinitionsToAdd)
				end
			}

			aspect class ModelTransformation inherits org::kermeta::language::structure::MultiplicityElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var aspectModelElement : org::kermeta::language::structure::ModelTransformation
					aspectModelElement ?= self.similarElementInAspectModel
					super()
					// find referenced elements not in merged model
					// warning order not ensured, TODO
					var typeParametersToMove : kermeta::standard::Sequence<org::kermeta::language::structure::ModelTypeVariable> init self.typeParameters.select{ o | not o.similarElementInMergedModel.isVoid }
					typeParametersToMove.each{ o |
						//stdio.writeln("[fixReferences]replacing "+o.toString+" by "+o.similarElementInMergedModel.toString+" (referenced by attribute typeParameters)")
						self.typeParameters.remove(o)
						self.typeParameters.add(o.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelTypeVariable))
					}
					
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::structure::ModelTransformation
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
					// merge references from aspect and primary model (not involved in composition)
					// TODO warning partial order not ensured
					var typeParametersToAdd : kermeta::standard::Sequence<org::kermeta::language::structure::ModelTypeVariable>
					typeParametersToAdd := self.typeParameters.select{o | 
							// select content in aspect element which aren't in the mergedModel element
							not mergedModelElement.typeParameters.exists{ p | 
								if context.useGenericMerge then
									p.genericLocalMatch(o)
								else
									p.localMatch(o)
								end
							}
						}.collect{ c |
							// make sure to get the version that is in the merged model
							c.getElementInMergedModel().asType(org::kermeta::language::structure::ModelTypeVariable)
						}
					mergedModelElement.typeParameters.addAll(typeParametersToAdd)
				end
			}

			aspect class UnresolvedModelTypeDefinition inherits org::kermeta::language::structure::ModelTypeDefinition, org::kermeta::language::structure::UnresolvedReference {
				method fixReferences( ) : Void from org::kermeta::language::structure::ModelTypeDefinition is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedModelTypeDefinition
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::ModelTypeDefinition is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedModelTypeDefinition
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class UnresolvedModelTransformation inherits org::kermeta::language::structure::ModelTransformation, org::kermeta::language::structure::UnresolvedReference {
				method fixReferences( ) : Void from org::kermeta::language::structure::ModelTransformation is do
					var aspectModelElement : org::kermeta::language::structure::UnresolvedModelTransformation
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::ModelTransformation is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedModelTransformation
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

			aspect class ModelTypeDefinitionContainer inherits org::kermeta::language::structure::KermetaModelElement {
				method fixReferences( ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var aspectModelElement : org::kermeta::language::structure::ModelTypeDefinitionContainer
					aspectModelElement ?= self.similarElementInAspectModel
					super()
				end
				method mergeReferences( context : BinaryMergerContext ) : Void from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::ModelTypeDefinitionContainer
					mergedModelElement ?= self.similarElementInMergedModel
					super(context)
				end
			}

		}


	}


}

