package rts;

require kermeta

using kermeta::standard

class TimeManager inherits rts::Activable
{
    reference date : kermeta::standard::Integer
    reference timer_list : Linked_queue<rts::Timer>
    operation make() is do
        date := 0
    end
    operation reset(d : kermeta::standard::Integer) is do
        timer_list.clear
        date := d
    end
    method nb_transitions() : kermeta::standard::Integer from rts::Activable is do
    	result := 0
        if not timer_list.empty then
        	result := 1
        end
    end
    method guards(n : kermeta::standard::Integer) : kermeta::standard::Boolean from rts::Activable is do
        result := true
    end
    method labels(n : kermeta::standard::Integer) : kermeta::standard::String from rts::Activable is do
        result := timer_list.first.label
    end
    method action(n : kermeta::standard::Integer) from rts::Activable is do
        date := timer_list.first.deadline
        timer_list.first.fire
    end
    operation has(t : rts::Timer) : kermeta::standard::Boolean is do
        result := timer_list.exists{ r | r.equals(t) }
    end
    operation remove(t : rts::Timer) is do
        timer_list.remove(t)
    end
    operation put(t : rts::Timer) is do
        timer_list.add(t)
    end
}

abstract class Activable
{
    reference identity : rts::Identity
    operation nb_transitions() : kermeta::standard::Integer is abstract
    operation labels(n : kermeta::standard::Integer) : kermeta::standard::String is abstract
    operation action(n : kermeta::standard::Integer) is abstract
    operation guards(n : kermeta::standard::Integer) : kermeta::standard::Boolean is abstract
    operation init_activable(name : kermeta::standard::String) is do
        if name != void and name != "" then
        	identity.set_out(name)
        end
    end
}

abstract class Reactive
{
    operation receive(e : rts::Event) is abstract
}

abstract class StateMachine inherits rts::Reactive
{
    operation entry() is do
        //Empty in Eiffel code
    end
    operation exit() is do
        //Empty in Eiffel code
    end
    operation enter(new_state : rts::StateMachine) is do
        //////////////////////////////////////////////////////////////////////////////////////////////////////////
        // FIXME : in Eiffel code, a hack replaces current state
        // with the new_state, using the same object ID
        new_state.entry
    end
    operation leave(old_state : rts::StateMachine) is do
        //same hack than enter() method
        old_state.exit
    end
    operation oclInState(other : rts::StateMachine) : Boolean is do
    	// FIXME : no conforms_to() method in StateMachine !!!
//        result := self.conforms_to(other)
    end
}

class Timer inherits rts::TimeManagerAccessor
{
    reference label : kermeta::standard::String
    reference deadline : kermeta::standard::Integer
    reference target : rts::Reactive
    reference alarm : rts::Alarm
    operation make(reactor : rts::Reactive) is do
        target := reactor
        alarm := Alarm.new
    end
    operation setSignal(reactor : rts::Reactive, signal : rts::Alarm, delay : kermeta::standard::Integer, new_label : kermeta::standard::String) is do
        target := reactor
        alarm := signal
        deadline := current_date + delay
        label := new_label
        manager.put(self)
    end
    operation current_date() : kermeta::standard::Integer is do
        result := manager.date
    end
    operation is_running() : kermeta::standard::Boolean is do
        result := manager.has(self)
    end
    operation is_ringing() : kermeta::standard::Boolean is do
        result := current_date >= deadline
    end
    // Kermeta does not have infix operations !!!!
//    operation infix "<"(other : rts::Timer) : kermeta::standard::Boolean is do
//        if other != void then
//        	result := deadline < other.deadline
//        end
//    end
    operation is_equal(other : rts::Timer) : kermeta::standard::Boolean is do
        if other != void then
        	result := deadline == other.deadline
        end
    end
    operation reset() is do
        manager.remove(self)
    end
    operation reschedule(new_delay : kermeta::standard::Integer, new_label : kermeta::standard::String) is do
        if is_running then
        	reset
        end
        deadline := current_date + new_delay
        label := new_label
        manager.put(self)
    end
    operation fire() is do
        reset
        target.receive(alarm)
    end
}

class Identity
{
	////////////////////////////////////////////////////////////////////////////////////////////////
	// FIXME : Eiffel code uses a static structure for identities storage
	//         but Kermeta has no static capability
    reference out : kermeta::standard::String
    operation default_create() is do
        //TODO: implement operation default_create
    end
    operation set_out(new_out : kermeta::standard::String) is do
        out := new_out
    end
    operation deep_twin() : rts::Identity is do
        result := self
    end
    operation is_deep_equal(other : rts::Identity) : kermeta::standard::Boolean is do
        result := out == other.out
    end
}

abstract class Event
{
    reference arguments : Linked_queue<Object>
    operation event_name() : kermeta::standard::String is abstract
    operation make() is do
        //Empty. Nothing to do
    end
    operation send_to(target : Object) is do
        var reactive : Reactive
        reactive ?= target
        if reactive != void then
        	reactive.receive(self)
        end
    end
    operation dispatch_to(target : Object) is abstract
    operation label() : kermeta::standard::String is do
        result := event_name + label_for_arguments
    end
    operation label_for_arguments() : kermeta::standard::String is do
        var arg : Integer
        var act : Activable
        var res : String init ""
        if arguments != void then
        	if arguments.size > 0 then
        		res.append("(")
        		from arg := 0
        		until arg == arguments.size
        		loop
        			act ?= arguments.elementAt(arg)
        			if act != void then
        				res.append(act.identity.out)
        			else
        				// the argument type is not Activable known type so
        				// we must use Kermeta Object toString() method
        				res.append(arguments.elementAt(arg).toString)
        			end
        			res.append(",")
        			arg := arg + 1
        		end
        	end
        end
    end
    operation out() : kermeta::standard::String is do
        result := label
    end
}

class TimeEvent inherits rts::Event
{

}

abstract class ActiveStateMachine inherits rts::Activable, rts::StateMachine
{
    reference message_queue : Linked_queue<rts::Event>
//    reference message_queue : rts::Linked_queue<rts::Event>
    reference events_from_action : String
    method init_activable(name : kermeta::standard::String) from rts::Activable is do
        super(name)
    end
    method receive(e : rts::Event) from rts::Reactive is do
        if message_queue.size >= message_queue_capacity then
           raise "QUEUE_FULL"
        else
           message_queue.add(e)
        end
    end
    operation dispatch() is do
        var current_event : rts::Event
        current_event := message_queue.one
        message_queue.remove(message_queue.one)
        current_event.dispatch_to(self)
    end
    method nb_transitions() : kermeta::standard::Integer from rts::Activable is do
        if not message_queue.empty then
        	result := 1
        end
    end
    method labels(n : kermeta::standard::Integer) : kermeta::standard::String from rts::Activable is do
        result := "?" + message_queue.one.label
    end
    method guards(n : kermeta::standard::Integer) : kermeta::standard::Boolean from rts::Activable is do
        result := true
    end
    method action(n : kermeta::standard::Integer) from rts::Activable is do
        // actions associated with fireable transistions
        var nb_completion : Integer
        var is_discarded : Boolean
//        if not is_discarded then
       		nb_completion := nb_transitions
        	if not message_queue.empty then
        		nb_completion := nb_completion - 1
        		if n <= nb_completion then
        			completion(n)
        		else
        			dispatch
        		end
        	end
//        end
    end
    operation completion(n : kermeta::standard::Integer) from rts::StateMachine is do
        // actions associated with spontaneus transitions
        // Empty (would be rewrited in state instances)
    end
    operation reset_events_from_action() is do
    	events_from_action := ""
    end
    operation message_queue_capacity() : Integer is do
    	result := 1
    end
}

abstract class PassiveStateMachine inherits rts::StateMachine
{
    method receive(e : rts::Event) from rts::Reactive is do
        e.dispatch_to(self)
    end
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// FIXME : this class is a singleton => how code it in Kermeta
class TimeManagerAccessor
{
	reference timeManager : rts::TimeManager
    operation manager() : rts::TimeManager is do
//        if timeManager == void then
//        	timeManager := TimeManager.new
//        	timeManager.make
//        end
    end
}

abstract class CADPSimulator inherits rts::TimeManagerAccessor
{
    reference current_configuration : rts::Configuration
    reference exported_configurations : set rts::Configuration[0..*]
    reference exported_labels : kermeta::utils::Hashtable<String, String>
    reference nb_exported_configurations_since_last_gc : kermeta::standard::Integer
    operation make_CADP_simulator() is do
        nb_exported_configurations_since_last_gc := 0
    end
    operation initial_configuration() : rts::Configuration is abstract
    /////////////////////////////////////////////////////////////////////////////////////////////
    //TODO : implement SIMULATOR
}

class Configuration
{
    reference process_table : Linked_queue<rts::Activable>
    operation out() : kermeta::standard::String is do
        var i : Integer
        var l : Integer
        var a : ActiveStateMachine
        result := "There are " + process_table.size.toString
        result.append(" activable objects :\n")
        from i := 0
        until i >= process_table.size
        loop
        	result.append(i.toString + " -> ")
        	result.append(process_table.elementAt(i).getMetaClass.name + "\n")
        	a ?= process_table.elementAt(i)
        	if a != void then
    			result.append(a.message_queue.out)
    		end
    		i := i + 1
    	end
    end
    operation hash() : kermeta::standard::Integer is do
        var i : Integer
        var l : Integer
        var e : Integer
        var m : Event
        var res : Integer init 0
        var a : ActiveStateMachine
        from i := 0
        until i >= process_table.size
        loop
        	a ?= process_table.elementAt(i)
        	if a != void then
        		l := a.message_queue.size + 1
        		if l > 1 then
        			m := a.message_queue.one
        			e := m.oid
        		else
        			e := 1
        		end
       		else
       			l := 1
       			e := 1
        	end
        	res := res + i * l * e * a.oid
        end
    end
    operation make() is do
        // Empty (should initialize process_table, but not need for that in Kermeta)
    end
    operation register(new_process : rts::Activable) is do
        process_table.addAt(process_table.size, new_process)
    end
}

class Port inherits rts::StateMachine, rts::Activable
{
    reference fifo : set rts::Event[0..*]
//    reference fifo : Linked_queue<rts::Event>
    reference server : Object
    operation initialize() is do
        // Empty. Nothing to do
    end
    operation connect(new_server : Object) is do
        server := new_server
    end
    method receive(e : rts::Event) from rts::Reactive is do
        enqueue(e)
    end
    operation enqueue(e : rts::Event) is do
        fifo.add(e)
    end
    method nb_transitions() : kermeta::standard::Integer from rts::Activable is do
        result := 0
        if not fifo.empty then
        	result := 1
        end
    end
    method labels(n : kermeta::standard::Integer) : kermeta::standard::String from rts::Activable is do
        result := fifo.one.label
    end
    method guards(n : kermeta::standard::Integer) : kermeta::standard::Boolean from rts::Activable is do
        result := true
    end
    method action(n : kermeta::standard::Integer) from rts::Activable is do
        // unqueue message in the fifo and pass it to the upper layer
        fifo.one.send_to(server)
        fifo.remove(fifo.one)
    end
}

class Any
{

}

abstract class Proxy
{
    reference server : Object
    operation connect(new_server : Object) is do
        server := new_server
    end
    operation send(e : rts::Event) is do
        e.send_to(server)
    end
    operation initialize() is do
        //Empty. Nothing to do
    end
    /* code factorisation for ActiveStateMachine actions */
/*    operation append_ASM_action_events(serverActiveStateMachine : ActiveStateMachine, event : Event) is do
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
    end */
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// FIXME : the general goal of this class needs to be understand before implementing it
// NOTA BENE : the Enumeration type is not used in RTS package
abstract class Enumeration
{
    reference out : kermeta::standard::String
    operation make() is do
        out := ""
    end
    operation ~enumeration() : kermeta::standard::String is do
    	// Returns the ennumeration name of the current value
        result := out
    end
    operation ~value() : rts::Enumeration is do
        result := self
    end
    operation is_initialized() : kermeta::standard::Boolean is do
        result := out != ""
    end
    operation is_valid_enumeration(enum_name : kermeta::standard::String) : kermeta::standard::Boolean is do
        result := all_images.getValue(enum_name) != void
    end
    operation value_of(enum_name : kermeta::standard::String) : rts::Enumeration is do
    	// FIXME : the Eiffel version of this operation
    	// seems replacing the current object by a new one
    	from_string(enum_name)
    	result :=  self
    end
    operation from_string(str : kermeta::standard::String) is do
        set_by_name(str)
    end
    operation set_image(new_image : kermeta::standard::String) is do
        out := new_image
    end
    reference all_images : kermeta::utils::Hashtable<String,Enumeration>
    operation set_by_name(str : kermeta::standard::String) is do
        //TODO : implement operation 
    end
    operation setEnum(new_enum : rts::Enumeration) is do
        //TODO: implement operation ~set
    end
}

class Linked_queue<E> inherits OrderedSet<E>
{
    operation out() : kermeta::standard::String is do
        var s : String init "There are "
        s.append(size.toString)
        s.append(" queued messages :\n")
        from var i : Integer init 0
        until i > size
        loop
        	s.append(elementAt(i).toString + "\n")
        	i := i + 1
        end
        result := s
    end
    operation is_empty() : Boolean is do
    	result := size == 0
    end
    operation item() : E is do
    	result := last
    end
}

class Alarm inherits rts::Event
{
}
