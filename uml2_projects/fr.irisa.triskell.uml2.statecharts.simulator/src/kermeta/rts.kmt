package rts;

require kermeta
require "simulator.kmt"

using kermeta::standard

class TimeManager inherits rts::Activable
{
    reference date : kermeta::standard::Integer
    reference timer_list : Linked_queue<rts::Timer>
    operation make() is do
        date := 0
    end
    operation reset(d : kermeta::standard::Integer) is do
        timer_list.clear
        date := d
    end
    method nb_transitions() : kermeta::standard::Integer from rts::Activable is do
    	result := 0
        if not timer_list.empty then
        	result := 1
        end
    end
    method guards(n : kermeta::standard::Integer) : kermeta::standard::Boolean from rts::Activable is do
        result := true
    end
    method labels(n : kermeta::standard::Integer) : kermeta::standard::String from rts::Activable is do
        result := timer_list.first.label
    end
    method action(n : kermeta::standard::Integer) from rts::Activable is do
        date := timer_list.first.deadline
        timer_list.first.fire
    end
    operation has(t : rts::Timer) : kermeta::standard::Boolean is do
        result := timer_list.exists{ r | r.equals(t) }
    end
    operation remove(t : rts::Timer) is do
        timer_list.remove(t)
    end
    operation put(t : rts::Timer) is do
        timer_list.add(t)
    end
}

abstract class Activable
{
    reference identity : rts::Identity
    operation nb_transitions() : kermeta::standard::Integer is abstract
    operation labels(n : kermeta::standard::Integer) : kermeta::standard::String is abstract
    operation completion(n : kermeta::standard::Integer) is abstract
    operation action(n : kermeta::standard::Integer) is abstract
    operation guards(n : kermeta::standard::Integer) : kermeta::standard::Boolean is abstract
    operation init_activable(name : kermeta::standard::String) is do
    	identity := rts::Identity.new
        if name != void and name != "" then
        	identity.set_out(name)
        end
    end
}

abstract class Reactive
{
    operation receive(e : rts::Event) is abstract
}

abstract class StateMachine inherits rts::Reactive
{
	// needed for state change
	reference instanceCurrentState : rts::StateMachine
	reference context : rts::Configuration
	reference machine : StateMachine
	
    operation entry() is abstract
    operation exit() is abstract
    operation enter(new_state : rts::StateMachine) is do
        // tells the simulator about the next state
        
        // as the transitions manipulate objects through proxies
        // which point directly onto instances, we need to give
        // the new state the values of all attributes of the
        // corresponding instance (which is the current object).
        var currentState : ActiveStateMachine
        if machine != void then
        	// we are in a state were the corresponding instance has been referenced
	        context.swap(machine.instanceCurrentState, new_state)
 	    	machine.instanceCurrentState := new_state
 	    	new_state.instanceCurrentState := new_state
	    end

        // we then execute the entering code
        new_state.entry
    end
    operation leave(old_state : rts::StateMachine) is do
        // we just execute the exiting code
        if not old_state.isVoid then old_state.exit end
    end
    operation oclInState(other : rts::StateMachine) : Boolean is do
        result := self.getMetaClass.isInstance(other)
    end
}

class Timer inherits rts::TimeManagerAccessor
{
    reference label : kermeta::standard::String
    reference deadline : kermeta::standard::Integer
    reference target : rts::Reactive
    reference alarm : rts::Alarm
    operation make(reactor : rts::Reactive) is do
        target := reactor
        alarm := Alarm.new
    end
    operation setSignal(reactor : rts::Reactive, signal : rts::Alarm, delay : kermeta::standard::Integer, new_label : kermeta::standard::String) is do
        target := reactor
        alarm := signal
        deadline := current_date + delay
        label := new_label
        manager.put(self)
    end
    operation current_date() : kermeta::standard::Integer is do
        result := manager.date
    end
    operation is_running() : kermeta::standard::Boolean is do
        result := manager.has(self)
    end
    operation is_ringing() : kermeta::standard::Boolean is do
        result := current_date >= deadline
    end
    operation is_equal(other : rts::Timer) : kermeta::standard::Boolean is do
        if other != void then
        	result := deadline == other.deadline
        end
    end
    operation reset() is do
        manager.remove(self)
    end
    operation reschedule(new_delay : kermeta::standard::Integer, new_label : kermeta::standard::String) is do
        if is_running then
        	reset
        end
        deadline := current_date + new_delay
        label := new_label
        manager.put(self)
    end
    operation fire() is do
        reset
        target.receive(alarm)
    end
}

class Identity
{
    reference out : kermeta::standard::String
    operation set_out(new_out : kermeta::standard::String) is do
        out := new_out
    end
    operation deep_twin() : rts::Identity is do
        result := self
    end
    operation is_deep_equal(other : rts::Identity) : kermeta::standard::Boolean is do
        result := out == other.out
    end
}

abstract class Event
{
    reference arguments : Linked_queue<Object>
    operation event_name() : kermeta::standard::String is abstract
    operation make() is do
        arguments := Linked_queue<Object>.new
    end
    operation send_to(target : Object) is do
    	// the reactive object we must send to the event is the current state
    	var machine : StateMachine
    	machine ?= target
        var reactive : Reactive
        reactive := machine.instanceCurrentState
        if reactive != void then
        	reactive.receive(self)
        end
    end
    operation dispatch_to(target : Object) is abstract
    operation label() : kermeta::standard::String is do
        result := event_name
        result.append(label_for_arguments)
    end
    operation label_for_arguments() : kermeta::standard::String is do
        var arg : Integer
        var act : Activable
        var res : String init ""
        if arguments != void then
    		res.append("(")
    		from arg := 0
    		until arg == arguments.size
    		loop
    			if arg > 0 then res.append(", ") end
    			act ?= arguments.elementAt(arg)
    			if act != void then
    				res.append(act.identity.out)
    			else
    				// the argument type is not Activable known type so
    				// we must use Kermeta Object toString() method
    				res.append(arguments.elementAt(arg).toString)
    			end
    			arg := arg + 1
    		end
        end
        result := res
    end
    operation out() : kermeta::standard::String is do
        result := label
    end
}

class TimeEvent inherits rts::Event
{

}

abstract class ActiveStateMachine inherits rts::Activable, rts::StateMachine
{
    reference message_queue : Linked_queue<rts::Event>
    reference events_from_action : String
    method init_activable(name : kermeta::standard::String) from rts::Activable is do
    	message_queue := Linked_queue<rts::Event>.new
        super(name)
    end
    method receive(e : rts::Event) from rts::Reactive is do
        if message_queue.size >= message_queue_capacity then
           var s : String init "QUEUE_FULL"
           s.append(" (former "+message_queue.size.toString +" messages for a capacity of "+message_queue_capacity.toString+")")
           raise s
        else
           message_queue.add(e)
           //// FIXME : attempt to rise the action (nothing like that in UMLAUT)
           dispatch
        end
    end
    operation dispatch() is do
        var current_event : rts::Event
        current_event := message_queue.one
        message_queue.remove(message_queue.one)
        current_event.dispatch_to(self)
    end
    method nb_transitions() : kermeta::standard::Integer from rts::Activable is do
    	result := 0
        if not message_queue.empty then
        	result := 1
        end
    end
    method labels(n : kermeta::standard::Integer) : kermeta::standard::String from rts::Activable is do
        result := "?"
        if message_queue.size == 1 then
        	result.append(message_queue.one.label)
        else
        	result.append("  ERROR in ActiveStateMachine.labels() - no message in the message_queue !!")
        end
    end
    method guards(n : kermeta::standard::Integer) : kermeta::standard::Boolean from rts::Activable is do
        result := true
    end
    method action(n : kermeta::standard::Integer) from rts::Activable is do
        // actions associated with fireable transitions
        var nb_completion : Integer
        var is_discarded : Boolean
//        if not is_discarded then
       		nb_completion := nb_transitions
        	if not message_queue.empty then
        		nb_completion := nb_completion - 1
        		if n <= nb_completion then
        			completion(n)
        		else
        			dispatch
        		end
        	end
//        end
    end
    method completion(n : kermeta::standard::Integer) from rts::Activable is do
        // actions associated with spontaneus transitions
        // Empty (would be rewrited in state instances)
    end
    operation reset_events_from_action() is do
    	events_from_action := ""
    end
    operation message_queue_capacity() : Integer is do
    	result := 1
    end
}

abstract class PassiveStateMachine inherits rts::StateMachine
{
    method receive(e : rts::Event) from rts::Reactive is do
        e.dispatch_to(self)
    end
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// FIXME : this class is a singleton => how code it in Kermeta, without static methods
class TimeManagerAccessor
{
	reference timeManager : rts::TimeManager
    operation manager() : rts::TimeManager is do
//        if timeManager == void then
//        	timeManager := TimeManager.new
//        	timeManager.make
//        end
//        result := timeManager
    end
}

abstract class CADPSimulator inherits rts::TimeManagerAccessor, simulator::core::Simulator
{
    reference current_configuration : rts::Configuration
    reference tuples_table : oset TransitionTuple[1..*]
    operation make_CADP_simulator() is do
        // nothing to do
    end
    operation initial_configuration() : rts::Configuration is abstract
    
    /////////////////////////////////////////////////////////////////////////////////////////////
    //TODO : implement SIMULATOR
    method setInitialConfiguration(configuration : simulator::core::Configuration) is do
    	current_configuration ?= configuration
    	// we need to force a complete copy of attributes from implementations
    	// to their beginning state to fully all the current states
    	current_configuration.process_table.each{ r | 
    		var impl : ActiveStateMachine
    		impl ?= r
    		current_configuration.swap(impl, impl.instanceCurrentState)
    	}
    end
    
    //////////////////////////////////////////////////////////////////////
    //FIXME : remove the run() method from here and use the simulator generic one
    method run() is do	// a first really simple one
    	stdio.writeln("\n .... Running the simulator ....\n")
    	var quit : Boolean init false
    	from 0
    	until quit
    	loop
    		stdio.writeln(current_configuration.getStatus)
    		tuples_table.clear
    		// get & display fireable transitions
    		var iter : Integer init 0
    		stdio.writeln("Fireable transitions :")
    		current_configuration.process_table.each{ p |
    			// we need to get the current state of each instance
    			var active : ActiveStateMachine
    			active ?= p
    			var state : ActiveStateMachine
    			state ?= active.instanceCurrentState
    			var n : Integer init state.nb_transitions
    			from var j : Integer init 0
    			until j == n
    			loop
    				var t : TransitionTuple init TransitionTuple.new
    				t.num := j
    				t.activable := state
    				stdio.writeln("   -- " + iter.toString + " -- "+ active.identity.out + " -> " + state.labels(j))
    				tuples_table.add(t)
     				iter := iter + 1
     				j := j + 1
    			end
    		}
    		// getting the user's choice
    		var nTrans : Integer
    		nTrans := string2Integer(stdio.read("  --> give the choosen transition number ( 'q' for quit) : "))
    		if nTrans >=0 then
	    		// firing the choosen transition
	    		if nTrans < tuples_table.size then
	    			stdio.writeln("\n   You choose the '" + nTrans.toString + "' transition")
	    			tuples_table.elementAt(nTrans).activable.completion(tuples_table.elementAt(nTrans).num)
	    		else
	    			stdio.writeln("   There is only " + tuples_table.size.toString + " transitions")
	    		end
    		else
    			stdio.writeln("\nExiting the simulator")
    			quit := true
    		end
    	end
    end
    
    /** Ugly hack to be able to get the order of choosen transition */
    operation string2Integer(n : String) : Integer is do
    	var nSize : Integer init n.size
    	var res : Integer init 0
    	from var i : Integer init 0
    	until i == nSize
    	loop
    		var x : Integer
    		var c : String
    		c := n.elementAt(i).toString
    		if c == "0" then x := 0 end
    		if c == "1" then x := 1 end
    		if c == "2" then x := 2 end
    		if c == "3" then x := 3 end
    		if c == "4" then x := 4 end
    		if c == "5" then x := 5 end
    		if c == "6" then x := 6 end
    		if c == "7" then x := 7 end
    		if c == "8" then x := 8 end
    		if c == "9" then x := 9 end
    		if c == "q" or c == "Q" then x := -10000 end
    		if x.isVoid then x := 0 end
    		from var j : Integer init nSize - i - 1
    		until j == 0
    		loop
    			x := x * 10
    			j := j - 1
    		end
    		res := res + x
    		i := i + 1
    	end
    	result := res
    end
}
/** this class is needed for storage and firing of transitions inside CADPSimulator */
class TransitionTuple
{
	reference activable : Activable
	reference num : Integer
}

class Configuration inherits simulator::core::Configuration
{
    reference process_table : Linked_queue<rts::Activable>
    operation make() is do
    	process_table := Linked_queue<rts::Activable>.new
    end
    operation register(new_process : rts::Activable) is do
    	// implements the SIMULATOR references
        process_table.add(new_process)
        // need to force the type to StateMachine for managing copy in enter() method
        var sm : ActiveStateMachine
        sm ?= new_process
        sm.context := self
    end
    operation superSwap(modelPack : kermeta::language::structure::Package,
    					sClass : kermeta::reflection::Class,
    					origin : rts::StateMachine,
    					dest : rts::StateMachine) is do
    	var pack : kermeta::language::structure::Package
    	pack ?= sClass.typeDefinition.container
    	if pack == modelPack then
			sClass.ownedAttribute.each{ p |
				getSet(origin, dest, p)
			}
			// recursive call, for exploring all inherited attributes
			// (Class_in_State -|> Class_top_state -|> Class_impl -|> Class)
			var sc : kermeta::reflection::Class
			var sd : kermeta::reflection::ClassDefinition
			sd ?= sClass.typeDefinition
			sd.superType.each{ st |
				if not st.isVoid then
					superSwap(modelPack, st, origin, dest)
				end
			}
			
		end
    end
	operation swap(origin : rts::StateMachine, dest : rts::StateMachine) is do
		// the getSet() can't copy multiple properties of a state on itself
		if dest.oid != origin.oid then
			// hard copy of instance current state attributes to the next state
			// for replacing the current state by the next state as instance
			// in the simulator. Links to this object in other instances
			// must also be change to point on next state.
	    	var pack : kermeta::language::structure::Package
	    	pack ?= origin.getMetaClass.typeDefinition.container
			superSwap(pack, origin.getMetaClass, origin, dest)
			
			// links of other instances on current instance|state
			process_table.each{ i |
				// browses reflexivly the direct links of other instances
				// for replacing current state by next
				var inst : ActiveStateMachine
				inst ?= i
				if i != origin then
					i.getMetaClass.ownedAttribute.each{ p | 
						if inst.get(p) == origin.instanceCurrentState then
							inst.~set(p, dest)
						end
					}
					inst.getMetaClass.superClass.each{ s |
						if s.name != "ActiveStateMachine" then
							s.ownedAttribute.each{ p |
								if inst.get(p).oid == origin.instanceCurrentState.oid then
									inst.~set(p, dest)
								end
							}
						end
					}
				end
			}
		end
	end
	method getStatus() : String is do
		// As the current state object the only one which attributes change
		// we get the list of them in the impl but their value in the state.
		var res : String init ""
		res.append("\n===================================\n")
		res.append("    Current state of the system    \n")
		res.append("===================================\n\n")
		process_table.each{ i |
			// browses reflexivly attributes of the meta class
			// (we are on the "_impl" of the model class)
			var inst : ActiveStateMachine
			inst ?= i
			var state : ActiveStateMachine
			state ?= inst.instanceCurrentState
			res.append(" * object '"+i.identity.out + "'  (in state : " +state.identity.out+") :\n")
			
			i.getMetaClass.superClass.each{ s |
				if s.name != "ActiveStateMachine" then	// no need for RTS inherited attributes
					s.ownedAttribute.each{ p |
						if p.upper == 1 then
							res.append("     - "+p.name + " = ")
							var active : Activable
							active ?= state.get(p)
							if active != void then
								res.append(active.identity.out)
							else
								var proxy : Proxy
								proxy ?= state.get(p)
								if proxy != void then
									var act : Activable
									act ?= proxy.server
									if act != void then
										res.append("proxy to '"+act.identity.out+"'")
									else
										res.append(state.get(p).toString)
									end
								else
									res.append(state.get(p).toString)
								end
							end
							res.append("\n")
						else
							var collP : Collection<kermeta::reflection::Object>
							collP ?= state.get(p)
							var j : Integer init 0
							collP.each{ k |
								res.append("     - "+p.name + "("+j.toString+") = ")
								var proxy : Proxy
								proxy ?= k
								if proxy != void then
									res.append("proxy to '")
									var active : Activable
									active ?= proxy.server
									if active != void then
										res.append(active.identity.out)
									else
										res.append(proxy.server.toString)
									end
								else
									res.append(k.toString)
								end
									res.append("'\n")
								j := j + 1
							}
						end
					}
				end
			}
		}
		result := res
	end
	operation getSet(orig : StateMachine, dest : Object, prop : kermeta::reflection::Property) is do
		if prop.upper != 1 then
			var collOrig : Collection<kermeta::reflection::Object>
			collOrig ?= orig.get(prop)
			var collDest : Collection<kermeta::reflection::Object>
			collDest ?= dest.get(prop)
			collDest.clear
			collDest.addAll(collOrig)
		else
			dest.~set(prop, orig.get(prop))
		end
	end
}

class Port inherits rts::StateMachine, rts::Activable
{
    reference fifo : set rts::Event[0..*]
    reference server : Object
    operation connect(new_server : Object) is do
        server := new_server
    end
    method receive(e : rts::Event) from rts::Reactive is do
        enqueue(e)
    end
    operation enqueue(e : rts::Event) is do
        fifo.add(e)
    end
    method nb_transitions() : kermeta::standard::Integer from rts::Activable is do
        result := 0
        if not fifo.empty then
        	result := 1
        end
    end
    method labels(n : kermeta::standard::Integer) : kermeta::standard::String from rts::Activable is do
        result := fifo.one.label
    end
    method guards(n : kermeta::standard::Integer) : kermeta::standard::Boolean from rts::Activable is do
        result := true
    end
    method action(n : kermeta::standard::Integer) from rts::Activable is do
        // unqueue message in the fifo and pass it to the upper layer
        fifo.one.send_to(server)
        fifo.remove(fifo.one)
    end
    operation initialize() is do
    	// nothing to do
    end
}

class Any
{

}

abstract class Proxy
{
    reference server : Object
    operation connect(new_server : Object) is do
        server := new_server
    end
    operation send(e : rts::Event) is do
        e.send_to(server)
    end
}

class Linked_queue<E> inherits OrderedSet<E>
{
    operation out() : kermeta::standard::String is do
        var s : String init "There are "
        s.append(size.toString)
        s.append(" queued messages :\n")
        from var i : Integer init 0
        until i > size
        loop
        	s.append(elementAt(i).toString + "\n")
        	i := i + 1
        end
        result := s
    end
    operation is_empty() : Boolean is do
    	result := size == 0
    end
    operation item() : E is do
    	result := last
    end
}

class Alarm inherits rts::Event
{
}
