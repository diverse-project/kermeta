/* $Id: Profile.kmt,v 1.2 2008-02-05 09:20:33 dvojtise Exp $
 * Creation date: November 30, 2007
 * License: EPL
 * Copyright:
 * Authors: Gilles Perrouin
 */

 
package uml; 


require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
// the decision of choosing one or 
//the another ecore depends if the source file uses UML defined stereotypes. Indeed Standard.profile.ecore defines 
//such stereotypes and extends UML...
//require "platform:/resource/org.kermeta.uml2.profiles.model/model/ecore/uml.ecore" 
require "platform:/plugin/org.kermeta.uml2.profiles.model/model/ecore/Standard.profile.ecore"
require "platform:/plugin/org.kermeta.uml2.profiles.model/model/ecore/Ecore.profile.ecore"
require "ToEcore.kmt"
require "../UMLUtils/UMLProfilesUtils.kmt"
require "UMLProfile2EcoreTrace.kmt"   
require "../UMLUtils/UMLQualifiedNameAspect.kmt"
   

using ecore
using kermeta::standard
using kermeta::language::structure
using kermeta::persistence
using UMLProfileUtils
 
@aspect "true"
class Profile inherits ToEcore  
{
	reference prof : EObject
	/** This method deals with creation of new Ecore objects */
	method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
	trace.traceLog("Entering Profile : Pass1")
	prof := EPackage.new
	// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName
	trace.setQualNameObj(qName,prof)
	
	prof.asType(EPackage).name := self.name
	 
	// special profiles have EPackage nature also... 
	if (isInstanceOf(EPackage)) then
		prof.asType(EPackage).nsPrefix := self.asType(EPackage).nsPrefix
		prof.asType(EPackage).nsURI := self.asType(EPackage).nsURI
	 else 
		// There is no way to derive nsURI and nsPrefix information from UML in the general case...
		// nsPrefix = package name and NsURI is where the resource is located (set in pass2)
		prof.asType(EPackage).nsPrefix := name
	end
	
 
	result:= prof
	
	trace.traceLog("Elements in a (sub)-profile: "+ self.containingResource.contents.size.toString)
	trace.traceLog("Quitting Profile : Pass1")
	end
	
	 
	/** This method deals with relationship establishment*/
	method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
	trace.traceLog("Entering Profile : Pass2")
	if self.container != void then
	trace.traceLog("Container is not void, trying to retreive it....")
	var e:EObject init trace.getEcoreFromUMLQualName(self.container.asType(uml::Package).getQualifiedName)
		//var res : Resource init prof.eResource.asType(Resource)
		//res.contents.select{p | p.isInstanceOf(ecore::EPackage) and p.asType(ecore::EPackage).name == self.nestingPackage.name}
		e.asType(ecore::EPackage).eSubpackages.add(prof.asType(EPackage))
		trace.traceLog(prof.containingResource.uri)
		prof.containingResource.instances.remove(prof)
		// setting the good NsURI based on the resource location
		// another option is to put "http:// " + name of the package, don't get the difference.... :(
		prof.asType(EPackage).nsURI :=  prof.containingResource.uri
	else
		// setting the good NsURI
		// another option is to put "http:// " + name of the package, don't get the difference.... :(
		prof.asType(EPackage).nsURI :=  prof.containingResource.uri
	end
	trace.traceLog("Quitting Profile : Pass2")
end
} 

@aspect "true"
class Stereotype inherits ToEcore {

reference st : EClass

/** This method deals with creation of new Ecore objects */
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering Stereotype : Pass1")
	st := EClass.new
	
	// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName
	trace.setQualNameObj(qName,st)
	
	st.asType(EClass).name := name
	st.~abstract := self.isAbstract
	//self.ownedAttribute.each{att| st.eStructuralFeatures.add(att.asType(uml::Property).toEcorePass1.asType(EStructuralFeature))}
	
	result := st
	trace.traceLog("Quitting Stereotype : Pass1")
	end

 /** This method deals with relationship establishment*/
	method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
	trace.traceLog("Entering Stereotype : Pass2")
		
	// if there is a container for this element we retreive it and add the element to it...
	if self.container != void then
		trace.traceLog("Container is not void, trying to retreive it....")
		var e:EObject init trace.getEcoreFromUMLQualName(self.container.asType(uml::Package).getQualifiedName)
		trace.traceLog("container name: "+ e.asType(ecore::EPackage).name)
		st.ePackage := e.asType(ecore::EPackage)
		// removing the element from the resource
		st.containingResource.instances.remove(st)
		
	end
	trace.traceLog("Quitting Stereotype : Pass2")
	end
}

@aspect "true"
class Class inherits ToEcore {

reference cls : EClass

/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
	trace.traceLog("Entering Class : Pass1")
	 cls := EClass.new
// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName
	trace.setQualNameObj(qName,cls)
cls.name := self.name

result := cls
trace.traceLog("Quitting Class : Pass1")
end

/** This method deals with relationship establishment*/
	method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
	trace.traceLog("Entering Class : Pass2")
	if self.container != void then
		trace.traceLog("Container is not void, trying to retreive it....")
		var e:EObject init trace.getEcoreFromUMLQualName(self.container.asType(uml::Package).getQualifiedName)
		trace.traceLog("container name: "+ e.asType(ecore::EPackage).name)
		cls.ePackage := e.asType(ecore::EPackage)
		cls.containingResource.instances.remove(cls)	
	end
	trace.traceLog("Quitting Class : Pass2")
	end
}

@aspect "true"
class Enumeration inherits ToEcore {
reference enum : EEnum

/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering Enumeration : Pass1")
enum := EEnum.new

// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName
	trace.setQualNameObj(qName,enum)

enum.name := self.name

//self.ownedLiteral.each{l|enum.eLiterals.add(l.asType(uml::EnumerationLiteral).toEcorePass1.asType(EEnumLiteral))}
result := enum
trace.traceLog("Quitting Enumeration : Pass1")
end

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering Enumeration : Pass2")
if self.container != void then
		trace.traceLog("Container is not void, trying to retreive it....")
		var e:EObject init trace.getEcoreFromUMLQualName(self.container.asType(uml::Package).getQualifiedName)
		trace.traceLog("container name: "+ e.asType(ecore::EPackage).name)
		enum.ePackage := e.asType(ecore::EPackage)
		// removing form the resource...
		enum.containingResource.instances.remove(enum)
	end
trace.traceLog("Quitting Enumeration : Pass2")

end
}

@aspect "true"
class EnumerationLiteral inherits ToEcore {

reference literal : EEnumLiteral

/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering EnumerationLiteral : Pass1")

literal := EEnumLiteral.new

// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName
	trace.setQualNameObj(qName,literal)

literal.name := self.name
result := literal
trace.traceLog("Quitting EnumerationLiteral : Pass1")
end

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering EnumerationLiteral : Pass2")
var e:ecore::EObject init trace.getEcoreFromUMLQualName(self.~enumeration.asType(uml::Enumeration).getQualifiedName)
trace.traceLog("Owning Enumeration :" + e.asType(ecore::EEnum).name)
// setting the integer value for the enumeration literal
literal.~value := e.asType(ecore::EEnum).eLiterals.size
literal.eEnum := e.asType(ecore::EEnum)
literal.containingResource.instances.remove(literal)	
trace.traceLog("Quitting EnumerationLiteral : Pass2")
end
}

@aspect "true"
class Property inherits ToEcore 
{
reference att : EAttribute
reference ref : EReference
reference obj: EObject
//reference enum : EEnum
 


//reference ref : EReference
/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do

trace.traceLog("Entering Property : Pass1")
if self.type.isVoid 
	then
		trace.traceLog("UML property type is void...")
		obj := EObject.new
		result := obj
	else
 		if  self.type.isInstanceOf(uml::PrimitiveType) or self.type.isInstanceOf(uml::Enumeration)
		then
			trace.traceLog("UML primitive property or enumeration... " + self.type.name)
			att := EAttribute.new
			att.name := self.name
			// managing multiplicities
			if self.lowerValue != void then
				trace.traceLog("lower bound : " + self.lowerValue.asType(uml::LiteralInteger).~value.toString)
				att.lowerBound := self.lowerValue.asType(uml::LiteralInteger).~value
			end
			if self.upperValue != void then
				trace.traceLog("upper bound :" + self.upperValue.asType(uml::LiteralUnlimitedNatural).~value.toString) 
				att.upperBound := self.upperValue.asType(uml::LiteralUnlimitedNatural).~value 
			end
			trace.traceLog("type qualified name "+self.type.getQualifiedName)
			result := att
		else
			if self.type.isInstanceOf(uml::Class) 
			then
				trace.traceLog("class reference... " + self.type.name)
				// "Hack" for managing types that are not directly imported...
				trace.registerBaseType(self.type.name)
				
				ref:= EReference.new
				ref.name := self.name
				if self.lowerValue != void then
					trace.traceLog("lower bound " + self.lowerValue.asType(uml::LiteralInteger).~value.toString)
					ref.lowerBound := self.lowerValue.asType(uml::LiteralInteger).~value
				end
				if self.upperValue != void then
					trace.traceLog("upper bound :" + self.upperValue.asType(uml::LiteralUnlimitedNatural).~value.toString)	
					ref.upperBound := self.upperValue.asType(uml::LiteralUnlimitedNatural).~value 	
				end
				result := ref
			end
		end
end
trace.traceLog("Quitting Property : Pass1")
end



/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void 

/*pre malformedOwner is do
self.~class != void 
end*/
is do
trace.traceLog("Entering Property : Pass2")
if att != void then
	trace.traceLog("Dealing with EAttribute :" + self.name)
	var e:ecore::EObject init trace.getEcoreFromUMLQualName(self.~class.asType(uml::Class).getQualifiedName)
	att.eContainingClass := e.asType(ecore::EClass)
	// if the attribute is a primitive type we try to get it from our registered 
	//ecore types initialized by element import...
	if self.type.isInstanceOf(uml::PrimitiveType) then
	 var te: ecore::EDataType init trace.getEcoreDataType(self.type.name)
		if te != void then
			att.eType := trace.getEcoreDataType(self.type.name)
		else
			trace.traceLog("ERROR primitive type not retrieved !!!" + self.type.name)
		end	
	else
		var t:ecore::EObject init trace.getEcoreFromUMLQualName(self.type.getQualifiedName)
		if t != void and t.isInstanceOf(ecore::EEnum) then
			att.eType := t.asType(ecore::EEnum)
		else
				trace.traceLog("ERROR enumerated type not retrieved !!!" + self.type.name)
		end
	end
	att.containingResource.instances.remove(att)
else
	if ref != void then
		trace.traceLog("Dealing with EReference :" + self.name)
		var e:ecore::EObject init trace.getEcoreFromUMLQualName(self.~class.asType(uml::Class).getQualifiedName)
		ref.eContainingClass := e.asType(ecore::EClass)

		// reference having base_ in their name refers to the metaclass 
		//their containing stereotype extends. we need to retrieve it from the trace hashtables 
		if ref.name.indexOf("base_") != -1 then
			var c:EClass init trace.getBaseType(self.type.name)
			var t:ecore::EObject init trace.getEcoreFromUMLQualName(self.type.getQualifiedName)
			if c != void then
				ref.eType := c
			else
				if t != void then
					ref.eType := t.asType(ecore::EClass)
				else
					trace.traceLog("ERROR refered base type not retrieved !!!" + self.type.name)
				end	
			end
			// whatever the original multiplicity was, in ecore bass_Class have lowerBound = upperBound =1
			ref.lowerBound := 1
			ref.upperBound := 1
			// so that ecore validation is happy... (experimental)
			ref.unique := true  
			ref.ordered := false
		else
			 var t:ecore::EObject init trace.getEcoreFromUMLQualName(self.type.getQualifiedName)
			if t != void then
				ref.eType := t.asType(ecore::EClass)
			else
				// managing external types
				var et:ecore::EObject init trace.getBaseType(self.type.name)
				if et != void then
				ref.eType := et.asType(ecore::EClass)
				else
				trace.traceLog("ERROR refered type not retrieved !!!" + self.type.name)
				end
			end
		end
		ref.containingResource.instances.remove(ref)
	else
		trace.traceLog("ERROR Dealing with an unknown property !!! :" + self.name)
	end
end	


trace.traceLog("Quitting Property : Pass2")
end

}

@aspect "true"
class DataType inherits ToEcore {

reference type : EClassifier
/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace): EObject is do
trace.traceLog("Entering DataType : Pass1")
type := EClass.new
// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName
	trace.setQualNameObj(qName,type)


result := type
trace.traceLog("Quitting DataType : Pass1")
end

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering DataType : Pass2")
trace.traceLog("Quitting DataType : Pass2")
end
}

@aspect "true"
class Extension inherits ToEcore {

reference obj: EObject
/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering Extension : Pass1")
obj := EObject.new
// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName  
	trace.setQualNameObj(qName,obj)
	// since this is an extension we need to register the base classifier...
	self.ownedEnd.each{p|trace.traceLog(p.asType(uml::Property).type.name)}
	var metaclass : uml::Property init self.memberEnd.select{p| not p.isInstanceOf(uml::ExtensionEnd)}.one
	trace.traceLog("metaclass name: " + metaclass.type.name)
	trace.registerBaseType(metaclass.type.name) 
result := obj
trace.traceLog("Quitting Extension : Pass1") 
end 

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering Extension : Pass2")
// removing the element from the resource
obj.containingResource.instances.remove(obj)
trace.traceLog("Quitting Extension : Pass2")
end

}

@aspect "true"
class ElementImport inherits ToEcore {

reference obj: EObject
/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering ElementImport : Pass1")
trace.traceLog("ElementImport.... " + self.importedElement.getQualifiedName)

if self.importedElement.getQualifiedName.indexOf("UMLPrimitiveTypes") != -1
	then
		trace.registerEcoreDataType(self.importedElement.name)
		obj := ecore::EObject.new
		result := obj
	else
		// if the type is coming from uml we handle it the same way as for an extension
		if self.importedElement.getQualifiedName.indexOf("uml::") != -1 then
			trace.registerBaseType(self.importedElement.name)
			obj := ecore::EObject.new
			result := obj 
		// if the type is not primitive we try to transform it as any UML element...
		else	
			obj := self.importedElement.asType(ToEcore).toEcorePass1(trace)
		end
		if obj != void then
			result := obj
		else
			trace.traceLog("ERROR Imported Element not supported !!!")
			obj := ecore::EObject.new
			result := obj  
		end
end 
trace.traceLog("Quitting ElementImport : Pass1")


end 

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering ElementImport : Pass2")
// removing the element from the resource
if obj != void then
	obj.containingResource.instances.remove(obj)
end
trace.traceLog("Quitting ElementImport : Pass2")
end

}

aspect class PackageImport inherits ToEcore {

reference obj: EObject
/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering PackageImport : Pass1")
obj := EObject.new
if self.importedPackage.name.indexOf("uml") != -1 then
	trace.traceLog("Registering elements via PackageImport: " + self.importedPackage.name) 
	//trace.traceLog("Imported Package size: " + self.importedPackage.packagedElement.select{c|c.isInstanceOf(uml::Classifier)}.size.toString())
	//.each{c|trace.registerBaseType(c.asType(uml::Classifier).name)}
end
// registering elements in the trace to keep track of them...
	//var qName: String init self.getQualifiedName
	//trace.setQualNameObj(qName,obj)

result := obj
trace.traceLog("Quitting PackageImport : Pass1")
end 

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering PackageImport : Pass2")
// removing the element from the resource
obj.containingResource.instances.remove(obj)
trace.traceLog("Quitting PackageImport : Pass2")
end
}

@aspect "true"
class EAnnotation inherits ToEcore {

reference obj: EObject
/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering EAnnotation : Pass1")
obj := EObject.new
// registering elements in the trace to keep track of them...
	//var qName: String init self.getQualifiedName
	//trace.setQualNameObj(qName,obj)

result := obj
trace.traceLog("Quitting EAnnotation : Pass1")
end 

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering EAnnotation : Pass2")
// removing the element from the resource
obj.containingResource.instances.remove(obj)
trace.traceLog("Quitting EAnnotation : Pass2")
end

}

@aspect "true"
class LiteralString inherits ToEcore {

reference obj: EObject
/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering LiteralString : Pass1")
obj := EObject.new
// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName
	trace.setQualNameObj(qName,obj)
result := obj
trace.traceLog("Quitting LiteralString : Pass1")
end 

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering LiteralString : Pass2")
// removing the element from the resource
obj.containingResource.instances.remove(obj)
trace.traceLog("Quitting LiteralString : Pass2")
end

}

@aspect "true"
class ExtensionEnd inherits ToEcore {

reference eend: EObject
/** This method deals with creation of new Ecore objects*/
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering ExtensionEnd : Pass1")
eend := EObject.new
// registering elements in the trace to keep track of them...
	var qName: String init self.getQualifiedName
	trace.setQualNameObj(qName,eend)

result := eend
trace.traceLog("Quitting ExtensionEnd : Pass1")
end 

/** This method deals with relationship establishment*/
method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering ExtensionEnd : Pass2")
// removing the element from the resource
eend.containingResource.instances.remove(eend)
trace.traceLog("Quitting ExtensionEnd : Pass2")
end

}

@aspect "true"
class Generalization inherits ToEcore {

reference gen : EObject
method toEcorePass1(trace: UMLProfile2EcoreTrace) : EObject is do
trace.traceLog("Entering Generalization : Pass1")
gen := EObject.new
trace.traceLog("Quitting Generalization : Pass1")
result := gen
end

method toEcorePass2(trace: UMLProfile2EcoreTrace) : Void is do
trace.traceLog("Entering Generalization : Pass2")
var spe :  ecore::EClass init trace.getEcoreFromUMLQualName(self.specific.getQualifiedName).asType(ecore::EClass)
var general :  ecore::EClass init trace.getEcoreFromUMLQualName(self.general.getQualifiedName).asType(ecore::EClass)
if spe != void and general != void then
	spe.eSuperTypes.add(general)
else
	trace.traceLog("ERROR Dangling Generalization !!!")
end
// removing the element from the resource
gen.containingResource.instances.remove(gen)
trace.traceLog("Quitting Generalization : Pass2")
end
}
