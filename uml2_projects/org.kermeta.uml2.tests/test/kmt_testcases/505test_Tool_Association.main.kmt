/* $Id: 505test_Tool_Association.main.kmt,v 1.5 2008-04-10 13:03:26 dvojtise Exp $
 * Creation date: Summer 2006
 * License:		Eclipse Public License
 * Copyright:	INRIA
 * Authors:		Vincent MAHE <vmahe@irisa.fr>
 */
@mainClass "tools_tests::ToolAssociationTestCase"
@mainOperation "main"


package tools_tests;

require kermeta
require "platform:/plugin/org.kermeta.uml2/src/kermeta/transformations/StaticTools.kmt"

using uml
using uml::transformations

class ToolAssociationTestCase inherits kermeta::kunit::TestCase
{
	operation main() : Void is do 
		var tr : kermeta::kunit::TestRunner init kermeta::kunit::TestRunner.new
		tr.run(ToolAssociationTestCase)
		tr.printTestResult		
	end

	reference model : Model
    reference Aclass : Class
    reference Bclass : Class
    reference assocTool : Association_Tool
	
	method setUp() is do
    	model := Model.new
    	Aclass := Class.new
    	Bclass := Class.new
    	Aclass.name := "A"
    	Bclass.name := "B"
    	model.packagedElement.add(Aclass)
    	model.packagedElement.add(Bclass)
    	
    	assocTool := Association_Tool.new
	end
	
	method tearDown() is do
		// We don't need to tearDown anything in this test case.
	end
    
    operation testAssociationTool_SimpleAssociation() is do
    	model.packagedElement.add(assocTool.addSimpleAssociation(Aclass, Bclass, "association", "source", "target"))
    	
    	var assoc : Association
    	assoc ?= model.packagedElement.select{ u | u.name == "association"}.one
    	assertTrueWithMsg(assoc != void,
    		"the model must have a non void 'association'")
    		
		assertTrueWithMsg(assoc.ownedEnd.size == 0,
    		"the association must not own its ends, the classes must own them")
    	assertTrueWithMsg(Aclass.ownedAttribute.select{ u | u.name == "source" }.size == 1,
    		"the navigable source property must be owned by A")
		assertTrueWithMsg(Bclass.ownedAttribute.select{ u | u.name == "target" }.size == 1,
    		"the navigable target property must be owned by B")    		    		
    end
    
    operation testAssociationTool_OneSideNavigableAssociation() is do
    	model.packagedElement.add(assocTool.addOneSideNavigableAssociation(Aclass, Bclass, "association", "source", "target"))
    	
    	assertTrueWithMsg(model.packagedElement.select{ u | u.name == "association"}.size == 1,
    		"the model must contain an Association element")
    	
    	// a "One side navigable" association must own only one end
    	var assoc : Association
    	assoc ?= model.packagedElement.select{ u | u.name == "association"}.one
    	assertTrueWithMsg(assoc != void,
    		"the model must have a non void 'association'")
    	assertTrueWithMsg(assoc.ownedEnd.size == 1,
    		"the association must have only 1 property")
    	assertTrueWithMsg(assoc.ownedEnd.one.name == "source",
    		"the association single property must be 'source'")
     	
    	// the other end is owned by the class opposite
    	assertTrueWithMsg(Aclass.ownedAttribute.select{ u | u.name == "target" }.size == 1,
    		"the navigable property must be in the opposite class")
    end

    
    operation testAssociationTool_NavigableComposition() is do
    	model.packagedElement.add(assocTool.addNavigableComposition(Aclass, Bclass, "association", "target"))
    	
    	// a "One side navigable" association must own only one end
    	var assoc : Association
    	assertTrueWithMsg(model.packagedElement.select{ u | u.name == "association"}.size == 1,
    		"the model must have a non void 'association'")
    	assoc ?= model.packagedElement.select{ u | u.name == "association"}.one
    	assertTrueWithMsg(assoc != void,
    		"the model must have a non void 'association'")
    	assertTrueWithMsg(assoc.ownedEnd.size == 1,
    		"the association must have only 1 property")
     	
    	// the other end is owned by the container
    	assertTrueWithMsg(Aclass.ownedAttribute.select{ u | u.name == "target" }.size == 1,
    		"the navigable property must be in the container class")
    	var prop : Property init Aclass.ownedAttribute.select{ u | u.name == "target" }.one
    	assertTrueWithMsg(prop.aggregation == AggregationKind.composite,
    		"the navigable end must be a composite end")
    end
    
    operation testAssociationTool_NavigableAggregation() is do
    	model.packagedElement.add(assocTool.addNavigableAggregation(Aclass, Bclass, "association", "target"))
    	
    	// a "One side navigable" association must own only one end
    	var assoc : Association
    	assertTrueWithMsg(model.packagedElement.select{ u | u.name == "association"}.size == 1,
    		"the model must have a non void 'association'")
    	assoc ?= model.packagedElement.select{ u | u.name == "association"}.one
    	assertTrueWithMsg(assoc.ownedEnd.size == 1,
    		"the association must have only 1 property")
     	
    	// the other end is owned by the container
    	assertTrueWithMsg(Aclass.ownedAttribute.select{ u | u.name == "target" }.size == 1,
    		"the navigable property must be in the container class")
    	var prop : Property init Aclass.ownedAttribute.select{ u | u.name == "target" }.one
    	assertTrueWithMsg(prop.aggregation == AggregationKind.shared,
    		"the navigable end must be a aggregation end")
    end
}