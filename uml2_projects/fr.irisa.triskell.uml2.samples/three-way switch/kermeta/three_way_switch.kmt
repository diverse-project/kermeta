/* $Id: three_way_switch.kmt,v 1.3 2006-06-01 09:54:30 vmahe Exp $
 * Creation date: May 19, 2006
 * License:
 * Copyright:
 * Authors: vmahe@irisa.fr
 */

package three_way_switch;


require kermeta
require "rts.kmt"

using kermeta::standard
using rts

abstract class Light {
	reference illuminated : Boolean
	reference switch : Switch[2..2]
	operation powerOn() is abstract
	operation powerOff() is abstract
	operation get_illuminated() : Boolean is abstract
	operation get_switch(order : Integer) : Switch is abstract
	operation set_illuminated(new_illuminated : Boolean) is abstract
	operation add_switch(new_switch : Switch) is abstract
}

abstract class Switch {
	reference up : Boolean
	reference light : Light
	reference operator : Inhabitant
	operation switchUp() is abstract
	operation switchDown() is abstract
	operation get_up() : Boolean is abstract
	operation get_light() : Light is abstract
	operation get_operator() : Inhabitant is abstract
	operation set_up(new_up : Boolean) is abstract
	operation set_light(new_light : Light) is abstract
	operation set_operator(new_operator : Inhabitant) is abstract
}

abstract class Inhabitant {
	reference switch : oset Switch[2..2]
	operation get_switch(order : Integer) : Switch is abstract
	operation add_switch(new_switch : Switch) is abstract
}

class Light_impl inherits Light, ActiveStateMachine {
	reference light_top_state : Light_top_state
	reference light_in_On : Light_in_On
	reference light_in_Off : Light_in_Off
	method powerOn() is do
		//Empty. For state change, see proxy class
	end
	method powerOff() is do
		//Empty. For state change, see proxy class
	end
	method get_illuminated() : Boolean is do
		result := illuminated
	end
	method get_switch(order : Integer) : Switch is do
		result := switch.elementAt(order)
	end
	method set_illuminated(new_illuminated:Boolean) is do
		illuminated := new_illuminated
	end
	method add_switch(new_switch:Switch) is do
		if switch == void then
			switch := OrderedSet<Switch>.new
		end
		switch.add(new_switch)
	end
	operation make() is do
		illuminated := false
		light_top_state := Light_top_state.new
		light_in_On := Light_in_On.new
		light_in_Off := Light_in_Off.new
	end
}

class Switch_impl inherits Switch, ActiveStateMachine {
	reference switch_top_state : Switch_top_state
	reference switch_in_up : Switch_in_up
	reference switch_in_down : Switch_in_down
	method switchUp() is do
		// Empty. For state change, see proxy class
	end
	method switchDown() is do
		// Empty. For state change, see proxy class
	end
	method get_up() : Boolean is do
		result := up
	end
	method get_light() : Light is do
		result := light
	end
	method get_operator() : Inhabitant is do
		result := operator
	end
	method set_up(new_up : Boolean) is do
		up := new_up
	end
	method set_light(new_light : Light) is do
		light := new_light
	end
	method set_operator(new_operator : Inhabitant) is do
		operator := new_operator
	end
	operation make() is do
		up := false
		switch_top_state := Switch_top_state.new
		switch_in_up := Switch_in_up.new
		switch_in_down := Switch_in_down.new
	end
}

class Inhabitant_impl inherits Inhabitant, ActiveStateMachine {
	reference inhabitant_top_state : Inhabitant_top_state
	reference inhabitant_in_idle : Inhabitant_in_idle
	method get_switch(order : Integer) : Switch is do
		result := switch.elementAt(order)
	end
	method add_switch(new_switch : Switch) is do
		switch.add(new_switch)
	end
	operation make() is do
		inhabitant_top_state := Inhabitant_top_state.new
		inhabitant_in_idle := Inhabitant_in_idle.new
	end
}

class Light_top_state inherits Light_impl {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
}

class Light_in_On inherits Light_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method powerOn() is do
		// Nothing to do
 	end
	method powerOff() is do
		leave(light_in_On)
		powerOff
		enter(light_in_Off)
	end
	method nb_transitions() : Integer is do
		// TODO ??
	end
	method labels(n : Integer) : String is do
		// TODO ??
	end
}

class Light_in_Off inherits Light_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method powerOn() is do
		leave(light_in_Off)
		powerOn
		enter(light_in_On)
	end
	method powerOff() is do
		// Nothing to do
	end
	method nb_transitions() : Integer is do
		// TODO ??
	end
	method labels(n : Integer) : String is do
		// TODO ??
	end
}

class Switch_top_state inherits Switch_impl {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
}

class Switch_in_up inherits Switch_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method switchUp() is do
		// Nothing to do
	end
	method switchDown() is do
		leave(switch_in_up)
		switchDown
		enter(switch_in_down)
	end
	method nb_transitions() : Integer is do
		// TODO ??
	end
	method labels(n : Integer) : String is do
		// TODO ??
	end
}

class Switch_in_down inherits Switch_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method switchUp() is do
		leave(switch_in_down)
		switchUp
		enter(switch_in_up)
	end
	method switchDown() is do
		// Nothing to do
	end
	method nb_transitions() : Integer is do
		// TODO ??
	end
	method labels(n : Integer) : String is do
		// TODO ??
	end
}

class Inhabitant_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
}

class Inhabitant_in_idle {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method get_switch(order : Integer) : Switch is do
		// Empty
	end
	method add_switch(new_switch : Switch) is do
		// Empty
	end
}

class Light_proxy inherits Light, Proxy {
	method powerOn() is do
		var event : Light_powerOn_call_event init Light_powerOn_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		// factorisation of common code in Proxy class, unlike old UMLAUT
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
	method powerOff() is do
		var event : Light_powerOff_call_event init Light_powerOff_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
	method get_illuminated() : Boolean is do
		var event : Light_get_illuminated_call_event init Light_get_illuminated_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
		var illuminated : Boolean
		illuminated ?= event.arguments.last
		result := illuminated
	end
	method get_switch(order : Integer) : Switch is do
		var event : Light_get_switch_call_event init Light_get_switch_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
		var switch : Switch
		switch ?= event.arguments.elementAt(order)
		result := switch
	end
	method set_illuminated(new_illuminated : Boolean) is do
		var event : Light_set_illuminated_call_event init Light_set_illuminated_call_event.new
		event.arguments.add(new_illuminated)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
	method add_switch(new_switch : Switch) is do
		var event : Light_add_switch_call_event init Light_add_switch_call_event.new
		event.arguments.add(new_switch)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
}

class Switch_proxy inherits Switch, Proxy {
	method switchUp() is do
		var event : Switch_switchUp_call_event init Switch_switchUp_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		// factorisation of common code in Proxy class, unlike old UMLAUT
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
	method switchDown() is do
		var event : Switch_switchDown_call_event init Switch_switchDown_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
	method get_light() : Light is do
		var event : Switch_get_light_call_event init Switch_get_light_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
		var light : Light
		light ?= event.arguments.last
		result := light
	end
	method get_operator() : Inhabitant is do
		var event : Switch_get_operator_call_event init Switch_get_operator_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
		var operator : Inhabitant
		operator ?= event.arguments.last
		result := operator
	end
	method set_light(new_light : Light) is do
		var event : Switch_set_light_call_event init Switch_set_light_call_event.new
		event.arguments.add(new_light)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
	method set_operator(new_operator : Inhabitant) is do
		var event : Switch_set_operator_call_event init Switch_set_operator_call_event.new
		event.arguments.add(new_operator)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
}

class Inhabitant_proxy inherits Inhabitant, Proxy {
	method get_switch(order : Integer) : Switch is do
		var event : Inhabitant_get_switch_call_event init Inhabitant_get_switch_call_event.new
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
		var switch : Switch
		switch ?= event.arguments.elementAt(order)
		result := switch
	end
	method add_switch(new_switch : Switch) is do
		var event : Inhabitant_add_switch_call_event init Inhabitant_add_switch_call_event.new
		event.arguments.add(new_switch)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		append_ASM_action_events(serverActiveStateMachine, event)
		send(event)
	end
}

class Light_powerOn_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		target_as_Light.powerOn
	end
	method event_name() : String is do
		result := "powerOn"
	end
}
class Light_powerOn_signal {
}

class Light_powerOff_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		target_as_Light.powerOff
	end
	method event_name() : String is do
		result := "powerOff"
	end
}
class Light_powerOff_signal {
}

class Light_get_illuminated_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		target_as_Light.get_illuminated
	end
	method event_name() : String is do
		result := "get_illuminated"
	end
}
class Light_get_illuminated_signal {
	reference ~result : Boolean
}

class Light_get_switch_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		var arg0 : Integer
		arg0 ?= arguments.elementAt(0)
		target_as_Light.get_switch(arg0)
	end
	method event_name() : String is do
		result := "get_switch"
	end
}
class Light_get_switch_signal {
	reference order : Integer
	reference ~result : Switch
}

class Light_set_illuminated_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		var arg0 : Boolean
		arg0 ?= arguments.elementAt(0)
		target_as_Light.set_illuminated(arg0)
	end
	method event_name() : String is do
		result := "set_illuminated"
	end
}
class Light_set_illuminated_signal {
	reference new_illuminated : Boolean
}

class Light_add_switch_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		var arg0 : Switch
		arg0 ?= arguments.elementAt(0)
		target_as_Light.add_switch(arg0)
	end
	method event_name() : String is do
		result := "add_switch"
	end
}
class Light_add_switch_signal {
	reference new_switch : Switch
}

class Switch_switchUp_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		target_as_Switch.switchUp
	end
	method event_name() : String is do
		result := "switchUp"
	end
}
class Switch_switchUp_signal {
}

class Switch_switchDown_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		target_as_Switch.switchDown
	end
	method event_name() : String is do
		result := "switchDown"
	end
}
class Switch_switchDown_signal {
}

class Switch_get_light_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		target_as_Switch.get_light
	end
	method event_name() : String is do
		result := "get_light"
	end
}
class Switch_get_light_signal {
	reference ~result : Light
}

class Switch_get_operator_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		target_as_Switch.get_operator
	end
	method event_name() : String is do
		result := "get_operator"
	end
}
class Switch_get_operator_signal {
	reference ~result : Inhabitant
}

class Switch_set_light_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		var arg0 : Light
		arg0 ?= arguments.elementAt(0)
		target_as_Switch.set_light(arg0)
	end
	method event_name() : String is do
		result := "set_light"
	end
}
class Switch_set_light_signal {
	reference new_light : Light
}

class Switch_set_operator_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		var arg0 : Inhabitant
		arg0 ?= arguments.elementAt(0)
		target_as_Switch.set_operator(arg0)
	end
	method event_name() : String is do
		result := "set_operator"
	end
}
class Switch_set_operator_signal {
	reference new_operator : Inhabitant
}

class Inhabitant_get_switch_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Inhabitant : Inhabitant
		target_as_Inhabitant ?= target
		var arg0 : Integer
		arg0 ?= arguments.elementAt(0)
		target_as_Inhabitant.get_switch(arg0)
	end
	method event_name() : String is do
		result := "get_switch"
	end
}
class Inhabitant_get_switch_signal {
	reference order : Integer
	reference ~result : Switch
}

class Inhabitant_add_switch_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Inhabitant : Inhabitant
		target_as_Inhabitant ?= target
		var arg0 : Switch
		arg0 ?= arguments.elementAt(0)
		target_as_Inhabitant.add_switch(arg0)
	end
	method event_name() : String is do
		result := "add_switch"
	end
}
class Inhabitant_add_switch_signal {
	reference new_switch : Switch
}

// create initial state instances for simulation
class ThreeWaySwitch inherits CADPSimulator {
	operation make() is do
		make_CADP_simulator
	end
	operation set_proxy_on(proxy : Proxy,
	                       server : StateMachine,
	                       remote : Boolean) is do
		var port : Port
		if remote then
			port := Port.new
			port.initialize
			port.init_activable(void)
			port.connect(port)
			port.connect(server)
		else
			proxy.connect(server)
		end
	end
	// features specific to ThreeWaySwitch
	// -- class instances
	reference aMan : Inhabitant_impl
	reference first : Switch_impl
	reference second : Switch_impl
	reference aBulb : Light_impl
	// -- association instances
	reference aMan_first_proxy : Switch_proxy
	reference first_aMan_proxy : Inhabitant_proxy
	reference aMan_second_proxy : Switch_proxy
	reference second_aMan_proxy : Inhabitant_proxy
	reference first_aBulb_proxy : Light_proxy
	reference second_aBulb_proxy : Light_proxy
	reference aBulb_first_proxy : Switch_proxy
	reference aBulb_second_proxy : Switch_proxy
	method initial_configuration() : Configuration is do
		// create implemens
		aMan := Inhabitant_impl.new
		aMan.make
		aMan.init_activable("aMan")
		
		first := Switch_impl.new
		first.make
		first.init_activable("firstSwitch")
		
		second := Switch_impl.new
		second.make
		second.init_activable("secondSwitch")
		
		aBulb := Light_impl.new
		aBulb.make
		aBulb.init_activable("aBulb")
		
		// create proxies
		aMan_first_proxy := Switch_proxy.new
		first_aMan_proxy := Inhabitant_proxy.new
		aMan_second_proxy := Switch_proxy.new
		second_aMan_proxy := Inhabitant_proxy.new
		first_aBulb_proxy := Light_proxy.new
		second_aBulb_proxy := Light_proxy.new
		aBulb_first_proxy := Switch_proxy.new
		aBulb_second_proxy := Switch_proxy.new
		
		// set links
		aMan.add_switch(aMan_first_proxy)
		set_proxy_on(first_aMan_proxy, aMan, false)
		first.set_operator(first_aMan_proxy)
		set_proxy_on(aMan_first_proxy, first, false)
		
		aMan.add_switch(aMan_second_proxy)
		set_proxy_on(second_aMan_proxy, aMan, false)
		second.set_operator(second_aMan_proxy)
		set_proxy_on(aMan_second_proxy, second, false)
		
		first.set_light(first_aBulb_proxy)
		set_proxy_on(aBulb_first_proxy, first, false)
		aBulb.add_switch(aBulb_first_proxy)
		set_proxy_on(first_aBulb_proxy, aBulb, false)
		
		second.set_light(second_aBulb_proxy)
		set_proxy_on(aBulb_second_proxy, second, false)
		aBulb.add_switch(aBulb_second_proxy)
		set_proxy_on(second_aBulb_proxy, aBulb, false)
		
		// -- set attributes
		first.set_up(true)
		second.set_up(false)
		aBulb.set_illuminated(false)
		
		// -- register the instances
		var configuration : Configuration
		configuration.register(aMan)
		configuration.register(first)
		configuration.register(second)
		configuration.register(aBulb)
	end
}