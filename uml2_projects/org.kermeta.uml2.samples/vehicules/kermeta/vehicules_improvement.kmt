/* $Id: vehicules_improvement.kmt,v 1.2 2007-12-14 12:34:00 vmahe Exp $
 * Creation date: August 4, 2006
 * License: GPL
 * Copyright: irisa.fr
 * Authors: vmahe@irisa.fr
 */
@mainClass "vehicules::Main"
@mainOperation "main"


package vehicules;

require kermeta
require "platform:/plugin/org.kermeta.uml2/src/kermeta/transformations/StaticTools.kmt"
require "platform:/plugin/org.kermeta.uml2/src/kermeta/transformations/UmlCloneFactory.kmt"

class Main
{
	reference origModelName : kermeta::standard::String
	reference origModel : uml::Model
	reference cloneModelName : kermeta::standard::String
	reference cloneModel : uml::Model
	reference root_package : uml::Package
	
	/**
	 * This sample program will preserve the given sample model
	 * in order to be reused as many times as you want.
	 * So the program loads the model, clones it,
	 * and then does the transformations on the clone.
	 * You can then open the resulting model in the Ecore editor
	 * or use a graphical editor (like TopCased) to draw it.
	 */
    operation main() : Void is do
    	 
		stdio.writeln(" >>>------> loading the original model")
		
		//creating needed instances
		origModelName := "platform:/resource/org.kermeta.uml2.samples/vehicules/models/vehicules.uml"
		
    	// load the given UML2 resource
    	var inputRepository : kermeta::persistence::EMFRepository init kermeta::persistence::EMFRepository.new
    	var inputResource : kermeta::persistence::EMFResource
    	inputResource ?= inputRepository.getResource(origModelName)
    	
    	// "instances" only gives the main diagramm package for the targeted code tree
    	origModel ?= inputResource.instances.one
		
		stdio.writeln(" >>>------> cloning the original model (kept virgin) into a new one")
		
		var factory : uml::transformations::UmlCloneFactory init uml::transformations::UmlCloneFactory.new
		factory.initialize
		cloneModel := factory.cloneStaticDiagram(origModel)
		
		stdio.writeln(" >>>------> transforming the cloned model")
		
		// we need the package containing the classes
		root_package ?= cloneModel.packagedElement.select{ e | e.name == "vehicules" }.one
		
		addGetterOnWattsPower
		addEngineInterface
		addCarEngineComposition
		addEngineGeneralisation
		
		stdio.writeln(" >>>------> saving the transformed model")
		
		cloneModelName := "platform:/resource/org.kermeta.uml2.samples/vehicules/models/improved_vehicules.uml"
    	var outputRepository : kermeta::persistence::EMFRepository init kermeta::persistence::EMFRepository.new
    	var outputResource : kermeta::persistence::EMFResource
    	outputResource ?= outputRepository.createResource(cloneModelName, "platform:/plugin/org.eclipse.uml2.uml/model/UML.ecore")
    	outputResource.instances.add(cloneModel)
    	outputResource.save()
		
		stdio.writeln(" <------<<< model saved")
    end
    
    /////////////  code for transformations //////////////////
	operation addGetterOnWattsPower() is do
		// we get the "GasEngine" class (before this class will loose its attributes, passed to the interface)
		var cl : uml::Class
		cl ?= root_package.packagedElement.select{ e | e.name == "GasEngine" }.one
		
		// we need the accessors tool for transformation
		var accTool : uml::transformations::Accessor_Tool init uml::transformations::Accessor_Tool.new
		
		// we make the getter corresponding to each property of the class
		cl.ownedAttribute.each{ prop |
			// we add the getter operation corresponding to the property
			accTool.addGetter(cl, prop)
		}
	end
	operation addEngineInterface() is do
		// we get the "GasEngine" class to generalize it in a "IEngine" interface
		var cl : uml::Class
		cl ?= root_package.packagedElement.select{ e | e.name == "GasEngine" }.one
		
		// we need the interface tool for extraction
		var ifTool : SpecializedEngineInterface_Tool init SpecializedEngineInterface_Tool.new
		
		// we get then the interface
		var ifc : uml::Interface
		ifc := ifTool.extractInterface(cl)
		
		// we add the new interface to the resulting model
		root_package.packagedElement.add(ifc)
		// Rem: the interfaceRealization between the interface and the (original)
		// concrete class doesn't need to be added to the model
		// (it is owned by the concrete class)
	end
	operation addCarEngineComposition() is do
		// we get the "IEngine" interface to link it with "Car" class
		var iEngine : uml::Interface
		iEngine ?= root_package.packagedElement.select{ e | e.name == "IEngine" }.one
		
		// we get the "Car" class to associate it with an "IEngine" interface
		var clCar : uml::Class
		clCar ?= root_package.packagedElement.select{ e | e.name == "Car" }.one
		
		// we need the association tool for transformation
		var assocTool : uml::transformations::Association_Tool init uml::transformations::Association_Tool.new
		
		// we then get the new composition
		var assoc : uml::Association init uml::Association.new
		assoc := assocTool.addNavigableComposition(clCar, iEngine, "poweredBy", "engine")
		
		// we add the new association to the resulting model
		root_package.packagedElement.add(assoc)
	end
	operation addEngineGeneralisation() is do
		// we need the interface tool to link interface and engine
		var ifTool : SpecializedEngineInterface_Tool init SpecializedEngineInterface_Tool.new
		
		// we get then the "IEngine" interface
		var ifc : uml::Interface
		ifc ?= root_package.packagedElement.select{ e | e.name == "IEngine" }.one
		
		// we select and process the classes with a WattsPower attribute
		root_package.packagedElement.select{ e |
			var c : uml::Class
			c ?= e
			if c != void then
				not c.ownedAttribute.select{a | a.name == "wattsPower"}.isEmpty
			else false end
		}.each{ cl |
			var c : uml::Class
			c ?= cl
			if c != void then ifTool.addInterfaceRealization(ifc, c) end
		}
	end
}
	
////////////// class for overwrite interface method for name
class SpecializedEngineInterface_Tool inherits uml::transformations::Interface_Tool
{
	/** overwrite the original method */
	method nameForInterface(name : kermeta::standard::String) : kermeta::standard::String is do
    	result := "IEngine"
    end
}