@mainClass "tools_tests::ToolGOFStateTestCase"
@mainOperation "test_GOFStateTool_Context"

package tools_tests;


require kermeta
require "../../src/kermeta/transformations/GOFStatePatternTool.kmt"
require "../../src/kermeta/transformations/IOElementsTable.kmt"

using uml2
using uml2::transformations

class ToolGOFStateTestCase inherits kermeta::kunit::TestCase
{
	reference tool : GOFStatePatternTool
	reference table : IOElementsTable
	reference model : Model
	reference aClass : Class
	reference sm : StateMachine
	reference smReg : Region
	reference s0 : Pseudostate
	reference s1 : State
	reference s2 : State
	reference f : FinalState
	reference s1a : State
	reference s1b : State
	reference s1reg : Region
	reference t01 : Transition
	reference t12 : Transition
	reference t21 : Transition
	reference t2f : Transition
	
	method setUp() is do
		// initializing the output table
		table := IOElementsTable.new
		table.initialize
		
		//creating needed instances
		model := Model.new
		aClass := Class.new
		aClass.name := "AClass"
		model.ownedMember.add(aClass)
		table.putValue(model, model)
		table.putValue(aClass, aClass)	// only static UML2 elements in the output
		
		sm := StateMachine.new
		aClass.ownedBehavior.add(sm)
		
		smReg := Region.new
		smReg.name := "smReg"
		sm.region.add(smReg)
		
		s0 := Pseudostate.new
		s0.kind := PseudostateKind.initial
		smReg.subvertex.add(s0)
		
		s1 := State.new
		s1.name := "S1"
		smReg.subvertex.add(s1)
		
		s2 := State.new
		s2.name := "S2"
		smReg.subvertex.add(s2)
		
		f := FinalState.new
		f.name := "Final"
		smReg.subvertex.add(f)
		
		// S1 sub state machine
		s1reg := Region.new
		s1reg.name := "S1reg"
		s1.region.add(s1reg)
		
		s1a := State.new
		s1a.name := "S1a"
		s1reg.subvertex.add(s1a)
		
		s1b := State.new
		s1b.name := "S1b"
		s1reg.subvertex.add(s1b)
		
		var gofState : GOFStatePatternTool init GOFStatePatternTool.new
		gofState.applyPattern(sm, model, table)
	end
	
	method tearDown() is do
		// We don't need to tearDown anything in this test case.
	end
    
    operation test_GOFStateTool_Context() is do
    	assertTrueWithMsg(aClass.ownedAttribute.select{ u | u.name == "state" }.size == 1,
    		"The 'Context' class must have a 'state' link to current state")
    		
    	assertTrueWithMsg(aClass.ownedOperation.select{ u | u.name == "request" }.size == 1,
    		"The 'Context' class must have a 'request()' operation")
    	
    	var op : Operation init aClass.ownedOperation.select{ u | u.name == "request" }.one
    	assertTrueWithMsg(model.ownedComment.one.annotatedElement.select{ u | u == op }.size == 1,
    		"The model must have a Comment for Context 'request()' operation")
    	var comment : Comment
    	comment := model.ownedComment.select{ u | u.annotatedElement.contains(op) }.one
    	assertTrueWithMsg(comment.body != void,
    		"The comment for the 'request()' operation must have a body")
    	assertTrueWithMsg(comment.body == "@language \"kermeta\"\ndo\n\tstate.handle()\nend",
    		"The comment for the 'request()' operation must have a correct body")
    end
    
    operation test_GOFStateTool_AbstractState() is do
    	assertTrueWithMsg(model.ownedMember.select{ u | u.name == aClass.name + "_State" }.size == 1,
    		"the model must now have an abstract state class for 'AClass'")
    	
    	var stateClass : Class
    	stateClass ?= model.ownedMember.select{ u | u.name == aClass.name + "_State" }.one
    	assertTrueWithMsg(stateClass.isAbstract,
    		"the abstract State class must be abstract")
    	
    	assertTrueWithMsg(stateClass.ownedOperation.select{ u | u.name == "handle" }.size == 1,
    		"The abstract State class must have a 'handle()' operation")
    	var op : Operation init stateClass.ownedOperation.select{ u | u.name == "handle" }.one
    	assertTrueWithMsg(op.isAbstract,
    		"The abstract State class 'handle()' operation must be abstract")
    end
    
    operation test_GOFStateTool_ConcretePseudoState() is do
    	assertTrueWithMsg(model.ownedMember.select{ u | u.name == "ConcreteState" }.size == 1,
    		"the model must now have a 'ConcreteState' state class for 'AClass'")
    	
    	var stateClass : Class
    	stateClass ?= model.ownedMember.select{ u | u.name == "ConcreteState" }.one
    	assertTrueWithMsg(not stateClass.isAbstract,
    		"the abstract State class must be not abstract")
    	
    	assertTrueWithMsg(stateClass.ownedOperation.select{ u | u.name == "handle" }.size == 1,
    		"The ConcreteState class must have a 'handle()' operation")
    	var op : Operation init stateClass.ownedOperation.select{ u | u.name == "handle" }.one
    	assertTrueWithMsg(not op.isAbstract,
    		"The ConcreteState class 'handle()' operation must not be abstract")
    end
    
    operation test_GOFStateTool_ConcreteStates() is do
    	assertTrueWithMsg(model.ownedMember.select{ u | u.name == "ConcreteStateS1" }.size == 1,
    		"the model must now have a 'ConcreteStateS1' state class for 'AClass'")
    	
    	var stateClass : Class
    	stateClass ?= model.ownedMember.select{ u | u.name == "ConcreteStateS1" }.one
    	assertTrueWithMsg(not stateClass.isAbstract,
    		"the ConcreteState class must be not abstract")
    	
    	assertTrueWithMsg(stateClass.ownedOperation.select{ u | u.name == "handle" }.size == 1,
    		"The ConcreteStateS1 class must have a 'handle()' operation")
    	var op : Operation init stateClass.ownedOperation.select{ u | u.name == "handle" }.one
    	assertTrueWithMsg(not op.isAbstract,
    		"The ConcreteStateS1 class 'handle()' operation must not be abstract")
    		
    	assertTrueWithMsg(model.ownedMember.select{ u | u.name == "ConcreteStateS2" }.size == 1,
    		"the model must now have a 'ConcreteState'S2 state class for 'AClass'")
    	
    	var stateClassS2 : Class
    	stateClassS2 ?= model.ownedMember.select{ u | u.name == "ConcreteStateS2" }.one
    	assertTrueWithMsg(not stateClass.isAbstract,
    		"the ConcreteStateS2 class must be not abstract")
    	
    	assertTrueWithMsg(stateClassS2.ownedOperation.select{ u | u.name == "handle" }.size == 1,
    		"The ConcreteStateS2 class must have a 'handle()' operation")
    	var opS2 : Operation init stateClassS2.ownedOperation.select{ u | u.name == "handle" }.one
    	assertTrueWithMsg(not opS2.isAbstract,
    		"The ConcreteStateS2 class 'handle()' operation must not be abstract")
    end
    
    operation test_GOFStateTool_ConcreteFinalState() is do
    	assertTrueWithMsg(model.ownedMember.select{ u | u.name == "ConcreteStateFinal" }.size == 1,
    		"the model must now have a 'ConcreteStateFinal' state class for 'AClass'")
    	
    	var stateClass : Class
    	stateClass ?= model.ownedMember.select{ u | u.name == "ConcreteStateFinal" }.one
    	assertTrueWithMsg(not stateClass.isAbstract,
    		"the ConcreteStateFinal class must be not abstract")
    	
    	assertTrueWithMsg(stateClass.ownedOperation.select{ u | u.name == "handle" }.size == 1,
    		"The ConcreteStateFinal class must have a 'handle()' operation")
    	var op : Operation init stateClass.ownedOperation.select{ u | u.name == "handle" }.one
    	assertTrueWithMsg(not op.isAbstract,
    		"The ConcreteStateFinal class 'handle()' operation must not be abstract")
    end
    operation test_GOFStateTool_SubStateAbstractState() is do
    	assertTrueWithMsg(model.ownedMember.select{ u | u.name == "ConcreteState" + s1.name + "_State" }.size == 1,
    		"the model must now have an abstract state class for 'S1'")
    	
    	var stateClass : Class
    	stateClass ?= model.ownedMember.select{ u | u.name == "ConcreteState" + s1.name + "_State" }.one
    	assertTrueWithMsg(stateClass.isAbstract,
    		"the abstract State class must be abstract")
    	
    	assertTrueWithMsg(stateClass.ownedOperation.select{ u | u.name == "handle" }.size == 1,
    		"The abstract State class must have a 'handle()' operation")
    	var op : Operation init stateClass.ownedOperation.select{ u | u.name == "handle" }.one
    	assertTrueWithMsg(op.isAbstract,
    		"The abstract State class 'handle()' operation must be abstract")
    end
    
    operation test_GOFStateTool_SubStateConcreteStates() is do
    	assertTrueWithMsg(model.ownedMember.select{ u | u.name == "ConcreteStateS1a" }.size == 1,
    		"the model must now have a 'ConcreteStateS1a' state class for S1'")
    	
    	var stateClass : Class
    	stateClass ?= model.ownedMember.select{ u | u.name == "ConcreteStateS1a" }.one
    	assertTrueWithMsg(not stateClass.isAbstract,
    		"the ConcreteState class must be not abstract")
    	
    	assertTrueWithMsg(stateClass.ownedOperation.select{ u | u.name == "handle" }.size == 1,
    		"The ConcreteStateS1 class must have a 'handle()' operation")
    	var op : Operation init stateClass.ownedOperation.select{ u | u.name == "handle" }.one
    	assertTrueWithMsg(not op.isAbstract,
    		"The ConcreteStateS1a class 'handle()' operation must not be abstract")
    		
    	assertTrueWithMsg(model.ownedMember.select{ u | u.name == "ConcreteStateS1b" }.size == 1,
    		"the model must now have a 'ConcreteState'S1b state class for 'S1'")
    	
    	var stateClassS2 : Class
    	stateClassS2 ?= model.ownedMember.select{ u | u.name == "ConcreteStateS1b" }.one
    	assertTrueWithMsg(not stateClass.isAbstract,
    		"the ConcreteStateS1b class must be not abstract")
    	
    	assertTrueWithMsg(stateClassS2.ownedOperation.select{ u | u.name == "handle" }.size == 1,
    		"The ConcreteStateS1b class must have a 'handle()' operation")
    	var opS2 : Operation init stateClassS2.ownedOperation.select{ u | u.name == "handle" }.one
    	assertTrueWithMsg(not opS2.isAbstract,
    		"The ConcreteStateS1b class 'handle()' operation must not be abstract")
    end
    }