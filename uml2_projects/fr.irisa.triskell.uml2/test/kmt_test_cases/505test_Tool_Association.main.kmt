package tools_tests;

require kermeta
require "../../src/kermeta/transformations/StaticTools.kmt"

using uml
using uml::transformations

class ToolAssociationTestCase inherits kermeta::kunit::TestCase
{
	reference model : Model
    reference Aclass : Class
    reference Bclass : Class
    reference assocTool : Association_Tool
	
	method setUp() is do
    	model := Model.new
    	Aclass := Class.new
    	Bclass := Class.new
    	Aclass.name := "A"
    	Bclass.name := "B"
    	model.packagedElement.add(Aclass)
    	model.packagedElement.add(Bclass)
    	
    	assocTool := Association_Tool.new
	end
	
	method tearDown() is do
		// We don't need to tearDown anything in this test case.
	end
    
    operation testAssociationTool_SimpleAssociation() is do
//    	model.packagedElement.add(assocTool.addSimpleAssociation(Aclass, Bclass, "association", "source", "target"))
    	
    	assertTrueWithMsg(false,
    		"TODO : feature not implemented")
    end
    
    operation testAssociationTool_OneSideNavigableAssociation() is do
    	model.packagedElement.add(assocTool.addOneSideNavigableAssociation(Aclass, Bclass, "association", "source", "target"))
    	
    	assertTrueWithMsg(model.packagedElement.select{ u | u.name == "association"}.size == 1,
    		"the model must contain an Association element")
    	
    	// a "One side navigable" association must own only one end
    	var assoc : Association
    	assoc ?= model.packagedElement.select{ u | u.name == "association"}.one
    	assertTrueWithMsg(assoc != void,
    		"the model must have a non void 'association'")
    	assertTrueWithMsg(assoc.ownedEnd.size == 1,
    		"the association must have only 1 property")
    	assertTrueWithMsg(assoc.ownedEnd.one.name == "source",
    		"the association single property must be 'source'")
     	
    	// the other end is owned by the class opposite
    	assertTrueWithMsg(Aclass.ownedAttribute.select{ u | u.name == "target" }.size == 1,
    		"the navigable property must be in the opposite class")
    end
    
    operation testAssociationTool_SimpleComposition() is do
//    	model.packagedElement.add(assocTool.addSimpleComposition(Aclass, Bclass, "association", "target"))
    	
    	assertTrueWithMsg(false,
    		"TODO : feature not implemented")
    end
    
    operation testAssociationTool_SimpleAggregation() is do
//    	model.packagedElement.add(assocTool.addSimpleAggregation(Aclass, Bclass, "association", "target"))
    	
    	assertTrueWithMsg(false,
    		"TODO : feature not implemented")
    end
    
    operation testAssociationTool_NavigableComposition() is do
    	model.packagedElement.add(assocTool.addNavigableComposition(Aclass, Bclass, "association", "target"))
    	
    	// a "One side navigable" association must own only one end
    	var assoc : Association
    	assertTrueWithMsg(model.packagedElement.select{ u | u.name == "association"}.size == 1,
    		"the model must have a non void 'association'")
    	assoc ?= model.packagedElement.select{ u | u.name == "association"}.one
    	assertTrueWithMsg(assoc != void,
    		"the model must have a non void 'association'")
    	assertTrueWithMsg(assoc.ownedEnd.size == 1,
    		"the association must have only 1 property")
     	
    	// the other end is owned by the container
    	assertTrueWithMsg(Aclass.ownedAttribute.select{ u | u.name == "target" }.size == 1,
    		"the navigable property must be in the container class")
    	var prop : Property init Aclass.ownedAttribute.select{ u | u.name == "target" }.one
    	assertTrueWithMsg(prop.aggregation == AggregationKind.composite,
    		"the navigable end must be a composite end")
    end
    
    operation testAssociationTool_NavigableAggregation() is do
    	model.packagedElement.add(assocTool.addNavigableAggregation(Aclass, Bclass, "association", "target"))
    	
    	// a "One side navigable" association must own only one end
    	var assoc : Association
    	assertTrueWithMsg(model.packagedElement.select{ u | u.name == "association"}.size == 1,
    		"the model must have a non void 'association'")
    	assoc ?= model.packagedElement.select{ u | u.name == "association"}.one
    	assertTrueWithMsg(assoc.ownedEnd.size == 1,
    		"the association must have only 1 property")
     	
    	// the other end is owned by the container
    	assertTrueWithMsg(Aclass.ownedAttribute.select{ u | u.name == "target" }.size == 1,
    		"the navigable property must be in the container class")
    	var prop : Property init Aclass.ownedAttribute.select{ u | u.name == "target" }.one
    	assertTrueWithMsg(prop.aggregation == AggregationKind.shared,
    		"the navigable end must be a aggregation end")
    end
}