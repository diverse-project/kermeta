package uml2kmt_visitors;


require kermeta
require "Uml2.kmt"
require "TopDownVisitor.kmt"
require "KmBuilder.kmt"

using kermeta::standard
using kermeta::language::structure
using km_builder

class Pass2_Uml2KMTVisitor inherits topdown_visitor::TopDownVisitor
{
    attribute output : kermeta::utils::Hashtable<uml2::Element, Object>
    attribute rootPackage : Package
    
    operation initialize(outputKm : kermeta::utils::Hashtable<uml2::Element, Object>) is do
    	output := outputKm
    	rootPackage := void
    end
    
	// the second pass knows the package which represents the root of the kermeta code
    operation codeRoot() : Package is do
    	result := rootPackage
    end
    
    method visitComment(visitable : uml2::Comment) is do
    	// the comments need only to rely to their owner
    	var tag : Tag 
		tag ?= output.getValue(visitable)
		if visitable.annotatedElement.size > 0 then
			visitable.annotatedElement.each{ e |
				var obj : Object init output.getValue(e)
				tag.object.add(obj)
			}
		else
			// the comment concerns the Model
			tag.object.add(rootPackage)
		end
    	super(visitable)
    end
    
    method visitClass(visitable : uml2::Class) is do
    	// UML2 Class is a ClassDefinition in Kermeta
    	var cldef : ClassDefinition
    	cldef ?= output.getValue(visitable)
    	
    	// links all class' operations
    	visitable.ownedOperation.each{ o |
    		var op : Operation
    		op ?= output.getValue(o)
    		cldef.ownedOperation.add(op)
    	}
    	
    	// links all class' attributes
    	visitable.ownedAttribute.each{ a |
    		var prop : Property
    		prop ?= output.getValue(a)
    		// associations' ends must not be referenced
    		if a.association == void then
    			cldef.ownedAttribute.add(prop)
    		end
    	}
    	
    	super(visitable)
    end
    
    /* visit Attributes, Properties, ... */
    method visitProperty(visitable : uml2::Property) is do
		
    	// we need to manage the Type class of the property,
    	// in case of external package reference
    	visitable.type.accept(self)
    	
    	var prop : Property
    	prop ?= output.getValue(visitable)
    	var cl : Class
    	cl ?= output.getValue(visitable.type)
    	prop.type := cl
    	super(visitable)
    end
    
    method visitOperation(visitable : uml2::Operation) is do
    	
    	//DEBUG
    	stdio.writeln("DEBUG : visitOp = "+visitable.toString)
    	
    	// completes the operation
    	var op : Operation
    	op ?= output.getValue(visitable)
    	
    	// the return type if exists
		visitable.returnResult.each{e | 
    	
    	//DEBUG
    	stdio.writeln("    - return = "+e.toString)
    	
		   	var cl : Class init Class.new
	    	var cdef : ClassDefinition
	    	cdef ?= output.getValue(e.type)
	    	cl.typeDefinition := cdef
			op.type := cl
		}
			
    	// all other parameters
		visitable.formalParameter.each{e | 
    	
    	//DEBUG
    	stdio.writeln("    - param = "+e.toString)
    	stdio.writeln("    - param.type = "+e.type.toString)
    	
		   	var tv : TypeVariable
	    	tv ?= output.getValue(e.type)
			op.typeParameter.add(tv)
		}
    	
    	super(visitable)
    end
    
    method visitParameter(visitable : uml2::Parameter) is do
    	// associates the type of parameter to the ClassDefinition of this type
    	var p : Parameter
    	p ?= output.getValue(visitable)
    	var cl : Class init Class.new
    	var cdef : ClassDefinition
    	cdef ?= output.getValue(visitable.type)
    	cl.typeDefinition := cdef
    	p.type := cl
    	
    	// we must add the new Class "cl" to the objects storage
    	output.put(uml2::Parameter.new, cl)
    	
    	
    	//DEBUG
    	stdio.writeln("DEBUG : visitParam : p = "+p.toString)
    	
    	super(visitable)
    end
    
    method visitPackage(visitable : uml2::Package) is do
    	var p : Package
    	p ?= output.getValue(visitable)
    	
    	// the first package to be processed is the root package
    	// (the visitPackage operation is the entry point for a model)
    	if rootPackage == void then rootPackage := p end
    	
    	// attach the elements which belong to a package
    	visitable.ownedMember.each{ e |
	    	var obj : TypeDefinition
	    	obj ?= output.getValue(e)
	    	if obj != void
	    	then
	    		/* we don't reference DataTypes in the package
	    		  (used for typing parameters and properties) */
	    		var dt : DataType
	    		dt ?= obj
	    		if dt.isVoid() then p.ownedTypeDefinition.add(obj) end
			end
    	}
    	
    	super(visitable)
    end
    
    method visitDataType(visitable : uml2::DataType) is do
    	// TODO
    	super(visitable)
    end
    
    method visitGeneralization(visitable : uml2::Generalization) is do
    	// we must add the "general" type to the "source" object
    	var general : ClassDefinition
    	general ?= output.getValue(visitable.general)
   		var spec : ClassDefinition
   		spec ?= output.getValue(visitable.specific)
   		var cl : Class
   		cl ?= output.getValue(visitable)
   		cl.typeDefinition := general
   		if not spec.superType.exists{ k | k.oid == cl.oid }
   		then
	   		spec.superType.add(cl)
   		end
   		
     	super(visitable)
    end
    
    method visitAssociation(visitable : uml2::Association) is do
    	// TODO
    	super(visitable)
    end
}