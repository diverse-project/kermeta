package uml2kmt_visitors;

require kermeta
require "Uml2.kmt"
require "TopDownVisitor.kmt"
require "KmBuilder.kmt"

using kermeta::standard
using kermeta::interpreter
using kermeta::language::structure
using km_builder

class Pass2_Uml2KMTVisitor inherits topdown_visitor::TopDownVisitor
{
    reference output : kermeta::utils::Hashtable<uml2::Element, Object>
    reference rootPackage : Package
    reference resourceObjects : Set<Object>
    
    operation initialize(outputKm : kermeta::utils::Hashtable<uml2::Element, Object>) is do
    	output := outputKm
    	rootPackage := void
    	resourceObjects := Set<Object>.new
    end
    
	// the second pass knows the package which represents the root of the kermeta code
    operation codeRoot() : Package is do
    	result := rootPackage
    end
    
    method visitComment(visitable : uml2::Comment) is do
    	// the comments need only to rely to their owner
    	var tag : Tag 
		tag ?= output.getValue(visitable)
		if visitable.annotatedElement.size > 0 then
			visitable.annotatedElement.each{ e |
				var obj : Object init output.getValue(e)
				tag.object.add(obj)
			}
		else
			// the comment concerns the Model
			tag.object.add(rootPackage)
		end
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		if tag.name != "km_body" then
			resourceObjects.add(tag)
		else
			// except for the body of operations, parsed in Pass3
			output.remove(visitable)
		end
		
    	super(visitable)
    end
    
    method visitClass(visitable : uml2::Class) is do
    	// UML2 Class is a ClassDefinition in Kermeta
    	var cldef : ClassDefinition
    	cldef ?= output.getValue(visitable)
    	
    	// links all class' operations
    	visitable.ownedOperation.each{ o |
    		var op : Operation
    		op ?= output.getValue(o)
    		cldef.ownedOperation.add(op)
    		
	   		// manage the inherited properties and operations (if redefined in specific class)
	   		op.superOperation := superOperation(op.name, visitable.generalization)
    	}
    	
    	// links all class' attributes
    	visitable.ownedAttribute.each{ att |
    		var prop : Property
    		prop ?= output.getValue(att)
			cldef.ownedAttribute.add(prop)
    	}
    	
    	super(visitable)
    end
    
    /* visit Attributes, Properties, ... */
    method visitProperty(visitable : uml2::Property) is do
    	// we need to manage the Type class of the property,
    	// in case of external package reference
//    	visitable.type.accept(self)
    	
    	var prop : Property
    	prop ?= output.getValue(visitable)
    	
    	var type : Object
    	type := output.getValue(visitable.type)
		if ClassDefinition.isInstance(type) then
		   	var cl : Class init Class.new
	    	var cdef : ClassDefinition
	    	cdef ?= type
	    	cl.typeDefinition := cdef
			prop.type := cl
		else
			var t : Type
			t ?= type
			prop.type := t
		end
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		resourceObjects.add(prop.type)
    	
    	super(visitable)
    end
    
    method visitOperation(visitable : uml2::Operation) is do
    	// completes the operation
    	var op : Operation
    	op ?= output.getValue(visitable)
    	
    	// the return type if exists
		visitable.returnResult.each{e | 
	    	var type : Object
	    	type := output.getValue(visitable.type)
			if ClassDefinition.isInstance(type) then
			   	var cl : Class init Class.new
		    	var cdef : ClassDefinition
		    	cdef ?= output.getValue(e.type)
		    	cl.typeDefinition := cdef
				op.type := cl
			else
				var t : Type
				t ?= type
				op.type := t
			end
			// as Class/DataType/Tag are not linked thru composition
			// we must add them in the resulting KM resource
			resourceObjects.add(op.type)
		}
			
    	// all other parameters
		visitable.formalParameter.each{e |
			var par : Parameter
			par ?= output.getValue(e)
			op.ownedParameter.add(par)
		}
    	
    	super(visitable)
    end
    
    method visitParameter(visitable : uml2::Parameter) is do
    	// associates the type of parameter to the ClassDefinition of this type
    	var p : Parameter
    	p ?= output.getValue(visitable)
    	var type : Object
    	type := output.getValue(visitable.type)
		if ClassDefinition.isInstance(type) then
	    	var cl : Class init Class.new
	    	cl.typeDefinition ?= type
	    	p.type := cl
	    else
			p.type ?= type
    	end
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		resourceObjects.add(p.type)
	    	
    	super(visitable)
    end
    
    method visitPackage(visitable : uml2::Package) is do
    	var p : Package
    	p ?= output.getValue(visitable)
    	
    	// the first package to be processed is the root package
    	// (the visitPackage operation is the entry point for a model)
    	if rootPackage == void then rootPackage := p end
    	
    	// attach the elements which belong to a package
    	visitable.ownedMember.each{ e |
	    	var obj : TypeDefinition
	    	obj ?= output.getValue(e)
	    	if obj != void
	    	then
	    		/* we don't reference DataTypes in the package
	    		  (used for typing parameters and properties) */
	    		var dt : DataType
	    		dt ?= obj
	    		if dt.isVoid() then p.ownedTypeDefinition.add(obj) end
			end
    	}
    	
    	super(visitable)
    end
    
    method visitDataType(visitable : uml2::DataType) is do
    	super(visitable)
    end
    
    method visitGeneralization(visitable : uml2::Generalization) is do
    	// we must add the "general" type to the "source" object
    	var gen : ClassDefinition
    	gen ?= output.getValue(visitable.general)
   		var spec : ClassDefinition
   		spec ?= output.getValue(visitable.specific)
   		var cl : Class init Class.new
   		cl.typeDefinition := gen
   		if not spec.superType.exists{ k | k.oid == cl.oid }
   		then
	   		spec.superType.add(cl)
   		end
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		resourceObjects.add(cl)
   		
     	super(visitable)
    end
    
    method visitAssociation(visitable : uml2::Association) is do
    	/* the structure of representations differs
    	 * from UML2 to Kermeta depending on the association cases
    	 *
    	 * We only have two main cases in Kermeta
    	 *  - 1 diamond-ed end => containance relation thru "attribute" keyword
    	 *    This case is managed in Pass1.visitProperty().
    	 *  - others cases (including white diamonds) => "reference" keyword
    	 *    Nothing to do (will be ordinary properties)
    	 * 
    	 * Navigation thru the association demand a "Navigable" tag in UML2
    	 * and named association's ends in Kermeta, so we need them both
    	 * Rem : the 2 ends must be navigable to be concerned by Kermeta "Opposite"
    	 * (note than Pass1 has disqualified associations with more than 2 members)
    	 */
    	if visitable.ownedEnd.size == 0  then
    		var it : Iterator<uml2::Property> init visitable.memberEnd.iterator
    		// get the first end
			var end1 : uml2::Property init it.next
			var p1 : Property
			p1 ?= output.getValue(end1)
    		// get the second end
			var end2 : uml2::Property init it.next
			var p2 : Property
			p2 ?= output.getValue(end2)
    		// link the opposites
    		p1.opposite := p2
    		p2.opposite := p1
    	end
    	
    	// UML2 and Kermeta store in inverted places the "composite" property
		var it : Iterator<uml2::Property> init visitable.memberEnd.iterator
		// get the first end
		var end1 : uml2::Property init it.next
		var p1 : Property
		p1 ?= output.getValue(end1)
		// get the second end
		var end2 : uml2::Property init it.next
		var p2 : Property
		p2 ?= output.getValue(end2)
		
		// link the opposites
		var b : Boolean init p2.isComposite
		p2.isComposite := p1.isComposite
		p1.isComposite := b
    	
    	super(visitable)
    end
    
	method visitInterface(visitable : uml2::Interface) is do
		// Interface doesn(t exists as concept in Kermeta
		// so interfaces must be processed as Uml2 abstract classes
		
    	// UML2 Interface is a ClassDefinition in Kermeta
    	var cldef : ClassDefinition
    	cldef ?= output.getValue(visitable)
    	
    	// links all class' operations
    	visitable.ownedOperation.each{ o |
    		var op : Operation
    		op ?= output.getValue(o)
    		cldef.ownedOperation.add(op)
    	}
    	
    	// links all class' attributes
    	visitable.ownedAttribute.each{ att |
    		var prop : Property
    		prop ?= output.getValue(att)
			cldef.ownedAttribute.add(prop)
    	}
		
    	super(visitable)
	end
	
	/**
	 * recursive method to obtain the nearest super Operation,
	 * for a given operation name, if it exists in the given generalization
	 */
	 operation superOperation(name : String, genSet : Set<uml2::Generalization>) : Operation is do
	 	result := void
	 	
   		// Take note that a method redefined deeper than one level of inheritance
   		// would not be processed, as UML2 doesn't give any recursive access to superclasses,
   		// so Kermeta interpreter will raise a error on it
   		genSet.each{ gen |
	   		var superClass : uml2::Class
	   		superClass ?= gen.general
   			superClass.ownedOperation.each{ supOp |
   				if supOp.name == name then
   					// inherited operation
   					var genOp : Operation
   					result ?=output.getValue(supOp)
   				end
   			}
   			// recursive exploration of super super classes
   			if result.isVoid then
   				result := superOperation(name, superClass.generalization)
   			end
   		}
	 end
}