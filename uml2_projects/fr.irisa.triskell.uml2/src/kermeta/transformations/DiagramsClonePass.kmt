/* $Id: DiagramsClonePass.kmt,v 1.4 2006-07-27 13:34:21 vmahe Exp $
 * Creation date: July 7, 2006
 * License:
 * Copyright:
 * Authors:
 */

package uml2::transformations;


require kermeta
require "../TopDownVisitor.kmt"
require "UmlCloneFactory.kmt"
require "IOElementsTable.kmt"

using uml2

class DiagramClonePass inherits topdown_visitor::TopDownVisitor
{
	reference currentPackage : Package
	reference table : IOElementsTable
	reference factory : UmlCloneFactory

    operation initialize(inputModel : Model, clonesTable : IOElementsTable, cloneFactory : UmlCloneFactory) is do 
        // the Hashtable could be used by the calling program
        // which must give it to the passes for putting in the clones
        table := clonesTable
        factory := cloneFactory
    end
    method visitPackage(visitable : Package) is do 
        // must manage the current package for each processed element
        // to be put in the corresponding package
        var previousPackage : Package init currentPackage
        currentPackage := visitable
        
        // processing the node (different for each pass)
        self.processPackage(visitable)
        // end of processing the node
        
        super(visitable)
        currentPackage := previousPackage
    end
    operation processPackage(visitable : Package) is abstract
}

class StaticDiagramClonePass1 inherits DiagramClonePass
{
    method visitModel(visitable : Model) is do
		table.putValue(visitable, factory.cloneModel(visitable))
	    super(visitable)
    end
    
    method processPackage(visitable : Package) is do 
        // processing the node
        var clone : Package init factory.clonePackage(visitable)
        table.putValue(visitable, clone)
    end
    
    /* cloned with its properties and operations (and corresponding parameters) */
    method visitClass(visitable : Class) is do
		// we need to break infinite recursivity thru Type
		var o : Element init table.getValue(visitable)
		if o.isVoid
		then
    		table.putValue(visitable, factory.cloneClass(visitable))
	    	super(visitable)
    	end
    end
    
    method visitComment(visitable : Comment) is do
		
		//DEBUG
		stdio.writeln("DEBUG pass1.visitComment() - body =  "+visitable.body)
		
    	// we must put only one clone
    	// (passed three times : from package, from annotated element, third unknown)
//		var o : Element init table.getValue(visitable)
//		if o.isVoid
//		then
	    	table.putValue(visitable, factory.cloneComment(visitable))
	    	super(visitable)
//    	end
    end
    
    method visitDataType(visitable : DataType) is do
    	table.putValue(visitable, factory.cloneDataType(visitable))
    	super(visitable)
    end
    
    method visitGeneralization(visitable : Generalization) is do
    	table.putValue(visitable, factory.cloneGeneralization(visitable))
    	super(visitable)
    end
    
    method visitAssociation(visitable : Association) is do
		
		//DEBUG
		visitable.memberEnd.each{u|stdio.writeln("DEBUG pass1.assoc("+visitable.name+") - memberEnd =  "+u.name+" - "+u.toString)}
		
    	table.putValue(visitable, factory.cloneAssociation(visitable))
    	super(visitable)
    end
    
    method visitInterface(visitable : Interface) is do
    	table.putValue(visitable, factory.cloneInterface(visitable))
    	super(visitable)
    end
}

class StaticDiagramClonePass2 inherits DiagramClonePass
{
    method processPackage(visitable : Package) is do 
        // include all members in the clone package
        var clone : Package
        clone ?= table.getValue(visitable)
        visitable.ownedMember.each{ u |
        	var mClone : PackageableElement
        	mClone ?= table.getValue(u)
        	clone.ownedMember.add(mClone)
        }
    end
    
    method visitModel(visitable : Model) is do
        // include all members in the clone Model
        var clone : Model
        clone ?= table.getValue(visitable)
        visitable.ownedMember.each{ u |
        	var mClone : PackageableElement
        	mClone ?= table.getValue(u)
        	clone.ownedMember.add(mClone)
        }
    	super(visitable)
    end
    
    method visitClass(visitable : Class) is do
        var clone : Class
        clone ?= table.getValue(visitable)
        
        //  Classifier uncloned properties
        visitable.generalization.each{ u |
        	var eClone : Generalization
        	eClone ?= table.getValue(u)
        	clone.generalization.add(eClone)
        }
        visitable.ownedUseCase.each{ u |
        	var eClone : UseCase
        	eClone ?= table.getValue(u)
        	clone.ownedUseCase.add(eClone)
        }
        //powertypeExtent : FIXME
        visitable.redefinedClassifier.each{ u |
        	var eClone : Classifier
        	eClone ?= table.getValue(u)
        	clone.redefinedClassifier.add(eClone)
        }
        //representation : FIXME
        //substitution : FIXME
        //usedCase				: not in StaticDiagram
        
        //  BehavioredClassifier uncloned properties
		//classifierBehavior	: not in StaticDiagram
		//implementation		: not in StaticDiagram
		//ownedTrigger			: not in StaticDiagram
		//ownedStateMachine		: not in StaticDiagram
    	super(visitable)
    end
    
    method visitComment(visitable : Comment) is do
    	
    	//DEBUG
    	stdio.writeln("DEBUG pass2.visitComment : "+visitable.body)
    	
        var clone : Comment
        clone ?= table.getValue(visitable)
        currentPackage.ownedComment.add(clone)
    	visitable.annotatedElement.each{u |
    	
    	//DEBUG
    	stdio.writeln("DEBUG pass2.visitComment : annotatedElement = "+u.toString)
    	stdio.writeln("DEBUG pass2.visitComment : annotatedElement clone = "+table.getValue(u).toString)
    	
    		clone.annotatedElement.add(table.getValue(u))
    	}
    	//  Comment uncloned properties : none
    	super(visitable)
    end
    
    method visitDataType(visitable : DataType) is do
        var clone : DataType
        clone ?= table.getValue(visitable)
        //  Classifier uncloned properties
        visitable.ownedAttribute.each{ u |
			var uVal : Property
			uVal ?= table.getValue(u)
			clone.ownedAttribute.add(uVal)
		}
        visitable.ownedOperation.each{ u |
			var uVal : Operation
			uVal ?= table.getValue(u)
			clone.ownedOperation.add(uVal) }
    	super(visitable)
    end
    
    method visitGeneralization(visitable : Generalization) is do
        var clone : Generalization
        clone ?= table.getValue(visitable)
        var specVal : Classifier
        specVal ?= table.getValue(visitable.specific)
    	
    	//DEBUG
    	stdio.writeln("DEBUG - pass2.visitGene("+visitable.toString+") : specific = "+visitable.specific.toString)
    	stdio.writeln("DEBUG - pass2.visitGene("+visitable.toString+") : specific clone = "+specVal.toString)
    	
        clone.specific := specVal
        
        var genVal : Classifier
        genVal ?= table.getValue(visitable.general)
    	
    	//DEBUG
    	stdio.writeln("DEBUG - pass2.visitGene("+visitable.toString+") : general = "+visitable.general.toString)
    	stdio.writeln("DEBUG - pass2.visitGene("+visitable.toString+") : general clone = "+genVal.toString)
    	
        clone.general := genVal
        
       /* FIXME : not available for the moment
        visitable.generalizationSet.each{ u |
			var uVal : GeneralizationSet
			uVal ?= table.getValue(u)
			clone.generalizationSet.add(uVal) }	*/
		
		//  DirectedRelationship uncloned properties : none
    	super(visitable)
    end
    
    method visitAssociation(visitable : Association) is do
		
		//DEBUG
		stdio.writeln("DEBUG pass2.assoc("+visitable.name+")")
		
        var clone : Association
        clone ?= table.getValue(visitable)
        visitable.memberEnd.each{ u |
			var uVal : Property
			uVal ?= table.getValue(u)
		
		//DEBUG
		stdio.writeln("DEBUG pass2.assoc("+visitable.name+") - memberEnd =  "+u.name+" - "+u.toString)
		stdio.writeln("DEBUG pass2.assoc("+visitable.name+") - memberEnd clone = "+uVal.toString)
		
			if uVal != void then	//////FIXME : defensive programming
				clone.memberEnd.add(uVal)
			end
			}
        
        //  Classifier uncloned properties
        visitable.generalization.each{ u |
        	var eClone : Generalization
        	eClone ?= table.getValue(u)
        	clone.generalization.add(eClone)
        }
        /* not part in static diagrams so not cloned
        visitable.ownedUseCase.each{ u |
        	var eClone : UseCase
        	eClone ?= table.getValue(u)
        	clone.ownedUseCase.add(eClone)
        }	*/
        //powertypeExtent : FIXME
        visitable.redefinedClassifier.each{ u |
        	var eClone : Classifier
        	eClone ?= table.getValue(u)
        	clone.redefinedClassifier.add(eClone)
        }
        //representation : FIXME
        //substitution : FIXME
        //usedCase				: not in StaticDiagram
        
		//  Relationship uncloned properties : none
    	super(visitable)
    end
    
    method visitParameter(visitable : Parameter) is do
    	var clone : Parameter
        clone ?= table.getValue(visitable)
        
        //DEBUG
        stdio.writeln("DEBUG pass2.visitPar("+visitable.name+" - "+visitable.toString+") : clone = "+clone.toString)
        
        var cl : Classifier
        cl ?=table.getValue(visitable.type)
        clone.type := cl
    end
    
    method visitProperty(visitable : Property) is do
    	var clone : Property
        clone ?= table.getValue(visitable)
        
        //DEBUG
        stdio.writeln("DEBUG pass2.visitProp("+visitable.name+" - "+visitable.toString+") : clone = "+clone.toString)
        
        var cl : Classifier
        cl ?=table.getValue(visitable.type)
        clone.type := cl
    end
    
    method visitInterface(visitable : Interface) is do
        var clone : Interface
        clone ?= table.getValue(visitable)
        visitable.nestedClassifier.each{ u | 
        	var cl : Classifier
        	cl ?= table.getValue(u)
        	clone.nestedClassifier.add(cl)
        }
        
        //  Classifier uncloned properties
        visitable.generalization.each{ u |
        	var eClone : Generalization
        	eClone ?= table.getValue(u)
        	clone.generalization.add(eClone)
        }
        /* not part in static diagrams so not cloned
        visitable.ownedUseCase.each{ u |
        	var eClone : UseCase
        	eClone ?= table.getValue(u)
        	clone.ownedUseCase.add(eClone)
        }	*/
        //powertypeExtent : FIXME
        visitable.redefinedClassifier.each{ u |
        	var eClone : Classifier
        	eClone ?= table.getValue(u)
        	clone.redefinedClassifier.add(eClone)
        }
        //representation : FIXME
        //substitution : FIXME
        //usedCase				: not in StaticDiagram
    	super(visitable)
    end
}