/* $Id: DiagramsClonePass.kmt,v 1.1 2006-07-18 15:10:45 vmahe Exp $
 * Creation date: July 7, 2006
 * License:
 * Copyright:
 * Authors:
 */

package uml2::transformations;


require kermeta
require "../Uml2.kmt"
require "../TopDownVisitor.kmt"
require "UmlCloneFactory.kmt"
require "IOElementsTable.kmt"

using uml2

class DiagramClonePass inherits topdown_visitor::TopDownVisitor
{
	reference currentPackage : Package
	reference table : IOElementsTable
	reference factory : UmlCloneFactory

    operation initialize(inputPackage : Package, clonesTable : IOElementsTable, cloneFactory : UmlCloneFactory) is do 
        // the Hashtable could be used by the calling program
        // which must give it to the passes for putting in the clones
        table := clonesTable
        factory := cloneFactory
        visitPackage(inputPackage)
    end
    method visitPackage(visitable : Package) is do 
        // must manage the current package for each processed element
        // to be put in the corresponding package
        var previousPackage : Package init currentPackage
        currentPackage := visitable
        
        // processing the node (different for each pass)
        processPackage(visitable)
        // end of processing the node
        
        super(visitable)
        currentPackage := previousPackage
    end
    operation processPackage(visitable : Package) is abstract
}

class StaticDiagramClonePass1 inherits DiagramClonePass
{
    method processPackage(visitable : Package) is do 
        // processing the node
        var clone : Package init factory.clonePackage(visitable)
        if visitable.nestingPackage != void then
        	// nested package so we must nest the clone too
        	var p : Package
        	p ?= table.getValue(visitable.nestingPackage)
        	p.nestingPackage := clone
        end
        table.putValue(visitable, clone)
    end
    
    /* cloned with its properties and operations (and corresponding parameters) */
    method visitClass(visitable : Class) is do
		// we need to break infinite recursivity thru Type
		var o : Element init table.getValue(visitable)
		if o.isVoid
		then
    		table.putValue(visitable, factory.cloneClass(visitable))
	    	super(visitable)
    	end
    end
    
    method visitComment(visitable : Comment) is do
    	table.putValue(visitable, factory.cloneComment(visitable))
    	super(visitable)
    end
    
    method visitDataType(visitable : DataType) is do
    	table.putValue(visitable, factory.cloneDataType(visitable))
    	super(visitable)
    end
    
    method visitGeneralization(visitable : Generalization) is do
    	table.putValue(visitable, factory.cloneGeneralization(visitable))
    	super(visitable)
    end
    
    method visitAssociation(visitable : Association) is do
    	table.putValue(visitable, factory.cloneAssociation(visitable))
    	super(visitable)
    end
    
    method visitInterface(visitable : Interface) is do
    	table.putValue(visitable, factory.cloneInterface(visitable))
    	super(visitable)
    end
}

class StaticDiagramClonePass2 inherits DiagramClonePass
{
    method processPackage(visitable : Package) is do 
        // include all members in the clone package
        var clone : Package
        clone ?= table.getValue(visitable)
        visitable.ownedMember.each{ u |
        	var mClone : PackageableElement
        	mClone ?= table.getValue(u)
        	clone.ownedMember.add(mClone)
        }
    end
    
    method visitClass(visitable : Class) is do
        var clone : Class
        clone ?= table.getValue(visitable)
        
        //  Classifier uncloned properties
        visitable.generalization.each{ u |
        	var eClone : Generalization
        	eClone ?= table.getValue(u)
        	clone.generalization.add(eClone)
        }
        visitable.ownedUseCase.each{ u |
        	var eClone : UseCase
        	eClone ?= table.getValue(u)
        	clone.ownedUseCase.add(eClone)
        }
        //powertypeExtent : FIXME
        visitable.redefinedClassifier.each{ u |
        	var eClone : Classifier
        	eClone ?= table.getValue(u)
        	clone.redefinedClassifier.add(eClone)
        }
        //representation : FIXME
        //substitution : FIXME
        //usedCase				: not in StaticDiagram
        
        //  BehavioredClassifier uncloned properties
		//classifierBehavior	: not in StaticDiagram
		//implementation		: not in StaticDiagram
		//ownedTrigger			: not in StaticDiagram
		//ownedStateMachine		: not in StaticDiagram
    	super(visitable)
    end
    
    method visitComment(visitable : Comment) is do
        var clone : Comment
        clone ?= table.getValue(visitable)
    	visitable.annotatedElement.each{u |
    		clone.annotatedElement.add(table.getValue(u))
    	}
    	//  TemplateableElement uncloned properties : none
    	super(visitable)
    end
    
    method visitDataType(visitable : DataType) is do
        var clone : DataType
        clone ?= table.getValue(visitable)
        visitable.ownedAttribute.each{ u |
			var uVal : Property
			uVal ?= table.getValue(u)
			clone.ownedAttribute.add(uVal)
		}
        visitable.ownedOperation.each{ u |
			var uVal : Operation
			uVal ?= table.getValue(u)
			clone.ownedOperation.add(uVal) }
    	super(visitable)
    end
    
    method visitGeneralization(visitable : Generalization) is do
        var clone : Generalization
        clone ?= table.getValue(visitable)
       /* FIXME : not available for the moment
        visitable.generalizationSet.each{ u |
			var uVal : GeneralizationSet
			uVal ?= table.getValue(u)
			clone.generalizationSet.add(uVal) }	*/
		
		//  DirectedRelationship uncloned properties : none
    	super(visitable)
    end
    
    method visitAssociation(visitable : Association) is do
        var clone : Association
        clone ?= table.getValue(visitable)
        visitable.memberEnd.each{ u |
			var uVal : Property
			uVal ?= table.getValue(u)
			clone.memberEnd.add(uVal) }
        
        //  Classifier uncloned properties
        visitable.generalization.each{ u |
        	var eClone : Generalization
        	eClone ?= table.getValue(u)
        	clone.generalization.add(eClone)
        }
        visitable.ownedUseCase.each{ u |
        	var eClone : UseCase
        	eClone ?= table.getValue(u)
        	clone.ownedUseCase.add(eClone)
        }
        //powertypeExtent : FIXME
        visitable.redefinedClassifier.each{ u |
        	var eClone : Classifier
        	eClone ?= table.getValue(u)
        	clone.redefinedClassifier.add(eClone)
        }
        //representation : FIXME
        //substitution : FIXME
        //usedCase				: not in StaticDiagram
        
		//  Relationship uncloned properties : none
    	super(visitable)
    end
    
    method visitInterface(visitable : Interface) is do
        var clone : Interface
        clone ?= table.getValue(visitable)
        visitable.nestedClassifier.each{ u | 
        	var cl : Classifier
        	cl ?= table.getValue(u)
        	clone.nestedClassifier.add(cl)
        }
        
        //  Classifier uncloned properties
        visitable.generalization.each{ u |
        	var eClone : Generalization
        	eClone ?= table.getValue(u)
        	clone.generalization.add(eClone)
        }
        visitable.ownedUseCase.each{ u |
        	var eClone : UseCase
        	eClone ?= table.getValue(u)
        	clone.ownedUseCase.add(eClone)
        }
        //powertypeExtent : FIXME
        visitable.redefinedClassifier.each{ u |
        	var eClone : Classifier
        	eClone ?= table.getValue(u)
        	clone.redefinedClassifier.add(eClone)
        }
        //representation : FIXME
        //substitution : FIXME
        //usedCase				: not in StaticDiagram
    	super(visitable)
    end
}