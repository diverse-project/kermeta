/* $Id: UmlCloneFactory.kmt,v 1.4 2006-07-27 13:34:21 vmahe Exp $
 * Creation date: July 5, 2006
 * License:
 * Copyright:
 * Authors:
 */

package uml2::transformations;


require kermeta
//require "../Uml2.kmt"
require "DiagramsClonePass.kmt"
require "IOElementsTable.kmt"

using uml2

class UmlCloneFactory
{
	reference ioTable : IOElementsTable
	
	operation initialize() is do
		ioTable := IOElementsTable.new
		ioTable.initialize
	end

///////////////////////// MAIN DIAGRAMS CLONING ///////////////////////
// these operations offer cloning of a complete UML2 diagram in once //
///////////////////////////////////////////////////////////////////////

	operation cloneStaticDiagram(node : Model) : Model is do
		// first pass clones classes, operations, parameters
		var pass1 : StaticDiagramClonePass1 init StaticDiagramClonePass1.new
		pass1.initialize(node, ioTable, self)
		pass1.visitModel(node)
		
		// second pass clones links and change parameters'type to the type clone
		var pass2 : StaticDiagramClonePass2 init StaticDiagramClonePass2.new
		pass2.initialize(node, ioTable, self)
		pass2.visitModel(node)
		
		// give the cloned top package as resulting model (without non static UML2 elements)
		result ?= ioTable.getValue(node)
	end

///////////////////////////// SINGLE ELEMENTS CL0NING ////////////////////
// REM: as we clone UML model elements, we don't need to explore        //
//      the inherited properties like it would be for their instances.  //
//////////////////////////////////////////////////////////////////////////

    operation cloneModel(element : Model) : Model is do
        var clone : Model init Model.new
        // superclasses
        affectPackage(element, clone)
        //specific properties
        clone.viewpoint := element.viewpoint
        result := clone
    end

    operation clonePackage(element : Package) : Package is do 
        var clone : Package init Package.new
        affectPackage(element, clone)
        result := clone
    end

    operation cloneClass(element : Class) : Class is do 
        var clone : Class init Class.new
        affectBehavioredClassifier(element, clone)
        affectEncapsulatedClassifier(element, clone)
        clone.isActive := element.isActive
        element.ownedOperation.each{ u |
        	var opClone : Operation init cloneOperation(u)
        	ioTable.putValue(u, opClone)
        	clone.ownedOperation.add(opClone)
        }
        //nested classifiers will be top/down visited or must be clone through a explicit demand
        //ownedReception : TODO
        result := clone
    end

    operation cloneOperation(element : Operation) : Operation is do 
        var clone : Operation init Operation.new
    	// super classes properties
    	affectMultiplicityElement(element, clone)
    	affectTypedElement(element, clone)
    	affectParameterableElement(element, clone)
    	affectBehavioralFeature(element, clone)
    	// specific properties
        element.ownedParameter.each{ u |
        	var par : Parameter init cloneParameter(u)
        	ioTable.putValue(u, par)
        	clone.ownedParameter.add(par)
        	par.~operation := clone
        }
        result := clone
    end
    
    /** return a clone of the parameter but with the same Type instance */
    operation cloneParameter(element : Parameter) : Parameter is do
    	var clone : Parameter init Parameter.new
    	// super classes properties
    	affectMultiplicityElement(element, clone)
    	affectTypedElement(element, clone)
    	affectConnectableElement(element, clone)
    	// specific properties
    	clone.direction := element.direction
    	clone.effect := element.effect
    	clone.isException := element.isException
    	clone.isStream := element.isStream
    	if element.defaultValue != void then clone.defaultValue := cloneValueSpecification(element.defaultValue) end
    	// rem : the "operation" attribute must be fixed by its owning operation
    	result := clone
    end
    
    /** return a clone of the parameter but with the same Type instance */
    operation cloneProperty(element : Property) : Property is do
    	var clone : Property init Property.new
    	// super classes properties
    	affectMultiplicityElement(element, clone)
    	affectStructuralFeature(element, clone)
    	affectConnectableElement(element, clone)
    	affectDeploymentTarget(element, clone)
    	// specific properties
    	if element.defaultValue != void then clone.defaultValue := cloneValueSpecification(element.defaultValue) end
        clone.isDerived := element.isDerived
        clone.isReadOnly := element.isReadOnly
        clone.isDerivedUnion := element.isDerivedUnion
        clone.association := element.association	// NB : not a clone of the association but the original one
    	// rem : the "owningAssociation" attribute must be fixed by its owning association
    	// redefinedProperty : TODO
    	// subsettedProperty : TODO
    	// rem : the "associationEnd" attribute must be fixed by the property (of an association) which own the qualifier
    	// qualifier : TODO (should fixed the opposite "associationEnd)
    	
    	// specific treatment of AggregationKind
        if element.aggregation == AggregationKind.none then
        	clone.aggregation := AggregationKind.none
        else if element.aggregation == AggregationKind.composite then
        	clone.aggregation := AggregationKind.composite
        else if element.aggregation == AggregationKind.shared then
        	clone.aggregation := AggregationKind.shared
        end end end
    	result := clone
    end
    
    /** return a clone of the ValueSpecification with the same value */
    operation cloneValueSpecification(element : ValueSpecification) : ValueSpecification is do
    	// we need to clone the element depending on its type
    	if element != void then
	    	var expr : Expression
	    	var opexpr : OpaqueExpression
	    	var bool : LiteralBoolean
	    	var int : LiteralInteger
	    	var str : LiteralString
	    	var un : LiteralUnlimitedNatural
	    	var zero : LiteralNull
	    	var inst : InstanceValue
	    	expr ?= element
	    	opexpr ?= element
	    	bool ?= element
	    	int ?= element
	    	str ?= element
	    	un ?= element
	    	zero ?= element
	    	inst ?= element
	    	if expr != void then
	    		var clone : Expression init Expression.new
	    		clone.symbol := expr.symbol
	    		result := clone
	    	else if opexpr != void then
	    		var clone : OpaqueExpression init OpaqueExpression.new
	    		clone.body := opexpr.body
	    		clone.language := opexpr.language
	    		result := clone
	    	else if bool != void then
	    		var clone : LiteralBoolean init LiteralBoolean.new
	    		clone.~value := bool.~value
	    		result := clone
	    	else if int != void then
	    		var clone : LiteralInteger init LiteralInteger.new
	    		clone.~value := int.~value
	    		result := clone
	    	else if str != void then
	    		var clone : LiteralString init LiteralString.new
	    		clone.~value := str.~value
	    		result := clone
	    	else if un != void then
	    		var clone : LiteralUnlimitedNatural init LiteralUnlimitedNatural.new
	    		clone.~value := un.~value
	    		result := clone
	    	else if zero != void then
	    		var clone : LiteralNull init LiteralNull.new
	    		result := clone
	    	else if inst != void then
	    		var clone : InstanceValue init InstanceValue.new
	    		clone.instance := inst.instance
	    		result := clone
	    	else
	    		raise "Incorrect non void ValueSpecification for cloning method"
	    	end end end end end end end end
	    end
	    // superclasses
	    var cl : ValueSpecification
	    cl := result
	    affectTypedElement(element, cl)
	    affectParameterableElement(element, cl)
	    // specific properties : none (excepting the ones dedicated to each subtype)
    end
    
    /** return a clone of the Comment with the same value */
    operation cloneComment(element : Comment) : Comment is do
    	var clone : Comment init Comment.new
    	affectTemplateableElement(element, clone)
    	//annotatedElement	: not cloned (must be linked by user)
    	clone.body := element.body
    	// FIXME :
//    	if element.bodyExpression != void then clone.bodyExpression := cloneExpression(element.bodyExpression) end
    	result := clone
    end
    
    /** return a clone of the Association with the same value */
    operation cloneAssociation(element : Association) : Association is do
    	var clone : Association init Association.new
    	// superclasses
    	affectClassifier(element, clone)
    	affectRelationship(element, clone)
    	// specific properties
    	clone.isDerived := element.isDerived
    	//memberEnd		: not cloned (must be linked by user)
    	element.ownedEnd.each{ e |	// ends not possessed by a Class
    		var eClone : Property init cloneProperty(e)
    		ioTable.putValue(e, eClone)
    		clone.ownedEnd.add(eClone)
    	}
    	result := clone
    end
    
    /** return a clone of the ElementImport with the same value */
    operation cloneElementImport(element : ElementImport) : ElementImport is do
    	var clone : ElementImport init ElementImport.new
    	affectDirectedRelationship(element, clone)
    	clone.~alias := element.~alias
        if element.visibility == VisibilityKind.public then
        	clone.visibility := VisibilityKind.public
        else if element.visibility == VisibilityKind.private then
        	clone.visibility := VisibilityKind.private
        else if element.visibility == VisibilityKind.protected then
        	clone.visibility := VisibilityKind.protected
        else if element.visibility == VisibilityKind.~package then
        	clone.visibility := VisibilityKind.~package
        end end end end
    	clone.importedElement := element.importedElement
    	// rem : the "importingNamespace" attribute must be fixed by its owning namespace
    	result := clone
    end
    
    operation cloneDataType(element : DataType) : DataType is do
    	var clone : DataType init DataType.new
    	affectClassifier(element, clone)
        //ownedAttribute	: not cloned (must be linked by user)
        //ownedOperation	: not cloned (must be linked by user)
    end
    
    operation cloneGeneralization(element : Generalization) : Generalization is do
    	var clone : Generalization init Generalization.new
    	affectDirectedRelationship(element, clone)
    	//general			: not cloned (must be linked by user)
    	//generalizationSet	: not cloned (must be linked by user)
    	clone.isSubstitutable := element.isSubstitutable
		//specific			: not cloned (must be linked by user)
        
        result := clone
    end
    
    operation cloneInterface(element : Interface) : Interface is do
    	var clone : Interface init Interface.new
    	affectClassifier(element, clone)
        //nestedClassifier	: not cloned (must be linked by user)
        element.ownedAttribute.each{ u |
        	var pClone : Property init cloneProperty(u)
        	ioTable.putValue(u, pClone)
        	clone.ownedAttribute.add(pClone)
        }
        element.ownedOperation.each{ u |
        	var opClone : Operation init cloneOperation(u)
        	ioTable.putValue(u, opClone)
        	clone.ownedOperation.add(opClone)
        }
        //ownedReception : TODO
    	//protocolStateMachine : not processed because outside static UML (unlike Interface elements)
    	//         Must be processed by user through the corresponding visitor (in a case of statemachine diagram visit)
        element.redefinedInterface.each{ u |
        	var ifClone : Interface init cloneInterface(u)
        	ioTable.putValue(u, ifClone)
        	clone.redefinedInterface.add(ifClone)
        }
    end
    
    ////////////////////// GENERIC AFFECTATIONS FOR ABSTRACT CLASSES ////////////////////////
    // we centralize affectations of properties inherited from abstract high level classes //
    /////////////////////////////////////////////////////////////////////////////////////////

    operation affectPackage(element : Package, clone : Package) is do 
        // superclasses
        affectNamespace(element, clone)
        affectPackageableElement(element, clone)
        //specific properties : none
    end
    
    operation affectBehavioredClassifier(element : BehavioredClassifier, clone : BehavioredClassifier) is do
    	// superclasses
    	affectClassifier(element, clone)
    	// specific properties
		//classifierBehavior	// not cloned (must be done by user)
		//implementation		// not cloned (must be done by user)
		//ownedTrigger			// not cloned (must be done by user)
		//ownedStateMachine		// not cloned (must be done by user)
    end
    
	operation affectEncapsulatedClassifier(element : EncapsulatedClassifier, clone : EncapsulatedClassifier) is do
		// superclasses
		affectStructuredClassifier(element, clone)
    	// specific properties
		//ownedPort				// not cloned (must be done by user)
	end
	
    operation affectClassifier(element : Classifier, clone : Classifier) is do
    	// superclasses
    	affectNamespace(element, clone)
    	affectType(element, clone)
    	affectRedefinableElement(element, clone)
    	// SPecific properties
    	//generalization		// not cloned (must be done by user)
    	clone.isAbstract := element.isAbstract
    	//occurrence			// not cloned (must be done by user)
    	//ownedUseCase			// not cloned (must be done by user)
    	//powertypeExtent		// not cloned (must be done by user)
    	//redefinedClassifier	// not cloned (must be done by user)
    	//representation		// not cloned (must be done by user)
    	//substitution			// not cloned (must be done by user)
    	//useCase				// not cloned (must be done by user)
    end
    
    operation affectStructuredClassifier(element : StructuredClassifier, clone : StructuredClassifier) is do
    	// superclasses
    	affectClassifier(element, clone)
    	// specific properties
    	element.ownedAttribute.each{ u |
    		var pClone : Property init cloneProperty(u)
    		ioTable.putValue(u, pClone)
    		clone.ownedAttribute.add(pClone)
    	}
    end
    
    operation affectElement(element : Element, clone : Element) is do
    		//imply 3 clones of each comment (and the link is manage through Comment.annotatedElement)
/*    	element.ownedComment.each{ c |
    		clone.ownedComment.add(cloneComment(c))
    	}	*/
    end
    
    operation affectBehavioralFeature(element : BehavioralFeature, clone : BehavioralFeature) is do
    	// superclasses
    	affectNamespace(element, clone)
    	affectFeature(element, clone)
    	// specific properties
    	clone.concurrency := element.concurrency
    	// we must complete the "operation" attribute for any Parameter (if the BehavioralFeature is an Operation)
    	var op : Operation
    	op ?= clone
        element.formalParameter.each{ u |
        	var par : Parameter init cloneParameter(u)
        	ioTable.putValue(u, par)
	        clone.formalParameter.add(par)
        	par.~operation := op
        }
        clone.isAbstract := element.isAbstract
        element.returnResult.each{ u |
        	var par : Parameter init cloneParameter(u)
        	ioTable.putValue(u, par)
	        clone.returnResult.add(par)
//        	par.~operation := op	// FIXME : it destroys the parameter in returnResult
        }
        // the raised exceptions are direct types and we don't clone referenced types
        element.raisedException.each{ u | clone.raisedException.add(u) }
    end
    
    operation affectFeature(element : Feature, clone : Feature) is do
    	// superclasses
    	affectRedefinableElement(element, clone)
    	// specific properties
    	clone.isStatic := element.isStatic
    end
    
    operation affectTemplateableElement(element : TemplateableElement, clone : TemplateableElement) is do
    	// superclasses
    	affectElement(element, clone)
    	// specific properties
    	// TODO
    end
    
    operation affectNamedElement(element : NamedElement, clone : NamedElement) is do
    	// superclasses
    	affectTemplateableElement(element, clone)
    	// specific properties
    	clone.name := element.name
        if element.visibility == VisibilityKind.public then
        	clone.visibility := VisibilityKind.public
        else if element.visibility == VisibilityKind.private then
        	clone.visibility := VisibilityKind.private
        else if element.visibility == VisibilityKind.protected then
        	clone.visibility := VisibilityKind.protected
        else if element.visibility == VisibilityKind.~package then
        	clone.visibility := VisibilityKind.~package
        end end end end
    end
    
    operation affectPackageableElement(element : PackageableElement, clone : PackageableElement) is do
    	// superclasses
    	affectNamedElement(element, clone)
    	affectParameterableElement(element, clone)
    	// specific properties
        if element.packageableElement_visibility == VisibilityKind.public then
        	clone.packageableElement_visibility := VisibilityKind.public
        else if element.packageableElement_visibility == VisibilityKind.private then
        	clone.packageableElement_visibility := VisibilityKind.private
        else if element.packageableElement_visibility == VisibilityKind.protected then
        	clone.packageableElement_visibility := VisibilityKind.protected
        else if element.packageableElement_visibility == VisibilityKind.~package then
        	clone.packageableElement_visibility := VisibilityKind.~package
        end end end end
    end
    
    operation affectTypedElement(element : TypedElement, clone : TypedElement) is do
    	// superclasses
    	affectNamedElement(element, clone)
    	// specific properties
    	var dt : DataType
    	dt ?= element.type
    	if dt != void then
    		var dtClone : DataType init cloneDataType(dt)
    		ioTable.putValue(dt, dtClone)
    		clone.type := dtClone
    	else
    		clone.type := element.type
    	end
    end
    
    operation affectRedefinableElement(element : RedefinableElement, clone : RedefinableElement) is do
    	// superclasses
    	affectNamedElement(element, clone)
    	// specific properties
    	clone.isLeaf := element.isLeaf	// NB : not a clone of the type but the original one
    end
    
    operation affectNamespace(element : Namespace, clone : Namespace) is do
    	// superclasses
    	affectNamedElement(element, clone)
    	// specific properties
    	element.elementImport.each{ ei |
    		var eiClone : ElementImport init cloneElementImport(ei)
    		ioTable.putValue(ei, eiClone)
    		clone.elementImport.add(eiClone)
    	}
    end
    
    operation affectConnectableElement(element : ConnectableElement, clone : ConnectableElement) is do
    	// superclasses
    	affectNamedElement(element, clone)
    	affectParameterableElement(element, clone)
    	// specific properties
    	///////////// FIXME : what could be the right way tp process that ?? ////////
    	// clone.~end := element.~end
    end
    
    operation affectParameterableElement(element : ParameterableElement, clone : ParameterableElement) is do
    	// superclasses
    	affectElement(element, clone)
    	// specific properties
    	// TODO
    end
    
    operation affectMultiplicityElement(element : MultiplicityElement, clone : MultiplicityElement) is do
    	// superclasses
    	affectElement(element, clone)
    	// specific properties
    	clone.isOrdered := element.isOrdered
        clone.isUnique := element.isUnique
    	if element.lowerValue != void then clone.lowerValue := cloneValueSpecification(element.lowerValue) end
    	if element.upperValue != void then clone.upperValue := cloneValueSpecification(element.upperValue) end
    end
    
    operation affectRelationship(element : Relationship, clone : Relationship) is do
    	//superclasses
    	affectElement(element, clone)
    	// specific properties : none
    end
    
    operation affectDirectedRelationship(element : DirectedRelationship, clone : DirectedRelationship) is do
    	//superclasses
    	affectRelationship(element, clone)
    	// specific properties : none
    end
    
    operation affectType(element : Type, clone : Type) is do
    	// superclasses
    	affectParameterableElement(element, clone)
    	// specific properties : none
    end
    
    operation affectStructuralFeature(element : StructuralFeature, clone : StructuralFeature) is do
    	//superclasses
    	affectFeature(element, clone)
    	affectTypedElement(element, clone)
    	affectMultiplicityElement(element, clone)
    	// specific properties
    	clone.isReadOnly := element.isReadOnly
    end
    
    operation affectDeploymentTarget(element : DeploymentTarget, clone : DeploymentTarget) is do
    	//superclasses
    	affectNamedElement(element, clone)
    	//specific properties
    	// deployment : TODO
    end
}