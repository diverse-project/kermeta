/* $Id: GOFStatePatternTool.kmt,v 1.4 2006-08-17 14:49:05 vmahe Exp $
 * Creation date: July 6, 2006
 * License:
 * Copyright:
 * Authors:
 */

package uml2::transformations;


require "StaticTools.kmt"
require "UmlCloneFactory.kmt"
require "../TopDownVisitor.kmt"

using uml2

//class GOFStatePatternTool inherits UmlTool, topdown_visitor::TopDownVisitor
class GOFStatePatternTool inherits UmlTool, topdown_visitor::TopDownVisitor
{
	reference ioTable : IOElementsTable
	reference currentContext : BehavioredClassifier
	reference currentPackage : Package
	
	/** method for applying the pattern only on one element
	  * @parameter machine : we will calculate the "class" owning the state machine
	  *     in order to give it the reified states as links (recursive composites)
	  * @parameter input : the package where the state machine is
	  *     for correspondance through the hash table
	  * @parameter outputTable : the table containing its clone
	  *     (needed as the pattern involves a visitor approach) */
	operation applyPattern(machine : StateMachine, input : Package, outputTable : IOElementsTable) is do
		// The outputTable must contain the output elements corresponding to all input package elements.
		// Output elements can be strictly the same than the input ones but the table must have been
		// filled before it is passed to the current GOF tool.
		inputRootPackage := input
		ioTable := outputTable
		currentPackage := input
		
		visitStateMachine(machine)
	end
	
    method visitPackage(visitable : Package) is do 
        // must manage the current package for each processed element
        // to be put in the corresponding package
        var previousPackage : Package init currentPackage
        currentPackage := visitable
        currentPackage := previousPackage
    end
    
    method visitStateMachine(visitable : StateMachine) : Void is do
    	// for a root state machine, the GOF State context class corresponds to the statemachine owning Class.
    	ioTable.putValue(visitable, visitable.context)
    	
		var context : Class
		context ?= visitable.context
    	context.ownedOperation.add(getRequestOperation)
    	
    	// FIXME : in this version, multiple regions are not processed
		if visitable.region.size != 1 then
			var e : kermeta::exceptions::NotImplementedException init kermeta::exceptions::NotImplementedException.new
			e.message := "GOF State Pattern tool : multiple regions are not processed"
			raise e
		end
		
		super(visitable)
		
		// region(s) has been processed since the "super" call 
		// so we can link the abstract state class to its context
		var assocTool : Association_Tool init Association_Tool.new
		var abstractState : Class
		abstractState ?= ioTable.getValue(visitable.region.one)
		currentPackage.ownedMember.add(assocTool.addNavigableAggregation(context, abstractState, "", nameForCurrentStateLink))
    end
    
    method visitRegion(visitable : Region) : Void is do 
		// states will retrieve their abstract state class through their owning region (state 'container' property)
		var abstractState : Class init Class.new
		abstractState.isAbstract := true
		
		// add the name of the abstract state class
		var context : Class
		context ?= ioTable.getValue(visitable.stateMachine)
		if context == void then context ?= ioTable.getValue(visitable.state) end
		abstractState.name := nameForIAbstractState(context.name)
		
    	// add "handle()" operation
    	abstractState.ownedOperation.add(getHandleOperation(true))
    	
		ioTable.putValue(visitable, abstractState)
		currentPackage.ownedMember.add(abstractState)
        super(visitable)
    end
    
    method visitState(visitable : State) : Void is do
    	preProcessState(visitable)
        super(visitable)
    	postProcessState(visitable)
    end
    
    method visitFinalState(visitable : FinalState) : Void is do
    	preProcessState(visitable)
        super(visitable)
    	postProcessState(visitable)
    end
    
    method visitPseudostate(visitable : Pseudostate) : Void is do 
        if visitable.kind == PseudostateKind.initial then
	    	var concreteState : Class init concreteVertex(visitable)
	    	// add it to the table and the model
	    	ioTable.putValue(visitable, concreteState)
			currentPackage.ownedMember.add(concreteState)
        else
        	// others pseudostates don't concern GOF State pattern
        end
        super(visitable)
    end
    
    //////////////// methods used both by visitors and applyPattern ////////////////
    
    operation preProcessState(visitable : State) : Void is do
    	var concreteState : Class init concreteVertex(visitable)
    	ioTable.putValue(visitable, concreteState)
		currentPackage.ownedMember.add(concreteState)
    	
    	// substate machine (if exist)
    	if visitable.region.size > 1 then
			var e : kermeta::exceptions::NotImplementedException init kermeta::exceptions::NotImplementedException.new
			e.message := "GOF State Pattern tool : multiple regions are not processed"
			raise e
		end
	end
        
    operation postProcessState(visitable : State) : Void is do
    	var concreteState : Class
    	concreteState ?= ioTable.getValue(visitable)
		// subregion(s) has been processed since the "super" call
		// so we can link the submachine abstract state class to its context
    	if visitable.region.size == 1 then
			var assocTool : Association_Tool init Association_Tool.new
			var abstractState : Class
			abstractState ?= ioTable.getValue(visitable.region.one)
			// link between the context class and its abstract state class
			// the current concreteState is one level higher than the abstractState which sees it as its CONTEXT CLASS
			currentPackage.ownedMember.add(assocTool.addNavigableAggregation(concreteState, abstractState, "", nameForCurrentStateLink))
		end
    end
    
    /**
     * process any UML2 vertex (vertices are states, pseudo and final states).
     * It is a factorization of the operation for states and pseudo states visits.
     */
    operation concreteVertex(vertex : Vertex) : Class is do
    	var concreteVertex : Class init Class.new
		
		// add the name of the abstract state class
		concreteVertex.name := nameForConcreteState(vertex.name)
		concreteVertex.isAbstract := false
    	
    	// add "handle()" operation
    	concreteVertex.ownedOperation.add(getHandleOperation(false))
    	
    	var geneTool : Generalization_Tool init Generalization_Tool.new
    	// we add a generalisation between the new concrete state and the corresponding
    	// abstract state class which is stored under the current state's region in ioTable
    	// See Umlaut-Architecture-guide for more informations on the use of IOElementsTable
    	// in the GoF State Pattern tool.
    	var abstractState : Class
    	abstractState ?= ioTable.getValue(vertex.container)
    	geneTool.addGeneralization(abstractState, concreteVertex)
    	
    	result := concreteVertex
    end
    
    operation getHandleOperation(isAbstract : kermeta::standard::Boolean) : Operation is do
    	// "handle()" operation
    	var handleOp : Operation init Operation.new
    	handleOp.name := nameForHandleMethod
    	handleOp.isAbstract := isAbstract
    	result := handleOp
    end
    
    operation getRequestOperation() : Operation is do
    	// "request()" operation
    	var requestOp : Operation init Operation.new
    	requestOp.name := nameForRequestMethod
    	requestOp.isAbstract := false
    	result := requestOp
    	
    	// code of request() op => parameterized "handle()" call :
    	//      do
    	//         state.handle()
    	//      end
    	var code : Comment init Comment.new
    	code.body := "do\n\t" + nameForCurrentStateLink + "." + nameForHandleMethod + "()\nend"
    	code.annotatedElement.add(requestOp)
    	currentPackage.ownedComment.add(code)
    end
    
    // prefixes & suffixes for (re)naming the elements
    operation prefixForAbstractState() : kermeta::standard::String is do result := "" end
    operation suffixForAbstractState() : kermeta::standard::String is do result := "_State" end
    operation nameForIAbstractState(name : kermeta::standard::String) : kermeta::standard::String is do
    	result := prefixForAbstractState + name + suffixForAbstractState
    end
    operation prefixForConcreteState() : kermeta::standard::String is do result := "ConcreteState" end
    operation suffixForConcreteState() : kermeta::standard::String is do result := "" end
    operation nameForConcreteState(name : kermeta::standard::String) : kermeta::standard::String is do
    	if name != void then
	    	result := prefixForConcreteState + name + suffixForConcreteState
    	else	// pseudo states generaly don't have name
	    	result := prefixForConcreteState + suffixForConcreteState
    	end
    end
    operation nameForCurrentStateLink() : kermeta::standard::String is do result := "state" end
    operation nameForRequestMethod() : kermeta::standard::String is do result := "request" end
    operation nameForHandleMethod() : kermeta::standard::String is do result := "handle" end
}