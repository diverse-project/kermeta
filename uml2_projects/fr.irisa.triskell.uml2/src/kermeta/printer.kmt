//@mainClass "kermeta::utils::PrettyPrinter"
//@mainmethod "visit"
/* $Id: printer.kmt,v 1.4 2006-04-26 11:36:19 vmahe Exp $
 * Project : Kermeta samples
 * File : printer.kmt
 * License : GPL
 * Copyright : IRISA / Universite de Rennes 1
 * ----------------------------------------------------------------------------
 * Creation date : Jul 04, 2005
 * Authors : 
 *  Zoe Drey 		zdrey@irisa.fr
 * 
 * Notes : 
 *   This is a Kermeta transcription of the KM2KMTPrettyPrinter written in Java
 */

package kermeta::utils;
require kermeta
using kermeta::language::structure
using kermeta::language::behavior
using kermeta::standard


/**
 * Prints in its textual representation a parsed kermeta entity.
 * self.pretty printer only visits :
 *  - package,
 *	- class,
 *  - method,
 *  - attribute.
 *  Indeed, the tags (as MOF elements attached to any MOF entity) are only handled yet
 *  for these types.
 */
class BasicPrettyPrinter inherits 
	kermeta::language::structure::KMStructureVisitor<Integer, String>,
	kermeta::language::behavior::KMExpressionVisitor<Integer, String>
{
	/** self.is a print helper */
 	attribute pp : PrintHelper
 	attribute aset : set TypeVariable[0..*]
 	attribute indent : String
 	attribute typedef : Boolean
 	attribute current_pname : String
 	/** the output of produced code, which could be a file or stdio */
 	attribute out : kermeta::io::StdIO
 	
 	operation initialize() is do
 		pp := PrintHelper.new
 		pp.initialize(self)
 		indent := ""
 		typedef := false
 		current_pname := ""
 		// default output
 		out := stdio
 	end
 	
 	operation setOutput(output : kermeta::io::StdIO) is do
 		out := output
 	end
 	 
    /**
     * visit a class and transcript it in the Kermeta Text format.
     * Doesn't realize a code line in itself, just transmits a textual complete name.
     */
    method visitClass(node : Class, context : Integer) : String is do
    	// TODO : do not print qualified name if class belongs to current package
    	result := node.typeDefinition.qualifiedName
		if (node.typeParamBinding.size > 0) then
			out.write("<" + self.visitTypeVariableBindingSet(node.typeParamBinding, context) + ">")
		end
    end
    
    method visitMultiplicityElement(node : MultiplicityElement, context : Integer) : String is do
	    result := "" 
		// Visit never go there...(handled by ppTypeFromMultiplicityElement)
    end
    
    /**
	 * Visit a property (attribute, reference, property)
	 * Generates full code lines.
	 */
	method visitOperation(node : Operation, context : Integer) : String is do
		out.write(indent)
		out.write(visitTagSet(node.tag, context))
		if (node.superOperation != void) then out.write( "method ")
		else out.write("operation ") 
		end
		// node name
		out.write( node.name)
		// type parameters of operation
		if (node.typeParameter.size() > 0) then
			out.write( "<")
			self.visitTypeVariableSet(node.typeParameter, context)
			out.write( ">")
		end
		// arguments
		out.write( "(")
		out.write( self.visitTypeParameters(node.ownedParameter, context))
		out.write( ")")
		if(node.type != void) then
//			out.write( " : " + pp.ppTypeFromMultiplicityElement(node))
			var typ : Type
			typ ?= node.type
			out.write( " : " + visitType(typ, context))
		end
	 
		if (node.superOperation != void) then
			out.write( " from " + node.superOperation.owningClass.qualifiedName )
		end
		if (node.raisedException.size > 0) then
			out.write( " raises " + self.visitTypeSet(node.raisedException, context, ", "))
		end
		if (node.body != void) then
			out.write( " is\n")
			pushIndent()
			out.write(self.accept(node.body, context))
			popIndent()
		
		else 
			if (node.isAbstract) then out.write( " is abstract")

			else 
				out.write( " is do\n")
				pushIndent()
				out.write( indent + "//TODO: implement operation " + node.name + "\n") 
				popIndent()
				out.write( indent + "end")
			end
		end
		result := ""
	end
	
	/** inserts the "kdoc" tags as comments in Kermeta code */
	method visitTag(node : Tag, context : Integer) : String is do 
	    result := ""
	    if node.name == "kdoc" then
	    	out.write(indent + "/**\n")
	    	out.write(pp.processTagCRLF(node, indent + " * "))
	    	out.write("\n" + indent + " */")
	    else if node.name == "km_body" then
	    	// must indent the code (from the tag value)
	    	out.write(pp.processTagCRLF(node, indent))
	    else
	    	out.write(indent + "@" + node.name + " \"" + node.~value + "\"")
	    end end
	end
	
	/**
	 * Visit a property (attribute, reference, property)
	 */
	method visitProperty(node : Property, context : Integer) : String is do
		result := "" // weird behavior when we directly write : result := indent???
		out.write(indent)
		if (node.isDerived) then
			out.write( "property " )
		else 
			if (node.isComposite) then 
				out.write("attribute ")
			else 
				out.write("reference ")
			end
		end
			
		if (node.isReadOnly) then out.write("readonly ")
		end
		
		// print the attribute def
		out.write(node.name + " : " + pp.ppTypeFromMultiplicityElement(node))
		
		if (node.opposite != void) then
			out.write("#" + node.opposite.name)
		end
		
		if (node.isDerived) then
			pushIndent()
			out.write("\n" + indent + "getter is " )
			if (node.getterBody != void) then
				//out.write(node.getterbody.acceptKMExpressionVisitor(self, node.getterbody))
			else
				out.write("do\n")
				pushIndent()
				out.write(indent + "//TODO: implement getter for derived property " + node.name + "\n") 
				popIndent()
				out.write(indent + "end")
			end
			
			if (not node.isReadOnly) then
				out.write("\n" + indent + "setter is ")
				if (node.getterBody != void) then 
					//out.write(node.getterbody.acceptKMExpressionVisitor(self, node.getterbody))
				else 
					out.write("do\n")
					pushIndent()
					out.write(indent + "//TODO: implement setter for derived property " + node.name + "\n")
					popIndent()
					out.write(indent + "end")
				end
			end
			popIndent()
		end
		out.write("\n")

	end
	
	method visitClassDefinition(node : ClassDefinition, context : Integer) : String from kermeta::language::structure::KMStructureVisitor is do
	    var a : String
		result := ""
		out.write(visitTagSet(node.tag, context))
		
		out.write(indent)
	    if (node.isAbstract) then 
			out.write("abstract ")
		end
	    
//		out.write("class " + node.qualifiedName)
		out.write("class " + node.name)
		var s : Set<kermeta::reflection::TypeVariable>
		var it : Iterator<kermeta::reflection::TypeVariable>
		it := 	node.typeParameter.iterator
		
		
		if (node.typeParameter.size > 0) then
			out.write("<"+self.visitTypeVariableSet(node.typeParameter, context)+">")
		end
    	
		if (node.superType.size > 0) then
			out.write(" inherits ")
			out.write(self.visitClassSet(node.superType, context, ", "))
		end
		
		// print the attributes
		out.write("\n"+self.indent+"{\n")
		self.pushIndent()
		out.write(self.visitFeatures(node.ownedAttribute, context))
		
		// print the operations
		out.write(self.visitFeatures(node.ownedOperation, context))
		self.popIndent()
		out.write("\n"+self.indent+"}\n")
	end
	
	method visitTypedElement(node : TypedElement, context : Integer) : String is do
		result := "[typed element]"
	end
	
	method visitTypeVariable(node : TypeVariable, context : Integer) : String is do
		result := pp.ppIdentifier(node.name)
	end
	
	method visitProductType(node : ProductType, context : Integer) : String is do
		result := "[" + visitTypeSet(node.type, context, ", ") + "]"
	end
	
	method visitFunctionType(node : FunctionType, context : Integer) : String is do
		result := "< " + self.accept(node.left, context) + "->" + self.accept(node.right, context)
	end
	
	/**
	 * Parent visit method for "Type" instances, it should be a more tidy visitor,
	 * with no "isInstance" tests...
	 */ 
	method visitType(node : Type, context : Integer) : String is do
		result := ""
		if (PrimitiveType.isInstance(node)) then 
			var pt : PrimitiveType
			pt ?= node
			result := self.accept(pt.instanceType, context)
		else
			if Class.isInstance(node) then
				var cl : Class
				cl ?= node
				result := cl.typeDefinition.qualifiedName
			else
				result := node.toString
			end
		end
	end
	
	method visitTypeVariableBinding(node : TypeVariableBinding, context : Integer) : String is do
		result := self.accept(node.type, context)
	end
	
	method visitPrimitiveType(node : PrimitiveType, context : Integer) : String is do
		result := "primitive type"
		if (typedef == true) then
			typedef := false
			result := "alias " + node.name + " : " + self.accept(node.instanceType, context) + ";"
			typedef := true
		else 
			result := node.getMetaClass.typeDefinition.qualifiedName
		end
	end
	
	method visitNamedElement(node : NamedElement, context : Integer) : String is do
		result := "[named element]"
	end
	
	/*method visitSelfType(node : SelfType, context : Integer) : String is do
		result := "self"
	end*/
	
	method visitPackage(node : Package, context : Integer) : String is do
		result := ""
		out.write(visitTagSet(node.tag, context))
		out.write("package " + node.qualifiedName) // TODO : the ppIdentifier of the Java KM2KMTPrettyPrinter
		out.write( indent + "{\n")
		var old_cname : String init current_pname
		var current_pname : String init node.qualifiedName
		pushIndent()
		typedef := true
		if (node.ownedTypeDefinition.size > 0) then
			out.write( self.visitExpressionSet(node.ownedTypeDefinition, context, "\n"))
		end
		if (node.nestedPackage.size > 0) then
			out.write( self.visitExpressionSet(node.nestedPackage, context, "\n"))
		end
		popIndent()
		current_pname := old_cname
		out.write( indent + "\n}\n")
		
	end
	
	method visitTypeDefinition(node : TypeDefinition, context : Integer) : String is do
		result := node.name
	end
	
	method visitVoidType(node : VoidType, context : Integer) : String is do
		result := "Void"
	end
	
	method visitDataType(node : DataType, context : Integer) : String is do
		if node.name == "String"
		  or node.name == "Integer"
		  or node.name == "Boolean"
		  or node.name == "Real"
		  or node.name == "Character"
		then
			result := node.name
		else
			result := "[DataType : the \"" + node.name + "\" type doesn't exist in Kermeta !]"
		end
	end
	
	method visitEnumeration(node : Enumeration, context : Integer) : String is do
		result := ""
		if (typedef == true) then
			typedef := false
			out.write("enumeration " + pp.ppIdentifier(node.name) + "\n")
			out.write( indent + "{\n")
			pushIndent()
			out.write( self.accept(node.ownedLiteral, context)) 
			popIndent() 
			out.write( indent + "}")
			typedef := true
		
		else 
			var qname : String init getQualifiedName(node)
			var name : String init pp.ppIdentifier(node.name)
			result := qname
		end
	end
	
	method visitEnumerationLiteral(node : EnumerationLiteral, context : Integer) : String is do
		result := ""
		result := pp.ppIdentifier(node.name) + ";"
	end
	
	method visitParameter(node : Parameter, context : Integer) : String is do
		// node name
		out.write( node.name)
    	out.write(" : " + pp.ppTypeFromMultiplicityElement(node))
		result := ""
    end
    
    
    /**
     * Helper
    */
    operation getQualifiedName(node : Object) : String is do
    	result := node.getMetaClass.typeDefinition.qualifiedName
    end

    /*
     *
     *  Here begins the inheritance of the KMExpressionVisitor methods
     *
     *
     */
     method visitTypeReference(node : kermeta::language::behavior::TypeReference, context : Integer) : String is do
    	result := pp.ppTypeFromMultiplicityElement(node)
     end
     
     method visitBlock(node : kermeta::language::behavior::Block, context : Integer) : String is do
     	result := ""
     	out.write(indent)
     	out.write("do\n")
		pushIndent()
		out.write(self.visitExpressionSet(node.statement, context, "\n"+indent))
		popIndent()
		from var it : Iterator<Rescue> init node.rescueBlock.iterator
		until it.isOff
		loop 
			var resc : Rescue
			resc := it.next
			out.write(indent + self.accept(resc, context) + "\n") 
		end
		out.write("\n" + indent + "end\n")
     end
    
	method visitAssignment(node : Assignment, context : Integer) : String is do
		var left : String init self.accept(node.target, context).toString
		var right : String init self.accept(node.~value, context).toString
		var op : String
		if (node.isCast) then op := "?" else op :=":" end
		result := left + " " + op + "= " + right
	end     

	method visitCallResult(node  : CallResult, context : Integer) : String is do
		result := "result"
	end
	
	method visitCallFeature(node : CallFeature, context : Integer) : String is do
		result := "" 
		if (node.target != void) then 
			out.write( self.accept(node.target, context))
		else
			out.write( "self")
		end
		
		out.write( "." + node.name)
		// handle the special case where there is 1 parameter, and when This
		// parameter is a lambdaPostFix
		if (node.parameters.size==1 and LambdaExpression.isInstance(node.parameters.one )) then
	   		out.write(self.visitExpressionSet(node.parameters, context, ", "))
		// the classic case : a list of parameters
		else 
			if (node.parameters.size> 0) then
				out.write( "(" + self.visitExpressionSet(node.parameters, context, ", ")+ ")")
			end 
		end
		rescue kermeta::exceptions::EmptyCollection 
			// DO nothing : this case is protected by the above condition

	end
	
	method visitCallSuperOperation(node : CallSuperOperation, context : Integer) : String is do
		result := "super("
		out.write( self.visitExpressionSet(node.parameters, context, ", "))
		out.write( ")")
	end
	
	method visitCallVariable(node : CallVariable, context : Integer) : String is do
		result := node.name
		if (node.parameters.size> 0) then
			out.write("(" + visitExpressionSet(node.parameters, context, ", ") + ")")
		end
	end

	method visitConditional(node : Conditional, context : Integer) : String is do 
		result := ""
		out.write("if " + self.accept(node.condition, context) + " then\n")
		pushIndent()
		if (node.thenBody != void) then
			out.write(self.accept(node.thenBody, context) + "\n")
		end
		popIndent()
		// TODO : this condition is not perfect : elseBody is in fact never void, even if
		// there is no ;..body in elseBody....
		if (node.elseBody != void) then
			out.write( indent + "else\n")
			pushIndent()
			out.write(self.accept(node.elseBody, context) + "\n")
			popIndent()
		end
		out.write(indent + "end")
	end
	
	method visitEmptyExpression(node : EmptyExpression, context : Integer) : String is do
		result := " "
	end
	method visitIntegerLiteral(node : IntegerLiteral, context : Integer) : String is do
		result := node.~value.toString
	end

	method visitStringLiteral(node : StringLiteral, context : Integer) : String is do
		result := "\""+node.~value+"\""
	end
	
	method visitBooleanLiteral(node : BooleanLiteral, context : Integer) : String is do
		result := node.~value.toString 
	end
	
	method visitTypeLiteral(node : TypeLiteral, context : Integer) : String is do
		result := self.accept(node.typeref, context) 
	end
	
	method visitVoidLiteral(node : VoidLiteral, context : Integer) : String is do 
		result := "void"
	end
	
	method visitLoop(node : Loop, context : Integer) : String is do
		result := "from "
		out.write( self.accept(node.initialization, context) + "\n")
		out.write( indent + "until " + self.accept(node.stopCondition, context) + "\n")
		out.write( indent +"loop\n") 
		pushIndent()
		out.write( self.accept(node.body, context))
		popIndent()
		out.write( indent +"end")
	end
	
	method visitSelfExpression(node : SelfExpression, context : Integer) : String is do 
		result := "self"
	end
	
	method visitVariableDecl(node : VariableDecl, context : Integer) : String is do 
		result := "var" + node.identifier + " : " + self.accept(node.type, context)
		
		if (node.initialization != void) then
			out.write(" init " + self.accept(node.initialization, context))
		end
	end 
	
	method visitRaise(node : Raise, context : Integer) : String is do
		result := "raise " + self.accept(node.expression, context)
	end
	
	method visitRescue(node : Rescue, context : Integer) : String is do 
		result := "rescue "
		if (node.exceptionName != void) then
			out.write( "(" + node.exceptionName + " : " + self.accept(node.exceptionType, context) + ")")
		end
		out.write("\n")
		pushIndent()
		out.write(self.visitExpressionSet(node.body, context, "\n"+indent))
		popIndent()
	end
	
	method visitJavaStaticCall(node : JavaStaticCall, context : Integer) : String is do 
		result := "extern "
		out.write(node.jclass + "." + node.jmethod + "(")
		out.write(self.visitExpressionSet( node.parameters, context, ", "))
		out.write(")")
	end
	
	method visitLambdaExpression(node : LambdaExpression, context : Integer) : String is do 
		result := "{"
		out.write(self.visitExpressionSet(node.parameters, context, ", "))
		out.write(" | ")
		pushIndent()
		out.write(self.accept(node.body, context))
		popIndent()
		out.write("}")
	end
	
	method visitLambdaParameter(node : LambdaParameter, context : Integer) : String is do
		result := node.name 
		if (node.type != void) then
			out.write(" : " + self.accept(node.type, context))
		end
    end

    /**
     * Visit a set that contains visitable elements
     * @param pset : the set to visit
     * @param context : the context attached to self.visitor
     * @param Indent : the indentation (can be an empty string)
    */
    operation visitTypeSet
    	(pset : Set<kermeta::reflection::Type>, context : Integer, sep : String) : String is do
//    	result := basicVisitSet(pset, context, ", ", "")	
    	result := ""
		from var it : Iterator<kermeta::reflection::Type> init pset.iterator
		until it.isOff
		loop
			var next : kermeta::reflection::Type init it.next
			var cnext : Type
			cnext ?= next
			// TODO : a real visit..
			out.write(cnext.toString)
//			out.write(self.accept(cnext, context))
			if (it.hasNext) then
				out.write(", ")
			end
		end
    end
 
     /**
     * Visit a set that contains visitable elements
     * @param pset : the set to visit
     * @param context : the context attached to self.visitor
     * @param Indent : the indentation (can be an empty string)
    */
    operation visitClassSet
    	(pset : Set<kermeta::reflection::Class>, context : Integer, sep : String) : String is do
//    	result := basicVisitSet(pset, context, ", ", "")	
    	result := ""
		from var it : Iterator<kermeta::reflection::Class> init pset.iterator
		until it.isOff
		loop
			var next : kermeta::reflection::Type init it.next
			var cnext : Class
			cnext ?= next
			// TODO : a real visit..
			out.write(cnext.typeDefinition.qualifiedName)
			if (it.hasNext) then
				out.write(", ")
			end
		end
    end
    
    /**
     * Visit a set of Expression.
     * (note : we could create a generic method for visiting Sets, but )
     */
     operation visitGenericSet<ConcreteType, AbstractType>
    	(typedElement : ConcreteType, pset : Set<AbstractType>, context : Integer, sep : String) : String is do
    	result := ""
		from var it : Iterator<AbstractType> init pset.iterator
		until it.isOff
		loop
			var next : AbstractType init it.next
			var cnext : ConcreteType
			//cnext ?= next
			out.write(self.accept(cnext, context))
			if (it.hasNext) then
				out.write(sep)
			end
		end
    end
    
    /**
     * Visit a set of Expression.
     * (note : we could create a generic method for visiting Sets, but )
     */
     operation visitExpressionSet<BExpression>
    	(pset : Set<BExpression>, context : Integer, sep : String) : String is do
    	result := ""
    	// FIXME : quite dirty that...
    	if (sep.equals("\n"+indent)) then out.write(indent) end
		from var it : Iterator<BExpression> init pset.iterator
		until it.isOff
		loop
			var next : BExpression init it.next
			out.write(self.accept(next, context))
			if (it.hasNext) then
				out.write(sep) 
			end
		end
    end

    
    /**
     * Visit the type parameters.
     * TODO : create a generic operation, and find a way to get the concrete implementation
     * of the element in the set that we want to pretty print
     */
    operation visitTypeParameters
    	(pset : Set<kermeta::reflection::Parameter>, context : Integer) : String is do
    	result := ""
		from var it : Iterator<kermeta::reflection::Parameter> init pset.iterator
		until it.isOff
		loop
			var inext : Parameter
			inext ?= it.next
			self.accept(inext, context)
			if (it.hasNext) then
				out.write(", ")
			end
		end
    end
 
 
     /**
     * Visit the type parameters.
     * TODO : create a generic operation, and find a way to get the concrete implementation
     * of the element in the set that we want to pretty print
     */
    operation visitTypeVariableBindingSet
    	(pset : Set<kermeta::reflection::TypeVariableBinding>, context : Integer) : String is do
    	result := ""
		from var it : Iterator<kermeta::reflection::TypeVariableBinding> init pset.iterator
		until it.isOff
		loop
			var cnext : TypeVariableBinding  
			cnext ?= it.next
			out.write(self.accept(cnext, context))
			if (it.hasNext) then
				out.write(", ")
			end
		end
    end
    
    /** Prettyprints tags -- todo : define a generic parametric method!!! */
    operation visitTagSet( tags : Set<kermeta::reflection::Tag>, context : Integer) : String is do
    	result := ""
		from var it : Iterator<kermeta::reflection::Tag> init tags.iterator
		until it.isOff
		loop
			var next : Tag
			next ?= it.next
			out.write(self.accept(next, context))
			out.write("\n"+indent)
		end
    end
    
    
    /** Pretty prints a set of TypeVariables, separated by a comma */
	operation visitTypeVariableSet(tparams : Set<kermeta::reflection::TypeVariable>, context : Integer) : String is do
		result := "" 
		from var it : Iterator<kermeta::reflection::TypeVariable> init tparams.iterator
		until it.isOff
		loop
			var next : TypeVariable 
			next ?= it.next
			out.write(next.name)
			if (it.hasNext) then
				out.write(", ")
			end
		end
	end

    
    /**
     * Visit a set that contains elements that 
     * : kermeta::language::structure::KMStructureVisitable
     */
    operation visitFeatures<T : kermeta::language::structure::KMStructureVisitable>(pset : Set<T>,	context : Integer) : String is do
    	result := ""
		from var it : Iterator<T> init pset.iterator
		until it.isOff
		loop
			var next : T init it.next
			out.write(next.acceptKMStructureVisitor(self, context ))
			
		end
    end
    
	/**
	 * Calls acceptKMExpressionVisitor oR acceptKMStructureVisitor according to the 
	 * type of parsed node
	 */
    operation accept(node : Object, context : Integer) : String is do
    	// structurevisitable node
		var snode : KMStructureVisitable init void
		var enode : KMExpressionVisitable init void
		
		var node_qname : String init node.getMetaClass.typeDefinition.qualifiedName
		var node_name : String init node.getMetaClass.typeDefinition.name
		var diff_size : Integer init node_qname.size - node_name.size
		//stdio.writeln(node_name+"->"+node_qname)
		// FIXME : ok until isInstance "works"
		if (node_qname.substring(0, diff_size).equals("kermeta::language::behavior::")) then
			enode ?= node
			result := enode.acceptKMExpressionVisitor(self, context)
		else 
			if (node_qname.substring(0, diff_size).equals("kermeta::language::structure::")) then
				snode := node
				result:= snode.acceptKMStructureVisitor(self, context)
			else
				// we only have visitors for kermeta::language features so others
				// elements found in the .km files need specific process
				//
				// the default result is the name of the element (it applies well to
				// features like "String", "Integer", ....
				stdio.writeln("DEBUG : no accept() for feature out of kermeta::language -> "+node_qname)
				result := node_name
			end
		end
		
//		if (node_name.
  // isInstance does not work yet
/*		if (claz.isInstance(node)) then

			enode ?= node
			enode.acceptKMExpressionVisitor(self, context)
		else
			snode := node
			snode.acceptKMStructureVisitor(self, context)
		end
*/		
    end
    

    operation pushIndent() is do
    	self.indent.append("    ")
    end
    
    operation popIndent() is do
    	if (indent != void and indent.size>0) then
	    	indent := indent.substring(0, indent.size-4)
	    end
    end
    
    
}

/**
 * Provides a set of methods that help the pretty printer.
 * Greatly inspired from KM2KMTPrettyPrinter : 
 * TODO : add all the equivalent methods of KM2KMTPrettyPrinter would be great!
 */
class PrintHelper 
{

	/** The current package name */ 
	attribute current_pname : String
	reference pprinter : BasicPrettyPrinter
	
	operation initialize(p : BasicPrettyPrinter) is do
		pprinter := p
	end
	
	operation ppTypeName(qname : String, name : String) : String is do
		result := ""
		if (qname.equals(current_pname + "::" + name)) then
			 result := result + name
		
		else
			result := name
		end
	end
	
	/** FIXME : impletment this correctly */
	operation ppIdentifier(name : String) : String is do
		result := name
	end
	
	operation ppTypeFromMultiplicityElement(elem : kermeta::reflection::MultiplicityElement) : String is do
	 
		result := ""
		if (elem.upper != 1) then
			if (elem.isOrdered) then
				if (not elem.isUnique) then result.append("seq ") end
			
			else 
				if (elem.isUnique) then result.append("set ")
				else result.append("bag ") end
			end
		end
		
		// need to cast into concrete type
		var ctype : Type
		ctype ?= elem.type

		if not ctype.isVoid then
			result.append( pprinter.visitType(ctype, 0))
		else
			result.append("void")
		end
		
		if (elem.lower != 0 or elem.upper  != 1) then
			result.append( "[" + elem.lower.toString + "..")
			if (elem.upper<0) then result.append("*") else result.append(elem.upper.toString) end
			result.append( "]")
		end
	
	end
    
	/** manages the carriage return inside comments */
	operation processTagCRLF(node : Tag, lineBegin : String) : String is do 
	    result := ""
	    var str : String init node.~value
	    var line : String init ""
	    from var dim : Integer init str.size
	    until dim == 0
	    loop
	    	if str.indexOf("\n") != -1 then
			    line := str.substring(0, str.indexOf("\n")+1)
			    result.append(lineBegin + line)
			    str := str.substring(str.indexOf("\n")+1, str.size)
		    	dim := str.size
		    else
		    	// no other CRLF so we send the rest of the comment
		    	result.append(lineBegin + str)
		    	dim := 0
		    end
		end
	end
}

