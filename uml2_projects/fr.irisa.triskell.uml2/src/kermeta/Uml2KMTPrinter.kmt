package uml2;


require kermeta
require "printer.kmt"

using kermeta::language::structure
using kermeta::language::behavior
using kermeta::standard

class Uml2KMTPrinter inherits kermeta::utils::BasicPrettyPrinter
{
	
    /**
	 * Overwriting of the operation visit from the KM2KMT PrettyPrinter,
	 * because we only have the text of the operation body, in a "body" tag.
	 */
/*	method visitOperation(node : kermeta::language::structure::Operation, context : Integer) : String is do
		result := ""
		out.write(visitTagSet(node.tag, context))
		if (node.superOperation != void) then out.write(indent + "method ")
		else out.write(indent + "operation ") 
		end
		// node name
		out.write(node.name)
		
		// type parameters of operation
		if (node.typeParameter.size() > 0) then
			out.write( "<")
			out.write( self.visitTypeVariableSet(node.typeParameter, context))
			out.write( ">")
		end
		// arguments
		out.write( "(")
		out.write( self.visitTypeParameters(node.ownedParameter, context))
		out.write( ")")
		if(node.type != void) then
			out.write( " : " + pp.ppTypeFromMultiplicityElement(node))
		end
	 
		if (node.superOperation != void) then
			out.write( " from " + node.superOperation.owningClass.qualifiedName )
		end
		if (node.raisedException.size > 0) then
			out.write( " raises " + self.visitTypeSet(node.raisedException, context, ", "))
		end
		
		if node.tag.size > 0 then
			out.write( " is\n")
			var body : String
			from var it : Iterator<kermeta::reflection::Tag> init node.tag.iterator
			until it.isOff
			loop
				var next : Tag
				next ?= it.next
				// the body of each operation has been stored in a "km_body" tag
	    		if next.name == "km_body" then
	    			pushIndent()
					out.write(self.visitTag(next, context))
					popIndent()
				end
			end
		else 
			if (node.isAbstract) then
				out.write( " is abstract\n")
			else 
				out.write( " is\n")
				pushIndent()
				out.write( indent + "do\n")
					pushIndent()
					out.write( indent + "//TODO: implement operation " + node.name + "\n") 
					popIndent()
				out.write( indent + "end\n")
				popIndent()
			end
		end
	end		*/
	
	/** we need to rewrite this method to avoid operation body to be processed here */
/*    method visitTagSet( tags : kermeta::standard::Set<kermeta::reflection::Tag>, context : Integer) : String is do
    	result := ""
		from var it : Iterator<kermeta::reflection::Tag> init tags.iterator
		until it.isOff
		loop
			var next : Tag
			next ?= it.next
			// the body of each operation has been stored in a "km_body" tag
			// which is processed inside the "visitOperation" method
    		if next.name != "km_body" then
				out.write(self.accept(next, context))
				out.write("\n")
			end
		end
    end		*/

	/**
	 * needed because in Kermeta language the main package syntax differs from subpackages
	 */
	operation visitRootPackage(node : kermeta::language::structure::Package,
	  externs : OrderedSet<kermeta::language::structure::Package>,
	  context : Integer) : String is do
	  
		result := ""
		out.write(visitTagSet(node.tag, context))
		
		out.write("package " + node.qualifiedName + ";\n\n")
		
		out.write("require kermeta\n")
		// manage references to external diagrams
		externs.each{ p |
			// the kermeta corresponding code is supposed to be
			// in the same directory (suggest : a "kermeta" subdir) !!
			out.write("require " + p.name + ".kmt\n")
		}
		
		out.write("\nusing kermeta::standard\n\n")
		
		var old_cname : String init current_pname
		var current_pname : String init node.qualifiedName
//		pushIndent()
		typedef := true
		if (node.ownedTypeDefinition.size > 0) then
			out.write( self.visitExpressionSet(node.ownedTypeDefinition, context, "\n"))
		end
		if (node.nestedPackage.size > 0) then
			out.write( self.visitExpressionSet(node.nestedPackage, context, "\n"))
		end
//		popIndent()
		current_pname := old_cname
		out.write("\n")
	end
}