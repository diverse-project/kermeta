package uml2kmt_visitors;

require kermeta
require "Uml2.kmt"
require "TopDownVisitor.kmt"
require "KmBuilder.kmt"

using kermeta::standard
using kermeta::language::structure
using km_builder

class Pass1_Uml2KMTVisitor inherits topdown_visitor::TopDownVisitor
{
    attribute output : kermeta::utils::Hashtable<uml2::Element, Object>
    attribute build : KmBuilder
    
    operation initialize(outputKm : kermeta::utils::Hashtable<uml2::Element, Object>) is do
    	output := outputKm
    	build := KmBuilder.new
    end
    
    method visitComment(visitable : uml2::Comment) is do
    	// it is a UML2 comment, which becomes a tag in transition structure
    	// Operations' comments may become their bodies in final Kermeta code
    	
    	// Note : may be we should subclassify the Comment UML object,
    	// as it must not add semantics to its annotated elements
    	// (see UML2 Superstructure  - 1.2 Kernel - the Root Diagram)
    	
    	var tag : Tag init build.createTag()
   		tag.name := "kdoc"
		if visitable.annotatedElement.size > 0 then
			visitable.annotatedElement.each{ e |
				// only operation comments which start with "do" and finish with "end"
				// are taken as Kermeta code for the operation body
				if e.getMetaClass.equals(uml2::Operation)
					and visitable.body.substring(0,2).equals("do")
					and visitable.body.substring(visitable.body.size - 3,visitable.body.size).equals("end") then
	    				tag.name := "km_body"
    			end
    		}
    	end
    	tag.~value := visitable.body
    	output.put(visitable, tag)
    	super(visitable)
    end
    
    method visitClass(visitable : uml2::Class) is do
    	// a Uml2 class is a "ClassDefinition" in Kermeta
    	// (the Kermeta "Class" is only for typing purposes)
    	var cl : ClassDefinition
    	cl := build.createClassDefinition()
    	cl.name := visitable.name
    	output.put(visitable, cl)
    	cl.isAbstract := visitable.isAbstract
    	
    	super(visitable)
    end
    
    /* visit Attributes, Properties, ... */
    method visitProperty(visitable : uml2::Property) is do
    	// the Uml2 attributes, properties and associations' ends all become "Property" in Kermeta
    	var prop : Property init build.createProperty()
    	prop.name := visitable.name
    	prop.isDerived := visitable.isDerived
    	prop.isReadOnly := visitable.isReadOnly
    	prop.isOrdered := visitable.isOrdered
    	prop.isUnique := visitable.isUnique
    	prop.lower := lowerValue(visitable.lowerValue)
    	prop.upper := upperValue(visitable.upperValue)
    	
		// needed by PrettyPrinter
//    	prop.default := visitable.default	// derived value
//    	prop.isComposite := visitable.isComposite	// derived value
		prop.isComposite := false	// FIXME : manage this value in a correct way
		
    	// we need to manage the Type class of the attributes,
    	// in case of external package reference
//    	if visitable.association.isVoid then visitable.type.accept(self) end
    	visitable.type.accept(self)
    	
    	output.put(visitable, prop)
    	super(visitable)
    end
    
    method visitOperation(visitable : uml2::Operation) is do
    	// a Uml2 operation is also an operation in Kermeta
    	var op : Operation init build.createOperation()
    	op.name := visitable.name
    	op.isAbstract := visitable.isAbstract
    	output.put(visitable, op)
    	
    	op.isOrdered := visitable.isOrdered
    	op.isUnique := visitable.isUnique
    	op.lower := lowerValue(visitable.lowerValue)
    	op.upper := upperValue(visitable.upperValue)
    	
    	super(visitable)
    end
    
    method visitParameter(visitable : uml2::Parameter) is do
    	// Uml2 has 4 types of operation parameters : "In", "In Out", 'Out" and "Return"
    	// but Kermeta distinguishes only passed parameters and return type for operations
		var par : Parameter
		par := build.createParameter()
		par.name := visitable.name
		output.put(visitable, par)
    	
    	par.isOrdered := visitable.isOrdered
    	par.isUnique := visitable.isUnique
    	par.lower := lowerValue(visitable.lowerValue)
    	par.upper := upperValue(visitable.upperValue)
    	
		// need to visit its Type
		visitable.type.accept(self)
    	
    	super(visitable)
    end
    
    method visitPackage(visitable : uml2::Package) is do
    	// a Uml2 package is also a package in Kermeta
    	var pack : Package init build.createPackage()
    	pack.name := visitable.name
    	output.put(visitable, pack)
    	super(visitable)
    end
    
    method visitDataType(visitable : uml2::DataType) is do
    	// detects and manages Kermeta primitive types
    	var o : Object

    	if visitable.name == "String"
    	  or visitable.name == "Integer"
    	  or visitable.name == "Character"
    	  or visitable.name == "Boolean"
//    	  or visitable.name == "Real"	// FIXME : not yet implemented in Kermeta
    	then
    		if visitable.name == "String"
    		then
    			var s : String init ""
    			o := s.getMetaClass
    			output.put(visitable, o)
    		end
    		if visitable.name == "Integer"
    		then
    			var i : Integer init 1
    			o := i.getMetaClass
    			output.put(visitable, o)
    		end
    		if visitable.name == "Character"
    		then
    			var c : Character
    			c := "c".elementAt(0)
    			o := c.getMetaClass
    			output.put(visitable, o)
    		end
    		if visitable.name == "Boolean"
    		then
    			var b : Boolean init true
    			o := b.getMetaClass
    			output.put(visitable, o)
    		end
//    		if visitable.name == "Real"
//    		then
//    			var r : Real init '3.14'
//    			o := r.getMetaClass
//   			output.put(visitable, o)
//    		end
    	else
	    	// DataType are defined thru ClassDefinition in Kermeta
	    	var dt : DataType
	    	dt := build.createDataType()
	    	dt.name := visitable.name
	    	output.put(visitable, dt)
    	end
    	
    	super(visitable)
    end
    
    method visitGeneralization(visitable : uml2::Generalization) is do
    	// the Uml2 generalization instance corresponds to a typing "Class" in Kermeta
    	var cl : Class init build.createClass()
    	output.put(visitable, cl)
     	
    	// we need to manage the general's relations,
    	// in case of external package reference
    	visitable.general.accept(self)
    	
    	super(visitable)
    end
    
    method visitAssociation(visitable : uml2::Association) is do
    	// it is the most complex transformation to manage
    	// because the structure of representations differs
    	// from UML2 to Kermeta depending on the association cases
    	// 
    	// TODO
    	super(visitable)
    end
    
    /**
     * method for extract integer value from UML2 ValueSpecification objects
     */
    operation lowerValue(valueSpec : uml2::ValueSpecification) : Integer is do
    	// if not defined, the lowerBound must be at least equal or greater than zero
    	// (see UML2 Superstructure  - 1.4 Kernel - the Multiplicities Diagram)
    	result := 0
    	var int : uml2::LiteralInteger
    	int ?= valueSpec
    	if int != void then
    		result := int.~value
    	end
    end
    
    /**
     * method for extract integer value from UML2 ValueSpecification objects
     */
    operation upperValue(valueSpec : uml2::ValueSpecification) : Integer is do
    	// if not defined, the upperBound must be at least greater than zero
    	// (see UML2 Superstructure  - 1.4 Kernel - the Multiplicities Diagram)
    	result := 1
    	var int : uml2::LiteralInteger
    	int ?= valueSpec
    	if int != void then
    		result := int.~value
    	end
    end
}