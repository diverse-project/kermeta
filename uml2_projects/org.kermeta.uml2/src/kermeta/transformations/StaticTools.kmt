/* $Id: StaticTools.kmt,v 1.1 2007-12-13 10:34:40 vmahe Exp $
 * Creation date: July 3, 2006
 * License:
 * Copyright:
 * Authors:
 */

package uml::transformations;

require "UmlTool.kmt"

using uml 

/** Class dedicated to add a generalization between 2 classifiers */
class Generalization_Tool
{
    operation addGeneralization(ancestor : Classifier, heir : Classifier) : Void is do 
        var gene : Generalization init Generalization.new
        gene.general := ancestor
        gene.specific := heir
        // NB : Generalization is not a packageableElement
        // so we don't have to add it to the heir package
    end
}

/** Class dedicated to extract a interface from a classifier */
class Interface_Tool
{
    operation addInterfaceRealization(interface : Interface, concrete : Class) : Void is do
    	// dedect existing realization (for general interfacing on a collection of classes)
    	// in order to avoid double realizations
    	if concrete.interfaceRealization.select{ ir |
	        ir.contract == interface and
	        ir.implementingClassifier == concrete
	   	}.size == 0 then
     	
	        var realization : InterfaceRealization init InterfaceRealization.new
	        realization.contract := interface
	        realization.implementingClassifier := concrete
//	        concrete.interfaceRealization.add(realization)	// added by opposite
	
			// will feed derivate properties of InterfaceRealization type
	        realization.supplier.add(interface)
	        realization.client.add(concrete)
	        
	        // remove from concrete attributes which exist in interface
	        cleanAttributesFromInterface(concrete, interface)
	        
	        // the concrete class must implement interface operations
	        implementOperations(concrete, interface)
        
        end
    end
	/** given a concrete class, this method generates the corresponding Interface */
    operation extractInterface(concrete : Class) : Interface is do
        var ifce : Interface init Interface.new
        
        // rename the elements
        var name : kermeta::standard::String init concrete.name
        concrete.name := nameForImplementation(name)
        ifce.name := nameForInterface(name)
        ifce.visibility := concrete.visibility
        
        // link the concrete class with the interface
        addInterfaceRealization(ifce, concrete)
        
        // put the attributes in the interface ...
        concrete.ownedAttribute.each{ u |
        	ifce.ownedAttribute.add(u)
        }
        // ... and erase them from concrete class
        cleanAttributesFromInterface(concrete, ifce)
        
        // the operations of the concrete class became those of interface
        var factory : UmlCloneFactory init UmlCloneFactory.new
        factory.initialize
        concrete.ownedOperation.each{ u |
	    	var op : Operation init Operation.new
	    	op := factory.cloneOperation(u)
	    	op.isAbstract := true
	    	ifce.ownedOperation.add(op)
	    	if u.isAbstract then
	    		u.isAbstract := false
	    	end
        }
        result := ifce
    end
    
	/** given a class, this method transform it in an abstract class
	 * and generates the corresponding concrete class */
    operation concreteFromAbstract(classToAbstract : Class) : Class is do
        var factory : UmlCloneFactory init UmlCloneFactory.new
        factory.initialize
        
        var concrete : Class init factory.cloneClass(classToAbstract)
        
        // rename the elements
        var name : kermeta::standard::String init classToAbstract.name
        concrete.name := nameForNewConcrete(name)
        classToAbstract.name := nameForAbstract(name)
        concrete.visibility := classToAbstract.visibility
        
        // add generalisation
        var gt : Generalization_Tool init Generalization_Tool.new
        gt.addGeneralization(classToAbstract, concrete)
        
        // as all the attributes are in the abstract class ...
        // ... we must erase them from concrete class (clone)
        clearAttributes(concrete)
        
        // the class to abstract must now be abstract
         classToAbstract.isAbstract := true
        // the operations of the abstract class must be abstract
        classToAbstract.ownedOperation.each{ u |
	    	u.isAbstract := true
	    }
        // the concrete class must be concrete
        concrete.isAbstract := false
        // the operations of the concrete class must be concrete
        concrete.ownedOperation.each{ u |
	    	u.isAbstract := false
        }
        result := concrete
    end
    
    /** compare a concrete class to its interface and remove duplicate attributes */
    operation cleanAttributesFromInterface(concrete : Class, interface : Interface) is do
		interface.ownedAttribute.each{ a |
			var tmp : Property
			tmp := concrete.ownedAttribute.select{ attr | attr.name == a.name}.one
			concrete.ownedAttribute.remove(tmp)
		}
	end
    
	operation implementOperations(concrete : Class, interface : Interface) is do
		var compare : Compare_Tool init Compare_Tool.new
		
		interface.ownedOperation.each{ o |
			if concrete.ownedOperation.select{ op | 
				compare.isEqualOperation(op, o)
			}.size == 0 then
				// the operation presented in interface does not exist in concrete class
		        var factory : UmlCloneFactory init UmlCloneFactory.new
		        factory.initialize
		        concrete.ownedOperation.add(factory.cloneOperation(o))
	        
			end
		}
	end
    
    // prefixes & suffixes for (re)naming the elements
    
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForInterface() : kermeta::standard::String is do result := "I" end
    
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForInterface() : kermeta::standard::String is do result := "" end
    
	/** overwrite this method to change resulting name of the accessor */
    operation nameForInterface(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForInterface + tool.upperFirstChar(name) + suffixForInterface
    end
    
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForImplementation() : kermeta::standard::String is do result := "" end
    
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForImplementation() : kermeta::standard::String is do result := "" end
    
	/** overwrite this method to change resulting name of the accessor */
    operation nameForImplementation(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForImplementation + tool.upperFirstChar(name) + suffixForImplementation
    end
	
    /** this operation authorize the Valooder to erase attributes only after a specific work on them */
    operation clearAttributes(concrete : Class) is do
    	concrete.ownedAttribute.clear
    end
    
    // prefixes & suffixes for (re)naming the elements
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForAbstract() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForAbstract() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForAbstract(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForAbstract + tool.upperFirstChar(name) + suffixForAbstract
    end
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForNewConcrete() : kermeta::standard::String is do result := "concrete" end
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForNewConcrete() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForNewConcrete(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForNewConcrete + tool.upperFirstChar(name) + suffixForNewConcrete
    end
}

/** Class dedicated to add get & set operations for each attibute of a class */
class Accessor_Tool
{
	/** for each attribute of the class,
	 * add corresponding accessors to the class */
	operation addGettersSetters(cl : Class) is do
		cl.ownedAttribute.each{ u |
			addGetterSetter(cl, u)
		}
	end
	
	/** transform each public attribute of the class in a private one,
	 * adding corresponding accessors to the class */
	operation addPublicGettersSetters(cl : Class) is do
		cl.ownedAttribute.each{ u |
			if u.visibility == VisibilityKind.public then
				addGetterSetter(cl, u)
				u.visibility := VisibilityKind.private
			end
		}
	end
	
	/** take a class and one of ITS attributes and
	 * add the corresponding accessors to the class */
	operation addGetterSetter(cl : Class, prop : Property) is do
		cl.ownedOperation.add(createGetter(prop))
		cl.ownedOperation.add(createSetter(prop))
	end
	
	/** take a class and one of ITS attributes and
	 * add the corresponding Getter to the class */
	operation addGetter(cl : Class, prop : Property) is do
		cl.ownedOperation.add(createGetter(prop))
	end
	
	/** take a class and one of ITS attributes and
	 * add the corresponding Setter to the class */
	operation addSetter(cl : Class, prop : Property) is do
		cl.ownedOperation.add(createSetter(prop))
	end
	
	///////// utilities (builders) /////////////
	/** private builder - don't use it directly */
	operation createGetter(attr : Property) : Operation is do
		var op : Operation init Operation.new
		op.name := nameForGetter(attr.name)
		op.visibility := VisibilityKind.public
		var returnPar : Parameter init Parameter.new
//		returnPar.name := nameForReturn(attr.name)
		returnPar.type := attr.type
		returnPar.direction := ParameterDirectionKind.return
		op.ownedParameter.add(returnPar)
		op.isAbstract := false
		
		// reading the upper value of the multiplicity
		var lun : LiteralUnlimitedNatural
		lun ?=attr.upperValue
		var li : LiteralInteger
		li ?=attr.upperValue
		var multVal : kermeta::standard::Integer init 1
		if lun != void then multVal := lun.~value
		else
			if li != void then
				multVal := li.~value
			end
		end
		// defined code for result of the getter operation
		var code : Comment init Comment.new
		code.body := "do\n"
		if multVal == 0 or multVal == 1 then
			code.body.append("\tresult := "+attr.name+"\n")
		else	// multiple items for 'attr'
			var inPar : Parameter init Parameter.new
			inPar.name := nameForMultipleGetterInput(attr.name)
			var in : Class init Class.new
			in.name := "Integer"
			inPar.type := in
			inPar.direction := ParameterDirectionKind.in
			op.ownedParameter.add(inPar)
			
			code.body.append("\tresult := "+attr.name+ "("+nameForMultipleGetterInput(attr.name)+")\n")
		end
		code.body.append("end")
		// we don't know the package which will contain the class of the operation
		// so we must put the code comment into the operation
//		code.annotatedElement.add(op)
		op.ownedComment.add(code)
		
		result := op
	end
	/** private builder - don't use it directly */
	operation createSetter(attr : Property) : Operation is do
		var op : Operation init Operation.new
		op.visibility := VisibilityKind.public
		op.isAbstract := false
		var inPar : Parameter init Parameter.new
		inPar.type := attr.type
		inPar.direction := ParameterDirectionKind.in
		inPar.name := nameForSetterInput(attr.name)
		op.ownedParameter.add(inPar)
		
		// reading the upper value of the multiplicity
		var lun : LiteralUnlimitedNatural
		lun ?=attr.upperValue
		var li : LiteralInteger
		li ?=attr.upperValue
		var multVal : kermeta::standard::Integer init 1
		if lun != void then multVal := lun.~value
		else
			if li != void then
				multVal := li.~value
			end
		end
		
		// defined code for affectation to the setter operation
		var code : Comment init Comment.new
		code.body := "do\n"
		if multVal == 0 or multVal == 1 then
			op.name := nameForSetter(attr.name)
			code.body.append("\t"+attr.name + " := " + nameForSetterInput(attr.name)+"\n")
		else
			op.name := nameForSetterOnMultiple(attr.name)
			code.body.append("\t"+attr.name + ".add(" + nameForInputOnMultiple(attr.name) + ")\n")
		end
		code.body.append("end")
		// we don't know the package which will contain the class of the operation
		// so we must put the code comment into the operation
//		code.annotatedElement.add(op)
		op.ownedComment.add(code)
		
		result := op
	end
    // prefixes & suffixes for (re)naming the elements
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForGetter() : kermeta::standard::String is do result := "get_" end
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForGetter() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForGetter(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForGetter + tool.upperFirstChar(name) + suffixForGetter
    end
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForReturn() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForReturn() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForReturn(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForReturn + tool.upperFirstChar(name) + suffixForReturn
    end
	/** overwrite this method to change resulting name of the accessor */
//    operation prefixForMultipleGetterInput() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
//    operation suffixForMultipleGetterInput() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForMultipleGetterInput(name : kermeta::standard::String) : kermeta::standard::String is do
    	result := "order"
    end
    
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForSetter() : kermeta::standard::String is do result := "set_" end
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForSetter() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForSetter(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForSetter + tool.upperFirstChar(name) + suffixForSetter
    end
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForSetterInput() : kermeta::standard::String is do result := "new_" end
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForSetterInput() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForSetterInput(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForSetterInput + tool.upperFirstChar(name) + suffixForSetterInput
    end
    
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForSetterOnMultiple() : kermeta::standard::String is do result := "add_" end
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForSetterOnMultiple() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForSetterOnMultiple(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForSetterOnMultiple + tool.upperFirstChar(name) + suffixForSetterOnMultiple
    end
	/** overwrite this method to change resulting name of the accessor */
    operation prefixForInputOnMultiple() : kermeta::standard::String is do result := "new_" end
	/** overwrite this method to change resulting name of the accessor */
    operation suffixForInputOnMultiple() : kermeta::standard::String is do result := "" end
	/** overwrite this method to change resulting name of the accessor */
    operation nameForInputOnMultiple(name : kermeta::standard::String) : kermeta::standard::String is do
    	var tool : Tools init Tools.new
    	result := prefixForInputOnMultiple + tool.upperFirstChar(name) + suffixForInputOnMultiple
    end
}

/** Class dedicated to add some associations between 2 classes */
class Association_Tool
{
	////////////////// non navigable links ///////////////////
	
    operation addSimpleAssociation(firstClass : Classifier,
		                           secondClass : Classifier,
		                           associationName : kermeta::standard::String,
		                           firstEndName : kermeta::standard::String,
		                           secondEndName : kermeta::standard::String) : Association is do 
        var assoc : Association init Association.new
        
        /// TODO
        raise kermeta::exceptions::NotImplementedException
        
        result := assoc
    end
    operation addSimpleComposition(container : Classifier,
		                           component : Classifier,
		                           associationName : kermeta::standard::String,
		                           componentEndName : kermeta::standard::String) : Association is do 
        var assoc : Association init addSimpleAssociation(container, component, associationName, "", componentEndName)
        
        /// TODO
        raise kermeta::exceptions::NotImplementedException
        
        result := assoc
    end
    operation addSimpleAggregation(container : Class,
		                           component : Classifier,
		                           associationName : kermeta::standard::String,
		                           componentEndName : kermeta::standard::String) : Association is do 
        var assoc : Association init addSimpleAssociation(container, component, associationName, "", componentEndName)
        
        /// TODO
        raise kermeta::exceptions::NotImplementedException
        
        result := assoc
    end
    
	////////////////// one side navigable links ///////////////////
	
    operation addOneSideNavigableAssociation(owningClass : Class,
		                           navigatedClass : Classifier,
		                           associationName : kermeta::standard::String,
		                           ownerEndName : kermeta::standard::String,
		                           navigableEndName : kermeta::standard::String) : Association is do 
        var assoc : Association init Association.new
        assoc.name := associationName
        
        // the navigable side of the association is given to the owning class
        var classEnd : Property init Property.new
        classEnd.name := navigableEndName
        classEnd.type := navigatedClass
        owningClass.ownedAttribute.add(classEnd)
        assoc.memberEnd.add(classEnd)
        
        // the non navigable side of the association is for the association
        var assocEnd : Property init Property.new
        assocEnd.name := ownerEndName
        assocEnd.type := owningClass
        assoc.memberEnd.add(assocEnd)
        assoc.ownedEnd.add(assocEnd)
        
        result := assoc
    end
    operation addNavigableComposition(container : Class,
    	                           component : Classifier,
		                           associationName : kermeta::standard::String,
    	                           compositionName : kermeta::standard::String) : Association is do 
        var assoc : Association init addOneSideNavigableAssociation(container, component, associationName, "", compositionName)
        
        // the navigable end of the association must be a composite one
        var prop : Property init container.ownedAttribute.select{ u | u.name == compositionName }.one
        prop.aggregation := AggregationKind.composite
        
        result := assoc
    end
    operation addNavigableAggregation(container : Class,
    	                           component : Classifier,
		                           associationName : kermeta::standard::String,
    	                           compositionName : kermeta::standard::String) : Association is do 
        var assoc : Association init addOneSideNavigableAssociation(container, component, associationName, "", compositionName)
        
        // the navigable end of the association must be a aggregative one
        var prop : Property init container.ownedAttribute.select{ u | u.name == compositionName }.one
        prop.aggregation := AggregationKind.shared
        
        result := assoc
    end
    
	////////////////// two side navigable links ///////////////////
	// TODO
}

class Compare_Tool
{
	operation isEqualOperation(op1 : Operation, op2 : Operation) : kermeta::standard::Boolean is do
		result := true
		//compare names
		if op1.name != op2.name then
			result := false
		else
			// compare parameters
			op1.ownedParameter.each{ p1 |
				if op2.ownedParameter.select{ p2 |
					p2.name == p1.name
						and p2.type == p1.type
						and p2.direction == p1.direction
				}.size == 0 then result := false end
			}
			op2.ownedParameter.each{ p2 |
				if op1.ownedParameter.select{ p1 |
					p1.name == p2.name
						and p1.type == p2.type
						and p1.direction == p2.direction
				}.size == 0 then result := false end
			}
		end
	end 
}

class Tools
{
	reference tableUp : kermeta::utils::Hashtable<kermeta::standard::String,kermeta::standard::String>
	reference tableLow : kermeta::utils::Hashtable<kermeta::standard::String,kermeta::standard::String>
	operation initialize() is do
		tableUp := kermeta::utils::Hashtable<kermeta::standard::String,kermeta::standard::String>.new
		tableUp.put("a", "A")
		tableUp.put("b", "B")
		tableUp.put("c", "C")
		tableUp.put("d", "D")
		tableUp.put("e", "E")
		tableUp.put("f", "F")
		tableUp.put("g", "G")
		tableUp.put("h", "H")
		tableUp.put("i", "I")
		tableUp.put("j", "J")
		tableUp.put("k", "K")
		tableUp.put("l", "L")
		tableUp.put("m", "M")
		tableUp.put("n", "N")
		tableUp.put("o", "O")
		tableUp.put("p", "P")
		tableUp.put("q", "Q")
		tableUp.put("r", "R")
		tableUp.put("s", "S")
		tableUp.put("t", "T")
		tableUp.put("u", "U")
		tableUp.put("v", "V")
		tableUp.put("w", "W")
		tableUp.put("x", "X")
		tableUp.put("y", "Y")
		tableUp.put("z", "Z")
		tableLow := kermeta::utils::Hashtable<kermeta::standard::String,kermeta::standard::String>.new
		tableLow.put("A", "a")
		tableLow.put("B", "b")
		tableLow.put("C", "c")
		tableLow.put("D", "d")
		tableLow.put("F", "f")
		tableLow.put("G", "g")
		tableLow.put("H", "h")
		tableLow.put("I", "i")
		tableLow.put("J", "j")
		tableLow.put("K", "k")
		tableLow.put("L", "l")
		tableLow.put("M", "m")
		tableLow.put("N", "n")
		tableLow.put("O", "o")
		tableLow.put("P", "p")
		tableLow.put("Q", "q")
		tableLow.put("R", "r")
		tableLow.put("S", "s")
		tableLow.put("T", "t")
		tableLow.put("U", "u")
		tableLow.put("V", "v")
		tableLow.put("W", "w")
		tableLow.put("X", "x")
		tableLow.put("Y", "y")
		tableLow.put("Z", "z")
	end
	operation upperFirstChar(name : kermeta::standard::String) : kermeta::standard::String is do
		self.initialize
		result := upperChar(name.substring(0,1)) + name.substring(1,name.size)
	end
	operation upperChar(char : kermeta::standard::String) : kermeta::standard::String is do
		var upperizedChar : kermeta::standard::String init tableUp.getValue(char)
		if upperizedChar != void then
			result := upperizedChar
		else
			result := char
		end
	end
	operation lowerFirstChar(name : kermeta::standard::String) : kermeta::standard::String is do
		self.initialize
		result := lowerChar(name.substring(0,1)) + name.substring(1,name.size)
	end
	operation lowerChar(char : kermeta::standard::String) : kermeta::standard::String is do
		var lowerizedChar : kermeta::standard::String init tableLow.getValue(char)
		if lowerizedChar != void then
			result := lowerizedChar
		else
			result := char
		end
	end
}