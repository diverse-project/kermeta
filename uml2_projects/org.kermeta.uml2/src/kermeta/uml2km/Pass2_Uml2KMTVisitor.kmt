package uml2kmt_visitors;

require kermeta
require "../visitableUML.kmt"
require "KmBuilder.kmt"

using kermeta::standard
using kermeta::interpreter
using kermeta::language::structure
using km_builder

class Pass2_Uml2KMTVisitor inherits uml::visitors::TopDownVisitor
{
    reference output : kermeta::utils::Hashtable<uml::Element, Object>
    reference rootPackage : Package
    reference resourceObjects : Set<Object>
    
    operation initialize(outputKm : kermeta::utils::Hashtable<uml::Element, Object>) is do
    	output := outputKm
    	rootPackage := void
    	resourceObjects := Set<Object>.new
    end
    
	// the second pass knows the package which represents the root of the kermeta code
    operation codeRoot() : Package is do
    	result := rootPackage
    end
    
    method visitComment(visitable : uml::Comment) is do
    	// the comments need only to rely to their owner
    	var tag : Tag 
		tag ?= output.getValue(visitable)
		if visitable.annotatedElement.size > 0 then
			visitable.annotatedElement.each{ e |
				var obj : Object init output.getValue(e)
				tag.object.add(obj)
			}
		else
			// the comment concerns the Model
			tag.object.add(rootPackage)
		end
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		if tag.name != "km_body" then
			resourceObjects.add(tag)
		else
			// except for the body of operations, parsed in Pass3
			output.remove(visitable)
		end
		
    	super(visitable)
    end
    
    method visitClass(visitable : uml::Class) is do
    	// UML2 Class is a ClassDefinition in Kermeta
    	var cldef : ClassDefinition
    	cldef ?= output.getValue(visitable)
    	
    	// links all class' operations
    	visitable.ownedOperation.each{ o |
    		var op : Operation
    		op ?= output.getValue(o)
    		cldef.ownedOperation.add(op)
    		
	   		// manage the inherited properties and operations (if redefined in specific class)
	   		op.superOperation := superInheritedOperation(op.name, visitable.generalization)
	   		op.superOperation := superImplementedOperation(op.name, visitable.interfaceRealization)
    	}
    	
    	// links all class' attributes
    	visitable.ownedAttribute.each{ att |
    		var prop : Property
    		prop ?= output.getValue(att)
			cldef.ownedAttribute.add(prop)
    	}
    	
    	super(visitable)
    end
    
    /* visit Attributes, Properties, ... */
    method visitProperty(visitable : uml::Property) is do
    	// we need to manage the Type class of the property,
    	// in case of external package reference
//    	visitable.type.accept(self)
    	
    	var prop : Property
    	prop ?= output.getValue(visitable)
    	
    	var type : Object
    	type := output.getValue(visitable.type)
		if ClassDefinition.isInstance(type) then
		   	var cl : Class init Class.new
	    	var cdef : ClassDefinition
	    	cdef ?= type
	    	cl.typeDefinition := cdef
			prop.type := cl
		else
			var t : Type
			t ?= type
			prop.type := t
		end
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		resourceObjects.add(prop.type)
    	
    	super(visitable)
    end
    
    method visitOperation(visitable : uml::Operation) is do
    	// completes the operation
    	var op : Operation
    	op ?= output.getValue(visitable)
    	
		visitable.ownedParameter.each{e | 
	    	// the return type if exists
			if e.direction == uml::ParameterDirectionKind.return then
			
		    	var type : Object
//		    	type := output.getValue(visitable.type)
		    	type := output.getValue(e.type)	// in UML 2.1, operation type is derived
				if ClassDefinition.isInstance(type) then
				   	var cl : Class init Class.new
			    	var cdef : ClassDefinition
			    	cdef ?= output.getValue(e.type)
			    	cl.typeDefinition := cdef
					op.type := cl
				else
					var t : Type
					t ?= type
					op.type := t
				end
				// as Class/DataType/Tag are not linked thru composition
				// we must add them in the resulting KM resource
				resourceObjects.add(op.type)
				
			else    	// all other parameters
			
				var par : Parameter
				par ?= output.getValue(e)
				op.ownedParameter.add(par)
				
			end
		}
    	
    	super(visitable)
    end
    
    method visitParameter(visitable : uml::Parameter) is do
    	// associates the type of parameter to the ClassDefinition of this type
    	var p : Parameter
    	p ?= output.getValue(visitable)
    	var type : Object
    	type := output.getValue(visitable.type)
		if ClassDefinition.isInstance(type) then
	    	var cl : Class init Class.new
	    	cl.typeDefinition ?= type
	    	p.type := cl
	    else
			p.type ?= type
    	end
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		resourceObjects.add(p.type)
	    	
    	super(visitable)
    end
    
    method visitPackage(visitable : uml::Package) is do
    	var p : Package
    	p ?= output.getValue(visitable)
    	
    	// the first package to be processed is the root package
    	// (the visitPackage operation is the entry point for a model)
    	if rootPackage == void then rootPackage := p end
    	
    	// attach the elements which belong to a package
    	visitable.packagedElement.each{ e |
	    		
	stdio.writeln("DEBUG - Pass2_UML2KM.visitPackage() - Package : "+p.name+" - packagedElement : "+e.name)
	    		
    		var o : Object init output.getValue(e)
	    	var obj : TypeDefinition
	    	obj ?= o
	    	if obj != void
	    	then
	    		/* we don't reference DataTypes in the package
	    		  (used for typing parameters and properties) */
	    		var dt : DataType
	    		dt ?= obj
	    		if dt.isVoid()
	    		then
	    			p.ownedTypeDefinition.add(obj)
	    		end
	    	else
	    		// manage nested packages
	    		var nestedP : Package
	    		nestedP ?= o
	    		if nestedP != void
	    		then
	    			p.nestedPackage.add(nestedP)
	    		else
	    		end
			end
    	}
    	
    	super(visitable)
    end
    
    method visitDataType(visitable : uml::DataType) is do
    	super(visitable)
    end
    
    method visitGeneralization(visitable : uml::Generalization) is do
    	// we must add the "general" type to the "source" object
    	var gen : ClassDefinition
    	gen ?= output.getValue(visitable.general)
    	
   		var spec : ClassDefinition
   		spec ?= output.getValue(visitable.specific)
   		
   		var cl : Class init Class.new
   		cl.typeDefinition := gen
   		if not spec.superType.exists{ k | k.oid == cl.oid }
   		then
	   		spec.superType.add(cl)
   		end
   		
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		resourceObjects.add(cl)
   		
     	super(visitable)
    end
    
    method visitInterfaceRealization(visitable : uml::InterfaceRealization) is do
    	// we must add the "general" type to the "source" object
    	var gen : ClassDefinition
    	gen ?= output.getValue(visitable.contract)
   		var spec : ClassDefinition
   		spec ?= output.getValue(visitable.implementingClassifier)
   		var cl : Class init Class.new
   		cl.typeDefinition := gen
   		if not spec.superType.exists{ k | k.oid == cl.oid }
   		then
	   		spec.superType.add(cl)
   		end
		// as Class/DataType/Tag are not linked thru composition
		// we must add them in the resulting KM resource
		resourceObjects.add(cl)
   		
     	super(visitable)
    end
    
    method visitAssociation(visitable : uml::Association) is do
    	/* the structure of representations differs
    	 * from UML2 to Kermeta depending on the association cases
    	 *
    	 * We only have two main cases in Kermeta
    	 *  - 1 diamond-ed end => containance relation thru "attribute" keyword
    	 *    This case is managed in Pass1.visitProperty().
    	 *  - others cases (including white diamonds) => "reference" keyword
    	 *    Nothing to do (will be ordinary properties)
    	 * 
    	 * Navigation thru the association demand a "Navigable" tag in UML2
    	 * and named association's ends in Kermeta, so we need them both
    	 * Rem : the 2 ends must be navigable to be concerned by Kermeta "Opposite"
    	 * (note than Pass1 has disqualified associations with more than 2 members)
    	 */
    	if visitable.ownedEnd.size == 0  then
    		var it : Iterator<uml::Property> init visitable.memberEnd.iterator
    		// get the first end
			var end1 : uml::Property init it.next
			var p1 : Property
			p1 ?= output.getValue(end1)
    		// get the second end
			var end2 : uml::Property init it.next
			var p2 : Property
			p2 ?= output.getValue(end2)
    		// link the opposites
    		p1.opposite := p2
    		p2.opposite := p1
    	end
    	
    	// UML2 and Kermeta store in inverted places the "composite" property
		var it : Iterator<uml::Property> init visitable.memberEnd.iterator
		// get the first end
		var end1 : uml::Property init it.next
		var p1 : Property
		p1 ?= output.getValue(end1)
		// get the second end
		var end2 : uml::Property init it.next
		var p2 : Property
		p2 ?= output.getValue(end2)
		
		// link the opposites
		var b : Boolean init p2.isComposite
		p2.isComposite := p1.isComposite
		p1.isComposite := b
    	
    	super(visitable)
    end
    
	method visitInterface(visitable : uml::Interface) is do
		// Interface doesn(t exists as concept in Kermeta
		// so interfaces must be processed as Uml2 abstract classes
		
    	// UML2 Interface is a ClassDefinition in Kermeta
    	var cldef : ClassDefinition
    	cldef ?= output.getValue(visitable)
    	
    	// links all class' operations
    	visitable.ownedOperation.each{ o |
    		var op : Operation
    		op ?= output.getValue(o)
    		cldef.ownedOperation.add(op)
    	}
    	
    	// links all class' attributes
    	visitable.ownedAttribute.each{ att |
    		var prop : Property
    		prop ?= output.getValue(att)
			cldef.ownedAttribute.add(prop)
    	}
		
    	super(visitable)
	end
	
	/**
	 * recursive method to obtain the nearest super Operation,
	 * for a given operation name, if it exists in the given generalization
	 */
	 operation superInheritedOperation(name : String, genSet : Set<uml::Generalization>) : Operation is do
	 	result := void
	 	
   		// Take note that a method redefined deeper than one level of inheritance
   		// would not be processed, as UML2 doesn't give any recursive access to superclasses,
   		// so Kermeta interpreter will raise a error on it
   		genSet.each{ gen |
	   		var superClass : uml::Class
	   		superClass ?= gen.general
   			superClass.ownedOperation.each{ supOp |
   				if supOp.name == name then
   					// inherited operation
   					var genOp : Operation
   					result ?=output.getValue(supOp)
   				end
   			}
   			// recursive exploration of super super classes
   			if result.isVoid then
   				result := superInheritedOperation(name, superClass.generalization)
   			end
   		}
	 end
	/**
	 * recursive method to obtain the nearest super Operation,
	 * for a given operation name, if it exists in the given generalization
	 */
	 operation superImplementedOperation(name : String, genSet : Set<uml::InterfaceRealization>) : Operation is do
	 	result := void
	 	
   		// Take note that a method redefined deeper than one level of inheritance
   		// would not be processed, as UML2 doesn't give any recursive access to superclasses,
   		// so Kermeta interpreter will raise a error on it
   		genSet.each{ gen |
	   		var superClass : uml::Interface
	   		superClass := gen.contract
   			superClass.ownedOperation.each{ supOp |
   				if supOp.name == name then
   					// inherited operation
   					var genOp : Operation
   					result ?=output.getValue(supOp)
   				end
   			}
   			// recursive exploration of super interfaces
   			if result.isVoid then
   				result := superInheritedOperation(name, superClass.generalization)
   			end
   		}
	 end
}