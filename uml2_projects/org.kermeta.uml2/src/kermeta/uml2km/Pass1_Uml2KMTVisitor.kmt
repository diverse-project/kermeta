package uml2kmt_visitors;

require kermeta
require "../visitableUML.kmt"
require "../keyword_list.kmt"
require "KmBuilder.kmt"

using kermeta::standard
using kermeta::language::structure
using km_builder

class Pass1_Uml2KMTVisitor inherits uml::visitors::TopDownVisitor
{
    attribute output : kermeta::utils::Hashtable<uml::Element, Object>
    attribute build : KmBuilder
    attribute kwList : kermeta::language::KeyWordList
    
    operation initialize(outputKm : kermeta::utils::Hashtable<uml::Element, Object>) is do
    	output := outputKm
    	build := KmBuilder.new
    	kwList := kermeta::language::KeyWordList.new
    	kwList.initialize
    end
    
    method visitComment(visitable : uml::Comment) is do
    	// it is a UML2 comment, which becomes a tag in transition structure
    	// Operations' comments may become their bodies in final Kermeta code
    	
    	// Note : may be we should subclassify the Comment UML object,
    	// as it must not add semantics to its annotated elements
    	// (see UML2 Superstructure  - 1.2 Kernel - the Root Diagram)
    	var tag : Tag init build.createTag()
   		tag.name := "kdoc"
		if visitable.annotatedElement.size > 0 then 
			visitable.annotatedElement.each{ e |
/*				// only operation comments which start with "do" and finish with "end"
				// are taken as Kermeta code for the operation body
				if e.getMetaClass.equals(uml::Operation)
					and visitable.body.substring(0,2).equals("do")
					and visitable.body.substring(visitable.body.size - 3,visitable.body.size).equals("end") then
	    				tag.name := "km_body"
    			end	*/
				// only operation comments which start with '@language "kermeta"'
				// are taken as Kermeta code for the operation body
				if e.getMetaClass.equals(uml::Operation)
					and visitable.body.substring(0,19).equals("@language \"kermeta\"") then
	    				tag.name := "km_body"
    			end
    		}
    	end
    	tag.~value := visitable.body
    	output.put(visitable, tag)
    	
    	super(visitable)
    end
    
    method visitClass(visitable : uml::Class) is do
		
		// we need to brake infinite recursivity thru Type
		var o : Object init output.getValue(visitable)
		if o.isVoid
		then
	    	// a Uml2 class is a "ClassDefinition" in Kermeta
	    	// (the Kermeta "Class" is only for typing purposes)
	    	var cldef : ClassDefinition
	    	cldef := build.createClassDefinition()
	    	cldef.name := validName(visitable.name)
	    	output.put(visitable, cldef)
	    	cldef.isAbstract := visitable.isAbstract
	    	
	    	super(visitable)
    	end
    end
    
    /* visit Attributes, Properties, ... */
    method visitProperty(visitable : uml::Property) is do
    	// tests UML2 model correctness
    	if visitable.type.isVoid then
    		raise "Uml2Kmt - PASS1 : " + "the property \""+visitable.name+"\" of the class \""
    			+ visitable.~class.name+"\" must be typed !"
    	end
    	
    	// the Uml2 attributes, properties and associations' ends all become "Property" in Kermeta
    	var prop : Property init build.createProperty()
    	prop.name := validName(visitable.name)
    	prop.isDerived := visitable.isDerived
    	prop.isReadOnly := visitable.isReadOnly
    	prop.isOrdered := visitable.isOrdered
    	prop.isUnique := visitable.isUnique
    	prop.lower := lowerValue(visitable.lowerValue)
    	prop.upper := upperValue(visitable.upperValue)
    	
		// needed by PrettyPrinter
		prop.isComposite := (visitable.aggregation == uml::AggregationKind.composite)
		
    	output.put(visitable, prop)
    	super(visitable) 
    end
    
    method visitOperation(visitable : uml::Operation) is do
    	// a Uml2 operation is also an operation in Kermeta
    	var op : Operation init build.createOperation()
    	op.name := validName(visitable.name)
    	op.isAbstract := visitable.isAbstract
    	output.put(visitable, op)
    	
    	// not compatible with UML 2.1 Operation (abstract methods & derived attributes)
//    	op.isOrdered := visitable.op_isOrdered
//    	op.isUnique := visitable.op_isUnique
    	op.lower := 1	// enforced because we are not able to know them in UML 2.1
    	op.upper := 1
    	
    	super(visitable)
    end
    
    method visitParameter(visitable : uml::Parameter) is do
    	// tests UML2 model correctness
    	if visitable.type.isVoid then
			raise "Uml2Kmt - PASS1 : an operation have a parameter \""+visitable.name+"\" which must be typed !"
    	end
    	
    	// Uml2 has 4 types of operation parameters : "In", "In Out", 'Out" and "Return"
    	// but Kermeta distinguishes only passed parameters and return type for operations
		var par : Parameter
		par := build.createParameter()
		par.name := visitable.name
		output.put(visitable, par)
    	
    	par.isOrdered := visitable.isOrdered
    	par.isUnique := visitable.isUnique
    	par.lower := lowerValue(visitable.lowerValue)
		par.upper := upperValue(visitable.upperValue)
	    	
    	super(visitable)
    end
    
    method visitPackage(visitable : uml::Package) is do
    	// a Uml2 package is also a package in Kermeta
    	var pack : Package init build.createPackage()
    	pack.name := validName(visitable.name)
    	output.put(visitable, pack)
    	super(visitable)
    end
    
    method visitDataType(visitable : uml::DataType) is do
    	// detects and manages Kermeta primitive types
    	var o : Object

    	if visitable.name == "String"
    	  or visitable.name == "Integer"
    	  or visitable.name == "Character"
    	  or visitable.name == "Boolean"
//    	  or visitable.name == "Real"	// FIXME : not yet implemented in Kermeta
    	then
    		if visitable.name == "String"
    		then
    			var s : String init ""
    			o := s.getMetaClass
    			output.put(visitable, o)
    		end
    		if visitable.name == "Integer"
    		then
    			var i : Integer init 1
    			o := i.getMetaClass
    			output.put(visitable, o)
    		end
    		if visitable.name == "Character"
    		then
    			var c : Character
    			c := "c".elementAt(0)
    			o := c.getMetaClass
    			output.put(visitable, o)
    		end
    		if visitable.name == "Boolean"
    		then
    			var b : Boolean init true
    			o := b.getMetaClass
    			output.put(visitable, o)
    		end
//    		if visitable.name == "Real"
//    		then
//    			var r : Real init '3.14'
//    			o := r.getMetaClass
//   			output.put(visitable, o)
//    		end
    	else
//	    	// DataType are defined thru ClassDefinition in Kermeta
//	    	var dt : DataType
//	    	dt := build.createDataType()
//	    	dt.name := validName(visitable.name)
//
//stdio.writeln("DEBUG - Pass1_Uml2KMTVisitor - createDataType() - type = "+ dt.name)
//
//	    	output.put(visitable, dt)
    	end
    	
    	super(visitable)
    end
    
    method visitGeneralization(visitable : uml::Generalization) is do
    	// the Uml2 generalization instance corresponds to a typing "Class" in Kermeta
    	// The Pass2 generates all it needs. Nothing to do in Pass1
    	
    	super(visitable)
    end
    
    method visitAssociation(visitable : uml::Association) is do
    	// no object to build as Kermeta links directly classes
    	
    	// FIXME : how to manage associations between more than 2 classes
    	if visitable.ownedEnd.size > 2 then
    		var msg : String
    		msg := "Uml2Kmt - PASS1 : " + "the association \""+visitable.name+"\" have more than 2 ends !\n"
    		visitable.memberEnd.each{ u | 
    			msg.append("   - Class : "+u.name+"\n")
    		}
    		raise msg
    	end
    	
    	super(visitable)
    end
    
	method visitInterface(visitable : uml::Interface) is do
		// Interface doesn(t exists as concept in Kermeta
		// so interfaces must be processed as Uml2 abstract classes
		
    	// a Uml2 interface is a "ClassDefinition" in Kermeta
    	// (the Kermeta "Class" is only for typing purposes)
    	var cl : ClassDefinition
    	cl := build.createClassDefinition()
    	cl.name := validName(visitable.name)
    	output.put(visitable, cl)
    	cl.isAbstract := true
		
    	super(visitable)
	end
	    
    /**
     * method for extract integer value from UML2 ValueSpecification objects
     */
    operation lowerValue(valueSpec : uml::ValueSpecification) : Integer is do
    	// if not defined, the lowerBound must be at least equal or greater than zero
    	// (see UML2 Superstructure  - 1.4 Kernel - the Multiplicities Diagram)
    	result := 0
    	var int : uml::LiteralInteger
    	int ?= valueSpec
    	if int != void then
    		result := int.~value
    	end
    end
    
    /**
     * method for extract integer value from UML2 ValueSpecification objects
     */
    operation upperValue(valueSpec : uml::ValueSpecification) : Integer is do
    	// if not defined, the upperBound must be at least greater than zero
    	// (see UML2 Superstructure  - 1.4 Kernel - the Multiplicities Diagram)
    	result := 1
    	var uint : uml::LiteralUnlimitedNatural
    	uint ?= valueSpec
    	if uint != void then
    		result := uint.~value
    	end
    end
    
    /**
     * method which avoid use of Kermeta key words
     */
    operation validName(name : String) : String is do
    	result := ""
    	if name != void then
	    	if kwList.isKeyword(name) then
	    		result.append("~" +name)
	    	else
	    		result.append(name)
	    	end
    	end
    end
}