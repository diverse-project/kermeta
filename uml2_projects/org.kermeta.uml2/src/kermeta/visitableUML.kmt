@uri "http://www.eclipse.org/uml2/2.1.0/UML"
package uml;


require "http://www.eclipse.org/emf/2002/Ecore"

alias Integer : kermeta::standard::Integer;
alias Boolean : kermeta::standard::Boolean;
alias String : kermeta::standard::String;
alias UnlimitedNatural : kermeta::standard::Integer;

class Comment inherits Element
{
	/**Specifies a string that is the comment.*/
	attribute body : String

	/**References the Element(s) being commented.*/
	reference annotatedElement : set Element[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitComment(self)
		end

}
abstract class Element inherits ecore::EModelElement
{
	/**The Elements owned by this element.*/
	property ownedElement : set Element[0..*]#owner
		getter is do
			//TODO: implement getter for derived property ownedElement
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The Element that owns this element.*/
	property owner : Element#ownedElement
		getter is do
			//TODO: implement getter for derived property owner
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property owner
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The Comments owned by this element.*/
	attribute ownedComment : set Comment[0..*]

	/**An element may not directly or indirectly own itself.
not self.allOwnedElements()->includes(self)*/
	operation not_own_self(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Elements that must be owned must have an owner.
self.mustBeOwned() implies owner->notEmpty()*/
	operation has_owner(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Destroys this element by removing all cross references to/from it and removing it from its containing resource or object.*/
	operation destroy() : Void[1..1] is
		abstract

	/**Determines whether this element has the specified keyword.*/
	operation hasKeyword(keyword : String[1..1]) : Boolean[1..1] is
		abstract

	/**Retrieves the keywords for this element.*/
	operation getKeywords() : set String[0..*] is
		abstract

	/**Adds the specified keyword to this element.*/
	operation addKeyword(keyword : String[1..1]) : Boolean[1..1] is
		abstract

	/**Removes the specified keyword from this element.*/
	operation removeKeyword(keyword : String[1..1]) : Boolean[1..1] is
		abstract

	/**Retrieves the nearest package that owns (either directly or indirectly) this element, or the element itself (if it is a package).*/
	operation getNearestPackage() : Package is
		abstract

	/**Retrieves the model that owns (either directly or indirectly) this element.*/
	operation getModel() : Model is
		abstract

	/**Determines whether the specified stereotype is applicable to this element.*/
	operation isStereotypeApplicable(stereotype : Stereotype[1..1]) : Boolean[1..1] is
		abstract

	/**Determines whether the specified stereotype is required for this element.*/
	operation isStereotypeRequired(stereotype : Stereotype[1..1]) : Boolean[1..1] is
		abstract

	/**Determines whether the specified stereotype is applied to this element.*/
	operation isStereotypeApplied(stereotype : Stereotype[1..1]) : Boolean[1..1] is
		abstract

	/**Applies the specified stereotype to this element.*/
	operation applyStereotype(stereotype : Stereotype[1..1]) : ecore::EObject[1..1] is
		abstract

	/**Unapplies the specified stereotype from this element.*/
	operation unapplyStereotype(stereotype : Stereotype[1..1]) : ecore::EObject[1..1] is
		abstract

	/**Retrieves the stereotypes that are applicable to this element, including those that are required and/or may already be applied.*/
	operation getApplicableStereotypes() : set Stereotype[0..*] is
		abstract

	/**Retrieves the stereotype with the specified qualified name that is applicable to this element, or null if no such stereotype is applicable.*/
	operation getApplicableStereotype(qualifiedName : String[1..1]) : Stereotype is
		abstract

	/**Retrieves the stereotype applications for this element.*/
	operation getStereotypeApplications() : set ecore::EObject[0..*] is
		abstract

	/**Retrieves the application of the specified stereotype for this element, or null if no such stereotype application exists.*/
	operation getStereotypeApplication(stereotype : Stereotype[1..1]) : ecore::EObject is
		abstract

	/**Retrieves the stereotypes that are required for this element.*/
	operation getRequiredStereotypes() : set Stereotype[0..*] is
		abstract

	/**Retrieves the stereotype with the specified qualified name that is required for this element, or null if no such stereotype is required.*/
	operation getRequiredStereotype(qualifiedName : String[1..1]) : Stereotype is
		abstract

	/**Retrieves the stereotypes that are applied to this element.*/
	operation getAppliedStereotypes() : set Stereotype[0..*] is
		abstract

	/**Retrieves the stereotype with the specified qualified name that is applied to this element, or null if no such stereotype is  applied.*/
	operation getAppliedStereotype(qualifiedName : String[1..1]) : Stereotype is
		abstract

	/**Retrieves the substereotypes of the specified stereotype that are applied to this element.*/
	operation getAppliedSubstereotypes(stereotype : Stereotype[1..1]) : set Stereotype[0..*] is
		abstract

	/**Retrieves the substereotype of the specified stereotype with the specified qualified name that is applied to this element, or null if no such stereotype is applied.*/
	operation getAppliedSubstereotype(stereotype : Stereotype[1..1], qualifiedName : String[1..1]) : Stereotype is
		abstract

	/**Determines whether this element has a (non-default) value for the property with the specified name in the specified stereotype.*/
	operation hasValue(stereotype : Stereotype[1..1], propertyName : String[1..1]) : Boolean[1..1] is
		abstract

	/**Retrieves the value of the property with the specified name in the specified stereotype for this element.*/
	operation getValue(stereotype : Stereotype[1..1], propertyName : String[1..1]) : ecore::EJavaObject is
		abstract

	/**Sets the value of the property with the specified name in the specified stereotype for this element.*/
	operation setValue(stereotype : Stereotype[1..1], propertyName : String[1..1], newValue : ecore::EJavaObject[1..1]) : Void[1..1] is
		abstract

	/**Creates an annotation with the specified source and this element as its model element.*/
	operation createEAnnotation(source : String[1..1]) : ecore::EAnnotation[1..1] is
		abstract

	/**Retrieves the relationships in which this element is involved.*/
	operation getRelationships() : set Relationship[0..*] is
		abstract

	/**Retrieves the relationships of the specified type in which this element is involved.*/
	operation op_getRelationships(eClass : ecore::EClass[1..1]) : set Relationship[0..*] is
		abstract

	/**Retrieves the directed relationships for which this element is a source.*/
	operation getSourceDirectedRelationships() : set DirectedRelationship[0..*] is
		abstract

	/**Retrieves the directed relationships of the specified type for which this element is a source.*/
	operation op_getSourceDirectedRelationships(eClass : ecore::EClass[1..1]) : set DirectedRelationship[0..*] is
		abstract

	/**Retrieves the directed relationships for which this element is a target.*/
	operation getTargetDirectedRelationships() : set DirectedRelationship[0..*] is
		abstract

	/**Retrieves the directed relationships of the specified type for which this element is a target.*/
	operation op_getTargetDirectedRelationships(eClass : ecore::EClass[1..1]) : set DirectedRelationship[0..*] is
		abstract

	/**The query allOwnedElements() gives all of the direct and indirect owned elements of an element.
result = ownedElement->union(ownedElement->collect(e | e.allOwnedElements()))*/
	operation allOwnedElements() : set Element[0..*] is
		abstract

	/**The query mustBeOwned() indicates whether elements of this type must have an owner. Subclasses of Element that do not require an owner must override this operation.
result = true*/
	operation mustBeOwned() : Boolean[1..1] is
		abstract

	operation accept(visitor : visitors::Visitor) : Void is
		do
			result := visitor.visitElement(self)
		end

}
class Package inherits Namespace, PackageableElement, TemplateableElement
{
	/**References the packaged elements that are Types.*/
	property ownedType : set Type[0..*]#~package
		getter is do
			//TODO: implement getter for derived property ownedType
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the PackageMerges that are owned by this Package.*/
	attribute packageMerge : set PackageMerge[0..*]#receivingPackage

	/**Specifies the packageable elements that are owned by this Package.*/
	attribute packagedElement : set PackageableElement[0..*]

	/**References the packaged elements that are Packages.*/
	property nestedPackage : set Package[0..*]#nestingPackage
		getter is do
			//TODO: implement getter for derived property nestedPackage
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the Package that owns this Package.*/
	property nestingPackage : Package#nestedPackage
		getter is do
			//TODO: implement getter for derived property nestingPackage
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property nestingPackage
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the ProfileApplications that indicate which profiles have been applied to the Package.*/
	attribute profileApplication : set ProfileApplication[0..*]#applyingPackage

	/**If an element that is owned by a package has visibility, it is public or private.
self.ownedElements->forAll(e | e.visibility->notEmpty() implies e.visbility = #public or e.visibility = #private)*/
	operation elements_public_or_private(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Creates a(n) (abstract) class with the specified name as an owned type of this package.*/
	operation createOwnedClass(name : String[1..1], isAbstract : Boolean[1..1]) : Class[1..1] is
		abstract

	/**Creates a enumeration with the specified name as an owned type of this package.*/
	operation createOwnedEnumeration(name : String[1..1]) : Enumeration[1..1] is
		abstract

	/**Creates a primitive type with the specified name as an owned type of this package.*/
	operation createOwnedPrimitiveType(name : String[1..1]) : PrimitiveType[1..1] is
		abstract

	/**Creates an interface with the specified name as an owned type of this package.*/
	operation createOwnedInterface(name : String[1..1]) : Interface[1..1] is
		abstract

	/**Determines whether the specified profile is applied to this package.*/
	operation isProfileApplied(profile : Profile[1..1]) : Boolean[1..1] is
		abstract

	/**Applies the current definition of the specified profile to this package and automatically applies required stereotypes in the profile to elements within this package's namespace hieararchy. If a different definition is already applied, automatically migrates any associated stereotype values on a "best effort" basis (matching classifiers and structural features by name).*/
	operation applyProfile(profile : Profile[1..1]) : set ecore::EObject[0..*] is
		abstract

	/**Unapplies the specified profile from this package and automatically unapplies stereotypes in the profile from elements within this package's namespace hieararchy.*/
	operation unapplyProfile(profile : Profile[1..1]) : set ecore::EObject[0..*] is
		abstract

	/**Retrieves the profiles that are applied to this package.*/
	operation getAppliedProfiles() : set Profile[0..*] is
		abstract

	/**Retrieves all the profiles that are applied to this package, including profiles applied to its nesting package(s).*/
	operation getAllAppliedProfiles() : set Profile[0..*] is
		abstract

	/**Retrieves the profile with the specified qualified name that is applied to this package, or null if no such profile is applied.*/
	operation getAppliedProfile(qualifiedName : String[1..1]) : Profile is
		abstract

	/**Retrieves the profile with the specified qualified name that is applied to this package or any of its nesting packages (if indicated), or null if no such profile is applied.*/
	operation op_getAppliedProfile(qualifiedName : String[1..1], recurse : Boolean[1..1]) : Profile is
		abstract

	/**Retrieves all the profile applications for this package, including profile applications for its nesting package(s).*/
	operation getAllProfileApplications() : set ProfileApplication[0..*] is
		abstract

	/**Retrieves the application of the specified profile to this package, or null if no such profile is applied.*/
	operation getProfileApplication(profile : Profile[1..1]) : ProfileApplication is
		abstract

	/**Retrieves the application of the specified profile to this package or any of its nesting packages (if indicated), or null if no such profile is applied.*/
	operation op_getProfileApplication(profile : Profile[1..1], recurse : Boolean[1..1]) : ProfileApplication is
		abstract

	/**Determines whether this package is a model library.*/
	operation isModelLibrary() : Boolean[1..1] is
		abstract

	/**The query visibleMembers() defines which members of a Package can be accessed outside it.
result = member->select( m | self.makesVisible(m))*/
	operation visibleMembers() : set PackageableElement[0..*] is
		abstract

	/**The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no visibility and elements with public visibility are made visible.
self.member->includes(el)
result = (ownedMember->includes(el)) or
(elementImport->select(ei|ei.importedElement = #public)->collect(ei|ei.importedElement)->includes(el)) or
(packageImport->select(pi|pi.visibility = #public)->collect(pi|pi.importedPackage.member->includes(el))->notEmpty())*/
	operation makesVisible(el : NamedElement[1..1]) : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Namespace is
		do
			result := visitor.visitPackage(self)
		end

}
abstract class PackageableElement inherits NamedElement, ParameterableElement
{
	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitPackageableElement(self)
		end

}
abstract class NamedElement inherits Element
{
	/**The name of the NamedElement.*/
	attribute name : String

	/**Determines where the NamedElement appears within different Namespaces within the overall model, and its accessibility.*/
	attribute visibility : VisibilityKind

	/**A name which allows the NamedElement to be identified within a hierarchy of nested Namespaces. It is constructed from the names of the containing namespaces starting at the root of the hierarchy and ending with the name of the NamedElement itself.*/
	property qualifiedName : String
		getter is do
			//TODO: implement getter for derived property qualifiedName
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property qualifiedName
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Indicates the dependencies that reference the client.*/
	reference clientDependency : set Dependency[0..*]#client

	/**Specifies the namespace that owns the NamedElement.*/
	property namespace : Namespace#ownedMember
		getter is do
			//TODO: implement getter for derived property namespace
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property namespace
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The string expression used to define the name of this named element.*/
	attribute nameExpression : StringExpression

	/**If there is no name, or one of the containing namespaces has no name, there is no qualified name.
(self.name->isEmpty() or self.allNamespaces()->select(ns | ns.name->isEmpty())->notEmpty())
  implies self.qualifiedName->isEmpty()*/
	operation has_no_qualified_name(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the names of the containing namespaces.
(self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()) implies
  self.qualifiedName = self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))*/
	operation has_qualified_name(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a NamedElement is not owned by a Namespace, it does not have a visibility.
namespace->isEmpty() implies visibility->isEmpty()*/
	operation visibility_needs_ownership(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Creates a dependency between this named element and the specified supplier, owned by this named element's nearest package.*/
	operation createDependency(supplier : NamedElement[1..1]) : Dependency[1..1] is
		abstract

	/**Retrieves a localized label for this named element.*/
	operation getLabel() : String is
		abstract

	/**Retrieves a label for this named element, localized if indicated.*/
	operation op_getLabel(localize : Boolean[1..1]) : String is
		abstract

	/**Creates a usage between this named element and the specified supplier, owned by this named element's nearest package.*/
	operation createUsage(supplier : NamedElement[1..1]) : Usage[1..1] is
		abstract

	/**When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the names of the containing namespaces.
result = if self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()
then 
    self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))
else
    Set{}
endif*/
	operation getQualifiedName() : String[1..1] is
		abstract

	/**The query allNamespaces() gives the sequence of namespaces in which the NamedElement is nested, working outwards.
result = if self.namespace->isEmpty()
then Sequence{}
else self.namespace.allNamespaces()->prepend(self.namespace)
endif*/
	operation allNamespaces() : Namespace[0..*] is
		abstract

	/**The query isDistinguishableFrom() determines whether two NamedElements may logically co-exist within a Namespace. By default, two named elements are distinguishable if (a) they have unrelated types or (b) they have related types but different names.
result = if self.oclIsKindOf(n.oclType) or n.oclIsKindOf(self.oclType)
then ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()
else true
endif*/
	operation isDistinguishableFrom(n : NamedElement[1..1], ns : Namespace[1..1]) : Boolean[1..1] is
		abstract

	/**The query separator() gives the string that is used to separate names when constructing a qualified name.
result = '::'*/
	operation separator() : String[1..1] is
		abstract

	/**The query allOwningPackages() returns all the directly or indirectly owning packages.
result = self.namespace->select(p | p.oclIsKindOf(Package))->union(p.allOwningPackages())*/
	operation allOwningPackages() : set Package[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitNamedElement(self)
		end

}
enumeration VisibilityKind
{
	public;
	private;
	protected;
	~package;
}
class Dependency inherits PackageableElement, DirectedRelationship
{
	/**The element(s) independent of the client element(s), in the same respect and the same dependency relationship. In some directed dependency relationships (such as Refinement Abstractions), a common convention in the domain of class-based OO software is to put the more abstract element in this role. Despite this convention, users of UML may stipulate a sense of dependency suitable for their domain, which makes a more abstract element dependent on that which is more specific.*/
	reference supplier : set NamedElement[1..*]

	/**The element(s) dependent on the supplier element(s). In some cases (such as a Trace Abstraction) the assignment of direction (that is, the designation of the client element) is at the discretion of the modeler, and is a stipulation.*/
	reference client : set NamedElement[1..*]#clientDependency

	method accept(visitor : visitors::Visitor) : Void from uml::PackageableElement is
		do
			result := visitor.visitDependency(self)
		end

}
abstract class DirectedRelationship inherits Relationship
{
	/**Specifies the sources of the DirectedRelationship.*/
	property source : set Element[1..*]
		getter is do
			//TODO: implement getter for derived property source
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Specifies the targets of the DirectedRelationship.*/
	property target : set Element[1..*]
		getter is do
			//TODO: implement getter for derived property target
			raise kermeta::exceptions::NotImplementedException.new 
		end

	method accept(visitor : visitors::Visitor) : Void from uml::Relationship is
		do
			result := visitor.visitDirectedRelationship(self)
		end

}
abstract class Relationship inherits Element
{
	/**Specifies the elements related by the Relationship.*/
	property relatedElement : set Element[1..*]
		getter is do
			//TODO: implement getter for derived property relatedElement
			raise kermeta::exceptions::NotImplementedException.new 
		end

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitRelationship(self)
		end

}
abstract class Namespace inherits NamedElement
{
	/**References the ElementImports owned by the Namespace.*/
	attribute elementImport : set ElementImport[0..*]#importingNamespace

	/**References the PackageImports owned by the Namespace.*/
	attribute packageImport : set PackageImport[0..*]#importingNamespace

	/**Specifies a set of Constraints owned by this Namespace.*/
	attribute ownedRule : set Constraint[0..*]#context

	/**A collection of NamedElements identifiable within the Namespace, either by being owned or by being introduced by importing or inheritance.*/
	property member : set NamedElement[0..*]
		getter is do
			//TODO: implement getter for derived property member
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.*/
	property importedMember : set PackageableElement[0..*]
		getter is do
			//TODO: implement getter for derived property importedMember
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**A collection of NamedElements owned by the Namespace.*/
	property ownedMember : set NamedElement[0..*]#namespace
		getter is do
			// derived union of Element.ownedElement and Namespace.member
			var union :  set NamedElement[0..*]
			allOwnedElements.each{e|
				var ne : NamedElement
				ne ?= e
				union.add(ne)
			}
			union.addAll(member)
			result := union
		end

	/**All the members of a Namespace are distinguishable within it.
membersAreDistinguishable()*/
	operation members_distinguishable(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Creates an import of the specified element into this namespace with the specified visibility.*/
	operation createElementImport(element : PackageableElement[1..1], visibility : VisibilityKind[1..1]) : ElementImport[1..1] is
		abstract

	/**Creates an import of the specified package into this namespace with the specified visibility.*/
	operation createPackageImport(package_ : Package[1..1], visibility : VisibilityKind[1..1]) : PackageImport[1..1] is
		abstract

	/**Retrieves the elements imported by this namespace.*/
	operation getImportedElements() : set PackageableElement[0..*] is
		abstract

	/**Retrieves the packages imported by this namespace.*/
	operation getImportedPackages() : set Package[0..*] is
		abstract

	/**The importedMember property is derived from the ElementImports and the PackageImports. References the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.
result = self.importMembers(self.elementImport.importedElement.asSet()-
>union(self.packageImport.importedPackage->collect(p | p.visibleMembers())))*/
	operation getImportedMembers() : set PackageableElement[0..*] is
		abstract

	/**The query getNamesOfMember() takes importing into account. It gives back the set of names that an element would have in an importing namespace, either because it is owned, or if not owned then imported individually, or if not individually then from a package.
The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace. In general a member can have multiple names in a Namespace if it is imported more than once with different aliases. The query takes account of importing. It gives back the set of names that an element would have in an importing namespace, either because it is owned, or if not owned then imported individually, or if not individually then from a package.
result = if self.ownedMember ->includes(element)
then Set{}->include(element.name)
else let elementImports: ElementImport = self.elementImport->select(ei | ei.importedElement = element) in
  if elementImports->notEmpty()
  then elementImports->collect(el | el.getName())
  else self.packageImport->select(pi | pi.importedPackage.visibleMembers()->includes(element))-> collect(pi | pi.importedPackage.getNamesOfMember(element))
  endif
endif*/
	operation getNamesOfMember(element : NamedElement[1..1]) : set String[0..*] is
		abstract

	/**The Boolean query membersAreDistinguishable() determines whether all of the namespace's members are distinguishable within it.
result = self.member->forAll( memb |
self.member->excluding(memb)->forAll(other |
memb.isDistinguishableFrom(other, self)))*/
	operation membersAreDistinguishable() : Boolean[1..1] is
		abstract

	/**The query importMembers() defines which of a set of PackageableElements are actually imported into the namespace. This excludes hidden ones, i.e., those which have names that conflict with names of owned members, and also excludes elements which would have the same name when imported.
result = self.excludeCollisions(imps)->select(imp | self.ownedMember->forAll(mem |
mem.imp.isDistinguishableFrom(mem, self)))*/
	operation importMembers(imps : set PackageableElement[0..*]) : set PackageableElement[0..*] is
		abstract

	/**The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this namespace.
result = imps->reject(imp1 | imps.exists(imp2 | not imp1.isDistinguishableFrom(imp2, self)))*/
	operation excludeCollisions(imps : set PackageableElement[0..*]) : set PackageableElement[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitNamespace(self)
		end

}
class ElementImport inherits DirectedRelationship
{
	/**Specifies the visibility of the imported PackageableElement within the importing Package. The default visibility is the same as that of the imported element. If the imported element does not have a visibility, it is possible to add visibility to the element import.*/
	attribute visibility : VisibilityKind[1..1]

	/**Specifies the name that should be added to the namespace of the importing package in lieu of the name of the imported packagable element. The aliased name must not clash with any other member name in the importing package. By default, no alias is used.*/
	attribute ~alias : String

	/**Specifies the PackageableElement whose name is to be added to a Namespace.*/
	reference importedElement : PackageableElement[1..1]

	/**Specifies the Namespace that imports a PackageableElement from another Package.*/
	reference importingNamespace : Namespace[1..1]#elementImport

	/**The visibility of an ElementImport is either public or private.
self.visibility = #public or self.visibility = #private*/
	operation visibility_public_or_private(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An importedElement has either public visibility or no visibility at all.
self.importedElement.visibility.notEmpty() implies self.importedElement.visibility = #public*/
	operation imported_element_is_public(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The query getName() returns the name under which the imported PackageableElement will be known in the importing namespace.
result = if self.alias->notEmpty() then
  self.alias
else
  self.importedElement.name
endif*/
	operation getName() : String[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::DirectedRelationship is
		do
			result := visitor.visitElementImport(self)
		end

}
class PackageImport inherits DirectedRelationship
{
	/**Specifies the visibility of the imported PackageableElements within the importing Namespace, i.e., whether imported elements will in turn be visible to other packages that use that importingPackage as an importedPackage. If the PackageImport is public, the imported elements will be visible outside the package, while if it is private they will not.*/
	attribute visibility : VisibilityKind[1..1]

	/**Specifies the Package whose members are imported into a Namespace.*/
	reference importedPackage : Package[1..1]

	/**Specifies the Namespace that imports the members from a Package.*/
	reference importingNamespace : Namespace[1..1]#packageImport

	/**The visibility of a PackageImport is either public or private.
self.visibility = #public or self.visibility = #private*/
	operation public_or_private(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::DirectedRelationship is
		do
			result := visitor.visitPackageImport(self)
		end

}
class Constraint inherits PackageableElement
{
	/**The ordered set of Elements referenced by this Constraint.*/
	reference constrainedElement : Element[0..*]

	/**A condition that must be true when evaluated in order for the constraint to be satisfied.*/
	attribute specification : ValueSpecification[1..1]

	/**Specifies the namespace that owns the NamedElement.*/
	reference context : Namespace#ownedRule

	/**A constraint cannot be applied to itself.
not constrainedElement->includes(self)*/
	operation not_apply_to_self(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The value specification for a constraint must evaluate to a Boolean value.
self.specification().booleanValue().isOclKindOf(Boolean)*/
	operation value_specification_boolean(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The value specification for a constraint must evaluate to a Boolean value.
true*/
	operation boolean_value(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Evaluating the value specification for a constraint must not have side effects.
true*/
	operation no_side_effects(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A constraint cannot be applied to itself.
not constrainedElement->includes(self)*/
	operation not_applied_to_self(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::PackageableElement is
		do
			result := visitor.visitConstraint(self)
		end

}
abstract class ValueSpecification inherits PackageableElement, TypedElement
{
	/**The query isComputable() determines whether a value specification can be computed in a model. This operation cannot be fully defined in OCL. A conforming implementation is expected to deliver true for this operation for all value specifications that it can compute, and to compute all of those for which the operation is true. A conforming implementation is expected to be able to compute the value of all literals.
result = false*/
	operation isComputable() : Boolean[1..1] is
		abstract

	/**The query integerValue() gives a single Integer value when one can be computed.
result = Set{}*/
	operation integerValue() : Integer[1..1] is
		abstract

	/**The query booleanValue() gives a single Boolean value when one can be computed.
result = Set{}*/
	operation booleanValue() : Boolean[1..1] is
		abstract

	/**The query stringValue() gives a single String value when one can be computed.
result = Set{}*/
	operation stringValue() : String[1..1] is
		abstract

	/**The query unlimitedValue() gives a single UnlimitedNatural value when one can be computed.
result = Set{}*/
	operation unlimitedValue() : UnlimitedNatural[1..1] is
		abstract

	/**The query isNull() returns true when it can be computed that the value is null.
result = false*/
	operation isNull() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::PackageableElement is
		do
			result := visitor.visitValueSpecification(self)
		end

}
abstract class TypedElement inherits NamedElement
{
	/**This information is derived from the return result for this Operation.
The type of the TypedElement.*/
	reference type : Type

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitTypedElement(self)
		end

}
abstract class Type inherits PackageableElement
{
	/**Specifies the owning package of this classifier, if any.*/
	property ~package : Package#ownedType
		getter is do
			//TODO: implement getter for derived property package
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property package
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Creates a(n) (binary) association between this type and the specified other type, with the specified navigabilities, aggregations, names, lower bounds, and upper bounds, and owned by this type's nearest package.*/
	operation createAssociation(end1IsNavigable : Boolean[1..1], end1Aggregation : AggregationKind[1..1], end1Name : String[1..1], end1Lower : Integer[1..1], end1Upper : UnlimitedNatural[1..1], end1Type : Type[1..1], end2IsNavigable : Boolean[1..1], end2Aggregation : AggregationKind[1..1], end2Name : String[1..1], end2Lower : Integer[1..1], end2Upper : UnlimitedNatural[1..1]) : Association[1..1] is
		abstract

	/**Retrieves the associations in which this type is involved.*/
	operation getAssociations() : set Association[0..*] is
		abstract

	/**The query conformsTo() gives true for a type that conforms to another. By default, two types do not conform to each other. This query is intended to be redefined for specific conformance situations.
result = false*/
	operation conformsTo(other : Type[1..1]) : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::PackageableElement is
		do
			result := visitor.visitType(self)
		end

}
class Association inherits Classifier, Relationship
{
	/**The ends that are owned by the association itself.*/
	attribute ownedEnd : Property[0..*]#owningAssociation

	/**Each end represents participation of instances of the classifier connected to the end in links of the association.*/
	reference memberEnd : Property[2..*]#association

	/**Specifies whether the association is derived from other model elements such as other associations or constraints.*/
	attribute isDerived : Boolean[1..1]

	/**References the classifiers that are used as types of the ends of the association.*/
	property endType : Type[1..*]
		getter is do
			//TODO: implement getter for derived property endType
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The navigable ends that are owned by the association itself.*/
	reference navigableOwnedEnd : set Property[0..*]

	/**An association specializing another association has the same number of ends as the other association.
self.parents()->forAll(p | p.memberEnd.size() = self.memberEnd.size())*/
	operation specialized_end_number(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**When an association specializes another association, every end of the specific association corresponds to an end of the general association, and the specific end reaches the same type or a subtype of the more general end.
true*/
	operation specialized_end_types(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Only binary associations can be aggregations.
self.memberEnd->exists(aggregation <> Aggregation::none) implies self.memberEnd->size() = 2*/
	operation binary_associations(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Association ends of associations with more than two ends must be owned by the association.
if memberEnd->size() > 2 then ownedEnd->includesAll(memberEnd)*/
	operation association_ends(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Determines whether this association is a binary association, i.e. whether it has exactly two member ends.*/
	operation isBinary() : Boolean[1..1] is
		abstract

	/**endType is derived from the types of the member ends.
result = self.memberEnd->collect(e | e.type)*/
	operation getEndTypes() : Type[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Classifier is
		do
			result := visitor.visitAssociation(self)
		end

}
abstract class Classifier inherits Namespace, RedefinableElement, Type, TemplateableElement
{
	/**If true, the Classifier does not provide a complete declaration and can typically not be instantiated. An abstract classifier is intended to be used by other classifiers e.g. as the target of general metarelationships or generalization relationships.
*/
	attribute isAbstract : Boolean[1..1]

	/**Specifies the Generalization relationships for this Classifier. These Generalizations navigaten to more general classifiers in the generalization hierarchy.*/
	attribute generalization : set Generalization[0..*]#specific

	/**Designates the GeneralizationSet of which the associated Classifier is a power type.*/
	reference powertypeExtent : set GeneralizationSet[0..*]#powertype

	/**Note that there may be members of the Classifier that are of the type Feature but are not included in this association, e.g. inherited features.
Specifies each feature defined in the classifier.*/
	property feature : set Feature[0..*]#featuringClassifier
		getter is do
			//TODO: implement getter for derived property feature
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Specifies all elements inherited by this classifier from the general classifiers.*/
	property inheritedMember : set NamedElement[0..*]
		getter is do
			//TODO: implement getter for derived property inheritedMember
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the Classifiers that are redefined by this Classifier.*/
	reference redefinedClassifier : set Classifier[0..*]

	/**References the general classifier in the Generalization relationship.
Specifies the general Classifiers for this Classifier.*/
	property general : set Classifier[0..*]
		getter is do
			//TODO: implement getter for derived property general
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the substitutions that are owned by this Classifier.*/
	attribute substitution : set Substitution[0..*]#substitutingClassifier

	/**Refers to all of the Properties that are direct (i.e. not inherited or imported) attributes of the classifier.*/
	property ~attribute : set Property[0..*]
		getter is do
			//TODO: implement getter for derived property attribute
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References a collaboration use which indicates the collaboration that represents this classifier.*/
	reference representation : CollaborationUse

	/**References the collaboration uses owned by the classifier.*/
	attribute collaborationUse : set CollaborationUse[0..*]

	/**References the use cases owned by this classifier.*/
	attribute ownedUseCase : set UseCase[0..*]

	/**The set of use cases for which this Classifier is the subject.*/
	reference useCase : set UseCase[0..*]#subject

	/**Generalization hierarchies must be directed and acyclical. A classifier can not be both a transitively general and transitively specific classifier of the same classifier.
not self.allParents()->includes(self)*/
	operation no_cycles_in_generalization(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Generalization hierarchies must be directed and acyclical. A classifier can not be both a transitively general and transitively specific classifier of the same classifier.
not self.allParents()->includes(self)*/
	operation generalization_hierarchies(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A classifier may only specialize classifiers of a valid type.
self.parents()->forAll(c | self.maySpecializeType(c))*/
	operation specialize_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor may its instances also be its subclasses.
true*/
	operation maps_to_generalization_set(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Retrieves all the attributes of this classifier, including those inherited from its parents.*/
	operation getAllAttributes() : set Property[0..*] is
		abstract

	/**Retrieves the operations of this classifier.*/
	operation getOperations() : set Operation[0..*] is
		abstract

	/**Retrieves all the operations of this classifier, including those inherited from its parents.*/
	operation getAllOperations() : set Operation[0..*] is
		abstract

	/**Retrieves the first operation with the specified name, parameter names, and parameter types from this classifier.*/
	operation getOperation(name : String, parameterNames : set String[0..*], parameterTypes : set Type[0..*]) : Operation is
		abstract

	/**Retrieves the first operation with the specified name, parameter names, and parameter types from this classifier, ignoring case if indicated.*/
	operation op_getOperation(name : String, parameterNames : set String[0..*], parameterTypes : set Type[0..*], ignoreCase : Boolean[1..1]) : Operation is
		abstract

	/**Retrieves the interfaces on which this classifier has a usage dependency.*/
	operation getUsedInterfaces() : set Interface[0..*] is
		abstract

	/**Retrieves all the interfaces on which this classifier or any of its parents has a usage dependency.*/
	operation getAllUsedInterfaces() : set Interface[0..*] is
		abstract

	/**The general classifiers are the classifiers referenced by the generalization relationships.
result = self.parents()*/
	operation getGenerals() : set Classifier[0..*] is
		abstract

	/**The inheritedMember association is derived by inheriting the inheritable members of the parents.
result = self.inherit(self.parents()->collect(p | p.inheritableMembers(self))*/
	operation getInheritedMembers() : set NamedElement[0..*] is
		abstract

	/**The query allFeatures() gives all of the features in the namespace of the classifier. In general, through mechanisms such as inheritance, this will be a larger set than feature.
result = member->select(oclIsKindOf(Feature))*/
	operation allFeatures() : set Feature[0..*] is
		abstract

	/**The query parents() gives all of the immediate ancestors of a generalized Classifier.
result = generalization.general*/
	operation parents() : set Classifier[0..*] is
		abstract

	/**The query inheritableMembers() gives all of the members of a classifier that may be inherited in one of its descendants, subject to whatever visibility restrictions apply.
c.allParents()->includes(self)
result = member->select(m | c.hasVisibilityOf(m))*/
	operation inheritableMembers(c : Classifier[1..1]) : set NamedElement[0..*] is
		abstract

	/**The query hasVisibilityOf() determines whether a named element is visible in the classifier. By default all are visible. It is only called when the argument is something owned by a parent.
self.allParents()->collect(c | c.member)->includes(n)
result = if (self.inheritedMember->includes(n)) then (n.visibility <> #private) else true*/
	operation hasVisibilityOf(n : NamedElement[1..1]) : Boolean[1..1] is
		abstract

	/**The query conformsTo() gives true for a classifier that defines a type that conforms to another. This is used, for example, in the specification of signature conformance for operations.
result = (self=other) or (self.allParents()->includes(other))*/
	operation op_conformsTo(other : Classifier[1..1]) : Boolean[1..1] from uml::Type is
		abstract

	/**The inherit operation is overridden to exclude redefined properties.
The query inherit() defines how to inherit a set of elements. Here the operation is defined to inherit them all. It is intended to be redefined in circumstances where inheritance is affected by redefinition.
result = inhs*/
	operation inherit(inhs : set NamedElement[0..*]) : set NamedElement[0..*] is
		abstract

	/**The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be redefined by classifiers that have different specialization constraints.
result = self.oclIsKindOf(c.oclType)*/
	operation maySpecializeType(c : Classifier[1..1]) : Boolean[1..1] is
		abstract

	/**The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.
result = self.parents()->union(self.parents()->collect(p | p.allParents())*/
	operation allParents() : set Classifier[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Namespace is
		do
			result := visitor.visitClassifier(self)
		end

}
abstract class RedefinableElement inherits NamedElement
{
	/**Indicates whether it is possible to further specialize a RedefinableElement. If the value is true, then it is not possible to further specialize the RedefinableElement.*/
	attribute isLeaf : Boolean[1..1]

	/**The redefinable element that is being redefined by this element.*/
	property redefinedElement : set RedefinableElement[0..*]
		getter is do
			//TODO: implement getter for derived property redefinedElement
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the contexts that this element may be redefined from.*/
	property redefinitionContext : set Classifier[0..*]
		getter is do
			//TODO: implement getter for derived property redefinitionContext
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.
self.redefinedElement->forAll(e | self.isRedefinitionContextValid(e))*/
	operation redefinition_context_valid(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A redefining element must be consistent with each redefined element.
self.redefinedElement->forAll(re | re.isConsistentWith(self))*/
	operation redefinition_consistent(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is possible, whether redefinition would be logically consistent. By default, this is false; this operation must be overridden for subclasses of RedefinableElement to define the consistency conditions.
redefinee.isRedefinitionContextValid(self)
result = false*/
	operation isConsistentWith(redefinee : RedefinableElement[1..1]) : Boolean[1..1] is
		abstract

	/**The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the other. By default at least one of the redefinition contexts of this element must be a specialization of at least one of the redefinition contexts of the specified element.
result = redefinitionContext->exists(c | c.allParents()->includes(redefined.redefinitionContext)))*/
	operation isRedefinitionContextValid(redefined : RedefinableElement[1..1]) : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitRedefinableElement(self)
		end

}
abstract class TemplateableElement inherits Element
{
	/**The optional bindings from this element to templates.*/
	attribute templateBinding : set TemplateBinding[0..*]#boundElement

	/**The optional template signature specifying the formal template parameters.*/
	attribute ownedTemplateSignature : TemplateSignature#template

	/**The query parameterableElements() returns the set of elements that may be used as the parametered elements for a template parameter of this templateable element. By default, this set includes all the owned elements. Subclasses may override this operation if they choose to restrict the set of parameterable elements.
result = allOwnedElements->select(oclIsKindOf(ParameterableElement))*/
	operation parameterableElements() : set ParameterableElement[0..*] is
		abstract

	/**The query isTemplate() returns whether this templateable element is actually a template.
result = ownedTemplateSignature->notEmpty()*/
	operation isTemplate() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitTemplateableElement(self)
		end

}
class TemplateBinding inherits DirectedRelationship
{
	/**The template signature for the template that is the target of the binding.*/
	reference signature : TemplateSignature[1..1]

	/**The parameter substitutions owned by this template binding.*/
	attribute parameterSubstitution : set TemplateParameterSubstitution[0..*]#templateBinding

	/**The element that is bound by this binding.*/
	reference boundElement : TemplateableElement[1..1]#templateBinding

	/**Each parameter substitution must refer to a formal template parameter of the target template signature.
parameterSubstitution->forAll(b | template.parameter->includes(b.formal))*/
	operation parameter_substitution_formal(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A binding contains at most one parameter substitution for each formal template parameter of the target template signature.
template.parameter->forAll(p | parameterSubstitution->select(b | b.formal = p)->size() <= 1)*/
	operation one_parameter_substitution(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::DirectedRelationship is
		do
			result := visitor.visitTemplateBinding(self)
		end

}
class TemplateSignature inherits Element
{
	/**The ordered set of all formal template parameters for this template signature.*/
	reference parameter : TemplateParameter[1..*]

	/**The formal template parameters that are owned by this template signature.*/
	attribute ownedParameter : TemplateParameter[0..*]#signature

	/**The element that owns this template signature.*/
	reference template : TemplateableElement[1..1]#ownedTemplateSignature

	/**Parameters must own the elements they parameter or those elements must be owned by the element being templated.
templatedElement.ownedElement->includesAll(parameter.parameteredElement - parameter.ownedParameteredElement)*/
	operation own_elements(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitTemplateSignature(self)
		end

}
class TemplateParameter inherits Element
{
	/**The template signature that owns this template parameter.*/
	reference signature : TemplateSignature[1..1]#ownedParameter

	/**The element exposed by this template parameter.*/
	reference parameteredElement : ParameterableElement[1..1]#templateParameter

	/**The element that is owned by this template parameter.*/
	attribute ownedParameteredElement : ParameterableElement#owningTemplateParameter

	/**The element that is the default for this formal template parameter.*/
	reference default : ParameterableElement

	/**The element that is owned by this template parameter for the purpose of providing a default.*/
	attribute ownedDefault : ParameterableElement

	/**The default must be compatible with the formal template parameter.
default->notEmpty() implies default->isCompatibleWith(parameteredElement)*/
	operation must_be_compatible(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitTemplateParameter(self)
		end

}
abstract class ParameterableElement inherits Element
{
	/**The formal template parameter that owns this element.*/
	reference owningTemplateParameter : TemplateParameter#ownedParameteredElement

	/**The template parameter that exposes this element as a formal parameter.*/
	reference templateParameter : TemplateParameter#parameteredElement

	/**The query isCompatibleWith() determines if this parameterable element is compatible with the specified parameterable element. By default parameterable element P is compatible with parameterable element Q if the kind of P is the same or a subtype as the kind of Q. Subclasses should override this operation to specify different compatibility constraints.
result = p->oclIsKindOf(self.oclType)*/
	operation isCompatibleWith(p : ParameterableElement[1..1]) : Boolean[1..1] is
		abstract

	/**The query isTemplateParameter() determines if this parameterable element is exposed as a formal template parameter.
result = templateParameter->notEmpty()*/
	operation isTemplateParameter() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitParameterableElement(self)
		end

}
class TemplateParameterSubstitution inherits Element
{
	/**The formal template parameter that is associated with this substitution.*/
	reference formal : TemplateParameter[1..1]

	/**The elements that are the actual parameters for this substitution.*/
	reference actual : set ParameterableElement[1..*]

	/**The actual parameters that are owned by this substitution.*/
	attribute ownedActual : set ParameterableElement[0..*]

	/**The optional bindings from this element to templates.*/
	reference templateBinding : TemplateBinding[1..1]#parameterSubstitution

	/**The actual parameter must be compatible with the formal template parameter, e.g. the actual parameter for a class template parameter must be a class.
actual->forAll(a | a.isCompatibleWith(formal.parameteredElement))*/
	operation must_be_compatible(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitTemplateParameterSubstitution(self)
		end

}
class Generalization inherits DirectedRelationship
{
	/**Indicates whether the specific classifier can be used wherever the general classifier can be used. If true, the execution traces of the specific classifier will be a superset of the execution traces of the general classifier.*/
	attribute isSubstitutable : Boolean

	/**References the general classifier in the Generalization relationship.*/
	reference general : Classifier[1..1]

	/**Designates a set in which instances of Generalization is considered members.*/
	reference generalizationSet : set GeneralizationSet[0..*]#generalization

	/**References the specializing classifier in the Generalization relationship.*/
	reference specific : Classifier[1..1]#generalization

	/**Every Generalization associated with a given GeneralizationSet must have the same general Classifier. That is, all Generalizations for a particular GeneralizationSet must have the same superclass.
true*/
	operation generalization_same_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::DirectedRelationship is
		do
			result := visitor.visitGeneralization(self)
		end

}
class GeneralizationSet inherits PackageableElement
{
	/**Indicates (via the associated Generalizations) whether or not the set of specific Classifiers are covering for a particular general classifier. When isCovering is true, every instance of a particular general Classifier is also an instance of at least one of its specific Classifiers for the GeneralizationSet. When isCovering is false, there are one or more instances of the particular general Classifier that are not instances of at least one of its specific Classifiers defined for the GeneralizationSet.*/
	attribute isCovering : Boolean[1..1]

	/**Indicates whether or not the set of specific Classifiers in a Generalization relationship have instance in common. If isDisjoint is true, the specific Classifiers for a particular GeneralizationSet have no members in common; that is, their intersection is empty. If isDisjoint is false, the specific Classifiers in a particular GeneralizationSet have one or more members in common; that is, their intersection is not empty. For example, Person could have two Generalization relationships, each with the different specific Classifier: Manager or Staff. This would be disjoint because every instance of Person must either be a Manager or Staff. In contrast, Person could have two Generalization relationships involving two specific (and non-covering) Classifiers: Sales Person and Manager. This GeneralizationSet would not be disjoint because there are instances of Person which can be a Sales Person and a Manager.*/
	attribute isDisjoint : Boolean[1..1]

	/**Designates the Classifier that is defined as the power type for the associated GeneralizationSet.*/
	reference powertype : Classifier#powertypeExtent

	/**Designates the instances of Generalization which are members of a given GeneralizationSet.*/
	reference generalization : set Generalization[0..*]#generalizationSet

	/**Every Generalization associated with a particular GeneralizationSet must have the same general Classifier.
generalization->collect(g | g.general)->asSet()->size() <= 1*/
	operation generalization_same_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor may its instances be its subclasses.
true*/
	operation maps_to_generalization_set(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::PackageableElement is
		do
			result := visitor.visitGeneralizationSet(self)
		end

}
abstract class Feature inherits RedefinableElement
{
	/**Specifies whether this feature characterizes individual instances classified by the classifier (false) or the classifier itself (true).*/
	attribute isStatic : Boolean[1..1]

	/**The Classifiers that have this Feature as a feature.*/
	property featuringClassifier : set Classifier[0..*]#feature
		getter is do
			//TODO: implement getter for derived property featuringClassifier
			raise kermeta::exceptions::NotImplementedException.new 
		end

	method accept(visitor : visitors::Visitor) : Void from uml::RedefinableElement is
		do
			result := visitor.visitFeature(self)
		end

}
class Substitution inherits Realization
{
	/**The contract with which the substituting classifier complies.*/
	reference contract : Classifier[1..1]

	/**Instances of the substituting classifier are runtime substitutable where instances of the contract classifier are expected.*/
	reference substitutingClassifier : Classifier[1..1]#substitution

	method accept(visitor : visitors::Visitor) : Void from uml::Realization is
		do
			result := visitor.visitSubstitution(self)
		end

}
class Realization inherits Abstraction
{
	method accept(visitor : visitors::Visitor) : Void from uml::Abstraction is
		do
			result := visitor.visitRealization(self)
		end

}
class Abstraction inherits Dependency
{
	/**An composition of an Expression that states the abstraction relationship between the supplier and the client. In some cases, such as Derivation, it is usually formal and unidirectional; in other cases, such as Trace, it is usually informal and bidirectional. The mapping expression is optional and may be omitted if the precise relationship between the elements is not specified.*/
	attribute mapping : OpaqueExpression

	method accept(visitor : visitors::Visitor) : Void from uml::Dependency is
		do
			result := visitor.visitAbstraction(self)
		end

}
class OpaqueExpression inherits ValueSpecification
{
	/**The text of the expression, possibly in multiple languages.*/
	attribute body : seq String[0..*]

	/**Specifies the languages in which the expression is stated. The interpretation of the expression body depends on the languages. If the languages are unspecified, they might be implicit from the expression body or the context. Languages are matched to body strings by order.*/
	attribute language : String[0..*]

	/**Restricts an opaque expression to return exactly one return result. When the invocation of the opaque expression completes, a single set of values is returned to its owner. This association is derived from the single return result parameter of the associated behavior.*/
	property ~result : Parameter
		getter is do
			//TODO: implement getter for derived property result
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property result
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Specifies the behavior of the opaque expression.*/
	reference behavior : Behavior

	/**If the language attribute is not empty, then the size of the body and language arrays must be the same.
language->notEmpty() implies (body->size() = language->size())*/
	operation language_body_size(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The behavior may only have return result parameters.
self.behavior.notEmpty() implies
  self.behavior.ownedParameters->select(p | p.direction<>#return)->isEmpty()*/
	operation only_return_result_parameters(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The behavior must have exactly one return result parameter.
self.behavior.notEmpty() implies
  self.behavior.ownedParameter->select(p | p.direction=#return)->size() = 1*/
	operation one_return_result_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getResult() : Parameter is
		abstract

	/**The query value() gives an integer value for an expression intended to produce one.
self.isIntegral()
true*/
	operation ~value() : Integer[1..1] is
		abstract

	/**The query isIntegral() tells whether an expression is intended to produce an integer.
result = false*/
	operation isIntegral() : Boolean[1..1] is
		abstract

	/**The query isPositive() tells whether an integer expression has a positive value.
self.isIntegral()
result = false*/
	operation isPositive() : Boolean[1..1] is
		abstract

	/**The query isNonNegative() tells whether an integer expression has a non-negative value.
self.isIntegral()
result = false*/
	operation isNonNegative() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ValueSpecification is
		do
			result := visitor.visitOpaqueExpression(self)
		end

}
class Parameter inherits ConnectableElement, MultiplicityElement
{
	/**The parameter sets containing the parameter. See ParameterSet.*/
	reference parameterSet : set ParameterSet[0..*]#parameter

	/**References the Operation owning this parameter.*/
	reference ~operation : Operation

	/**Indicates whether a parameter is being sent into or out of a behavioral element.*/
	attribute direction : ParameterDirectionKind[1..1]

	/**Specifies a String that represents a value to be used when no argument is supplied for the Parameter.*/
	property default : String
		getter is do
			//TODO: implement getter for derived property default
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property default
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Specifies a ValueSpecification that represents a value to be used when no argument is supplied for the Parameter.*/
	attribute defaultValue : ValueSpecification

	/**Tells whether an output parameter may emit a value to the exclusion of the other outputs.*/
	attribute isException : Boolean[1..1]

	/**Tells whether an input parameter may accept values while its behavior is executing, or whether an output parameter post values while the behavior is executing.*/
	attribute isStream : Boolean[1..1]

	/**Specifies the effect that the owner of the parameter has on values passed in or out of the parameter.*/
	attribute effect : ParameterEffectKind

	/**A parameter may only be associated with a connector end within the context of a collaboration.
self.end.notEmpty() implies self.collaboration.notEmpty()*/
	operation connector_end(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A parameter cannot be a stream and exception at the same time.
true*/
	operation stream_and_exception(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An input parameter cannot be an exception.
true*/
	operation not_exception(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Reentrant behaviors cannot have stream parameters.
true*/
	operation reentrant_behaviors(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Only in and inout parameters may have a delete effect. Only out, inout, and return parameters may have a create effect.
true*/
	operation in_and_out(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getDefault() : String is
		abstract

	operation isSetDefault() : Boolean[1..1] is
		abstract

	operation setDefault(newDefault : String[1..1]) : Void[1..1] is
		abstract

	operation unsetDefault() : Void[1..1] is
		abstract

	/**Sets the default value for this parameter to the specified Boolean value.*/
	operation setBooleanDefaultValue(~value : Boolean[1..1]) : Void[1..1] is
		abstract

	/**Sets the default value for this parameter to the specified integer value.*/
	operation setIntegerDefaultValue(~value : Integer[1..1]) : Void[1..1] is
		abstract

	/**Sets the default value for this parameter to the specified string value.*/
	operation setStringDefaultValue(~value : String[1..1]) : Void[1..1] is
		abstract

	/**Sets the default value for this parameter to the specified unlimited natural value.*/
	operation setUnlimitedNaturalDefaultValue(~value : UnlimitedNatural[1..1]) : Void[1..1] is
		abstract

	/**Sets the default value for this parameter to the null value.*/
	operation setNullDefaultValue() : Void[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ConnectableElement is
		do
			result := visitor.visitParameter(self)
		end

}
abstract class MultiplicityElement inherits Element
{
	/**For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of this element are sequentially ordered.*/
	attribute isOrdered : Boolean[1..1]

	/**For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of this element are unique.*/
	attribute isUnique : Boolean[1..1]

	/**Specifies the upper bound of the multiplicity interval.*/
	property upper : UnlimitedNatural
		getter is do
			//TODO: implement getter for derived property upper
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property upper
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Specifies the lower bound of the multiplicity interval.*/
	property lower : Integer
		getter is do
			//TODO: implement getter for derived property lower
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property lower
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The specification of the upper bound for this multiplicity.*/
	attribute upperValue : ValueSpecification

	/**The specification of the lower bound for this multiplicity.*/
	attribute lowerValue : ValueSpecification

	/**A multiplicity must define at least one valid cardinality that is greater than zero.
upperBound()->notEmpty() implies upperBound() > 0*/
	operation upper_gt_0(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The lower bound must be a non-negative integer literal.
lowerBound()->notEmpty() implies lowerBound() >= 0*/
	operation lower_ge_0(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The upper bound must be greater than or equal to the lower bound.
(upperBound()->notEmpty() and lowerBound()->notEmpty()) implies upperBound() >= lowerBound()*/
	operation upper_ge_lower(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a non-literal ValueSpecification is used for the lower or upper bound, then evaluating that specification must not have side effects.
true*/
	operation value_specification_no_side_effects(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a non-literal ValueSpecification is used for the lower or upper bound, then that specification must be a constant expression.
true*/
	operation value_specification_constant(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation setLower(newLower : Integer[1..1]) : Void[1..1] is
		abstract

	operation setUpper(newUpper : UnlimitedNatural[1..1]) : Void[1..1] is
		abstract

	/**The derived lower attribute must equal the lowerBound.
result = lowerBound()*/
	operation getLower() : Integer[1..1] is
		abstract

	/**The derived upper attribute must equal the upperBound.
result = upperBound()*/
	operation getUpper() : UnlimitedNatural[1..1] is
		abstract

	/**The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
upperBound()->notEmpty()
result = upperBound() > 1*/
	operation isMultivalued() : Boolean[1..1] is
		abstract

	/**The query includesCardinality() checks whether the specified cardinality is valid for this multiplicity.
upperBound()->notEmpty() and lowerBound()->notEmpty()
result = (lowerBound() <= C) and (upperBound() >= C)*/
	operation includesCardinality(C : Integer[1..1]) : Boolean[1..1] is
		abstract

	/**The query includesMultiplicity() checks whether this multiplicity includes all the cardinalities allowed by the specified multiplicity.
self.upperBound()->notEmpty() and self.lowerBound()->notEmpty() and M.upperBound()->notEmpty() and M.lowerBound()->notEmpty()
result = (self.lowerBound() <= M.lowerBound()) and (self.upperBound() >= M.upperBound())*/
	operation includesMultiplicity(M : MultiplicityElement[1..1]) : Boolean[1..1] is
		abstract

	/**The query lowerBound() returns the lower bound of the multiplicity as an integer.
result = if lowerValue->isEmpty() then 1 else lowerValue.integerValue() endif*/
	operation lowerBound() : Integer[1..1] is
		abstract

	/**The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an unlimited natural.
result = if upperValue->isEmpty() then 1 else upperValue.unlimitedValue() endif*/
	operation upperBound() : UnlimitedNatural[1..1] is
		abstract

	/**The operation compatibleWith takes another multiplicity as input. It checks if one multiplicity is compatible with another.
result = Integer.allInstances()->forAll(i : Integer | self.includesCardinality(i) implies other.includesCardinality(i))*/
	operation compatibleWith(other : MultiplicityElement[1..1]) : Boolean[1..1] is
		abstract

	/**The operation is determines if the upper and lower bound of the ranges are the ones given.
result = (lowerbound = self.lowerbound and upperbound = self.upperbound)*/
	operation ~is(lowerbound : Integer[1..1], upperbound : Integer[1..1]) : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitMultiplicityElement(self)
		end

}
abstract class ConnectableElement inherits TypedElement, ParameterableElement
{
	/**Denotes a connector that attaches to this connectable element.*/
	property ~end : ConnectorEnd[0..*]
		getter is do
			//TODO: implement getter for derived property end
			raise kermeta::exceptions::NotImplementedException.new 
		end

	operation getEnds() : set ConnectorEnd[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::TypedElement is
		do
			result := visitor.visitConnectableElement(self)
		end

}
class ConnectableElementTemplateParameter inherits TemplateParameter
{
	method accept(visitor : visitors::Visitor) : Void from uml::TemplateParameter is
		do
			result := visitor.visitConnectableElementTemplateParameter(self)
		end

}
class ConnectorEnd inherits MultiplicityElement
{
	/**A derived association referencing the corresponding association end on the association which types the connector owing this connector end. This association is derived by selecting the association end at the same place in the ordering of association ends as this connector end.
*/
	property definingEnd : Property
		getter is do
			//TODO: implement getter for derived property definingEnd
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property definingEnd
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Indicates the role of the internal structure of a classifier with the port to which the connector end is attached.*/
	reference partWithPort : Property

	/**The connectable element attached at this connector end. When an instance of the containing classifier is created, a link may (depending on the multiplicities) be created to an instance of the classifier that types this connectable element.
*/
	reference role : ConnectableElement[1..1]

	/**The multiplicity of the connector end may not be more general than the multiplicity of the association typing the owning connector.
true*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a connector end is attached to a port of the containing classifier, partWithPort will be empty.
true*/
	operation part_with_port_empty(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a connector end references both a role and a partWithPort, then the role must be a port that is defined by the type of the partWithPort.
true*/
	operation role_and_part_with_port(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The property held in self.partWithPort must not be a Port.
true*/
	operation self_part_with_port(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getDefiningEnd() : Property[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::MultiplicityElement is
		do
			result := visitor.visitConnectorEnd(self)
		end

}
class Property inherits StructuralFeature, ConnectableElement, DeploymentTarget, TemplateableElement
{
	/**References the Class that owns the Property.*/
	reference ~class : Class

	/**The DataType that owns this Property.*/
	reference datatype : DataType#ownedAttribute

	/**If isDerived is true, the value of the attribute is derived from information elsewhere.
Specifies whether the Property is derived, i.e., whether its value or values can be computed from other information.*/
	attribute isDerived : Boolean[1..1]

	/**Specifies whether the property is derived as the union of all of the properties that are constrained to subset it.*/
	attribute isDerivedUnion : Boolean[1..1]

	/**Specifies a String that represents a value to be used when no argument is supplied for the Property.
A String that is evaluated to give a default value for the Property when an object of the owning Classifier is instantiated.*/
	property default : String
		getter is do
			//TODO: implement getter for derived property default
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property default
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Specifies the kind of aggregation that applies to the Property.*/
	attribute aggregation : AggregationKind[1..1]

	/**If isComposite is true, the object containing the attribute is a container for the object or value contained in the attribute.
This is a derived value, indicating whether the aggregation of the Property is composite or not.*/
	property isComposite : Boolean[1..1]
		getter is do
			//TODO: implement getter for derived property isComposite
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property isComposite
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the properties that are redefined by this property.*/
	reference redefinedProperty : set Property[0..*]

	/**References the owning association of this property, if any.*/
	reference owningAssociation : Association#ownedEnd

	/**A ValueSpecification that is evaluated to give a default value for the Property when an object of the owning Classifier is instantiated.*/
	attribute defaultValue : ValueSpecification

	/**In the case where the property is one navigable end of a binary association with both ends navigable, this gives the other end.*/
	property opposite : Property
		getter is do
			//TODO: implement getter for derived property opposite
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property opposite
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the properties of which this property is constrained to be a subset.*/
	reference subsettedProperty : set Property[0..*]

	/**References the association of which this property is a member, if any.*/
	reference association : Association#memberEnd

	/**An optional list of ordered qualifier attributes for the end. If the list is empty, then the Association is not qualified.*/
	attribute qualifier : Property[0..*]#associationEnd

	/**Designates the optional association end that owns a qualifier attribute.*/
	reference associationEnd : Property#qualifier

	/**A multiplicity of a composite aggregation must not have an upper bound greater than 1.
A multiplicity on an aggregate end of a composite aggregation must not have an upper bound greater than 1.
isComposite implies (upperBound()->isEmpty() or upperBound() <= 1)*/
	operation multiplicity_of_composite(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.
self.subsettedProperty->notEmpty() implies
  (self.subsettingContext()->notEmpty() and self.subsettingContext()->forAll (sc |
    self.subsettedProperty->forAll(sp |
      sp.subsettingContext()->exists(c | sc.conformsTo(c)))))*/
	operation subsetting_context_conforms(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A redefined property must be inherited from a more general classifier containing the redefining property.
if (redefinedProperty->notEmpty()) then
  (redefinitionContext->notEmpty() and
      redefinedProperty->forAll(rp|
        ((redefinitionContext->collect(fc|
          fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp))*/
	operation redefined_property_inherited(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A subsetting property may strengthen the type of the subsetted property, and its upper bound may be less.
self.subsettedProperty->forAll(sp |
  self.type.conformsTo(sp.type) and
    ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies
      self.upperBound()<=sp.upperBound() ))*/
	operation subsetting_rules(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Only a navigable property can be marked as readOnly.
isReadOnly implies isNavigable()*/
	operation navigable_readonly(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A derived union is derived.
isDerivedUnion implies isDerived*/
	operation derived_union_is_derived(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A derived union is read only.
isDerivedUnion implies isReadOnly*/
	operation derived_union_is_read_only(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A property may not subset a property with the same name.
true*/
	operation subsetted_property_names(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A Property can be a DeploymentTarget if it is a kind of Node and functions as a part in the internal structure of an encompassing Node.
true*/
	operation deployment_target(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A binding of a property template parameter representing an attribute must be to an attribute.
(isAttribute(self) and (templateParameterSubstitution->notEmpty())
  implies (templateParameterSubstitution->forAll(ts | isAttribute(ts.formal)))*/
	operation binding_to_attribute(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getDefault() : String is
		abstract

	operation isSetDefault() : Boolean[1..1] is
		abstract

	operation setDefault(newDefault : String[1..1]) : Void[1..1] is
		abstract

	operation setIsComposite(newIsComposite : Boolean[1..1]) : Void[1..1] is
		abstract

	operation setOpposite(newOpposite : Property[1..1]) : Void[1..1] is
		abstract

	operation unsetDefault() : Void[1..1] is
		abstract

	/**Sets the navigability of this property as indicated.*/
	operation setIsNavigable(isNavigable : Boolean[1..1]) : Void[1..1] is
		abstract

	/**Retrieves the other end of the (binary) association in which this property is a member end.*/
	operation getOtherEnd() : Property is
		abstract

	/**Sets the default value for this property to the specified Boolean value.*/
	operation setBooleanDefaultValue(~value : Boolean[1..1]) : Void[1..1] is
		abstract

	/**Sets the default value for this property to the specified integer value.*/
	operation setIntegerDefaultValue(~value : Integer[1..1]) : Void[1..1] is
		abstract

	/**Sets the default value for this property to the specified string value.*/
	operation setStringDefaultValue(~value : String[1..1]) : Void[1..1] is
		abstract

	/**Sets the default value for this property to the specified unlimited natural value.*/
	operation setUnlimitedNaturalDefaultValue(~value : UnlimitedNatural[1..1]) : Void[1..1] is
		abstract

	/**Sets the default value for this property to the null value.*/
	operation setNullDefaultValue() : Void[1..1] is
		abstract

	/**The query isAttribute() is true if the Property is defined as an attribute of some classifier.
result = Classifier.allInstances->exists(c | c.attribute->includes(p))*/
	operation isAttribute(p : Property[1..1]) : Boolean[1..1] is
		abstract

	/**If this property is owned by a class, associated with a binary association, and the other end of the association is also owned by a class, then opposite gives the other end.
result = if owningAssociation->isEmpty() and association.memberEnd->size() = 2
  then
    let otherEnd = (association.memberEnd - self)->any() in
      if otherEnd.owningAssociation->isEmpty() then otherEnd else Set{} endif
    else Set {}
    endif*/
	operation getOpposite() : Property[1..1] is
		abstract

	/**The value of isComposite is true only if aggregation is composite.
result = (self.aggregation = #composite)*/
	operation op_isComposite() : Boolean[1..1] is
		abstract

	/**The query subsettingContext() gives the context for subsetting a property. It consists, in the case of an attribute, of the corresponding classifier, and in the case of an association end, all of the classifiers at the other ends.
result = if association->notEmpty()
then association.endType-type
else if classifier->notEmpty() then Set{classifier} else Set{} endif
endif*/
	operation subsettingContext() : set Type[0..*] is
		abstract

	/**The query isNavigable() indicates whether it is possible to navigate across the property.
result = not classifier->isEmpty() or association.owningAssociation.navigableOwnedEnd->includes(self)*/
	operation isNavigable() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::StructuralFeature is
		do
			result := visitor.visitProperty(self)
		end

}
abstract class DeploymentTarget inherits NamedElement
{
	/**The set of Deployments for a DeploymentTarget.*/
	attribute deployment : set Deployment[0..*]#location

	/**The set of elements that are manifested in an Artifact that is involved in Deployment to a DeploymentTarget.*/
	property deployedElement : set PackageableElement[0..*]
		getter is do
			//TODO: implement getter for derived property deployedElement
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**result = ((self.deployment->collect(deployedArtifact))->collect(manifestation))->collect(utilizedElement)*/
	operation getDeployedElements() : set PackageableElement[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitDeploymentTarget(self)
		end

}
class Deployment inherits Dependency
{
	/**The Artifacts that are deployed onto a Node. This association specializes the supplier association.*/
	reference deployedArtifact : set DeployedArtifact[0..*]

	/**The specification of properties that parameterize the deployment and execution of one or more Artifacts.*/
	attribute configuration : set DeploymentSpecification[0..*]#deployment

	/**The DeployedTarget which is the target of a Deployment.*/
	reference location : DeploymentTarget[1..1]#deployment

	method accept(visitor : visitors::Visitor) : Void from uml::Dependency is
		do
			result := visitor.visitDeployment(self)
		end

}
abstract class DeployedArtifact inherits NamedElement
{
	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitDeployedArtifact(self)
		end

}
class DeploymentSpecification inherits Artifact
{
	/**The location where an Artifact is deployed onto a Node. This is typically a 'directory' or 'memory address'.*/
	attribute deploymentLocation : String

	/**The location where a component Artifact executes. This may be a local or remote location.*/
	attribute executionLocation : String

	/**The deployment with which the DeploymentSpecification is associated.*/
	reference deployment : Deployment#configuration

	/**The deployedElements of a DeploymentTarget that are involved in a Deployment that has an associated Deployment-Specification is a kind of Component (i.e. the configured components).
self.deployment->forAll (d | d.location.deployedElements->forAll (de |
  de.oclIsKindOf(Component)))*/
	operation deployed_elements(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The DeploymentTarget of a DeploymentSpecification is a kind of ExecutionEnvironment.
result = self.deployment->forAll (d | d.location..oclIsKindOf(ExecutionEnvironment))*/
	operation deployment_target(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Artifact is
		do
			result := visitor.visitDeploymentSpecification(self)
		end

}
class Artifact inherits Classifier, DeployedArtifact
{
	/**A concrete name that is used to refer to the Artifact in a physical context. Example: file system name, universal resource locator.*/
	attribute fileName : String

	/**The Artifacts that are defined (nested) within the Artifact.
The association is a specialization of the ownedMember association from Namespace to NamedElement.
*/
	attribute nestedArtifact : set Artifact[0..*]

	/**The set of model elements that are manifested in the Artifact. That is, these model elements are utilized in the construction (or generation) of the artifact.*/
	attribute manifestation : set Manifestation[0..*]

	/**The Operations defined for the Artifact. The association is a specialization of the ownedMember association.*/
	attribute ownedOperation : Operation[0..*]

	/**The attributes or association ends defined for the Artifact.
The association is a specialization of the ownedMember association.
*/
	attribute ownedAttribute : Property[0..*]

	/**Creates an operation with the specified name, parameter names, parameter types, and return type (or null) as an owned operation of this artifact.*/
	operation createOwnedOperation(name : String, parameterNames : set String[0..*], parameterTypes : set Type[0..*], returnType : Type) : Operation[1..1] is
		abstract

	/**Creates a property with the specified name, type, lower bound, and upper bound as an owned attribute of this artifact.*/
	operation createOwnedAttribute(name : String, type : Type, lower : Integer[1..1], upper : UnlimitedNatural[1..1]) : Property[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Classifier is
		do
			result := visitor.visitArtifact(self)
		end

}
class Manifestation inherits Abstraction
{
	/**The model element that is utilized in the manifestation in an Artifact.*/
	reference utilizedElement : PackageableElement[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::Abstraction is
		do
			result := visitor.visitManifestation(self)
		end

}
class Operation inherits BehavioralFeature, ParameterableElement, TemplateableElement
{
	/**The Interface that owns this Operation.*/
	reference interface : Interface#ownedOperation

	/**The class that owns the operation.*/
	reference ~class : Class#ownedOperation

	/**Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged (isQuery=true) or whether side effects may occur (isQuery=false).*/
	attribute isQuery : Boolean[1..1]

	/**This information is derived from the return result for this Operation.
Specifies whether the return parameter is ordered or not, if present.*/
	property isOrdered : Boolean[1..1]
		getter is do
			//TODO: implement getter for derived property isOrdered
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property isOrdered
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**This information is derived from the return result for this Operation.
Specifies whether the return parameter is unique or not, if present.*/
	property isUnique : Boolean[1..1]
		getter is do
			//TODO: implement getter for derived property isUnique
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property isUnique
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**This information is derived from the return result for this Operation.
Specifies the lower multiplicity of the return parameter, if present.*/
	property lower : Integer
		getter is do
			//TODO: implement getter for derived property lower
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property lower
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**This information is derived from the return result for this Operation.
Specifies the upper multiplicity of the return parameter, if present.*/
	property upper : UnlimitedNatural
		getter is do
			//TODO: implement getter for derived property upper
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property upper
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**An optional set of Constraints on the state of the system when the Operation is invoked.*/
	reference precondition : set Constraint[0..*]

	/**An optional set of Constraints specifying the state of the system when the Operation is completed.*/
	reference postcondition : set Constraint[0..*]

	/**References the Operations that are redefined by this Operation.*/
	reference redefinedOperation : set Operation[0..*]

	/**The DataType that owns this Operation.*/
	reference datatype : DataType#ownedOperation

	/**An optional Constraint on the result values of an invocation of this Operation.*/
	reference bodyCondition : Constraint

	/**This information is derived from the return result for this Operation.
Specifies the return result of the operation, if present.*/
	property type : Type
		getter is do
			//TODO: implement getter for derived property type
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property type
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**An operation can have at most one return parameter; i.e., an owned parameter with the direction set to 'return'
self.ownedParameter->select(par | par.direction = #return)->size() <= 1*/
	operation at_most_one_return(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A bodyCondition can only be specified for a query operation.
bodyCondition->notEmpty() implies isQuery*/
	operation only_body_for_query(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getLower() : Integer[1..1] is
		abstract

	operation getUpper() : UnlimitedNatural[1..1] is
		abstract

	operation setIsOrdered(newIsOrdered : Boolean[1..1]) : Void[1..1] is
		abstract

	operation setIsUnique(newIsUnique : Boolean[1..1]) : Void[1..1] is
		abstract

	operation setLower(newLower : Integer[1..1]) : Void[1..1] is
		abstract

	operation setType(newType : Type[1..1]) : Void[1..1] is
		abstract

	operation setUpper(newUpper : UnlimitedNatural[1..1]) : Void[1..1] is
		abstract

	/**Retrieves the (only) return result parameter for this operation.*/
	operation getReturnResult() : Parameter is
		abstract

	/**If this operation has a return parameter, isOrdered equals the value of isOrdered for that parameter. Otherwise isOrdered is false.
result = if returnResult()->notEmpty() then returnResult()->any().isOrdered else false endif*/
	operation op_isOrdered() : Boolean[1..1] is
		abstract

	/**If this operation has a return parameter, isUnique equals the value of isUnique for that parameter. Otherwise isUnique is true.
result = if returnResult()->notEmpty() then returnResult()->any().isUnique else true endif*/
	operation op_isUnique() : Boolean[1..1] is
		abstract

	/**If this operation has a return parameter, lower equals the value of lower for that parameter. Otherwise lower is not defined.
result = if returnResult()->notEmpty() then returnResult()->any().lower else Set{} endif*/
	operation lowerBound() : Integer[1..1] is
		abstract

	/**If this operation has a return parameter, upper equals the value of upper for that parameter. Otherwise upper is not defined.
result = if returnResult()->notEmpty() then returnResult()->any().upper else Set{} endif*/
	operation upperBound() : UnlimitedNatural[1..1] is
		abstract

	/**If this operation has a return parameter, type equals the value of type for that parameter. Otherwise type is not defined.
result = if returnResult()->notEmpty() then returnResult()->any().type else Set{} endif*/
	operation getType() : Type[1..1] is
		abstract

	/**The query returnResult() returns the set containing the return parameter of the Operation if one exists, otherwise, it returns an empty set
result = ownedParameter->select (par | par.direction = #return)*/
	operation returnResult() : set Parameter[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::BehavioralFeature is
		do
			result := visitor.visitOperation(self)
		end

}
abstract class BehavioralFeature inherits Namespace, Feature
{
	/**Specifies the ordered set of formal parameters of this BehavioralFeature.*/
	attribute ownedParameter : Parameter[0..*]

	/**If true, then the behavioral feature does not have an implementation, and one must be supplied by a more specific element. If false, the behavioral feature must have an implementation in the classifier or one must be inherited from a more general element.*/
	attribute isAbstract : Boolean[1..1]

	/**A behavioral description that implements the behavioral feature. There may be at most one behavior for a particular pairing of a classifier (as owner of the behavior) and a behavioral feature (as specification of the behavior).*/
	reference ~method : set Behavior[0..*]#specification

	/**Specifies the semantics of concurrent calls to the same passive instance (i.e., an instance originating from a class with isActive being false). Active instances control access to their own behavioral features.*/
	attribute concurrency : CallConcurrencyKind[1..1]

	/**References the Types representing exceptions that may be raised during an invocation of this feature.
The signals that the behavioral feature raises as exceptions.*/
	reference raisedException : set Type[0..*]

	/**The ParameterSets owned by this BehavioralFeature.*/
	attribute ownedParameterSet : set ParameterSet[0..*]

	/**Creates a return result parameter with the specified name and type.*/
	operation createReturnResult(name : String, type : Type) : Parameter[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Namespace is
		do
			result := visitor.visitBehavioralFeature(self)
		end

}
abstract class Behavior inherits Class
{
	/**Tells whether the behavior can be invoked while it is still executing from a previous invocation.*/
	attribute isReentrant : Boolean[1..1]

	/**References a behavior that this behavior redefines. A subtype of Behavior may redefine any other subtype of Behavior. If the behavior implements a behavioral feature, it replaces the redefined behavior. If the behavior is a classifier behavior, it extends the redefined behavior.*/
	reference redefinedBehavior : set Behavior[0..*]

	/**References a list of parameters to the behavior which describes the order and type of arguments that can be given when the behavior is invoked and of the values which will be returned when the behavior completes its execution.
*/
	attribute ownedParameter : Parameter[0..*]

	/**The classifier that is the context for the execution of the behavior. If the behavior is owned by a BehavioredClassifier, that classifier is the context. Otherwise, the context is the first BehavioredClassifier reached by following the chain of owner relationships. For example, following this algorithm, the context of an entry action in a state machine is the classifier that owns the state machine. The features of the context classifier as well as the elements visible to the context classifier are visible to the behavior.*/
	property context : BehavioredClassifier
		getter is do
			//TODO: implement getter for derived property context
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property context
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**An optional set of Constraints specifying what must be fulfilled when the behavior is invoked.*/
	reference precondition : set Constraint[0..*]

	/**An optional set of Constraints specifying what is fulfilled after the execution of the behavior is completed, if its precondition was fulfilled before its invocation.*/
	reference postcondition : set Constraint[0..*]

	/**The ParameterSets owned by this Behavior.*/
	attribute ownedParameterSet : set ParameterSet[0..*]

	/**Designates a behavioral feature that the behavior implements. The behavioral feature must be owned by the classifier that owns the behavior or be inherited by it. The parameters of the behavioral feature and the implementing behavior must match. If a behavior does not have a specification, it is directly associated with a classifier (i.e., it is the behavior of the classifier as a whole).*/
	reference specification : BehavioralFeature#~method

	/**The parameters of the behavior must match the parameters of the implemented behavioral feature.
true*/
	operation parameters_match(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The implemented behavioral feature must be a feature (possibly inherited) of the context classifier of the behavior.
true*/
	operation feature_of_context_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If the implemented behavioral feature has been redefined in the ancestors of the owner of the behavior, then the behavior must realize the latest redefining behavioral feature.
true*/
	operation must_realize(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**There may be at most one behavior for a given pairing of classifier (as owner of the behavior) and behavioral feature (as specification of the behavior).
true*/
	operation most_one_behaviour(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getContext() : BehavioredClassifier is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Class is
		do
			result := visitor.visitBehavior(self)
		end

}
class Class inherits EncapsulatedClassifier, BehavioredClassifier
{
	/**References all the Classifiers that are defined (nested) within the Class.*/
	attribute nestedClassifier : Classifier[0..*]

	/**The operations owned by the class.*/
	attribute ownedOperation : Operation[0..*]#~class

	/**This gives the superclasses of a class.*/
	property superClass : set Class[0..*]
		getter is do
			//TODO: implement getter for derived property superClass
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Determines whether an object specified by this class is active or not. If true, then the owning class is referred to as an active class. If false, then such a class is referred to as a passive class.*/
	attribute isActive : Boolean[1..1]

	/**Receptions that objects of this class are willing to accept.*/
	attribute ownedReception : set Reception[0..*]

	/**References the Extensions that specify additional properties of the metaclass. The property is derived from the extensions whose memberEnds are typed by the Class.*/
	property extension : set Extension[0..*]#metaclass
		getter is do
			//TODO: implement getter for derived property extension
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**A passive class may not own receptions.
not self.isActive implies self.ownedReception.isEmpty()*/
	operation passive_class(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getExtensions() : set Extension[0..*] is
		abstract

	/**Creates an operation with the specified name, parameter names, parameter types, and return type (or null) as an owned operation of this class.*/
	operation createOwnedOperation(name : String, parameterNames : set String[0..*], parameterTypes : set Type[0..*], returnType : Type) : Operation[1..1] is
		abstract

	/**Determines whether this class is a metaclass.*/
	operation isMetaclass() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::EncapsulatedClassifier is
		do
			result := visitor.visitClass(self)
		end

}
abstract class BehavioredClassifier inherits Classifier
{
	/**References behavior specifications owned by a classifier.*/
	attribute ownedBehavior : set Behavior[0..*]

	/**A behavior specification that specifies the behavior of the classifier itself.*/
	reference classifierBehavior : Behavior

	/**The set of InterfaceRealizations owned by the BehavioredClassifier. Interface realizations reference the Interfaces of which the BehavioredClassifier is an implementation.*/
	attribute interfaceRealization : set InterfaceRealization[0..*]#implementingClassifier

	/**References Trigger descriptions owned by a Classifier.*/
	attribute ownedTrigger : set Trigger[0..*]

	/**If a behavior is classifier behavior, it does not have a specification.
self.classifierBehavior.notEmpty() implies self.specification.isEmpty()*/
	operation class_behavior(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Retrieves the interfaces on which this behaviored classifier has an interface realization dependency.*/
	operation getImplementedInterfaces() : set Interface[0..*] is
		abstract

	/**Retrieves all the interfaces on which this behaviored classifier or any of its parents has an interface realization dependency.*/
	operation getAllImplementedInterfaces() : set Interface[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Classifier is
		do
			result := visitor.visitBehavioredClassifier(self)
		end

}
class InterfaceRealization inherits Realization
{
	/**References the Interface specifying the conformance contract.*/
	reference contract : Interface[1..1]

	/**References the BehavioredClassifier that owns this Interfacerealization (i.e., the classifier that realizes the Interface to which it points).*/
	reference implementingClassifier : BehavioredClassifier[1..1]#interfaceRealization

	method accept(visitor : visitors::Visitor) : Void from uml::Realization is
		do
			result := visitor.visitInterfaceRealization(self)
		end

}
class Interface inherits Classifier
{
	/**The attributes (i.e. the properties) owned by the class.*/
	attribute ownedAttribute : Property[0..*]

	/**The operations owned by the class.*/
	attribute ownedOperation : Operation[0..*]#interface

	/**References all the Classifiers that are defined (nested) within the Class.*/
	attribute nestedClassifier : Classifier[0..*]

	/**References all the Interfaces redefined by this Interface.*/
	reference redefinedInterface : set Interface[0..*]

	/**Receptions that objects providing this interface are willing to accept.*/
	attribute ownedReception : set Reception[0..*]

	/**References a protocol state machine specifying the legal sequences of the invocation of the behavioral features described in the interface.*/
	attribute protocol : ProtocolStateMachine

	/**The visibility of all features owned by an interface must be public.
self.feature->forAll(f | f.visibility = #public)*/
	operation op_visibility(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Creates an operation with the specified name, parameter names, parameter types, and return type (or null) as an owned operation of this interface.*/
	operation createOwnedOperation(name : String, parameterNames : set String[0..*], parameterTypes : set Type[0..*], returnType : Type) : Operation[1..1] is
		abstract

	/**Creates a property with the specified name, type, lower bound, and upper bound as an owned attribute of this interface.*/
	operation createOwnedAttribute(name : String, type : Type, lower : Integer[1..1], upper : UnlimitedNatural[1..1]) : Property[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Classifier is
		do
			result := visitor.visitInterface(self)
		end

}
class Reception inherits BehavioralFeature
{
	/**The signal that this reception handles.*/
	reference signal : Signal

	/**A Reception can not be a query.
not self.isQuery*/
	operation not_query(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::BehavioralFeature is
		do
			result := visitor.visitReception(self)
		end

}
class Signal inherits Classifier
{
	/**The attributes owned by the signal.*/
	attribute ownedAttribute : Property[0..*]

	/**Creates a property with the specified name, type, lower bound, and upper bound as an owned attribute of this signal.*/
	operation createOwnedAttribute(name : String, type : Type, lower : Integer[1..1], upper : UnlimitedNatural[1..1]) : Property[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Classifier is
		do
			result := visitor.visitSignal(self)
		end

}
class ProtocolStateMachine inherits StateMachine
{
	/**Conformance between protocol state machines.*/
	attribute conformance : set ProtocolConformance[0..*]#specificMachine

	/**All transitions of a protocol state machine must be protocol transitions. (transitions as extended by the ProtocolStateMachines package)
region->forAll(r | r.transition->forAll(t | t.oclIsTypeOf(ProtocolTransition)))*/
	operation protocol_transitions(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The states of a protocol state machine cannot have entry, exit, or do activity actions.
region->forAll(r | r.subvertex->forAll(v | v.oclIsKindOf(State) implies
(v.entry->isEmpty() and v.exit->isEmpty() and v.doActivity->isEmpty())))
*/
	operation entry_exit_do(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Protocol state machines cannot have deep or shallow history pseudostates.
region->forAll (r | r.subvertex->forAll (v | v.oclIsKindOf(Psuedostate) implies
((v.kind <> #deepHistory) and (v.kind <> #shallowHistory)))))
*/
	operation deep_or_shallow_history(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If two ports are connected, then the protocol state machine of the required interface (if defined) must be conformant to the protocol state machine of the provided interface (if defined).
true*/
	operation ports_connected(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::StateMachine is
		do
			result := visitor.visitProtocolStateMachine(self)
		end

}
class StateMachine inherits Behavior
{
	/**The regions owned directly by the state machine.*/
	attribute region : set Region[1..*]#stateMachine

	/**References the submachine(s) in case of a submachine state. Multiple machines are referenced in case of a concurrent state.*/
	reference submachineState : set State[0..*]#submachine

	/**The connection points defined for this state machine. They represent the interface of the state machine when used as part of submachine state.*/
	attribute connectionPoint : set Pseudostate[0..*]#stateMachine

	/**The state machines of which this is an extension.*/
	reference extendedStateMachine : set StateMachine[0..*]

	/**The classifier context of a state machine cannot be an interface.
context->notEmpty() implies not context.oclIsKindOf(Interface)*/
	operation classifier_context(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The context classifier of the method state machine of a behavioral feature must be the classifier that owns the behavioral feature.
specification->notEmpty() implies (context->notEmpty() and specification->featuringClassifier->exists (c | c = context))*/
	operation context_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The connection points of a state machine are pseudostates of kind entry point or exit point.
conectionPoint->forAll (c | c.kind = #entryPoint or c.kind = #exitPoint)*/
	operation connection_points(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A state machine as the method for a behavioral feature cannot have entry/exit connection points.
specification->notEmpty() implies connectionPoint->isEmpty()*/
	operation ~method(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The operation LCA(s1,s2) returns an orthogonal state or region which is the least common ancestor of states s1 and s2, based on the statemachine containment hierarchy.
true*/
	operation LCA(s1 : State[1..1], s2 : State[1..1]) : Namespace[1..1] is
		abstract

	/**The query ancestor(s1, s2) checks whether s2 is an ancestor state of state s1. context StateMachine::ancestor (s1 : State, s2 : State) : Boolean

result = if (s2 = s1) then
true
else if (s1.container->isEmpty) then
true
else if (s2.container->isEmpty) then
false
else (ancestor (s1, s2.container))*/
	operation ancestor(s1 : State[1..1], s2 : State[1..1]) : Boolean[1..1] is
		abstract

	/**The query isRedefinitionContextValid() specifies whether the redefinition contexts of a statemachine are properly related to the redefinition contexts of the specified statemachine to allow this element to redefine the other. The containing classifier of a redefining statemachine must redefine the containing classifier of the redefined statemachine.
result = true*/
	operation op_isRedefinitionContextValid(redefined : StateMachine[1..1]) : Boolean[1..1] from uml::RedefinableElement is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Behavior is
		do
			result := visitor.visitStateMachine(self)
		end

}
class Region inherits Namespace, RedefinableElement
{
	/**The set of vertices that are owned by this region.*/
	attribute subvertex : set Vertex[0..*]#container

	/**The set of transitions owned by the region. Note that internal transitions are owned by a region, but applies to the source state.*/
	attribute transition : set Transition[0..*]#container

	/**The State that owns the Region. If a Region is owned by a State, then it cannot also be owned by a StateMachine.*/
	reference state : State#region

	/**The region of which this region is an extension.*/
	reference extendedRegion : Region

	/**The StateMachine that owns the Region. If a Region is owned by a StateMachine, then it cannot also be owned by a State.*/
	reference stateMachine : StateMachine#region

	/**A region can have at most one initial vertex
self.subvertex->select (v | v.oclIsKindOf(Pseudostate))->
select(p : Pseudostate | p.kind = #initial)->size() <= 1
*/
	operation initial_vertex(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A region can have at most one deep history vertex
self.subvertex->select (v | v.oclIsKindOf(Pseudostate))->
select(p : Pseudostate | p.kind = #deepHistory)->size() <= 1
*/
	operation deep_history_vertex(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A region can have at most one shallow history vertex
self.subvertex->select(v | v.oclIsKindOf(Pseudostate))->
select(p : Pseudostate | p.kind = #shallowHistory)->size() <= 1
*/
	operation shallow_history_vertex(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a Region is owned by a StateMachine, then it cannot also be owned by a State and vice versa.
(stateMachine->notEmpty() implies state->isEmpty()) and (state->notEmpty() implies stateMachine->isEmpty())*/
	operation owned(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The redefinition context of a region is the nearest containing statemachine
result = let sm = containingStateMachine() in
if sm.context->isEmpty() or sm.general->notEmpty() then
sm
else
sm.context
endif*/
	operation op_redefinitionContext() : Classifier[1..1] is
		abstract

	/**The query isRedefinitionContextValid() specifies whether the redefinition contexts of a region are properly related to the redefinition contexts of the specified region to allow this element to redefine the other. The containing statemachine/state of a redefining region must redefine the containing statemachine/state of the redefined region.
result = true*/
	operation op_isRedefinitionContextValid(redefined : Region[1..1]) : Boolean[1..1] from uml::RedefinableElement is
		abstract

	/**The operation containingStateMachine() returns the sate machine in which this Region is defined
result = if stateMachine->isEmpty() 
then
state.containingStateMachine()
else
stateMachine
endif*/
	operation containingStateMachine() : StateMachine[1..1] is
		abstract

	/**The operation belongsToPSM () checks if the region belongs to a protocol state machine
result = if not stateMachine->isEmpty() then
oclIsTypeOf(ProtocolStateMachine)
else if not state->isEmpty() then
state.container.belongsToPSM ()
else false*/
	operation belongsToPSM() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Namespace is
		do
			result := visitor.visitRegion(self)
		end

}
abstract class Vertex inherits NamedElement
{
	/**Specifies the transitions entering this vertex.*/
	property incoming : set Transition[0..*]
		getter is do
			//TODO: implement getter for derived property incoming
			raise kermeta::exceptions::NotImplementedException.new 
		end
//		setter is do
//			//TODO: implement getter for derived property incoming
//			raise kermeta::exceptions::NotImplementedException.new 
//		end

	/**Specifies the transitions departing from this vertex.*/
	property outgoing : set Transition[0..*]
		getter is do
			//TODO: implement getter for derived property outgoing
			raise kermeta::exceptions::NotImplementedException.new 
		end
//		setter is do
//			//TODO: implement getter for derived property outgoing
//			raise kermeta::exceptions::NotImplementedException.new 
//		end

	/**The region that contains this vertex.*/
	reference container : Region#subvertex

	/**The operation containingStateMachine() returns the state machine in which this Vertex is defined
result = if not container->isEmpty()
then
-- the container is a region
container.containingStateMachine()
else if (oclIsKindOf(Pseudostate)) then
-- entry or exit point?
if (kind = #entryPoint) or (kind = #exitPoint) then
stateMachine
else if (oclIsKindOf(ConnectionPointReference)) then
state.containingStateMachine() -- no other valid cases possible
endif
*/
	operation containingStateMachine() : StateMachine[1..1] is
		abstract

	operation getIncomings() : set Transition[0..*] is
		abstract

	operation getOutgoings() : set Transition[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitVertex(self)
		end

}
class Transition inherits Namespace, RedefinableElement
{
	/**Indicates  the precise type of the transition.*/
	attribute kind : TransitionKind[1..1]

	/**Designates the region that owns this transition.*/
	reference container : Region[1..1]#transition

	/**The transition that is redefined by this transition.*/
	reference redefinedTransition : Transition

	/**A guard is a constraint that provides a fine-grained control over the firing of the transition. The guard is evaluated when an event occurrence is dispatched by the state machine. If the guard is true at that time, the transition may be enabled, otherwise, it is disabled. Guards should be pure expressions without side effects. Guard expressions with side effects are ill formed.*/
	reference guard : Constraint

	/**Specifies an optional behavior to be performed when the transition fires.*/
	attribute effect : Behavior

	/**Specifies the triggers that may fire the transition.*/
	attribute trigger : set Trigger[0..*]

	/**Designates the target vertex that is reached when the transition is taken.*/
	reference target : Vertex[1..1]

	/**Designates the originating vertex (state or pseudostate) of the transition.*/
	reference source : Vertex[1..1]

	/**A fork segment must not have guards or triggers.
(source.oclIsKindOf(Pseudostate) and source.kind = #fork) implies (guard->isEmpty() and trigger->isEmpty())*/
	operation fork_segment_guards(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A join segment must not have guards or triggers.
(target.oclIsKindOf(Pseudostate) and target.kind = #join) implies (guard->isEmpty() and trigger->isEmpty())*/
	operation join_segment_guards(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A fork segment must always target a state.
(source.oclIsKindOf(Pseudostate) and source.kind = #fork) implies (target.oclIsKindOf(State))*/
	operation fork_segment_state(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A join segment must always originate from a state.
(target.oclIsKindOf(Pseudostate) and target.kind = #join) implies (source.oclIsKindOf(State))*/
	operation join_segment_state(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Transitions outgoing pseudostates may not have a trigger.
source.oclIsKindOf(Pseudostate) and
((source.kind <> #junction) and (source.kind <> #join) and (source.kind <> #initial)) implies trigger->isEmpty()
*/
	operation outgoing_pseudostates(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An initial transition at the topmost level (region of a statemachine) either has no trigger or it has a trigger with the stereotype <<create>>.
self.source.oclIsKindOf(Pseudostate) implies
(self.source.oclAsType(Pseudostate).kind = #initial) implies
(self.source.container = self.stateMachine.top) implies
((self.trigger->isEmpty) or
(self.trigger.stereotype.name = 'create'))
*/
	operation initial_transition(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**In case of more than one trigger, the signatures of these must be compatible in case the parameters of the signal are assigned to local variables/attributes.

true*/
	operation signatures_compatible(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The redefinition context of a transition is the nearest containing statemachine.
result = let sm = containingStateMachine() in
if sm.context->isEmpty() or sm.general->notEmpty() then
sm
else
sm.context
endif*/
	operation op_redefinitionContext() : Classifier[1..1] is
		abstract

	/**The query containingStateMachine() returns the state machine that contains the transition either directly or transitively.
result = container.containingStateMachine()*/
	operation containingStateMachine() : StateMachine[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Namespace is
		do
			result := visitor.visitTransition(self)
		end

}
enumeration TransitionKind
{
	internal;
	local;
	external;
}
class Trigger inherits NamedElement
{
	/**The event that causes the trigger.*/
	reference event : Event[1..1]

	/**A optional port of the receiver object on which the behavioral feature is invoked.*/
	reference port : set Port[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitTrigger(self)
		end

}
abstract class Event inherits PackageableElement
{
	method accept(visitor : visitors::Visitor) : Void from uml::PackageableElement is
		do
			result := visitor.visitEvent(self)
		end

}
class Port inherits Property
{
	/**Specifies whether requests arriving at this port are sent to the classifier behavior of this classifier. Such ports are referred to as behavior port. Any invocation of a behavioral feature targeted at a behavior port will be handled by the instance of the owning classifier itself, rather than by any instances that this classifier may contain.*/
	attribute isBehavior : Boolean[1..1]

	/**If true indicates that this port is used to provide the published functionality of a classifier; if false, this port is used to implement the classifier but is not part of the essential externally-visible functionality of the classifier and can, therefore, be altered or deleted along with the internal implementation of the classifier and other properties that are considered part of its implementation.*/
	attribute isService : Boolean[1..1]

	/**References the interfaces specifying the set of operations and receptions which the classifier expects its environment to handle. This association is derived as the set of interfaces required by the type of the port or its supertypes.*/
	property required : set Interface[0..*]
		getter is do
			//TODO: implement getter for derived property required
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**A port may be redefined when its containing classifier is specialized. The redefining port may have additional interfaces to those that are associated with the redefined port or it may replace an interface by one of its subtypes.*/
	reference redefinedPort : set Port[0..*]

	/**References the interfaces specifying the set of operations and receptions which the classifier offers to its environment, and which it will handle either directly or by forwarding it to a part of its internal structure. This association is derived from the interfaces realized by the type of the port or by the type of the port, if the port was typed by an interface.
*/
	property provided : set Interface[0..*]
		getter is do
			//TODO: implement getter for derived property provided
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References an optional protocol state machine which describes valid interactions at this interaction point.*/
	reference protocol : ProtocolStateMachine

	/**The required interfaces of a port must be provided by elements to which the port is connected.
true*/
	operation required_interfaces(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Port.aggregation must be composite.
true*/
	operation port_aggregation(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**When a port is destroyed, all connectors attached to this port will be destroyed also.
true*/
	operation port_destroyed(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A defaultValue for port cannot be specified when the type of the Port is an Interface
true*/
	operation default_value(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getProvideds() : set Interface[0..*] is
		abstract

	operation getRequireds() : set Interface[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Property is
		do
			result := visitor.visitPort(self)
		end

}
class State inherits Namespace, RedefinableElement, Vertex
{
	/**A state with isComposite=true is said to be a composite state. A composite state is a state that contains at least one region.*/
	property isComposite : Boolean[1..1]
		getter is do
			//TODO: implement getter for derived property isComposite
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property isComposite
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**A state with isOrthogonal=true is said to be an orthogonal composite state. An orthogonal composite state contains two or more regions.*/
	property isOrthogonal : Boolean[1..1]
		getter is do
			//TODO: implement getter for derived property isOrthogonal
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property isOrthogonal
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**A state with isSimple=true is said to be a simple state. A simple state does not have any regions and it does not refer to any submachine state machine.*/
	property isSimple : Boolean[1..1]
		getter is do
			//TODO: implement getter for derived property isSimple
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property isSimple
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**A state with isSubmachineState=true is said to be a submachine state. Such a state refers to a state machine (submachine).*/
	property isSubmachineState : Boolean[1..1]
		getter is do
			//TODO: implement getter for derived property isSubmachineState
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property isSubmachineState
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The state machine that is to be inserted in place of the (submachine) state.*/
	reference submachine : StateMachine#submachineState

	/**The entry and exit connection points used in conjunction with this (submachine) state, i.e. as targets and sources, respectively, in the region with the submachine state. A connection point reference references the corresponding definition of a connection point pseudostate in the statemachine referenced by the submachinestate.*/
	attribute connection : set ConnectionPointReference[0..*]#state

	/**The entry and exit pseudostates of a composite state. These can only be entry or exit Pseudostates, and they must have different names. They can only be defined for composite states.*/
	attribute connectionPoint : set Pseudostate[0..*]#state

	/**The state of which this state is a redefinition.*/
	reference redefinedState : State

	/**Specifies conditions that are always true when this state is the current state. In protocol state machines, state invariants are additional conditions to the preconditions of the outgoing transitions, and to the postcondition of the incoming transitions.
*/
	attribute stateInvariant : Constraint

	/**An optional behavior that is executed whenever this state is entered regardless of the transition taken to reach the state. If defined, entry actions are always executed to completion prior to any internal behavior or transitions performed within the state.
*/
	attribute entry : Behavior

	/**An optional behavior that is executed whenever this state is exited regardless of which transition was taken out of the state. If defined, exit actions are always executed to completion only after all internal activities and transition actions have completed execution.*/
	attribute exit : Behavior

	/**An optional behavior that is executed while being in the state. The execution starts when this state is entered, and stops either by itself, or when the state is exited, whichever comes first.*/
	attribute doActivity : Behavior

	/**A list of triggers that are candidates to be retained by the state machine if they trigger no transitions out of the state (not consumed). A deferred trigger is retained until the state machine reaches a state configuration where it is no longer deferred.
*/
	attribute deferrableTrigger : set Trigger[0..*]

	/**The regions owned directly by the state.*/
	attribute region : set Region[0..*]#state

	/**Only submachine states can have connection point references.
isSubmachineState implies connection->notEmpty ( )*/
	operation submachine_states(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The connection point references used as destinations/sources of transitions associated with a submachine state must be defined as entry/exit points in the submachine state machine.
self.isSubmachineState implies (self.connection->forAll (cp |
cp.entry->forAll (p | p.statemachine = self.submachine) and
cp.exit->forAll (p | p.statemachine = self.submachine)))*/
	operation destinations_or_sources_of_transitions(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A state is not allowed to have both a submachine and regions.
isComposite implies not isSubmachineState*/
	operation submachine_or_regions(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Only composite states can have entry or exit pseudostates defined.
connectionPoint->notEmpty() implies isComoposite*/
	operation composite_states(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Only entry or exit pseudostates can serve as connection points.
connectionPoint->forAll(cp|cp.kind = #entry or cp.kind = #exit)*/
	operation entry_or_exit(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A simple state is a state without any regions.
result = region.isEmpty()*/
	operation op_isSimple() : Boolean[1..1] is
		abstract

	/**A composite state is a state with at least one region.
result = region.notEmpty()*/
	operation op_isComposite() : Boolean[1..1] is
		abstract

	/**An orthogonal state is a composite state with at least 2 regions
result = (region->size () > 1)*/
	operation op_isOrthogonal() : Boolean[1..1] is
		abstract

	/**Only submachine states can have a reference statemachine.
result = submachine.notEmpty()*/
	operation op_isSubmachineState() : Boolean[1..1] is
		abstract

	/**The redefinition context of a state is the nearest containing statemachine.
result = let sm = containingStateMachine() in
if sm.context->isEmpty() or sm.general->notEmpty() then
sm
else
sm.context
endif*/
	operation op_redefinitionContext() : Classifier[1..1] is
		abstract

	/**The query isRedefinitionContextValid() specifies whether the redefinition contexts of a state are properly related to the redefinition contexts of the specified state to allow this element to redefine the other. The containing region of a redefining state must redefine the containing region of the redefined state.
result = true*/
	operation op_isRedefinitionContextValid(redefined : State[1..1]) : Boolean[1..1] from uml::RedefinableElement is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Namespace is
		do
			result := visitor.visitState(self)
		end

}
class ConnectionPointReference inherits Vertex
{
	/**The entryPoint kind pseudo states corresponding to this connection point.*/
	reference entry : set Pseudostate[0..*]

	/**The exitPoints kind pseudo states corresponding to this connection point.*/
	reference exit : set Pseudostate[0..*]

	/**The State in which the connection point refreshens are defined.*/
	reference state : State#connection

	/**The entry Pseudostates must be Pseudostates with kind entryPoint.
entry->notEmpty() implies entry->forAll(e | e.kind = #entryPoint)*/
	operation entry_pseudostates(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The exit Pseudostates must be Pseudostates with kind exitPoint.
exit->notEmpty() implies exit->forAll(e | e.kind = #exitPoint)*/
	operation exit_pseudostates(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Vertex is
		do
			result := visitor.visitConnectionPointReference(self)
		end

}
class Pseudostate inherits Vertex
{
	/**Determines the precise type of the Pseudostate and can be one of: entryPoint, exitPoint, initial, deepHistory, shallowHistory, join, fork, junction, terminate or choice.*/
	attribute kind : PseudostateKind[1..1]

	/**The StateMachine in which this Pseudostate is defined. This only applies to Pseudostates of the kind entryPoint or exitPoint.*/
	reference stateMachine : StateMachine#connectionPoint

	/**The State that owns this pseudostate and in which it appears.*/
	reference state : State#connectionPoint

	/**An initial vertex can have at most one outgoing transition.
(self.kind = #initial) implies (self.outgoing->size <= 1)*/
	operation initial_vertex(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**History vertices can have at most one outgoing transition.
((self.kind = #deepHistory) or (self.kind = #shallowHistory)) implies
(self.outgoing->size <= 1)
*/
	operation history_vertices(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**In a complete statemachine, a join vertex must have at least two incoming transitions and exactly one outgoing transition.
(self.kind = #join) implies
((self.outgoing->size = 1) and (self.incoming->size >= 2))
*/
	operation join_vertex(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**All transitions incoming a join vertex must originate in different regions of an orthogonal state.
(self.kind = #join) implies
  self.incoming->forAll (t1, t2 | t1<>t2 implies
    (self.stateMachine.LCA(t1.source, t2.source).container.isOrthogonal))*/
	operation transitions_incoming(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**In a complete statemachine, a fork vertex must have at least two outgoing transitions and exactly one incoming transition.
(self.kind = #fork) implies
((self.incoming->size = 1) and (self.outgoing->size >= 2))
*/
	operation fork_vertex(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**All transitions outgoing a fork vertex must target states in different regions of an orthogonal state.
(self.kind = #fork) implies
  self.outgoing->forAll (t1, t2 | t1<>t2 implies
    (self.stateMachine.LCA(t1.target, t2.target).container.isOrthogonal))*/
	operation transitions_outgoing(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**In a complete statemachine, a junction vertex must have at least one incoming and one outgoing transition.
(self.kind = #junction) implies
((self.incoming->size >= 1) and (self.outgoing->size >= 1))
*/
	operation junction_vertex(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**In a complete statemachine, a choice vertex must have at least one incoming and one outgoing transition.
(self.kind = #choice) implies
((self.incoming->size >= 1) and (self.outgoing->size >= 1))
*/
	operation choice_vertex(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The outgoing transition from and initial vertex may have a behavior, but not a trigger or a guard.
(self.kind = #initial) implies (self.outgoing.guard->isEmpty()
  and self.outgoing.trigger->isEmpty())*/
	operation outgoing_from_initial(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Vertex is
		do
			result := visitor.visitPseudostate(self)
		end

}
enumeration PseudostateKind
{
	initial;
	deepHistory;
	shallowHistory;
	join;
	fork;
	junction;
	choice;
	entryPoint;
	exitPoint;
	terminate;
}
class ProtocolConformance inherits DirectedRelationship
{
	/**Specifies the protocol state machine to which the specific state machine conforms.*/
	reference generalMachine : ProtocolStateMachine[1..1]

	/**Specifies the state machine which conforms to the general state machine.*/
	reference specificMachine : ProtocolStateMachine[1..1]#conformance

	method accept(visitor : visitors::Visitor) : Void from uml::DirectedRelationship is
		do
			result := visitor.visitProtocolConformance(self)
		end

}
abstract class EncapsulatedClassifier inherits StructuredClassifier
{
	/**References a set of ports that an encapsulated classifier owns.*/
	property ownedPort : set Port[0..*]
		getter is do
			//TODO: implement getter for derived property ownedPort
			raise kermeta::exceptions::NotImplementedException.new 
		end

	method accept(visitor : visitors::Visitor) : Void from uml::StructuredClassifier is
		do
			result := visitor.visitEncapsulatedClassifier(self)
		end

}
abstract class StructuredClassifier inherits Classifier
{
	/**References the properties owned by the classifier.*/
	attribute ownedAttribute : Property[0..*]

	/**References the properties specifying instances that the classifier owns by composition. This association is derived, selecting those owned properties where isComposite is true.*/
	property part : set Property[0..*]
		getter is do
			//TODO: implement getter for derived property part
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the roles that instances may play in this classifier.*/
	property role : set ConnectableElement[0..*]
		getter is do
			//TODO: implement getter for derived property role
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the connectors owned by the classifier.*/
	attribute ownedConnector : set Connector[0..*]

	/**The multiplicities on connected elements must be consistent.
true*/
	operation multiplicities(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Creates a property with the specified name, type, lower bound, and upper bound as an owned attribute of this structured classifier.*/
	operation createOwnedAttribute(name : String, type : Type, lower : Integer[1..1], upper : UnlimitedNatural[1..1]) : Property[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Classifier is
		do
			result := visitor.visitStructuredClassifier(self)
		end

}
class Connector inherits Feature
{
	/**An optional association that specifies the link corresponding to this connector.*/
	reference type : Association

	/**A connector may be redefined when its containing classifier is specialized. The redefining connector may have a type that specializes the type of the redefined connector. The types of the connector ends of the redefining connector may specialize the types of the connector ends of the redefined connector. The properties of the connector ends of the redefining connector may be replaced.*/
	reference redefinedConnector : set Connector[0..*]

	/**A connector consists of at least two connector ends, each representing the participation of instances of the classifiers typing the connectable elements attached to this end. The set of connector ends is ordered.*/
	attribute ~end : ConnectorEnd[2..*]

	/**Indicates the kind of connector.*/
	attribute kind : ConnectorKind

	/**The set of Behaviors that specify the valid interaction patterns across the connector.*/
	reference contract : set Behavior[0..*]

	/**The types of the connectable elements that the ends of a connector are attached to must conform to the types of the association ends of the association that types the connector, if any.
true*/
	operation types(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The connectable elements attached to the ends of a connector must be compatible.
true*/
	operation compatible(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The ConnectableElements attached as roles to each ConnectorEnd owned by a Connector must be roles of the Classifier that owned the Connector, or they must be ports of such roles.
true*/
	operation roles(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A delegation connector must only be defined between used Interfaces or Ports of the same kind, e.g. between two provided Ports or between two required Ports.
true*/
	operation between_interfaces_ports(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a delegation connector is defined between a used Interface or Port and an internal Part Classifier, then that Classifier must have an 'implements' relationship to the Interface type of that Port.
true*/
	operation between_interface_port_implements(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a delegation connector is defined between a source Interface or Port and a target Interface or Port, then the target Interface must support a signature compatible subset of Operations of the source Interface or Port.
true*/
	operation between_interface_port_signature(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**In a complete model, if a source Port has delegation connectors to a set of delegated target Ports, then the union of the Interfaces of these target Ports must be signature compatible with the Interface that types the source Port.
true*/
	operation union_signature_compatible(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An assembly connector must only be defined from a required Interface or Ports to a provided Interface or Port.
true*/
	operation assembly_connector(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Feature is
		do
			result := visitor.visitConnector(self)
		end

}
enumeration ConnectorKind
{
	assembly;
	delegation;
}
class Extension inherits Association
{
	/**Indicates whether an instance of the extending stereotype must be created when an instance of the extended class is created. The attribute value is derived from the multiplicity of the Property referenced by Extension::ownedEnd; a multiplicity of 1 means that isRequired is true, but otherwise it is false. Since the default multiplicity of an ExtensionEnd is 0..1, the default value of isRequired is false.*/
	property isRequired : Boolean[1..1]
		getter is do
			//TODO: implement getter for derived property isRequired
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property isRequired
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References the Class that is extended through an Extension. The property is derived from the type of the memberEnd that is not the ownedEnd.*/
	property metaclass : Class[1..1]#extension
		getter is do
			//TODO: implement getter for derived property metaclass
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property metaclass
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The non-owned end of an Extension is typed by a Class.
metaclassEnd()->notEmpty() and metaclass()->oclIsKindOf(Class)*/
	operation non_owned_end(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An Extension is binary, i.e., it has only two memberEnds.
memberEnd->size() = 2*/
	operation is_binary(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Retrieves the extension end that is typed by a stereotype (as opposed to a metaclass).*/
	operation getStereotypeEnd() : Property is
		abstract

	/**Retrieves the stereotype that extends a metaclass through this extension.*/
	operation getStereotype() : Stereotype is
		abstract

	/**The query metaclassEnd() returns the Property that is typed by a metaclass (as opposed to a stereotype).
result = memberEnd->reject(ownedEnd)*/
	operation metaclassEnd() : Property[1..1] is
		abstract

	/**The query metaclass() returns the metaclass that is being extended (as opposed to the extending stereotype).
result = metaclassEnd().type*/
	operation getMetaclass() : Class[1..1] is
		abstract

	/**The query isRequired() is true if the owned end has a multiplicity with the lower bound of 1.
result = (ownedEnd->lowerBound() = 1)*/
	operation op_isRequired() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Association is
		do
			result := visitor.visitExtension(self)
		end

}
class ExtensionEnd inherits Property
{
	/**The multiplicity of ExtensionEnd is 0..1 or 1.
(self->lowerBound() = 0 or self->lowerBound() = 1) and self->upperBound() = 1*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The aggregation of an ExtensionEnd is composite.
self.aggregation = #composite*/
	operation op_aggregation(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Property is
		do
			result := visitor.visitExtensionEnd(self)
		end

}
class Stereotype inherits Class
{
	/**Stereotype can change the graphical appearance of the extended model element by using attached icons. When this association is not null, it references the location of the icon content to be displayed within diagrams presenting the extended model elements.*/
	attribute icon : set Image[0..*]

	/**Stereotype names should not clash with keyword names for the extended model element.
true*/
	operation name_not_clash(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A Stereotype may only generalize or specialize another Stereotype.
generalization.general->forAll(e |e.oclIsKindOf(Stereotype)) and generalization.specific->forAll(e | e.oclIsKindOf(Stereotype)) */
	operation generalize(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Creates a(n) (required) extension of the specified metaclass with this stereotype.*/
	operation createExtension(metaclass : Class[1..1], isRequired : Boolean[1..1]) : Extension[1..1] is
		abstract

	/**Retrieves the profile that owns this stereotype.*/
	operation getProfile() : Profile is
		abstract

	/**Retrieves the localized keyword for this stereotype.*/
	operation getKeyword() : String[1..1] is
		abstract

	/**Retrieves the keyword for this stereotype, localized if indicated.*/
	operation op_getKeyword(localize : Boolean[1..1]) : String[1..1] is
		abstract

	/**Retrieves the metaclasses extended by this stereotype.*/
	operation getExtendedMetaclasses() : set Class[0..*] is
		abstract

	/**Retrieves all the metaclasses extended by this stereotype, including the metaclasses extended by its superstereotypes.*/
	operation getAllExtendedMetaclasses() : set Class[0..*] is
		abstract

	/**Retrieves the current definition (Ecore representation) of this stereotype.*/
	operation getDefinition() : ecore::EClass is
		abstract

	/**Creates an icon with the specified location for this stereotype.*/
	operation createIcon(location : String[1..1]) : Image[1..1] is
		abstract

	/**Creates an icon with the specified format and content for this stereotype.*/
	operation op_createIcon(format : String[1..1], content : String[1..1]) : Image[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Class is
		do
			result := visitor.visitStereotype(self)
		end

}
class Image inherits Element
{
	/**This contains the serialization of the image according to the format. The value could represent a bitmap, image such as a GIF file, or drawing 'instructions' using a standard such as Scalable Vector Graphic (SVG) (which is XML based).*/
	attribute content : String

	/**This contains a location that can be used by a tool to locate the image as an alternative to embedding it in the stereotype.*/
	attribute location : String

	/**This indicates the format of the content - which is how the string content should be interpreted. The following values are reserved: SVG, GIF, PNG, JPG, WMF, EMF, BMP.

In addition the prefix 'MIME: ' is also reserved. This option can be used as an alternative to express the reserved values above, for example "SVG" could instead be expressed as "MIME: image/svg+xml".*/
	attribute format : String

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitImage(self)
		end

}
class Profile inherits Package
{
	/**References the Stereotypes that are owned by the Profile.*/
	property ownedStereotype : set Stereotype[0..*]
		getter is do
			//TODO: implement getter for derived property ownedStereotype
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**References a metaclass that may be extended.*/
	reference metaclassReference : set ElementImport[0..*]

	/**References a package containing (directly or indirectly) metaclasses that may be extended.*/
	reference metamodelReference : set PackageImport[0..*]

	/**An element imported as a metaclassReference is not specialized or generalized in a Profile.
self.metaclassReference.importedElement->
  select(c | c.oclIsKindOf(Classifier) and
    (c.generalization.namespace = self or
      (c.specialization.namespace = self) )->isEmpty()*/
	operation metaclass_reference_not_specialized(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**All elements imported either as metaclassReferences or through metamodelReferences are members of the same base reference metamodel.
self.metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages())->
  union(self.metaclassReference.importedElement.allOwningPackages() )->notEmpty()*/
	operation references_same_metamodel(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Creates and returns an instance of (the Ecore representation of) the specified classifier defined in this profile.*/
	operation create(classifier : Classifier[1..1]) : ecore::EObject[1..1] is
		abstract

	/**Creates a(n) (abstract) stereotype with the specified name as an owned stereotype of this profile.*/
	operation createOwnedStereotype(name : String[1..1], isAbstract : Boolean[1..1]) : Stereotype[1..1] is
		abstract

	/**Determines whether this profile is defined.*/
	operation isDefined() : Boolean[1..1] is
		abstract

	/**Defines this profile by (re)creating Ecore representations of its current contents.*/
	operation define() : ecore::EPackage is
		abstract

	/**Defines this profile by (re)creating Ecore representations of its current contents, using the specified options, diagnostics, and context.*/
	operation op_define(options : ecore::EMap[1..1], diagnostics : ecore::EDiagnosticChain[1..1], context : ecore::EMap[1..1]) : ecore::EPackage[1..1] is
		abstract

	/**Retrieves the current definition (Ecore representation) of this profile.*/
	operation getDefinition() : ecore::EPackage is
		abstract

	/**Retrieves the current definition (Ecore representation) of the specified named element in this profile.*/
	operation op_getDefinition(namedElement : NamedElement[1..1]) : ecore::ENamedElement is
		abstract

	/**Retrieves the metaclasses referenced by this profile.*/
	operation getReferencedMetaclasses() : set Class[0..*] is
		abstract

	/**Retrieves the metamodels referenced by this profile.*/
	operation getReferencedMetamodels() : set Model[0..*] is
		abstract

	/**Retrieves the extensions owned by this profile, excluding non-required extensions if indicated.*/
	operation getOwnedExtensions(requiredOnly : Boolean[1..1]) : set Extension[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Package is
		do
			result := visitor.visitProfile(self)
		end

}
class Model inherits Package
{
	/**The name of the viewpoint that is expressed by a model (This name may refer to a profile definition).*/
	attribute viewpoint : String

	/**Determines whether this model is a metamodel.*/
	operation isMetamodel() : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Package is
		do
			result := visitor.visitModel(self)
		end

}
class ParameterSet inherits NamedElement
{
	/**Parameters in the parameter set.*/
	reference parameter : set Parameter[1..*]#parameterSet

	/**Constraint that should be satisfied for the owner of the parameters in an input parameter set to start execution using the values provided for those parameters, or the owner of the parameters in an output parameter set to end execution providing the values for those parameters, if all preconditions and conditions on input parameter sets were satisfied.*/
	attribute condition : set Constraint[0..*]

	/**The parameters in a parameter set must all be inputs or all be outputs of the same parameterized entity, and the parameter set is owned by that entity.
true*/
	operation same_parameterized_entity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a behavior has input parameters that are in a parameter set, then any inputs that are not in a parameter set must be streaming. Same for output parameters.
true*/
	operation input(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Two parameter sets cannot have exactly the same set of parameters.
true*/
	operation two_parameter_sets(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitParameterSet(self)
		end

}
enumeration CallConcurrencyKind
{
	sequential;
	guarded;
	concurrent;
}
class DataType inherits Classifier
{
	/**The Attributes owned by the DataType.*/
	attribute ownedAttribute : Property[0..*]#datatype

	/**The Operations owned by the DataType.*/
	attribute ownedOperation : Operation[0..*]#datatype

	/**Creates an operation with the specified name, parameter names, parameter types, and return type (or null) as an owned operation of this data type.*/
	operation createOwnedOperation(name : String, parameterNames : set String[0..*], parameterTypes : set Type[0..*], returnType : Type) : Operation[1..1] is
		abstract

	/**Creates a property with the specified name, type, lower bound, and upper bound as an owned attribute of this data type.*/
	operation createOwnedAttribute(name : String, type : Type, lower : Integer[1..1], upper : UnlimitedNatural[1..1]) : Property[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Classifier is
		do
			result := visitor.visitDataType(self)
		end

}
class OperationTemplateParameter inherits TemplateParameter
{
	method accept(visitor : visitors::Visitor) : Void from uml::TemplateParameter is
		do
			result := visitor.visitOperationTemplateParameter(self)
		end

}
abstract class StructuralFeature inherits Feature, TypedElement, MultiplicityElement
{
	/**States whether the feature's value may be modified by a client.*/
	attribute isReadOnly : Boolean[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::Feature is
		do
			result := visitor.visitStructuralFeature(self)
		end

}
enumeration AggregationKind
{
	none;
	shared;
	composite;
}
enumeration ParameterDirectionKind
{
	in;
	inout;
	out;
	return;
}
enumeration ParameterEffectKind
{
	create;
	read;
	update;
	delete;
}
class CollaborationUse inherits NamedElement
{
	/**The collaboration which is used in this occurrence. The collaboration defines the cooperation between its roles which are mapped to properties of the classifier owning the collaboration use.*/
	reference type : Collaboration[1..1]

	/**A mapping between features of the collaboration type and features of the classifier or operation. This mapping indicates which connectable element of the classifier or operation plays which role(s) in the collaboration. A connectable element may be bound to multiple roles in the same collaboration use (that is, it may play multiple roles).
*/
	attribute roleBinding : set Dependency[0..*]

	/**All the client elements of a roleBinding are in one classifier and all supplier elements of a roleBinding are in one collaboration and they are compatible.
true*/
	operation client_elements(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Every role in the collaboration is bound within the collaboration use to a connectable element within the classifier or operation.
true*/
	operation every_role(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The connectors in the classifier connect according to the connectors in the collaboration
true*/
	operation connectors(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitCollaborationUse(self)
		end

}
class Collaboration inherits BehavioredClassifier, StructuredClassifier
{
	/**References connectable elements (possibly owned by other classifiers) which represent roles that instances may play in this collaboration.*/
	reference collaborationRole : set ConnectableElement[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::BehavioredClassifier is
		do
			result := visitor.visitCollaboration(self)
		end

}
class UseCase inherits BehavioredClassifier
{
	/**References the Include relationships owned by this use case.*/
	attribute include : set Include[0..*]#includingCase

	/**References the Extend relationships owned by this use case.*/
	attribute extend : set Extend[0..*]#extension

	/**References the ExtensionPoints owned by the use case.*/
	attribute extensionPoint : set ExtensionPoint[0..*]#useCase

	/**References the subjects to which this use case applies. The subject or its parts realize all the use cases that apply to this subject. Use cases need not be attached to any specific subject, however. The subject may, but need not, own the use cases that apply to it.*/
	reference subject : set Classifier[0..*]#useCase

	/**A UseCase must have a name.
self.name -> notEmpty ()*/
	operation must_have_name(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**UseCases can only be involved in binary Associations.
true*/
	operation binary_associations(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**UseCases can not have Associations to UseCases specifying the same subject.
true*/
	operation no_association_to_use_case(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A use case cannot include use cases that directly or indirectly include it.
not self.allIncludedUseCases()->includes(self)*/
	operation cannot_include_self(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The query allIncludedUseCases() returns the transitive closure of all use cases (directly or indirectly) included by this use case.
result = self.include->union(self.include->collect(in | in.allIncludedUseCases()))*/
	operation allIncludedUseCases() : set UseCase[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::BehavioredClassifier is
		do
			result := visitor.visitUseCase(self)
		end

}
class Include inherits NamedElement, DirectedRelationship
{
	/**References the use case that is to be included.
*/
	reference addition : UseCase[1..1]

	/**References the use case which will include the addition and owns the include relationship.*/
	reference includingCase : UseCase[1..1]#include

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitInclude(self)
		end

}
class Extend inherits NamedElement, DirectedRelationship
{
	/**References the use case that is being extended.*/
	reference extendedCase : UseCase[1..1]

	/**References the condition that must hold when the first extension point is reached for the extension to take place. If no constraint is associated with the extend relationship, the extension is unconditional.
*/
	attribute condition : Constraint

	/**An ordered list of extension points belonging to the extended use case, specifying where the respective behavioral fragments of the extending use case are to be inserted. The first fragment in the extending use case is associated with the first extension point in the list, the second fragment with the second point, and so on. (Note that, in most practical cases, the extending use case has just a single behavior fragment, so that the list of extension points is trivial.)
*/
	reference extensionLocation : ExtensionPoint[1..*]

	/**References the use case that represents the extension and owns the extend relationship.*/
	reference extension : UseCase[1..1]#extend

	/**The extension points referenced by the extend relationship must belong to the use case that is being extended.


extensionLocation->forAll (xp | extendedCase.extensionPoint->includes(xp))*/
	operation extension_points(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitExtend(self)
		end

}
class ExtensionPoint inherits RedefinableElement
{
	/**References the use case that owns this extension point.*/
	reference useCase : UseCase[1..1]#extensionPoint

	/**An ExtensionPoint must have a name.
self.name->notEmpty ()*/
	operation must_have_name(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::RedefinableElement is
		do
			result := visitor.visitExtensionPoint(self)
		end

}
class RedefinableTemplateSignature inherits RedefinableElement, TemplateSignature
{
	/**The template signature that is extended by this template signature.*/
	reference extendedSignature : set RedefinableTemplateSignature[0..*]

	/**The formal template parameters of the extendedSignature.*/
	property inheritedParameter : set TemplateParameter[0..*]
		getter is do
			//TODO: implement getter for derived property inheritedParameter
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The classifier that owns this template signature.*/
	reference classifier : Classifier[1..1]

	/**The inherited parameters are the parameters of the extended template signature.
if extendedSignature->isEmpty() then Set{} else extendedSignature.parameter endif*/
	operation inherited_parameters(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getInheritedParameters() : set TemplateParameter[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::RedefinableElement is
		do
			result := visitor.visitRedefinableTemplateSignature(self)
		end

}
class ClassifierTemplateParameter inherits TemplateParameter
{
	/**Constrains the required relationship between an actual parameter and the parameteredElement for this formal parameter.*/
	attribute allowSubstitutable : Boolean[1..1]

	/**The classifier that is used by default if no argument is provided during template binding. If this property is empty, then there is no default.*/
	reference defaultClassifier : Classifier

	/**The classifier that constrains the argument that can be used for the parameter. If the allowSubstitutable attribute is true, then any classifier that is compatible with this constraining classifier can be substituted, otherwise it must be either this classifier or one of its subclasses. If this property is empty, there are no constraints on the classifier that can be used as an argument.*/
	reference constrainingClassifier : Classifier

	/**If "allowSubstitutable" is true, then there must be a constrainingClassifier.
allowSubstitutable implies constrainingClassifier->notEmpty()*/
	operation has_constraining_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::TemplateParameter is
		do
			result := visitor.visitClassifierTemplateParameter(self)
		end

}
class StringExpression inherits Expression, TemplateableElement
{
	/**The StringExpressions that constitute this StringExpression.*/
	attribute subExpression : set StringExpression[0..*]#owningExpression

	/**The string expression of which this expression is a substring.*/
	reference owningExpression : StringExpression#subExpression

	/**All the operands of a StringExpression must be LiteralStrings
operand->forAll (op | op.oclIsKindOf (LiteralString))*/
	operation operands(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a StringExpression has sub-expressions, it cannot have operands and vice versa (this avoids the problem of having to
define a collating sequence between operands and subexpressions).

if subExpression->notEmpty() then operand->isEmpty() else operand->notEmpty()*/
	operation subexpressions(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Expression is
		do
			result := visitor.visitStringExpression(self)
		end

}
class Expression inherits ValueSpecification
{
	/**The symbol associated with the node in the expression tree.*/
	attribute symbol : String

	/**Specifies a sequence of operands.*/
	attribute operand : ValueSpecification[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::ValueSpecification is
		do
			result := visitor.visitExpression(self)
		end

}
class Usage inherits Dependency
{
	method accept(visitor : visitors::Visitor) : Void from uml::Dependency is
		do
			result := visitor.visitUsage(self)
		end

}
class PackageMerge inherits DirectedRelationship
{
	/**References the Package that is to be merged with the receiving package of the PackageMerge.*/
	reference mergedPackage : Package[1..1]

	/**References the Package that is being extended with the contents of the merged package of the PackageMerge.*/
	reference receivingPackage : Package[1..1]#packageMerge

	method accept(visitor : visitors::Visitor) : Void from uml::DirectedRelationship is
		do
			result := visitor.visitPackageMerge(self)
		end

}
class ProfileApplication inherits DirectedRelationship
{
	/**References the Profiles that are applied to a Package through this ProfileApplication.*/
	reference appliedProfile : Profile[1..1]

	/**Specifies that the Profile filtering rules for the metaclasses of the referenced metamodel shall be strictly applied.*/
	attribute isStrict : Boolean[1..1]

	/**The package that owns the profile application.*/
	reference applyingPackage : Package[1..1]#profileApplication

	/**Retrieves the definition (Ecore representation) of the profile associated with this profile application.*/
	operation getAppliedDefinition() : ecore::EPackage is
		abstract

	/**Retrieves the definition (Ecore representation) of the specified named element in the profile associated with this profile application.*/
	operation op_getAppliedDefinition(namedElement : NamedElement[1..1]) : ecore::ENamedElement is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::DirectedRelationship is
		do
			result := visitor.visitProfileApplication(self)
		end

}
class Enumeration inherits DataType
{
	/**The ordered set of literals for this Enumeration.*/
	attribute ownedLiteral : EnumerationLiteral[0..*]#~enumeration

	method accept(visitor : visitors::Visitor) : Void from uml::DataType is
		do
			result := visitor.visitEnumeration(self)
		end

}
class EnumerationLiteral inherits InstanceSpecification
{
	/**The Enumeration that this EnumerationLiteral is a member of.*/
	reference ~enumeration : Enumeration#ownedLiteral

	method accept(visitor : visitors::Visitor) : Void from uml::InstanceSpecification is
		do
			result := visitor.visitEnumerationLiteral(self)
		end

}
class InstanceSpecification inherits DeploymentTarget, PackageableElement, DeployedArtifact
{
	/**The classifier or classifiers of the represented instance. If multiple classifiers are specified, the instance is classified by all of them.*/
	reference classifier : set Classifier[0..*]

	/**A slot giving the value or values of a structural feature of the instance. An instance specification can have one slot per structural feature of its classifiers, including inherited features. It is not necessary to model a slot for each structural feature, in which case the instance specification is a partial description.*/
	attribute slot : set Slot[0..*]#owningInstance

	/**A specification of how to compute, derive, or construct the instance.*/
	attribute specification : ValueSpecification

	/**The defining feature of each slot is a structural feature (directly or inherited) of a classifier of the instance specification.
slot->forAll(s | classifier->exists (c | c.allFeatures()->includes (s.definingFeature)))*/
	operation defining_feature(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**One structural feature (including the same feature inherited from multiple classifiers) is the defining feature of at most one slot in an instance specification.
classifier->forAll(c | (c.allFeatures()->forAll(f | slot->select(s | s.definingFeature = f)->size() <= 1)))*/
	operation structural_feature(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An InstanceSpecification can be a DeploymentTarget if it is the instance specification of a Node and functions as a part in the internal structure of an encompassing Node.
true*/
	operation deployment_target(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An InstanceSpecification can be a DeployedArtifact if it is the instance specification of an Artifact.
true*/
	operation deployment_artifact(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::DeploymentTarget is
		do
			result := visitor.visitInstanceSpecification(self)
		end

}
class Slot inherits Element
{
	/**The structural feature that specifies the values that may be held by the slot.*/
	reference definingFeature : StructuralFeature[1..1]

	/**The value or values corresponding to the defining feature for the owning instance specification.*/
	attribute ~value : ValueSpecification[0..*]

	/**The instance specification that owns this slot.*/
	reference owningInstance : InstanceSpecification[1..1]#slot

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitSlot(self)
		end

}
class PrimitiveType inherits DataType
{
	method accept(visitor : visitors::Visitor) : Void from uml::DataType is
		do
			result := visitor.visitPrimitiveType(self)
		end

}
abstract class LiteralSpecification inherits ValueSpecification
{
	method accept(visitor : visitors::Visitor) : Void from uml::ValueSpecification is
		do
			result := visitor.visitLiteralSpecification(self)
		end

}
class LiteralInteger inherits LiteralSpecification
{
	/**The specified Integer value.*/
	attribute ~value : Integer[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::LiteralSpecification is
		do
			result := visitor.visitLiteralInteger(self)
		end

}
class LiteralString inherits LiteralSpecification
{
	/**The specified String value.*/
	attribute ~value : String

	method accept(visitor : visitors::Visitor) : Void from uml::LiteralSpecification is
		do
			result := visitor.visitLiteralString(self)
		end

}
class LiteralBoolean inherits LiteralSpecification
{
	/**The specified Boolean value.*/
	attribute ~value : Boolean[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::LiteralSpecification is
		do
			result := visitor.visitLiteralBoolean(self)
		end

}
class LiteralNull inherits LiteralSpecification
{
	method accept(visitor : visitors::Visitor) : Void from uml::LiteralSpecification is
		do
			result := visitor.visitLiteralNull(self)
		end

}
class InstanceValue inherits ValueSpecification
{
	/**The instance that is the specified value.*/
	reference instance : InstanceSpecification[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::ValueSpecification is
		do
			result := visitor.visitInstanceValue(self)
		end

}
class LiteralUnlimitedNatural inherits LiteralSpecification
{
	/**The specified UnlimitedNatural value.*/
	attribute ~value : UnlimitedNatural[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::LiteralSpecification is
		do
			result := visitor.visitLiteralUnlimitedNatural(self)
		end

}
class OpaqueBehavior inherits Behavior
{
	/**Specifies the behavior in one or more languages.*/
	attribute body : seq String[0..*]

	/**Languages the body strings use in the same order as the body strings.*/
	attribute language : String[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::Behavior is
		do
			result := visitor.visitOpaqueBehavior(self)
		end

}
class FunctionBehavior inherits OpaqueBehavior
{
	/**A function behavior has at least one output parameter.
self.ownedParameters->
  select(p | p.direction=#out or p.direction=#inout or p.direction=#return)->size() >= 1*/
	operation one_output_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The types of parameters are all data types, which may not nest anything but other datatypes.
def: hasAllDataTypeAttributes(d : DataType) : Boolean =
  d.ownedAttribute->forAll(a |
    a.type.oclIsTypeOf(DataType) and
      hasAllDataTypeAttributes(a.type))
self.ownedParameters->forAll(p | p.type.notEmpty() and
  p.oclIsTypeOf(DataType) and hasAllDataTypeAttributes(p))*/
	operation types_of_parameters(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::OpaqueBehavior is
		do
			result := visitor.visitFunctionBehavior(self)
		end

}
class OpaqueAction inherits Action
{
	/**Specifies the action in one or more languages.*/
	attribute body : seq String[0..*]

	/**Languages the body strings use, in the same order as the body strings*/
	attribute language : String[0..*]

	/**Provides input to the action.*/
	attribute inputValue : set InputPin[0..*]

	/**Takes output from the action.*/
	attribute outputValue : set OutputPin[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitOpaqueAction(self)
		end

}
abstract class Action inherits ExecutableNode
{
	/**The ordered set of output pins connected to the Action. The action places its results onto pins in this set.*/
	property output : OutputPin[0..*]
		getter is do
			//TODO: implement getter for derived property output
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The ordered set of input pins connected to the Action. These are among the total set of inputs.*/
	property input : InputPin[0..*]
		getter is do
			//TODO: implement getter for derived property input
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The classifier that owns the behavior of which this action is a part.*/
	property context : Classifier
		getter is do
			//TODO: implement getter for derived property context
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property context
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Constraint that must be satisfied when execution is started.*/
	attribute localPrecondition : set Constraint[0..*]

	/**Constraint that must be satisfied when executed is completed.*/
	attribute localPostcondition : set Constraint[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::ExecutableNode is
		do
			result := visitor.visitAction(self)
		end

}
abstract class ExecutableNode inherits ActivityNode
{
	/**A set of exception handlers that are examined if an uncaught exception propagates to the outer level of the executable node.*/
	attribute handler : set ExceptionHandler[0..*]#protectedNode

	method accept(visitor : visitors::Visitor) : Void from uml::ActivityNode is
		do
			result := visitor.visitExecutableNode(self)
		end

}
abstract class ActivityNode inherits RedefinableElement
{
	/**Structured activity node containing the node.*/
	reference inStructuredNode : StructuredActivityNode#node

	/**Activity containing the node.*/
	reference activity : Activity#node

	/**Edges that have the node as source.*/
	reference outgoing : set ActivityEdge[0..*]#source

	/**Edges that have the node as target.*/
	reference incoming : set ActivityEdge[0..*]#target

	/**Partitions containing the node.*/
	reference inPartition : set ActivityPartition[0..*]#node

	/**Interruptible regions containing the node.*/
	reference inInterruptibleRegion : set InterruptibleActivityRegion[0..*]#node

	/**Groups containing the node.*/
	property inGroup : set ActivityGroup[0..*]#containedNode
		getter is do
			//TODO: implement getter for derived property inGroup
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Inherited nodes replaced by this node in a specialization of the activity.*/
	reference redefinedNode : set ActivityNode[0..*]

	/**Activity nodes may be owned by at most one structured node.
true*/
	operation owned_structured_node(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Activity nodes can only be owned by activities or groups.
true*/
	operation owned(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::RedefinableElement is
		do
			result := visitor.visitActivityNode(self)
		end

}
class StructuredActivityNode inherits Action, Namespace, ActivityGroup
{
	/**A variable defined in the scope of the structured activity node. It has no value and may not be accessed*/
	attribute variable : set Variable[0..*]#scope

	/**Edges immediately contained in the structured node.*/
	attribute edge : set ActivityEdge[0..*]#inStructuredNode

	/**If true, then the actions in the node execute in isolation from actions outside the node.*/
	attribute mustIsolate : Boolean[1..1]

	/**Nodes immediately contained in the group.*/
	attribute node : set ActivityNode[0..*]#inStructuredNode

	/**The edges owned by a structured node must have source and target nodes in the structured node, and vice versa.
true*/
	operation edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitStructuredActivityNode(self)
		end

}
abstract class ActivityGroup inherits Element
{
	/**Groups immediately contained in the group.*/
	property subgroup : set ActivityGroup[0..*]#superGroup
		getter is do
			//TODO: implement getter for derived property subgroup
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Group immediately containing the group.*/
	property superGroup : ActivityGroup#subgroup
		getter is do
			//TODO: implement getter for derived property superGroup
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property superGroup
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Activity containing the group.*/
	reference inActivity : Activity#group

	/**Edges immediately contained in the group.*/
	property containedEdge : set ActivityEdge[0..*]#inGroup
		getter is do
			//TODO: implement getter for derived property containedEdge
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Nodes immediately contained in the group.*/
	property containedNode : set ActivityNode[0..*]#inGroup
		getter is do
			//TODO: implement getter for derived property containedNode
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**All nodes and edges of the group must be in the same activity as the group.
true*/
	operation nodes_and_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**No node or edge in a group may be contained by its subgroups or its containing groups, transitively.
true*/
	operation not_contained(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Groups may only be owned by activities or groups.
true*/
	operation group_owned(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitActivityGroup(self)
		end

}
class Activity inherits Behavior
{
	/**Top-level structured nodes in the activity.*/
	property structuredNode : set StructuredActivityNode[0..*]
		getter is do
			//TODO: implement getter for derived property structuredNode
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Top-level variables in the activity.*/
	attribute variable : set Variable[0..*]#activityScope

	/**Nodes coordinated by the activity.*/
	attribute node : set ActivityNode[0..*]#activity

	/**If true, this activity must not make any changes to variables outside the activity or to objects. (This is an assertion, not an executable property. It may be used by an execution engine to optimize model execution. If the assertion is violated by the action, then the model is ill-formed.) The default is false (an activity may make nonlocal changes).*/
	attribute isReadOnly : Boolean[1..1]

	/**Edges expressing flow between nodes of the activity.*/
	attribute edge : set ActivityEdge[0..*]#activity

	/**Top-level partitions in the activity.*/
	reference partition : set ActivityPartition[0..*]

	/**If true, all invocations of the activity are handled by the same execution.*/
	attribute isSingleExecution : Boolean[1..1]

	/**Top-level groups in the activity.*/
	attribute group : set ActivityGroup[0..*]#inActivity

	/**The groups of an activity have no supergroups.
true*/
	operation no_supergroups(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The nodes of the activity must include one ActivityParameterNode for each parameter.
true*/
	operation activity_parameter_node(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An activity cannot be autonomous and have a classifier or behavioral feature context at the same time.
true*/
	operation autonomous(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Behavior is
		do
			result := visitor.visitActivity(self)
		end

}
class Variable inherits ConnectableElement, MultiplicityElement
{
	/**A structured activity node that owns the variable.*/
	reference scope : StructuredActivityNode#variable

	/**An activity that owns the variable.*/
	reference activityScope : Activity#variable

	/**A variable is owned by a StructuredNode or Activity, but not both.
true*/
	operation owned(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The isAccessibleBy() operation is not defined in standard UML. Implementations should define it to specify which actions can access a variable.

result = true*/
	operation isAccessibleBy(a : Action[1..1]) : Boolean[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ConnectableElement is
		do
			result := visitor.visitVariable(self)
		end

}
abstract class ActivityEdge inherits RedefinableElement
{
	/**Node from which tokens are taken when they traverse the edge.*/
	reference source : ActivityNode[1..1]#outgoing

	/**Node to which tokens are put when they traverse the edge.*/
	reference target : ActivityNode[1..1]#incoming

	/**Inherited edges replaced by this edge in a specialization of the activity.*/
	reference redefinedEdge : set ActivityEdge[0..*]

	/**Partitions containing the edge.*/
	reference inPartition : set ActivityPartition[0..*]#edge

	/**Specification evaluated at runtime to determine if the edge can be traversed.*/
	attribute guard : ValueSpecification[1..1]

	/**Number of tokens consumed from the source node on each traversal.*/
	attribute weight : ValueSpecification[1..1]

	/**Region that the edge can interrupt.*/
	reference interrupts : InterruptibleActivityRegion#interruptingEdge

	/**Structured activity node containing the edge.*/
	reference inStructuredNode : StructuredActivityNode#edge

	/**Groups containing the edge.*/
	property inGroup : set ActivityGroup[0..*]#containedEdge
		getter is do
			//TODO: implement getter for derived property inGroup
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Activity containing the edge.*/
	reference activity : Activity#edge

	/**The source and target of an edge must be in the same activity as the edge.
true*/
	operation source_and_target(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Activity edges may be owned only by activities or groups.
true*/
	operation owned(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Activity edges may be owned by at most one structured node.
true*/
	operation structured_node(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::RedefinableElement is
		do
			result := visitor.visitActivityEdge(self)
		end

}
class ActivityPartition inherits NamedElement, ActivityGroup
{
	/**Tells whether the partition groups other partitions along a dimension.*/
	attribute isDimension : Boolean[1..1]

	/**Tells whether the partition represents an entity to which the partitioning structure does not apply.*/
	attribute isExternal : Boolean[1..1]

	/**Nodes immediately contained in the group.*/
	reference node : set ActivityNode[0..*]#inPartition

	/**Partitions immediately contained in the partition.*/
	attribute subpartition : set ActivityPartition[0..*]#superPartition

	/**Partition immediately containing the partition.*/
	reference superPartition : ActivityPartition#subpartition

	/**An element constraining behaviors invoked by nodes in the partition.*/
	reference represents : Element

	/**Edges immediately contained in the group.*/
	reference edge : set ActivityEdge[0..*]#inPartition

	/**A partition with isDimension = true may not be contained by another partition.
true*/
	operation dimension_not_contained(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a partition represents a part, then all the non-external partitions in the same dimension and at the same level of nesting in that dimension must represent parts directly contained in the internal structure of the same classifier.
true*/
	operation represents_part(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a non-external partition represents a classifier and is contained in another partition, then the containing partition must represent a classifier, and the classifier of the subpartition must be nested in the classifier represented by the containing partition, or be at the contained end of a strong composition association with the classifier represented by the containing partition.
true*/
	operation represents_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a partition represents a part and is contained by another partition, then the part must be of a classifier represented by the containing partition, or of a classifier that is the type of a part representing the containing partition.
true*/
	operation represents_part_and_is_contained(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitActivityPartition(self)
		end

}
class InterruptibleActivityRegion inherits ActivityGroup
{
	/**Nodes immediately contained in the group.*/
	reference node : set ActivityNode[0..*]#inInterruptibleRegion

	/**The edges leaving the region that will abort other tokens flowing in the region.*/
	reference interruptingEdge : set ActivityEdge[0..*]#interrupts

	/**Interrupting edges of a region must have their source node in the region and their target node outside the region in the same activity containing the region.

true*/
	operation interrupting_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ActivityGroup is
		do
			result := visitor.visitInterruptibleActivityRegion(self)
		end

}
class ExceptionHandler inherits Element
{
	/**A node that is executed if the handler satisfies an uncaught exception.*/
	reference handlerBody : ExecutableNode[1..1]

	/**An object node within the handler body. When the handler catches an exception, the exception token is placed in this node, causing the body to execute.*/
	reference exceptionInput : ObjectNode[1..1]

	/**The kind of instances that the handler catches. If an exception occurs whose type is any of the classifiers in the set, the handler catches the exception and executes its body.*/
	reference exceptionType : set Classifier[1..*]

	/**The node protected by the handler. The handler is examined if an exception propagates to the outside of the node.*/
	reference protectedNode : ExecutableNode[1..1]#handler

	/**The exception handler and its input object node are not the source or target of any edge.
true*/
	operation exception_body(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The result pins of the exception handler body must correspond in number and types to the result pins of the protected node.
true*/
	operation result_pins(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The handler body has one input, and that input is the same as the exception input.
true*/
	operation one_input(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An edge that has a source in an exception handler structured node must have its target in the handler also, and vice versa.
true*/
	operation edge_source_target(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitExceptionHandler(self)
		end

}
abstract class ObjectNode inherits ActivityNode, TypedElement
{
	/**Tells whether and how the tokens in the object node are ordered for selection to traverse edges outgoing from the object node.*/
	attribute ordering : ObjectNodeOrderingKind[1..1]

	/**Tells whether the type of the object node is to be treated as control.*/
	attribute isControlType : Boolean[1..1]

	/**The maximum number of tokens allowed in the node. Objects cannot flow into the node if the upper bound is reached.*/
	attribute upperBound : ValueSpecification[1..1]

	/**The required states of the object available at this point in the activity.*/
	reference inState : set State[0..*]

	/**Selects tokens for outgoing edges.*/
	reference selection : Behavior

	/**All edges coming into or going out of object nodes must be object flow edges.
true*/
	operation object_flow_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Object nodes are not unique typed elements
isUnique = false*/
	operation not_unique(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If an object node has a selection behavior, then the ordering of the object node is ordered, and vice versa.
true*/
	operation selection_behavior(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A selection behavior has one input parameter and one output parameter. The input parameter must be a bag of elements of the same type as the object node or a supertype of the type of object node. The output parameter must be the same or a subtype of the type of object node. The behavior cannot have side effects.
true*/
	operation input_output_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ActivityNode is
		do
			result := visitor.visitObjectNode(self)
		end

}
enumeration ObjectNodeOrderingKind
{
	unordered;
	ordered;
	LIFO;
	FIFO;
}
class OutputPin inherits Pin
{
	/**Output pins may have incoming edges only when they are on actions that are structured nodes, and these edges may not target a node contained by the structured node.
true*/
	operation incoming_edges_structured_only(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Pin is
		do
			result := visitor.visitOutputPin(self)
		end

}
class Pin inherits ObjectNode, MultiplicityElement
{
	/**Tells whether the pins provide data to the actions, or just controls when it executes it.*/
	attribute isControl : Boolean[1..1]

	/**Control pins have a control type
isControl implies isControlType*/
	operation control_pins(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ObjectNode is
		do
			result := visitor.visitPin(self)
		end

}
class InputPin inherits Pin
{
	/**Input pins may have outgoing edges only when they are on actions that are structured nodes, and these edges must target a node contained by the structured node.
true*/
	operation outgoing_edges_structured_only(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Pin is
		do
			result := visitor.visitInputPin(self)
		end

}
abstract class CallAction inherits InvocationAction
{
	/**If true, the call is synchronous and the caller waits for completion of the invoked behavior.
If false, the call is asynchronous and the caller proceeds immediately and does not expect a return values.
*/
	attribute isSynchronous : Boolean[1..1]

	/**A list of output pins where the results of performing the invocation are placed.*/
	attribute ~result : OutputPin[0..*]

	/**Only synchronous call actions can have result pins.
true*/
	operation synchronous_call(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The number and order of argument pins must be the same as the number and order of parameters of the invoked behavior or behavioral feature. Pins are matched to parameters by order.
true*/
	operation number_and_order(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type, ordering, and multiplicity of an argument pin must be the same as the corresponding parameter of the behavior or behavioral feature.
true*/
	operation type_ordering_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InvocationAction is
		do
			result := visitor.visitCallAction(self)
		end

}
abstract class InvocationAction inherits Action
{
	/**Specification of the ordered set of argument values that appears during execution.*/
	attribute argument : InputPin[0..*]

	/**A optional port of the receiver object on which the behavioral feature is invoked.*/
	reference onPort : Port

	/**The onPort must be a port on the receiver object.
true*/
	operation on_port_receiver(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitInvocationAction(self)
		end

}
class SendSignalAction inherits InvocationAction
{
	/**The target object to which the signal is sent.*/
	attribute target : InputPin[1..1]

	/**The type of signal transmitted to the target object.*/
	reference signal : Signal[1..1]

	/**The number and order of argument pins must be the same as the number and order of attributes in the signal.
true*/
	operation number_order(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type, ordering, and multiplicity of an argument pin must be the same as the corresponding attribute of the signal.
true*/
	operation type_ordering_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InvocationAction is
		do
			result := visitor.visitSendSignalAction(self)
		end

}
class CallOperationAction inherits CallAction
{
	/**The operation to be invoked by the action execution.*/
	reference ~operation : Operation[1..1]

	/**The target object to which the request is sent. The classifier of the target object is used to dynamically determine a behavior to invoke. This object constitutes the context of the execution of the operation.*/
	attribute target : InputPin[1..1]

	/**The number of argument pins and the number of owned parameters of the operation of type in and in-out must be equal.
true*/
	operation argument_pin_equal_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The number of result pins and the number of owned parameters of the operation of type return, out, and in-out must be equal.
true*/
	operation result_pin_equal_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the target pin must be the same as the type that owns the operation.
true*/
	operation type_target_pin(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::CallAction is
		do
			result := visitor.visitCallOperationAction(self)
		end

}
class CallBehaviorAction inherits CallAction
{
	/**The invoked behavior. It must be capable of accepting and returning control.*/
	reference behavior : Behavior[1..1]

	/**The number of argument pins and the number of parameters of the behavior of type in and in-out must be equal.
true*/
	operation argument_pin_equal_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The number of result pins and the number of parameters of the behavior of type return, out, and in-out must be equal.
true*/
	operation result_pin_equal_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::CallAction is
		do
			result := visitor.visitCallBehaviorAction(self)
		end

}
class SequenceNode inherits StructuredActivityNode
{
	/**An ordered set of executable nodes.*/
	attribute executableNode : ExecutableNode[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::StructuredActivityNode is
		do
			result := visitor.visitSequenceNode(self)
		end

}
abstract class ControlNode inherits ActivityNode
{
	method accept(visitor : visitors::Visitor) : Void from uml::ActivityNode is
		do
			result := visitor.visitControlNode(self)
		end

}
class ControlFlow inherits ActivityEdge
{
	/**Control flows may not have object nodes at either end, except for object nodes with control type.
true*/
	operation object_nodes(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ActivityEdge is
		do
			result := visitor.visitControlFlow(self)
		end

}
class InitialNode inherits ControlNode
{
	/**An initial node has no incoming edges.
true*/
	operation no_incoming_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Only control edges can have initial nodes as source.
true*/
	operation control_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ControlNode is
		do
			result := visitor.visitInitialNode(self)
		end

}
class ActivityParameterNode inherits ObjectNode
{
	/**The parameter the object node will be accepting or providing values for.*/
	reference parameter : Parameter[1..1]

	/**Activity parameter nodes must have parameters from the containing activity.
true*/
	operation has_parameters(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of an activity parameter node is the same as the type of its parameter.
true*/
	operation same_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An activity parameter node may have all incoming edges or all outgoing edges, but it must not have both incoming and outgoing edges.
true*/
	operation no_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Activity parameter object nodes with no incoming edges and one or more outgoing edges must have a parameter with in or inout direction.

true*/
	operation no_incoming_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Activity parameter object nodes with no outgoing edges and one or more incoming edges must have a parameter with out, inout, or return direction.

true*/
	operation no_outgoing_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ObjectNode is
		do
			result := visitor.visitActivityParameterNode(self)
		end

}
class ValuePin inherits InputPin
{
	/**Value that the pin will provide.*/
	attribute ~value : ValueSpecification[1..1]

	/**The type of value specification must be compatible with the type of the value pin.
true*/
	operation compatible_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Value pins have no incoming edges.
true*/
	operation no_incoming_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InputPin is
		do
			result := visitor.visitValuePin(self)
		end

}
class Message inherits NamedElement
{
	/**The derived kind of the Message (complete, lost, found or unknown)*/
	property messageKind : MessageKind[1..1]
		getter is do
			//TODO: implement getter for derived property messageKind
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property messageKind
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The sort of communication reflected by the Message*/
	attribute messageSort : MessageSort[1..1]

	/**References the Receiving of the Message*/
	reference receiveEvent : MessageEnd

	/**References the Sending of the Message.*/
	reference sendEvent : MessageEnd

	/**The Connector on which this Message is sent.*/
	reference connector : Connector

	/**The enclosing Interaction owning the Message*/
	reference interaction : Interaction[1..1]#message

	/**The arguments of the Message*/
	attribute argument : ValueSpecification[0..*]

	/**The definition of the type or signature of the Message (depending on its kind). The associated named element is derived from the message end that constitutes the sending or receiving message event. If both a sending event and a receiving message event are present, the signature is obtained from the sending event.*/
	property signature : NamedElement
		getter is do
			//TODO: implement getter for derived property signature
			raise kermeta::exceptions::NotImplementedException.new 
		end
		setter is do
			//TODO: implement getter for derived property signature
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**If the sending MessageEvent and the receiving MessageEvent of the same Message are on the same Lifeline, the sending MessageEvent must be ordered before the receiving MessageEvent.
true*/
	operation sending_receiving_message_event(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The signature must either refer an Operation (in which case messageSort is either synchCall or asynchCall) or a Signal (in which case messageSort is asynchSignal). The name of the NamedElement referenced by signature must be the same as that of the Message.
true*/
	operation signature_refer_to(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**In the case when the Message signature is an Operation, the arguments of the Message must correspond to the parameters of the Operation. A Parameter corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.
true*/
	operation signature_is_operation(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**In the case when the Message signature is a Signal, the arguments of the Message must correspond to the attributes of the Signal. A Message Argument corresponds to a Signal Attribute if the Arguement is of the same Class or a specialization of that of the Attribute.
true*/
	operation signature_is_signal(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Arguments of a Message must only be:
i) attributes of the sending lifeline
ii) constants
iii) symbolic values (which are wildcard values representing any legal value)
iv) explicit parameters of the enclosing Interaction
v) attributes of the class owning the Interaction

true*/
	operation arguments(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Messages cannot cross bounderies of CombinedFragments or their operands.
true*/
	operation cannot_cross_boundaries(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If the MessageEnds are both OccurrenceSpecifications then the connector must go between the Parts represented by the Lifelines of the two MessageEnds.
true*/
	operation occurrence_specifications(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	operation getMessageKind() : MessageKind[1..1] is
		abstract

	operation getSignature() : NamedElement is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitMessage(self)
		end

}
enumeration MessageKind
{
	complete;
	lost;
	found;
	unknown;
}
enumeration MessageSort
{
	synchCall;
	asynchCall;
	asynchSignal;
	createMessage;
	deleteMessage;
	reply;
}
abstract class MessageEnd inherits NamedElement
{
	/**References a Message.*/
	reference message : Message

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitMessageEnd(self)
		end

}
class Interaction inherits Behavior, InteractionFragment
{
	/**Specifies the participants in this Interaction.*/
	attribute lifeline : set Lifeline[0..*]#interaction

	/**The ordered set of fragments in the Interaction.*/
	attribute fragment : InteractionFragment[0..*]#enclosingInteraction

	/**Actions owned by the Interaction.*/
	attribute action : set Action[0..*]

	/**Specifies the gates that form the message interface between this Interaction and any InteractionUses which reference it.
*/
	attribute formalGate : set Gate[0..*]

	/**The Messages contained in this Interaction.*/
	attribute message : set Message[0..*]#interaction

	method accept(visitor : visitors::Visitor) : Void from uml::Behavior is
		do
			result := visitor.visitInteraction(self)
		end

}
abstract class InteractionFragment inherits NamedElement
{
	/**References the Lifelines that the InteractionFragment involves.*/
	reference covered : set Lifeline[0..*]#coveredBy

	/**The general ordering relationships contained in this fragment.*/
	attribute generalOrdering : set GeneralOrdering[0..*]

	/**The Interaction enclosing this InteractionFragment.*/
	reference enclosingInteraction : Interaction#fragment

	/**The operand enclosing this InteractionFragment (they may nest recursively)*/
	reference enclosingOperand : InteractionOperand#fragment

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitInteractionFragment(self)
		end

}
class Lifeline inherits NamedElement
{
	/**References the ConnectableElement within the classifier that contains the enclosing interaction.*/
	reference represents : ConnectableElement

	/**References the Interaction enclosing this Lifeline.*/
	reference interaction : Interaction[1..1]#lifeline

	/**If the referenced ConnectableElement is multivalued, then this specifies the specific individual part within that set.*/
	attribute selector : ValueSpecification

	/**References the Interaction that represents the decomposition.*/
	reference decomposedAs : PartDecomposition

	/**References the InteractionFragments in which this Lifeline takes part.*/
	reference coveredBy : set InteractionFragment[0..*]#covered

	/**If two (or more) InteractionUses within one Interaction, refer to Interactions with 'common Lifelines,' those Lifelines must also appear in the Interaction with the InteractionUses. By common Lifelines we mean Lifelines with the same selector and represents associations.
true*/
	operation interaction_uses_share_lifeline(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The selector for a Lifeline must only be specified if the referenced Part is multivalued.
(self.selector->isEmpty() implies not self.represents.isMultivalued()) or
(not self.selector->isEmpty() implies self.represents.isMultivalued())
*/
	operation selector_specified(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The classifier containing the referenced ConnectableElement must be the same classifier, or an ancestor, of the classifier that contains the interaction enclosing this lifeline.
if (represents->notEmpty()) then
(if selector->notEmpty() then represents.isMultivalued() else not represents.isMultivalued())
*/
	operation same_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitLifeline(self)
		end

}
class PartDecomposition inherits InteractionUse
{
	/**PartDecompositions apply only to Parts that are Parts of Internal Structures not to Parts of Collaborations.
true*/
	operation parts_of_internal_structures(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Assume that within Interaction X, Lifeline L is of class C and decomposed to D. Within X there is a sequence of constructs along L (such constructs are CombinedFragments, InteractionUse and (plain) OccurrenceSpecifications). Then a corresponding sequence of constructs must appear within D, matched one-to-one in the same order.

i) CombinedFragment covering L are matched with an extra-global CombinedFragment in D
ii) An InteractionUse covering L are matched with a global (i.e. covering all Lifelines) InteractionUse in D.
iii) A plain OccurrenceSpecification on L is considered an actualGate that must be matched by a formalGate of D

true*/
	operation assume(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Assume that within Interaction X, Lifeline L is of class C and decomposed to D. Assume also that there is within X an
InteractionUse (say) U that covers L. According to the constraint above U will have a counterpart CU within D. Within the Interaction referenced by U, L should also be decomposed, and the decomposition should reference CU. (This rule is called commutativity of decomposition)

true*/
	operation commutativity_of_decomposition(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InteractionUse is
		do
			result := visitor.visitPartDecomposition(self)
		end

}
class InteractionUse inherits InteractionFragment
{
	/**Refers to the Interaction that defines its meaning*/
	reference refersTo : Interaction[1..1]

	/**The actual gates of the InteractionUse*/
	attribute actualGate : set Gate[0..*]

	/**The actual arguments of the Interaction*/
	attribute argument : Action[0..*]

	/**Actual Gates of the InteractionUse must match Formal Gates of the referred Interaction. Gates match when their names are equal.
true*/
	operation gates_match(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The InteractionUse must cover all Lifelines of the enclosing Interaction which appear within the referred Interaction.
true*/
	operation all_lifelines(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The arguments of the InteractionUse must correspond to parameters of the referred Interaction
true*/
	operation arguments_correspond_to_parameters(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The arguments must only be constants, parameters of the enclosing Interaction or attributes of the classifier owning the enclosing Interaction.
true*/
	operation arguments_are_constants(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InteractionFragment is
		do
			result := visitor.visitInteractionUse(self)
		end

}
class Gate inherits MessageEnd
{
	/**The message leading to/from an actualGate of an InteractionUse must correspond to the message leading from/to the formalGate with the same name of the Interaction referenced by the InteractionUse.
true*/
	operation messages_actual_gate(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The message leading to/from an (expression) Gate within a CombinedFragment must correspond to the message leading from/to the CombinedFragment on its outside.
true*/
	operation messages_combined_fragment(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::MessageEnd is
		do
			result := visitor.visitGate(self)
		end

}
class GeneralOrdering inherits NamedElement
{
	/**The OccurrenceSpecification referenced comes before the OccurrenceSpecification referenced by after.*/
	reference before : OccurrenceSpecification[1..1]#toAfter

	/**The OccurrenceSpecification referenced comes after the OccurrenceSpecification referenced by before.*/
	reference after : OccurrenceSpecification[1..1]#toBefore

	method accept(visitor : visitors::Visitor) : Void from uml::NamedElement is
		do
			result := visitor.visitGeneralOrdering(self)
		end

}
class OccurrenceSpecification inherits InteractionFragment
{
	/**References the GeneralOrderings that specify EventOcurrences that must occur before this OccurrenceSpecification
*/
	reference toBefore : set GeneralOrdering[0..*]#after

	/**References a specification of the occurring event.*/
	reference event : Event[1..1]

	/**References the GeneralOrderings that specify EventOcurrences that must occur after this OccurrenceSpecification
*/
	reference toAfter : set GeneralOrdering[0..*]#before

	method accept(visitor : visitors::Visitor) : Void from uml::InteractionFragment is
		do
			result := visitor.visitOccurrenceSpecification(self)
		end

}
class InteractionOperand inherits Namespace, InteractionFragment
{
	/**Constraint of the operand.*/
	attribute guard : InteractionConstraint

	/**The fragments of the operand.*/
	attribute fragment : InteractionFragment[0..*]#enclosingOperand

	/**The guard must be placed directly prior to (above) the OccurrenceSpecification that will become the first OccurrenceSpecification within this InteractionOperand.
true*/
	operation guard_directly_prior(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The guard must contain only references to values local to the Lifeline on which it resides, or values global to the whole Interaction.
true*/
	operation guard_contain_references(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Namespace is
		do
			result := visitor.visitInteractionOperand(self)
		end

}
class InteractionConstraint inherits Constraint
{
	/**The minimum number of iterations of a loop*/
	attribute minint : ValueSpecification

	/**The maximum number of iterations of a loop*/
	attribute maxint : ValueSpecification

	/**The dynamic variables that take part in the constraint must be owned by the ConnectableElement corresponding to the covered Lifeline.
true*/
	operation dynamic_variables(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The constraint may contain references to global data or write-once data.
true*/
	operation global_data(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Minint/maxint can only be present if the InteractionConstraint is associated with the operand of a loop CombinedFragment.
true*/
	operation minint_maxint(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If minint is specified, then the expression must evaluate to a non-negative integer.
true*/
	operation minint_non_negative(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If maxint is specified, then the expression must evaluate to a positive integer.
true*/
	operation maxint_positive(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If maxint is specified, then minint must be specified and the evaluation of maxint must be >= the evaluation of minint
true*/
	operation maxint_greater_equal_minint(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Constraint is
		do
			result := visitor.visitInteractionConstraint(self)
		end

}
abstract class ExecutionSpecification inherits InteractionFragment
{
	/**References the OccurrenceSpecification that designates the start of the Action or Behavior*/
	reference start : OccurrenceSpecification[1..1]

	/**References the OccurrenceSpecification that designates the finish of the Action or Behavior.*/
	reference finish : OccurrenceSpecification[1..1]

	/**The startEvent and the finishEvent must be on the same Lifeline
start.lifeline = finish.lifeline*/
	operation same_lifeline(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InteractionFragment is
		do
			result := visitor.visitExecutionSpecification(self)
		end

}
class StateInvariant inherits InteractionFragment
{
	/**A Constraint that should hold at runtime for this StateInvariant*/
	attribute invariant : Constraint[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::InteractionFragment is
		do
			result := visitor.visitStateInvariant(self)
		end

}
class ActionExecutionSpecification inherits ExecutionSpecification
{
	/**Action whose execution is occurring.*/
	reference action : Action[1..1]

	/**The Action referenced by the ActionExecutionSpecification, if any, must be owned by the Interaction owning the ActionExecutionOccurrence.
true*/
	operation action_referenced(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ExecutionSpecification is
		do
			result := visitor.visitActionExecutionSpecification(self)
		end

}
class BehaviorExecutionSpecification inherits ExecutionSpecification
{
	/**Behavior whose execution is occurring.*/
	reference behavior : Behavior

	method accept(visitor : visitors::Visitor) : Void from uml::ExecutionSpecification is
		do
			result := visitor.visitBehaviorExecutionSpecification(self)
		end

}
class ExecutionEvent inherits Event
{
	method accept(visitor : visitors::Visitor) : Void from uml::Event is
		do
			result := visitor.visitExecutionEvent(self)
		end

}
class CreationEvent inherits Event
{
	/**No othet OccurrenceSpecification may appear above an OccurrenceSpecification which references a CreationEvent on a given Lifeline in an InteractionOperand.
true*/
	operation no_occurrence_above(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Event is
		do
			result := visitor.visitCreationEvent(self)
		end

}
class DestructionEvent inherits Event
{
	/**No other OccurrenceSpecifications may appear below an OccurrenceSpecification which references a DestructionEvent on a given Lifeline in an InteractionOperand.
true*/
	operation no_occurrence_specifications_below(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Event is
		do
			result := visitor.visitDestructionEvent(self)
		end

}
class SendOperationEvent inherits MessageEvent
{
	/**The operation associated with this event.*/
	reference ~operation : Operation[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::MessageEvent is
		do
			result := visitor.visitSendOperationEvent(self)
		end

}
abstract class MessageEvent inherits Event
{
	method accept(visitor : visitors::Visitor) : Void from uml::Event is
		do
			result := visitor.visitMessageEvent(self)
		end

}
class SendSignalEvent inherits MessageEvent
{
	/**The signal associated with this event.*/
	reference signal : Signal[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::MessageEvent is
		do
			result := visitor.visitSendSignalEvent(self)
		end

}
class MessageOccurrenceSpecification inherits OccurrenceSpecification, MessageEnd
{
	method accept(visitor : visitors::Visitor) : Void from uml::OccurrenceSpecification is
		do
			result := visitor.visitMessageOccurrenceSpecification(self)
		end

}
class ExecutionOccurrenceSpecification inherits OccurrenceSpecification
{
	/**References the execution specification describing the execution that is started or finished at this execution event.*/
	reference execution : ExecutionSpecification[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::OccurrenceSpecification is
		do
			result := visitor.visitExecutionOccurrenceSpecification(self)
		end

}
class ReceiveOperationEvent inherits MessageEvent
{
	/**The operation associated with this event.*/
	reference ~operation : Operation[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::MessageEvent is
		do
			result := visitor.visitReceiveOperationEvent(self)
		end

}
class ReceiveSignalEvent inherits MessageEvent
{
	/**The signal associated with this event.*/
	reference signal : Signal[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::MessageEvent is
		do
			result := visitor.visitReceiveSignalEvent(self)
		end

}
class Actor inherits BehavioredClassifier
{
	/**An actor can only have associations to use cases, components and classes. Furthermore these associations must be binary.
self.ownedAttribute->forAll ( a |
(a.association->notEmpty()) implies
((a.association.memberEnd.size() = 2) and
(a.opposite.class.oclIsKindOf(UseCase) or
(a.opposite.class.oclIsKindOf(Class) and not a.opposite.class.oclIsKindOf(Behavior))))
*/
	operation associations(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An actor must have a name.
name->notEmpty()*/
	operation must_have_name(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::BehavioredClassifier is
		do
			result := visitor.visitActor(self)
		end

}
class CallEvent inherits MessageEvent
{
	/**Designates the operation whose invocation raised the call event.*/
	reference ~operation : Operation[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::MessageEvent is
		do
			result := visitor.visitCallEvent(self)
		end

}
class ChangeEvent inherits Event
{
	/**A Boolean-valued expression that will result in a change event whenever its value changes from false to true.*/
	attribute changeExpression : ValueSpecification[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::Event is
		do
			result := visitor.visitChangeEvent(self)
		end

}
class SignalEvent inherits MessageEvent
{
	/**The specific signal that is associated with this event.*/
	reference signal : Signal[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::MessageEvent is
		do
			result := visitor.visitSignalEvent(self)
		end

}
class AnyReceiveEvent inherits MessageEvent
{
	method accept(visitor : visitors::Visitor) : Void from uml::MessageEvent is
		do
			result := visitor.visitAnyReceiveEvent(self)
		end

}
class ForkNode inherits ControlNode
{
	/**A fork node has one incoming edge.
true*/
	operation one_incoming_edge(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The edges coming into and out of a fork node must be either all object flows or all control flows.
true*/
	operation edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ControlNode is
		do
			result := visitor.visitForkNode(self)
		end

}
class FlowFinalNode inherits FinalNode
{
	method accept(visitor : visitors::Visitor) : Void from uml::FinalNode is
		do
			result := visitor.visitFlowFinalNode(self)
		end

}
abstract class FinalNode inherits ControlNode
{
	/**A final node has no outgoing edges.
true*/
	operation no_outgoing_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ControlNode is
		do
			result := visitor.visitFinalNode(self)
		end

}
class CentralBufferNode inherits ObjectNode
{
	method accept(visitor : visitors::Visitor) : Void from uml::ObjectNode is
		do
			result := visitor.visitCentralBufferNode(self)
		end

}
class MergeNode inherits ControlNode
{
	/**A merge node has one outgoing edge.
true*/
	operation one_outgoing_edge(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The edges coming into and out of a merge node must be either all object flows or all control flows.
true*/
	operation edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ControlNode is
		do
			result := visitor.visitMergeNode(self)
		end

}
class DecisionNode inherits ControlNode
{
	/**Provides input to guard specifications on edges outgoing from the decision node.*/
	reference decisionInput : Behavior

	/**A decision node has one incoming edge.
true*/
	operation one_incoming_edge(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A decision input behavior has zero or one input parameter and one output parameter. Any input parameter must be the same as or a supertype of the type of object tokens coming along the incoming edge. The behavior cannot have side effects.
true*/
	operation input_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The edges coming into and out of a decision node must be either all object flows or all control flows.
true*/
	operation edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ControlNode is
		do
			result := visitor.visitDecisionNode(self)
		end

}
class ActivityFinalNode inherits FinalNode
{
	method accept(visitor : visitors::Visitor) : Void from uml::FinalNode is
		do
			result := visitor.visitActivityFinalNode(self)
		end

}
class ComponentRealization inherits Realization
{
	/**The Component that owns this ComponentRealization and which is implemented by its realizing classifiers.*/
	reference abstraction : Component#realization

	/**A classifier that is involved in the implementation of the Component that owns this ComponentRealization.*/
	reference realizingClassifier : Classifier[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::Realization is
		do
			result := visitor.visitComponentRealization(self)
		end

}
class Component inherits Class, Namespace
{
	/**The kind of instantiation that applies to a Component. If false, the component is instantiated as an addressable object. If true, the Component is defined at design-time, but at runtime (or execution-time) an object specified by the Component does not exist, that is, the component is instantiated indirectly, through the instantiation of its realizing classifiers or parts. Several standard stereotypes use this meta attribute, e.g. <<specification>>, <<focus>>, <<subsystem>>.*/
	attribute isIndirectlyInstantiated : Boolean[1..1]

	/**The interfaces that the component requires from other components in its environment in order to be able to offer its full set of provided functionality. These interfaces may be Used by the Component or any of its realizingClassifiers, or they may be the Interfaces that are required by its public Ports.*/
	property required : set Interface[0..*]
		getter is do
			//TODO: implement getter for derived property required
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**The interfaces that the component exposes to its environment. These interfaces may be Realized by the Component or any of its realizingClassifiers, or they may be the Interfaces that are provided by its public Ports.*/
	property provided : set Interface[0..*]
		getter is do
			//TODO: implement getter for derived property provided
			raise kermeta::exceptions::NotImplementedException.new 
		end
		
	/**The set of PackageableElements that a Component owns. In the namespace of a component, all model elements that are involved in or related to its definition may be owned or imported explicitly. These may include e.g. Classes, Interfaces, Components, Packages, Use cases, Dependencies (e.g. mappings), and Artifacts.*/
	attribute packagedElement : set PackageableElement[0..*]

	/**The set of Realizations owned by the Component. Realizations reference the Classifiers of which the Component is an abstraction; i.e., that realize its behavior.*/
	attribute realization : set ComponentRealization[0..*]#abstraction

	/**Creates a(n) (abstract) class with the specified name as a packaged element of this component.*/
	operation createOwnedClass(name : String[1..1], isAbstract : Boolean[1..1]) : Class[1..1] is
		abstract

	/**Creates a enumeration with the specified name as a packaged element of this component.*/
	operation createOwnedEnumeration(name : String[1..1]) : Enumeration[1..1] is
		abstract

	/**Creates a primitive type with the specified name as a packaged element of this component.*/
	operation createOwnedPrimitiveType(name : String[1..1]) : PrimitiveType[1..1] is
		abstract

	/**Creates an interface with the specified name as a packaged element of this component.*/
	operation createOwnedInterface(name : String[1..1]) : Interface[1..1] is
		abstract

	/**Utility returning the set of realized interfaces of a component:
result = (classifier.clientDependency->
select(dependency|dependency.oclIsKindOf(Realization) and dependency.supplier.oclIsKindOf(Interface)))->
collect(dependency|dependency.client)*/
	operation realizedInterfaces(classifier : Classifier[1..1]) : set Interface[0..*] is
		abstract

	/**Utility returning the set of used interfaces of a component:
result = (classifier.supplierDependency->
select(dependency|dependency.oclIsKindOf(Usage) and dependency.supplier.oclIsKindOf(interface)))->
collect(dependency|dependency.supplier)*/
	operation usedInterfaces(classifier : Classifier[1..1]) : set Interface[0..*] is
		abstract

	/**result = let usedInterfaces = UsedInterfaces(self) and
  let realizingClassifierUsedInterfaces = UsedInterfaces(self.realizingClassifier) and
  let typesOfUsedPorts = self.ownedPort.required in
    ((usedInterfaces->union(realizingClassifierUsedInterfaces))->
      union(typesOfUsedPorts))->asSet()*/
	operation getRequireds() : set Interface[0..*] is
		abstract

	/**result = let implementedInterfaces = self.implementation->collect(impl|impl.contract) and
  let realizedInterfaces = RealizedInterfaces(self) and
  let realizingClassifierInterfaces = RealizedInterfaces(self.realizingClassifier) and
  let typesOfRequiredPorts = self.ownedPort.provided in
    (((implementedInterfaces->union(realizedInterfaces)->union(realizingClassifierInterfaces))->
      union(typesOfRequiredPorts))->asSet()*/
	operation getProvideds() : set Interface[0..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Class is
		do
			result := visitor.visitComponent(self)
		end

}
class Node inherits Class, DeploymentTarget
{
	/**The Nodes that are defined (nested) within the Node.*/
	attribute nestedNode : set Node[0..*]

	/**The internal structure of a Node (if defined) consists solely of parts of type Node.
true*/
	operation internal_structure(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Class is
		do
			result := visitor.visitNode(self)
		end

}
class Device inherits Node
{
	method accept(visitor : visitors::Visitor) : Void from uml::Node is
		do
			result := visitor.visitDevice(self)
		end

}
class ExecutionEnvironment inherits Node
{
	method accept(visitor : visitors::Visitor) : Void from uml::Node is
		do
			result := visitor.visitExecutionEnvironment(self)
		end

}
class CommunicationPath inherits Association
{
	method accept(visitor : visitors::Visitor) : Void from uml::Association is
		do
			result := visitor.visitCommunicationPath(self)
		end

}
class CombinedFragment inherits InteractionFragment
{
	/**Specifies the operation which defines the semantics of this combination of InteractionFragments.*/
	attribute interactionOperator : InteractionOperatorKind[1..1]

	/**The set of operands of the combined fragment.*/
	attribute operand : InteractionOperand[1..*]

	/**Specifies the gates that form the interface between this CombinedFragment and its surroundings*/
	attribute cfragmentGate : set Gate[0..*]

	/**If the interactionOperator is opt, loop, break, or neg there must be exactly one operand
true*/
	operation opt_loop_break_neg(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The InteractionConstraint with minint and maxint only apply when attached to an InteractionOperand where the interactionOperator is loop.
true*/
	operation minint_and_maxint(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If the interactionOperator is break, the corresponding InteractionOperand must cover all Lifelines within the enclosing InteractionFragment.
true*/
	operation break(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The interaction operators 'consider' and 'ignore' can only be used for the CombineIgnoreFragment subtype of CombinedFragment
((interactionOperator = #consider) or (interactionOperator = #ignore)) implies oclsisTypeOf(CombineIgnoreFragment)*/
	operation consider_and_ignore(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InteractionFragment is
		do
			result := visitor.visitCombinedFragment(self)
		end

}
enumeration InteractionOperatorKind
{
	~seq;
	alt;
	opt;
	break;
	par;
	strict;
	~loop;
	critical;
	neg;
	assert;
	ignore;
	consider;
}
class Continuation inherits InteractionFragment
{
	/**True: when the Continuation is at the end of the enclosing InteractionFragment and False when it is in the beginning.*/
	attribute setting : Boolean[1..1]

	/**Continuations with the same name may only cover the same set of Lifelines (within one Classifier).
true*/
	operation same_name(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Continuations are always global in the enclosing InteractionFragment e.g. it always covers all Lifelines covered by the enclosing InteractionFragment.
true*/
	operation global(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Continuations always occur as the very first InteractionFragment or the very last InteractionFragment of the enclosing InteractionFragment.
true*/
	operation first_or_last_interaction_fragment(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InteractionFragment is
		do
			result := visitor.visitContinuation(self)
		end

}
class ConsiderIgnoreFragment inherits CombinedFragment
{
	/**The set of messages that apply to this fragment*/
	reference message : set NamedElement[0..*]

	/**The interaction operator of a ConsiderIgnoreFragment must be either 'consider' or 'ignore'.
(interactionOperator = #consider) or (interactionOperator = #ignore)*/
	operation consider_or_ignore(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The NamedElements must be of a type of element that identifies a message (e.g., an Operation, Reception, or a Signal).
message->forAll(m | m.oclIsKindOf(Operation) or m.oclIsKindOf(Reception) or m.oclIsKindOf(Signal))*/
	operation type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::CombinedFragment is
		do
			result := visitor.visitConsiderIgnoreFragment(self)
		end

}
class CreateObjectAction inherits Action
{
	/**Classifier to be instantiated.*/
	reference classifier : Classifier[1..1]

	/**Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

	/**The classifier cannot be abstract.
not (self.classifier.isAbstract = #true)*/
	operation classifier_not_abstract(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The classifier cannot be an association class
not self.classifier.oclIsKindOf(AssociationClass)*/
	operation classifier_not_association_class(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the result pin must be the same as the classifier of the action.
self.result.type = self.classifier*/
	operation same_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the output pin is 1..1.
self.result.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitCreateObjectAction(self)
		end

}
class DestroyObjectAction inherits Action
{
	/**Specifies whether links in which the object participates are destroyed along with the object.*/
	attribute isDestroyLinks : Boolean[1..1]

	/**Specifies whether objects owned by the object are destroyed along with the object.*/
	attribute isDestroyOwnedObjects : Boolean[1..1]

	/**The input pin providing the object to be destroyed.*/
	attribute target : InputPin[1..1]

	/**The multiplicity of the input pin is 1..1.
self.target.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The input pin has no type.
self.target.type->size() = 0*/
	operation no_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitDestroyObjectAction(self)
		end

}
class TestIdentityAction inherits Action
{
	/**Gives the pin on which an object is placed.*/
	attribute first : InputPin[1..1]

	/**Gives the pin on which an object is placed.*/
	attribute second : InputPin[1..1]

	/**Tells whether the two input objects are identical.*/
	attribute ~result : OutputPin[1..1]

	/**The input pins have no type.
self.first.type->size() = 0
and self.second.type->size() = 0
*/
	operation no_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the input pins is 1..1.
self.first.multiplicity.is(1,1)
and self.second.multiplicity.is(1,1)
*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the result is Boolean.
self.result.type.oclIsTypeOf(Boolean)*/
	operation result_is_boolean(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitTestIdentityAction(self)
		end

}
class ReadSelfAction inherits Action
{
	/**Gives the output pin on which the hosting object is placed.*/
	attribute ~result : OutputPin[1..1]

	/**The action must be contained in an behavior that has a host classifier.
self.context->size() = 1*/
	operation contained(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If the action is contained in an behavior that is acting as the body of a method, then the operation of the method must not be static.
true*/
	operation not_static(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the result output pin is the host classifier.
self.result.type = self.context*/
	operation type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the result output pin is 1..1.
self.result.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitReadSelfAction(self)
		end

}
abstract class StructuralFeatureAction inherits Action
{
	/**Structural feature to be read.*/
	reference structuralFeature : StructuralFeature[1..1]

	/**Gives the input pin from which the object whose structural feature is to be read or written is obtained.
*/
	attribute object : InputPin[1..1]

	/**The structural feature must not be static.
self.structuralFeature.isStatic = #false*/
	operation not_static(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the object input pin is the same as the classifier of the object passed on this pin.
true*/
	operation same_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the input pin must be 1..1.
self.object.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Visibility of structural feature must allow access to the object performing the action.
let host : Classifier = self.context in
self.structuralFeature.visibility = #public
or host = self.structuralFeature.featuringClassifier.type
or (self.structuralFeature.visibility = #protected and host.allSupertypes
->includes(self.structuralFeature.featuringClassifier.type)))
*/
	operation op_visibility(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A structural feature has exactly one featuringClassifier.
self.structuralFeature.featuringClassifier->size() = 1*/
	operation one_featuring_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitStructuralFeatureAction(self)
		end

}
class ReadStructuralFeatureAction inherits StructuralFeatureAction
{
	/**Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

	/**The type and ordering of the result output pin are the same as the type and ordering of the structural feature.
self.result.type = self.structuralFeature.type
and self.result.ordering = self.structuralFeature.ordering
*/
	operation type_and_ordering(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::StructuralFeatureAction is
		do
			result := visitor.visitReadStructuralFeatureAction(self)
		end

}
abstract class WriteStructuralFeatureAction inherits StructuralFeatureAction
{
	/**Value to be added or removed from the structural feature.*/
	attribute ~value : InputPin[1..1]

	/**The type input pin is the same as the classifier of the structural feature.
self.value.type = self.structuralFeature.featuringClassifier*/
	operation input_pin(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::StructuralFeatureAction is
		do
			result := visitor.visitWriteStructuralFeatureAction(self)
		end

}
class ClearStructuralFeatureAction inherits StructuralFeatureAction
{
	method accept(visitor : visitors::Visitor) : Void from uml::StructuralFeatureAction is
		do
			result := visitor.visitClearStructuralFeatureAction(self)
		end

}
class RemoveStructuralFeatureValueAction inherits WriteStructuralFeatureAction
{
	/**Specifies whether to remove duplicates of the value in nonunique structural features.*/
	attribute isRemoveDuplicates : Boolean[1..1]

	/**Specifies the position of an existing value to remove in ordered nonunique structural features. The type of the pin is UnlimitedNatural, but the value cannot be zero or unlimited.*/
	attribute removeAt : InputPin

	/**Actions removing a value from ordered nonunique structural features must have a single removeAt input pin if isRemoveDuplicates is false. It must be of type Unlimited Natural with multiplicity 1..1. Otherwise, the action has no removeAt input pin.

true*/
	operation non_unique_removal(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::WriteStructuralFeatureAction is
		do
			result := visitor.visitRemoveStructuralFeatureValueAction(self)
		end

}
class AddStructuralFeatureValueAction inherits WriteStructuralFeatureAction
{
	/**Specifies whether existing values of the structural feature of the object should be removed before adding the new value.*/
	attribute isReplaceAll : Boolean[1..1]

	/**Gives the position at which to insert a new value or move an existing value in ordered structural features. The type of the pin is UnlimitedNatural, but the value cannot be zero. This pin is omitted for unordered structural features.*/
	attribute insertAt : InputPin

	/**Actions adding a value to ordered structural features must have a single input pin for the insertion point with type UnlimitedNatural and multiplicity of 1..1, otherwise the action has no input pin for the insertion point.
let insertAtPins : Collection = self.insertAt in
if self.structuralFeature.isOrdered = #false
then insertAtPins->size() = 0
else let insertAtPin : InputPin= insertAt->asSequence()->first() in
insertAtPins->size() = 1
and insertAtPin.type = UnlimitedNatural
and insertAtPin.multiplicity.is(1,1))
endif
*/
	operation unlimited_natural_and_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::WriteStructuralFeatureAction is
		do
			result := visitor.visitAddStructuralFeatureValueAction(self)
		end

}
abstract class LinkAction inherits Action
{
	/**Data identifying one end of a link by the objects on its ends and qualifiers.*/
	attribute endData : set LinkEndData[2..*]

	/**Pins taking end objects and qualifier values as input.*/
	attribute inputValue : set InputPin[1..*]

	/**The association ends of the link end data must all be from the same association and include all and only the association ends of that association.
self.endData->collect(end) = self.association()->collect(connection))*/
	operation same_association(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The association ends of the link end data must not be static.
self.endData->forall(end.oclisKindOf(NavigableEnd) implies end.isStatic = #false*/
	operation not_static(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The input pins of the action are the same as the pins of the link end data and insertion pins.
self.input->asSet() =
let ledpins : Set = self.endData->collect(value) in
if self.oclIsKindOf(LinkEndCreationData)
then ledpins->union(self.endData.oclAsType(LinkEndCreationData).insertAt)
else ledpins
*/
	operation same_pins(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The association operates on LinkAction. It returns the association of the action.
result = self.endData->asSequence().first().end.association*/
	operation association() : Association[1..1] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitLinkAction(self)
		end

}
class LinkEndData inherits Element
{
	/**Input pin that provides the specified object for the given end. This pin is omitted if the link-end data specifies an 'open' end for reading.*/
	reference ~value : InputPin

	/**Association end for which this link-end data specifies values.*/
	reference ~end : Property[1..1]

	/**List of qualifier values*/
	attribute qualifier : set QualifierValue[0..*]

	/**The property must be an association end.
self.end.association->size() = 1*/
	operation property_is_association_end(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the end object input pin is the same as the type of the association end.
self.value.type = self.end.type*/
	operation same_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the end object input pin must be 1..1.
self.value.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The qualifiers include all and only the qualifiers of the association end.
self.qualifier->collect(qualifier) = self.end.qualifier*/
	operation qualifiers(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The end object input pin is not also a qualifier value input pin.
self.value->excludesAll(self.qualifier.value)*/
	operation end_object_input_pin(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitLinkEndData(self)
		end

}
class QualifierValue inherits Element
{
	/**Attribute representing the qualifier for which the value is to be specified.*/
	reference qualifier : Property[1..1]

	/**Input pin from which the specified value for the qualifier is taken.*/
	reference ~value : InputPin[1..1]

	/**The qualifier attribute must be a qualifier of the association end of the link-end data.
self.LinkEndData.end->collect(qualifier)->includes(self.qualifier)*/
	operation qualifier_attribute(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the qualifier value input pin is the same as the type of the qualifier attribute.
self.value.type = self.qualifier.type*/
	operation type_of_qualifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the qualifier value input pin is "1..1".
self.value.multiplicity.is(1,1)*/
	operation multiplicity_of_qualifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitQualifierValue(self)
		end

}
class ReadLinkAction inherits LinkAction
{
	/**The pin on which are put the objects participating in the association at the end not specified by the inputs.
*/
	attribute ~result : OutputPin[1..1]

	/**Exactly one link-end data specification (the 'open' end) must not have an end object input pin.
self.endData->select(ed | ed.value->size() = 0)->size() = 1*/
	operation one_open_end(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type and ordering of the result output pin are same as the type and ordering of the open association end.
let openend : AssociationEnd = self.endData->select(ed | ed.value->size() = 0)->asSequence()->first().end in
self.result.type = openend.type
and self.result.ordering = openend.ordering
*/
	operation type_and_ordering(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the open association end must be compatible with the multiplicity of the result output pin.
let openend : AssociationEnd = self.endData->select(ed | ed.value->size() = 0)->asSequence()->first().end in
openend.multiplicity.compatibleWith(self.result.multiplicity)
*/
	operation compatible_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The open end must be navigable.
let openend : AssociationEnd = self.endData->select(ed | ed.value->size() = 0)->asSequence()->first().end in
openend.isNavigable()
*/
	operation navigable_open_end(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Visibility of the open end must allow access to the object performing the action.
let host : Classifier = self.context in
let openend : AssociationEnd = self.endData->select(ed | ed.value->size() = 0)->asSequence()->first().end in
openend.visibility = #public
or self.endData->exists(oed | not oed.end = openend
and (host = oed.end.participant
or (openend.visibility = #protected
and host.allSupertypes->includes(oed.end.participant))))
*/
	operation op_visibility(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::LinkAction is
		do
			result := visitor.visitReadLinkAction(self)
		end

}
class LinkEndCreationData inherits LinkEndData
{
	/**Specifies whether the existing links emanating from the object on this end should be destroyed before creating a new link.*/
	attribute isReplaceAll : Boolean[1..1]

	/**Specifies where the new link should be inserted for ordered association ends, or where an existing link should be moved to. The type of the input is UnlimitedNatural, but the input cannot be zero. This pin is omitted for association ends that are not ordered.*/
	reference insertAt : InputPin

	/**LinkEndCreationData can only be end data for CreateLinkAction or one of its specializations.
self.LinkAction.oclIsKindOf(CreateLinkAction)*/
	operation create_link_action(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Link end creation data for ordered association ends must have a single input pin for the insertion point with type UnlimitedNatural and multiplicity of 1..1, otherwise the action has no input pin for the insertion point.
let insertAtPins : Collection = self.insertAt in
if self.end.ordering = #unordered
then insertAtPins->size() = 0
else let insertAtPin : InputPin = insertAts->asSequence()->first() in
insertAtPins->size() = 1
and insertAtPin.type = UnlimitedNatural
and insertAtPin.multiplicity.is(1,1))
endif
*/
	operation single_input_pin(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::LinkEndData is
		do
			result := visitor.visitLinkEndCreationData(self)
		end

}
class CreateLinkAction inherits WriteLinkAction
{
	/**The association cannot be an abstract classifier.
self.association().isAbstract = #false*/
	operation association_not_abstract(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::WriteLinkAction is
		do
			result := visitor.visitCreateLinkAction(self)
		end

}
abstract class WriteLinkAction inherits LinkAction
{
	/**The visibility of at least one end must allow access to the class using the action.
true*/
	operation allow_access(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::LinkAction is
		do
			result := visitor.visitWriteLinkAction(self)
		end

}
class DestroyLinkAction inherits WriteLinkAction
{
	method accept(visitor : visitors::Visitor) : Void from uml::WriteLinkAction is
		do
			result := visitor.visitDestroyLinkAction(self)
		end

}
class LinkEndDestructionData inherits LinkEndData
{
	/**Specifies whether to destroy duplicates of the value in nonunique association ends.*/
	attribute isDestroyDuplicates : Boolean[1..1]

	/**Specifies the position of an existing link to be destroyed in ordered nonunique association ends. The type of the pin is UnlimitedNatural, but the value cannot be zero or unlimited.*/
	reference destroyAt : InputPin

	/**LinkEndDestructionData can only be end data for DestroyLinkAction or one of its specializations.
true*/
	operation destroy_link_action(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**LinkEndDestructionData for ordered nonunique association ends must have a single destroyAt input pin if isDestroyDuplicates is false. It must be of type UnlimitedNatural and have a multiplicity of 1..1. Otherwise, the action has no input pin for the removal position.
true*/
	operation unlimited_natural_and_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::LinkEndData is
		do
			result := visitor.visitLinkEndDestructionData(self)
		end

}
class ClearAssociationAction inherits Action
{
	/**Gives the input pin from which is obtained the object whose participation in the association is to be cleared.*/
	attribute object : InputPin[1..1]

	/**Association to be cleared.*/
	reference association : Association[1..1]

	/**The type of the input pin must be the same as the type of at least one of the association ends of the association.
self.association->exists(end.type = self.object.type)*/
	operation same_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the input pin is 1..1.
self.object.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitClearAssociationAction(self)
		end

}
class BroadcastSignalAction inherits InvocationAction
{
	/**The specification of signal object transmitted to the target objects.*/
	reference signal : Signal[1..1]

	/**The number and order of argument pins must be the same as the number and order of attributes in the signal.
true*/
	operation number_and_order(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type, ordering, and multiplicity of an argument pin must be the same as the corresponding attribute of the signal.
true*/
	operation type_ordering_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InvocationAction is
		do
			result := visitor.visitBroadcastSignalAction(self)
		end

}
class SendObjectAction inherits InvocationAction
{
	/**The target object to which the object is sent.*/
	attribute target : InputPin[1..1]

	/**The request object, which is transmitted to the target object. The object may be copied in transmission, so identity might not be preserved.*/
	attribute request : InputPin[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::InvocationAction is
		do
			result := visitor.visitSendObjectAction(self)
		end

}
class ValueSpecificationAction inherits Action
{
	/**Value specification to be evaluated.*/
	attribute ~value : ValueSpecification[1..1]

	/**Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

	/**The type of value specification must be compatible with the type of the result pin.
true*/
	operation compatible_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the result pin is 1..1
true*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitValueSpecificationAction(self)
		end

}
class TimeExpression inherits ValueSpecification
{
	/**The value of the time expression.*/
	reference expr : ValueSpecification

	/**Refers to the time and duration observations that are involved in expr.*/
	reference observation : set Observation[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::ValueSpecification is
		do
			result := visitor.visitTimeExpression(self)
		end

}
abstract class Observation inherits PackageableElement
{
	method accept(visitor : visitors::Visitor) : Void from uml::PackageableElement is
		do
			result := visitor.visitObservation(self)
		end

}
class Duration inherits ValueSpecification
{
	/**The value of the Duration.*/
	reference expr : ValueSpecification

	/**Refers to the time and duration observations that are involved in expr.*/
	reference observation : set Observation[0..*]

	method accept(visitor : visitors::Visitor) : Void from uml::ValueSpecification is
		do
			result := visitor.visitDuration(self)
		end

}
class DurationInterval inherits Interval
{
	method accept(visitor : visitors::Visitor) : Void from uml::Interval is
		do
			result := visitor.visitDurationInterval(self)
		end

}
class Interval inherits ValueSpecification
{
	/**Refers to the ValueSpecification denoting the minimum value of the range.*/
	reference min : ValueSpecification[1..1]

	/**Refers to the ValueSpecification denoting the maximum value of the range.*/
	reference max : ValueSpecification[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::ValueSpecification is
		do
			result := visitor.visitInterval(self)
		end

}
class TimeConstraint inherits IntervalConstraint
{
	/**The value of firstEvent is related to constrainedElement. If firstEvent is true, then the corresponding observation event is the first time instant the execution enters constrainedElement. If firstEvent is false, then the corresponding observation event is the last time instant the execution is within constrainedElement.*/
	attribute firstEvent : Boolean

	method accept(visitor : visitors::Visitor) : Void from uml::IntervalConstraint is
		do
			result := visitor.visitTimeConstraint(self)
		end

}
class IntervalConstraint inherits Constraint
{
	method accept(visitor : visitors::Visitor) : Void from uml::Constraint is
		do
			result := visitor.visitIntervalConstraint(self)
		end

}
class TimeInterval inherits Interval
{
	method accept(visitor : visitors::Visitor) : Void from uml::Interval is
		do
			result := visitor.visitTimeInterval(self)
		end

}
class DurationConstraint inherits IntervalConstraint
{
	/**The value of firstEvent[i] is related to constrainedElement[i] (where i is 1 or 2). If firstEvent[i] is true, then the corresponding observation event is the first time instant the execution enters constrainedElement[i]. If firstEvent[i] is false, then the corresponding observation event is the last time instant the execution is within constrainedElement[i]. Default value is true applied when constrainedElement[i] refers an element that represents only one time instant.*/
	attribute firstEvent : set Boolean[0..2]

	/**The multiplicity of firstEvent must be 2 if the multiplicity of constrainedElement is 2. Otherwise the multiplicity of firstEvent is 0.
if (constrainedElement->size() =2)
  then (firstEvent->size() = 2) else (firstEvent->size() = 0)*/
	operation first_event_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::IntervalConstraint is
		do
			result := visitor.visitDurationConstraint(self)
		end

}
class TimeObservation inherits Observation
{
	/**The observation is determined by the entering or exiting of the event element during execution.*/
	reference event : NamedElement[1..1]

	/**The value of firstEvent is related to event. If firstEvent is true, then the corresponding observation event is the first time instant the execution enters event. If firstEvent is false, then the corresponding observation event is the time instant the execution exits event.*/
	attribute firstEvent : Boolean[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::Observation is
		do
			result := visitor.visitTimeObservation(self)
		end

}
class DurationObservation inherits Observation
{
	/**The observation is determined by the entering or exiting of the event element during execution.*/
	reference event : set NamedElement[1..2]

	/**The value of firstEvent[i] is related to event[i] (where i is 1 or 2). If firstEvent[i] is true, then the corresponding observation event is the first time instant the execution enters event[i]. If firstEvent[i] is false, then the corresponding observation event is the time instant the execution exits event[i]. Default value is true applied when event[i] refers an element that represents only one time instant.*/
	attribute firstEvent : set Boolean[0..2]

	/**The multiplicity of firstEvent must be 2 if the multiplicity of event is 2. Otherwise the multiplicity of firstEvent is 0.
if (event->size() = 2)
  then (firstEvent->size() = 2) else (firstEvent->size() = 0)*/
	operation first_event_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Observation is
		do
			result := visitor.visitDurationObservation(self)
		end

}
class FinalState inherits State
{
	/**A final state cannot have any outgoing transitions.
self.outgoing->size() = 0*/
	operation no_outgoing_transitions(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A final state cannot have regions.
self.region->size() = 0*/
	operation no_regions(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A final state cannot reference a submachine.
self.submachine->isEmpty()*/
	operation cannot_reference_submachine(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A final state has no entry behavior.
self.entry->isEmpty()*/
	operation no_entry_behavior(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A final state has no exit behavior.
self.exit->isEmpty()*/
	operation no_exit_behavior(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A final state has no state (doActivity) behavior.
self.doActivity->isEmpty()*/
	operation no_state_behavior(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::State is
		do
			result := visitor.visitFinalState(self)
		end

}
class TimeEvent inherits Event
{
	/**Specifies whether it is relative or absolute time.*/
	attribute isRelative : Boolean[1..1]

	/**Specifies the corresponding time deadline.*/
	attribute when : ValueSpecification[1..1]

	/**The ValueSpecification when must return a non-negative Integer.
true*/
	operation when_non_negative(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The starting time for a relative time event may only be omitted for a time event that is the trigger of a state machine.
true*/
	operation starting_time(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Event is
		do
			result := visitor.visitTimeEvent(self)
		end

}
abstract class VariableAction inherits Action
{
	/**Variable to be read.*/
	reference variable : Variable[1..1]

	/**The action must be in the scope of the variable.
self.variable.isAccessibleBy(self)*/
	operation scope_of_variable(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitVariableAction(self)
		end

}
class ReadVariableAction inherits VariableAction
{
	/**Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

	/**The type and ordering of the result output pin of a read-variable action are the same as the type and ordering of the variable.
self.result.type =self.variable.type
and self.result.ordering = self.variable.ordering
*/
	operation type_and_ordering(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the variable must be compatible with the multiplicity of the output pin.
self.variable.multiplicity.compatibleWith(self.result.multiplicity)*/
	operation compatible_multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::VariableAction is
		do
			result := visitor.visitReadVariableAction(self)
		end

}
abstract class WriteVariableAction inherits VariableAction
{
	/**Value to be added or removed from the variable.*/
	attribute ~value : InputPin[1..1]

	/**The type input pin is the same as the type of the variable.
self.value.type = self.variable.type*/
	operation same_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the input pin is 1..1.
self.value.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::VariableAction is
		do
			result := visitor.visitWriteVariableAction(self)
		end

}
class ClearVariableAction inherits VariableAction
{
	method accept(visitor : visitors::Visitor) : Void from uml::VariableAction is
		do
			result := visitor.visitClearVariableAction(self)
		end

}
class AddVariableValueAction inherits WriteVariableAction
{
	/**Specifies whether existing values of the variable should be removed before adding the new value.*/
	attribute isReplaceAll : Boolean[1..1]

	/**Gives the position at which to insert a new value or move an existing value in ordered variables. The types is UnlimitedINatural, but the value cannot be zero. This pin is omitted for unordered variables.*/
	attribute insertAt : InputPin

	/**Actions adding values to ordered variables must have a single input pin for the insertion point with type UnlimtedNatural and multiplicity of 1..1, otherwise the action has no input pin for the insertion point.
let insertAtPins : Collection = self.insertAt in
if self.variable.ordering = #unordered
then insertAtPins->size() = 0
else let insertAtPin : InputPin = insertAt->asSequence()->first() in
insertAtPins->size() = 1
and insertAtPin.type = UnlimitedNatural
and insertAtPin.multiplicity.is(1,1))
endif
*/
	operation single_input_pin(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::WriteVariableAction is
		do
			result := visitor.visitAddVariableValueAction(self)
		end

}
class RemoveVariableValueAction inherits WriteVariableAction
{
	/**Specifies whether to remove duplicates of the value in nonunique variables.*/
	attribute isRemoveDuplicates : Boolean[1..1]

	/**Specifies the position of an existing value to remove in ordered nonunique variables. The type of the pin is UnlimitedNatural, but the value cannot be zero or unlimited.*/
	attribute removeAt : InputPin

	/**Actions removing a value from ordered nonunique variables must have a single removeAt input pin if isRemoveDuplicates is false. It must be of type UnlimitedNatural with multiplicity of 1..1, otherwise the action has no removeAt input pin.
true*/
	operation unlimited_natural(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::WriteVariableAction is
		do
			result := visitor.visitRemoveVariableValueAction(self)
		end

}
class RaiseExceptionAction inherits Action
{
	/**An input pin whose value becomes an exception object.*/
	attribute exception : InputPin[1..1]

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitRaiseExceptionAction(self)
		end

}
class ActionInputPin inherits InputPin
{
	/**The action used to provide values.*/
	attribute fromAction : Action[1..1]

	/**The fromAction of an action input pin must have exactly one output pin.
true*/
	operation one_output_pin(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The fromAction of an action input pin must only have action input pins as input pins.
true*/
	operation input_pin(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The fromAction of an action input pin cannot have control or data flows coming into or out of it or its pins.
true*/
	operation no_control_or_data_flow(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::InputPin is
		do
			result := visitor.visitActionInputPin(self)
		end

}
class InformationItem inherits Classifier
{
	/**Determines the classifiers that will specify the structure and nature of the information. An information item represents all its represented classifiers.*/
	reference represented : set Classifier[0..*]

	/**The sources and targets of an information item (its related information flows) must designate subsets of the sources and targets of the representation information item, if any.The Classifiers that can realize an information item can only be of the following kind: Class, Interface, InformationItem, Signal, Component.
(self.represented->select(p | p->oclIsKindOf(InformationItem))->forAll(p |
  p.informationFlow.source->forAll(q | self.informationFlow.source->include(q)) and
    p.informationFlow.target->forAll(q | self.informationFlow.target->include(q)))) and
      (self.represented->forAll(p | p->oclIsKindOf(Class) or oclIsKindOf(Interface) or
        oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component)))*/
	operation sources_and_targets(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An informationItem has no feature, no generalization, and no associations.
self.generalization->isEmpty() and self.feature->isEmpty()*/
	operation has_no(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**It is not instantiable.
isAbstract*/
	operation not_instantiable(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Classifier is
		do
			result := visitor.visitInformationItem(self)
		end

}
class InformationFlow inherits PackageableElement, DirectedRelationship
{
	/**Determines which Relationship will realize the specified flow*/
	reference realization : set Relationship[0..*]

	/**Specifies the information items that may circulate on this information flow.*/
	reference conveyed : set Classifier[1..*]

	/**Defines from which source the conveyed InformationItems are initiated.*/
	reference informationSource : set NamedElement[1..*]

	/**Defines to which target the conveyed InformationItems are directed.*/
	reference informationTarget : set NamedElement[1..*]

	/**Determines which ActivityEdges will realize the specified flow.*/
	reference realizingActivityEdge : set ActivityEdge[0..*]

	/**Determines which Connectors will realize the specified flow.*/
	reference realizingConnector : set Connector[0..*]

	/**Determines which Messages will realize the specified flow.*/
	reference realizingMessage : set Message[0..*]

	/**The sources and targets of the information flow can only be one of the following kind: Actor, Node, UseCase, Artifact, Class, Component, Port, Property, Interface, Package, ActivityNode, ActivityPartition and InstanceSpecification except when its classifier is a relationship (i.e. it represents a link).
(self.source->forAll(p | p->oclIsKindOf(Actor) or oclIsKindOf(Node) or
  oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or oclIsKindOf(Class) or
  oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or
  oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or
  oclIsKindOf(ActivityPartition) or oclIsKindOf(InstanceSpecification))) and
    (self.target->forAll(p | p->oclIsKindOf(Actor) or oclIsKindOf(Node) or
      oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or oclIsKindOf(Class) or
      oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or
      oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or
      oclIsKindOf(ActivityPartition) or oclIsKindOf(InstanceSpecification)))*/
	operation sources_and_targets_kind(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The sources and targets of the information flow must conform with the sources and targets or conversely the targets and sources of the realization relationships.
true*/
	operation must_conform(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An information flow can only convey classifiers that are allowed to represent an information item.

self.conveyed.represented->forAll(p | p->oclIsKindOf(Class) or oclIsKindOf(Interface)
  or oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component))*/
	operation convey_classifiers(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::PackageableElement is
		do
			result := visitor.visitInformationFlow(self)
		end

}
class ReadExtentAction inherits Action
{
	/**The runtime instances of the classifier.*/
	attribute ~result : OutputPin[1..1]

	/**The classifier whose instances are to be retrieved.*/
	reference classifier : Classifier[1..1]

	/**The type of the result output pin is the classifier.
true*/
	operation type_is_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the result output pin is 0..*.
self.result.multiplicity.is(0,#null)*/
	operation multiplicity_of_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitReadExtentAction(self)
		end

}
class ReclassifyObjectAction inherits Action
{
	/**Specifies whether existing classifiers should be removed before adding the new classifiers.*/
	attribute isReplaceAll : Boolean[1..1]

	/**A set of classifiers to be removed from the classifiers of the object.*/
	reference oldClassifier : set Classifier[0..*]

	/**A set of classifiers to be added to the classifiers of the object.*/
	reference newClassifier : set Classifier[0..*]

	/**Holds the object to be reclassified.*/
	attribute object : InputPin[1..1]

	/**None of the new classifiers may be abstract.
not self.newClassifier->exists(isAbstract = true)*/
	operation classifier_not_abstract(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the input pin is 1..1.
self.argument.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The input pin has no type.
self.argument.type->size() = 0*/
	operation input_pin(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitReclassifyObjectAction(self)
		end

}
class ReadIsClassifiedObjectAction inherits Action
{
	/**Indicates whether the classifier must directly classify the input object.*/
	attribute isDirect : Boolean[1..1]

	/**The classifier against which the classification of the input object is tested.*/
	reference classifier : Classifier[1..1]

	/**After termination of the action, will hold the result of the test.*/
	attribute ~result : OutputPin[1..1]

	/**Holds the object whose classification is to be tested.*/
	attribute object : InputPin[1..1]

	/**The multiplicity of the input pin is 1..1.
self.object.multiplicity.is(1,1)*/
	operation multiplicity_of_input(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The input pin has no type.
self.object.type->isEmpty()*/
	operation no_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the output pin is 1..1.
self.result.multiplicity.is(1,1)*/
	operation multiplicity_of_output(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the output pin is Boolean
self.result.type = Boolean*/
	operation boolean_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitReadIsClassifiedObjectAction(self)
		end

}
class StartClassifierBehaviorAction inherits Action
{
	/**Holds the object on which to start the owned behavior.*/
	attribute object : InputPin[1..1]

	/**The multiplicity of the input pin is 1..1
true*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If the input pin has a type, then the type must have a classifier behavior.
true*/
	operation type_has_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitStartClassifierBehaviorAction(self)
		end

}
class ReadLinkObjectEndAction inherits Action
{
	/**Gives the input pin from which the link object is obtained.*/
	attribute object : InputPin[1..1]

	/**Link end to be read.*/
	reference ~end : Property[1..1]

	/**Pin where the result value is placed.*/
	attribute ~result : OutputPin[1..1]

	/**The property must be an association end.
self.end.association.notEmpty()*/
	operation ~property(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The association of the association end must be an association class.
self.end.Association.oclIsKindOf(AssociationClass)*/
	operation association_of_association(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The ends of the association must not be static.
self.end.association.memberEnd->forall(e | not e.isStatic)*/
	operation ends_of_association(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the object input pin is the association class that owns the association end.
self.object.type = self.end.association*/
	operation type_of_object(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the object input pin is 1..1.
self.object.multiplicity.is(1,1)*/
	operation multiplicity_of_object(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the result output pin is the same as the type of the association end.
self.result.type = self.end.type*/
	operation type_of_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the result output pin is 1..1.
self.result.multiplicity.is(1,1)*/
	operation multiplicity_of_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitReadLinkObjectEndAction(self)
		end

}
class ReadLinkObjectEndQualifierAction inherits Action
{
	/**Gives the input pin from which the link object is obtained.*/
	attribute object : InputPin[1..1]

	/**Pin where the result value is placed.*/
	attribute ~result : OutputPin[1..1]

	/**The attribute representing the qualifier to be read.*/
	reference qualifier : Property[1..1]

	/**The qualifier attribute must be a qualifier attribute of an association end.
self.qualifier.associationEnd->size() = 1*/
	operation qualifier_attribute(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The association of the association end of the qualifier attribute must be an association class.
self.qualifier.associationEnd.association.oclIsKindOf(AssociationClass)*/
	operation association_of_association(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The ends of the association must not be static.
self.qualifier.associationEnd.association.memberEnd->forall(e | not e.isStatic)*/
	operation ends_of_association(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the object input pin is the association class that owns the association end that has the given qualifier attribute.
self.object.type = self.qualifier.associationEnd.association*/
	operation type_of_object(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the qualifier attribute is 1..1.
self.qualifier.multiplicity.is(1,1)*/
	operation multiplicity_of_qualifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the object input pin is 1..1.
self.object.multiplicity.is(1,1)*/
	operation multiplicity_of_object(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the result output pin is the same as the type of the qualifier attribute.
self.result.type = self.qualifier.type*/
	operation same_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the result output pin is 1..1.
self.result.multiplicity.is(1,1)*/
	operation multiplicity_of_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitReadLinkObjectEndQualifierAction(self)
		end

}
class CreateLinkObjectAction inherits CreateLinkAction
{
	/**Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

	/**The association must be an association class.
self.association().oclIsKindOf(Class)*/
	operation association_class(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the result pin must be the same as the association of the action.
self.result.type = self.association()*/
	operation type_of_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the output pin is 1..1.
self.result.multiplicity.is(1,1)*/
	operation multiplicity(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::CreateLinkAction is
		do
			result := visitor.visitCreateLinkObjectAction(self)
		end

}
class AcceptEventAction inherits Action
{
	/**Indicates whether there is a single output pin for the event, or multiple output pins for attributes of the event.*/
	attribute isUnmarshall : Boolean[1..1]

	/**Pins holding the received event objects or their attributes. Event objects may be copied in transmission, so identity might not be preserved.*/
	attribute ~result : set OutputPin[0..*]

	/**The type of events accepted by the action, as specified by triggers. For triggers with signal events, a signal of the specified type or any subtype of the specified signal type is accepted.*/
	attribute trigger : set Trigger[1..*]

	/**AcceptEventActions may have no input pins.
true*/
	operation no_input_pins(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**There are no output pins if the trigger events are only ChangeEvents, or if they are only CallEvents when this action is an instance of AcceptEventAction and not an instance of a descendant of AcceptEventAction (such as AcceptCallAction).
true*/
	operation no_output_pins(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If the trigger events are all TimeEvents, there is exactly one output pin.
true*/
	operation trigger_events(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If isUnmarshall is true, there must be exactly one trigger for events of type SignalEvent. The number of result output pins must be the same as the number of attributes of the signal. The type and ordering of each result output pin must be the same as the corresponding attribute of the signal. The multiplicity of each result output pin must be compatible with the multiplicity of the corresponding attribute.
true*/
	operation unmarshall_signal_events(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitAcceptEventAction(self)
		end

}
class AcceptCallAction inherits AcceptEventAction
{
	/**Pin where a value is placed containing sufficient information to perform a subsequent reply and return control to the caller. The contents of this value are opaque. It can be passed and copied but it cannot be manipulated by the model.*/
	attribute returnInformation : OutputPin[1..1]

	/**The result pins must match the in and inout parameters of the operation specified by the trigger event in number, type, and order.
true*/
	operation result_pins(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The trigger event must be a CallEvent.
trigger.event.oclIsKindOf(CallEvent)*/
	operation trigger_call_event(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**isUnmrashall must be true for an AcceptCallAction.
isUnmarshall = true*/
	operation unmarshall(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::AcceptEventAction is
		do
			result := visitor.visitAcceptCallAction(self)
		end

}
class ReplyAction inherits Action
{
	/**The trigger specifying the operation whose call is being replied to.*/
	reference replyToCall : Trigger[1..1]

	/**A pin containing the return information value produced by an earlier AcceptCallAction.*/
	attribute returnInformation : InputPin[1..1]

	/**A list of pins containing the reply values of the operation. These values are returned to the caller.*/
	attribute replyValue : set InputPin[0..*]

	/**The reply value pins must match the return, out, and inout parameters of the operation on the event on the trigger in number, type, and order.
true*/
	operation pins_match_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The event on replyToCall trigger must be a CallEvent replyToCallEvent.oclIsKindOf(CallEvent)
replyToCallEvent.oclIsKindOf(CallEvent)*/
	operation event_on_reply_to_call_trigger(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitReplyAction(self)
		end

}
class UnmarshallAction inherits Action
{
	/**The values of the structural features of the input object.*/
	attribute ~result : set OutputPin[1..*]

	/**The type of the object to be unmarshalled.*/
	reference unmarshallType : Classifier[1..1]

	/**The object to be unmarshalled.*/
	attribute object : InputPin[1..1]

	/**The type of the object input pin must be the same as the unmarshall classifier.
true*/
	operation same_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of the object input pin is 1..1
true*/
	operation multiplicity_of_object(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The number of result output pins must be the same as the number of structural features of the unmarshall classifier.
true*/
	operation number_of_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type and ordering of each result output pin must be the same as the corresponding structural feature of the unmarshall classifier.
true*/
	operation type_and_ordering(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The multiplicity of each result output pin must be compatible with the multiplicity of the corresponding structural features of the unmarshall classifier.

true*/
	operation multiplicity_of_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The unmarshall classifier must have at least one structural feature.
true*/
	operation structural_feature(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**unmarshallType must be a Classifier with ordered attributes
true*/
	operation unmarshallType_is_classifier(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitUnmarshallAction(self)
		end

}
class ReduceAction inherits Action
{
	/**Behavior that is applied to two elements of the input collection to produce a value that is the same type as elements of the collection.*/
	reference reducer : Behavior[1..1]

	/**Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

	/**The collection to be reduced.*/
	attribute collection : InputPin[1..1]

	/**Tells whether the order of the input collection should determine the order in which the behavior is applied to its elements.*/
	attribute isOrdered : Boolean[1..1]

	/**The type of the input must be a collection.
true*/
	operation input_type_is_collection(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The type of the output must be compatible with the type of the output of the reducer behavior.
true*/
	operation output_types_are_compatible(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The reducer behavior must have two input parameters and one output parameter, of types compatible with the types of elements of the input collection.
true*/
	operation reducer_inputs_output(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Action is
		do
			result := visitor.visitReduceAction(self)
		end

}
class JoinNode inherits ControlNode
{
	/**Tells whether tokens having objects with the same identity are combined into one by the join.*/
	attribute isCombineDuplicate : Boolean[1..1]

	/**A specification giving the conditions under which the join with emit a token. Default is "and".*/
	attribute joinSpec : ValueSpecification[1..1]

	/**A join node has one outgoing edge.
self.outgoing->size() = 1*/
	operation one_outgoing_edge(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a join node has an incoming object flow, it must have an outgoing object flow, otherwise, it must have an outgoing control flow.
(self.incoming.select(e | e.isTypeOf(ObjectFlow)->notEmpty() implies
  self.outgoing.isTypeOf(ObjectFlow)) and
    (self.incoming.select(e | e.isTypeOf(ObjectFlow)->empty() implies
      self.outgoing.isTypeOf(ControlFlow))*/
	operation incoming_object_flow(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ControlNode is
		do
			result := visitor.visitJoinNode(self)
		end

}
class DataStoreNode inherits CentralBufferNode
{
	method accept(visitor : visitors::Visitor) : Void from uml::CentralBufferNode is
		do
			result := visitor.visitDataStoreNode(self)
		end

}
class ObjectFlow inherits ActivityEdge
{
	/**Tells whether the objects in the flow are passed by multicasting.*/
	attribute isMulticast : Boolean[1..1]

	/**Tells whether the objects in the flow are gathered from respondents to multicasting.*/
	attribute isMultireceive : Boolean[1..1]

	/**Changes or replaces data tokens flowing along edge.*/
	reference transformation : Behavior

	/**Selects tokens from a source object node.*/
	reference selection : Behavior

	/**Object flows may not have actions at either end.
true*/
	operation no_actions(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Object nodes connected by an object flow, with optionally intervening control nodes, must have compatible types. In particular, the downstream object node type must be the same or a supertype of the upstream object node type.

true*/
	operation compatible_types(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**Object nodes connected by an object flow, with optionally intervening control nodes, must have the same upper bounds.
true*/
	operation same_upper_bounds(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An edge with constant weight may not target an object node, or lead to an object node downstream with no intervening actions, that has an upper bound less than the weight.
true*/
	operation op_target(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A transformation behavior has one input parameter and one output parameter. The input parameter must be the same as or a supertype of the type of object token coming from the source end. The output parameter must be the same or a subtype of the type of object token expected downstream. The behavior cannot have side effects.
true*/
	operation transformation_behaviour(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**An object flow may have a selection behavior only if has an object node as a source.
true*/
	operation selection_behaviour(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A selection behavior has one input parameter and one output parameter. The input parameter must be a bag of elements of the same as or a supertype of the type of source object node. The output parameter must be the same or a subtype of the type of source object node. The behavior cannot have side effects.
true*/
	operation input_and_output_parameter(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**isMulticast and isMultireceive cannot both be true.
true*/
	operation is_multicast_or_is_multireceive(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::ActivityEdge is
		do
			result := visitor.visitObjectFlow(self)
		end

}
class ConditionalNode inherits StructuredActivityNode
{
	/**If true, the modeler asserts that at most one test will succeed.*/
	attribute isDeterminate : Boolean[1..1]

	/**If true, the modeler asserts that at least one test will succeed.*/
	attribute isAssured : Boolean[1..1]

	/**Set of clauses composing the conditional.*/
	attribute clause : set Clause[1..*]

	/**A list of output pins that constitute the data flow outputs of the conditional.*/
	attribute ~result : OutputPin[0..*]

	/**The result output pins have no incoming edges.
true*/
	operation result_no_incoming(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::StructuredActivityNode is
		do
			result := visitor.visitConditionalNode(self)
		end

}
class Clause inherits Element
{
	/**A nested activity fragment with a designated output pin that specifies the result of the test.*/
	reference test : set ExecutableNode[0..*]

	/**A nested activity fragment that is executed if the test evaluates to true and the clause is chosen over any concurrent clauses that also evaluate to true.*/
	reference body : set ExecutableNode[0..*]

	/**A set of clauses whose tests must all evaluate false before the current clause can be tested.*/
	reference predecessorClause : set Clause[0..*]#successorClause

	/**A set of clauses which may not be tested unless the current clause tests false.*/
	reference successorClause : set Clause[0..*]#predecessorClause

	/**An output pin within the test fragment the value of which is examined after execution of the test to determine whether the body should be executed.*/
	reference decider : OutputPin[1..1]

	/**A list of output pins within the body fragment whose values are moved to the result pins of the containing conditional node after execution of the clause body.*/
	reference bodyOutput : OutputPin[0..*]

	/**The decider output pin must be for the test body or a node contained by the test body as a structured node.
true*/
	operation decider_output(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The bodyOutput pins are output pins on actions in the body of the clause.
true*/
	operation body_output_pins(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Element is
		do
			result := visitor.visitClause(self)
		end

}
class LoopNode inherits StructuredActivityNode
{
	/**If true, the test is performed before the first execution of the body.
If false, the body is executed once before the test is performed.
*/
	attribute isTestedFirst : Boolean[1..1]

	/**The set of nodes and edges that perform the repetitive computations of the loop. The body section is executed as long as the test section produces a true value.*/
	reference bodyPart : set ExecutableNode[0..*]

	/**The set of nodes and edges that initialize values or perform other setup computations for the loop.*/
	reference setupPart : set ExecutableNode[0..*]

	/**An output pin within the test fragment the value of which is examined after execution of the test to determine whether to execute the loop body.*/
	reference decider : OutputPin[1..1]

	/**The set of nodes, edges, and designated value that compute a Boolean value to determine if another execution of the body will be performed.*/
	reference test : set ExecutableNode[0..*]

	/**A list of output pins that constitute the data flow output of the entire loop.*/
	attribute ~result : OutputPin[0..*]

	/**A list of output pins that hold the values of the loop variables during an execution of the loop. When the test fails, the values are movied to the result pins of the loop.*/
	reference loopVariable : OutputPin[0..*]

	/**A list of output pins within the body fragment the values of which are moved to the loop variable pins after completion of execution of the body, before the next iteration of the loop begins or before the loop exits.*/
	reference bodyOutput : OutputPin[0..*]

	/**A list of values that are moved into the loop variable pins before the first iteration of the loop.*/
	attribute loopVariableInput : InputPin[0..*]

	/**Loop variable inputs must not have outgoing edges.
true*/
	operation input_edges(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The bodyOutput pins are output pins on actions in the body of the loop node.
true*/
	operation body_output_pins(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The result output pins have no incoming edges.
true*/
	operation result_no_incoming(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::StructuredActivityNode is
		do
			result := visitor.visitLoopNode(self)
		end

}
class ExpansionNode inherits ObjectNode
{
	/**The expansion region for which the node is an output.*/
	reference regionAsOutput : ExpansionRegion#outputElement

	/**The expansion region for which the node is an input.*/
	reference regionAsInput : ExpansionRegion#inputElement

	method accept(visitor : visitors::Visitor) : Void from uml::ObjectNode is
		do
			result := visitor.visitExpansionNode(self)
		end

}
class ExpansionRegion inherits StructuredActivityNode
{
	/**The way in which the executions interact:
parallel: all interactions are independent
iterative: the interactions occur in order of the elements
stream: a stream of values flows into a single execution
*/
	attribute mode : ExpansionKind[1..1]

	/**An object node that holds a separate element of the input collection during each of the multiple executions of the region.*/
	reference inputElement : set ExpansionNode[1..*]#regionAsInput

	/**An object node that accepts a separate element of the output collection during each of the multiple executions of the region. The values are formed into a collection that is available when the execution of the region is complete.*/
	reference outputElement : set ExpansionNode[0..*]#regionAsOutput

	/**An ExpansionRegion must have one or more argument ExpansionNodes and zero or more result ExpansionNodes.
true*/
	operation expansion_nodes(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::StructuredActivityNode is
		do
			result := visitor.visitExpansionRegion(self)
		end

}
enumeration ExpansionKind
{
	parallel;
	iterative;
	stream;
}
class ProtocolTransition inherits Transition
{
	/**Specifies the post condition of the transition which is the condition that should be obtained once the transition is triggered. This post condition is part of the post condition of the operation connected to the transition.
*/
	reference postCondition : Constraint

	/**This association refers to the associated operation. It is derived from the operation of the call trigger when applicable.*/
	property referred : set Operation[0..*]
		getter is do
			//TODO: implement getter for derived property referred
			raise kermeta::exceptions::NotImplementedException.new 
		end

	/**Specifies the precondition of the transition. It specifies the condition that should be verified before triggering the transition. This guard condition added to the source state will be evaluated as part of the precondition of the operation referred by the transition if any.*/
	reference preCondition : Constraint

	/**A protocol transition always belongs to a protocol state machine.
container.belongsToPSM()*/
	operation belongs_to_psm(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**A protocol transition never has associated actions.
effect->isEmpty()*/
	operation associated_actions(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**If a protocol transition refers to an operation (i. e. has a call trigger corresponding to an operation), then that operation should apply to the context classifier of the state machine of the protocol transition.
true*/
	operation refers_to_operation(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Transition is
		do
			result := visitor.visitProtocolTransition(self)
		end

}
class AssociationClass inherits Class, Association
{
	/**An AssociationClass cannot be defined between itself and something else.
self.endType->excludes(self) and self.endType>collect(et|et.allparents()->excludes(self))*/
	operation cannot_be_defined(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : ecore::EBoolean is
		abstract

	/**The operation allConnections results in the set of all AssociationEnds of the Association.
result = memberEnd->union ( self.parents ()->collect (p | p.allConnections () )*/
	operation allConnections() : set Property[2..*] is
		abstract

	method accept(visitor : visitors::Visitor) : Void from uml::Class is
		do
			result := visitor.visitAssociationClass(self)
		end

}
package visitors
{
	abstract class Visitable
	{
		operation accept(visitor : Visitor) : Void is
			do
			end

	}
	abstract class Visitor
	{
		operation visit(visitable : Visitable) : Void is
			do
			end

		operation visitComment(visitable : Comment) : Void is
			do
			end

		operation visitElement(visitable : Element) : Void is
			do
			end

		operation visitPackage(visitable : Package) : Void is
			do
			end

		operation visitPackageableElement(visitable : PackageableElement) : Void is
			do
			end

		operation visitNamedElement(visitable : NamedElement) : Void is
			do
			end

		operation visitDependency(visitable : Dependency) : Void is
			do
			end

		operation visitDirectedRelationship(visitable : DirectedRelationship) : Void is
			do
			end

		operation visitRelationship(visitable : Relationship) : Void is
			do
			end

		operation visitNamespace(visitable : Namespace) : Void is
			do
			end

		operation visitElementImport(visitable : ElementImport) : Void is
			do
			end

		operation visitPackageImport(visitable : PackageImport) : Void is
			do
			end

		operation visitConstraint(visitable : Constraint) : Void is
			do
			end

		operation visitValueSpecification(visitable : ValueSpecification) : Void is
			do
			end

		operation visitTypedElement(visitable : TypedElement) : Void is
			do
			end

		operation visitType(visitable : Type) : Void is
			do
			end

		operation visitAssociation(visitable : Association) : Void is
			do
			end

		operation visitClassifier(visitable : Classifier) : Void is
			do
			end

		operation visitRedefinableElement(visitable : RedefinableElement) : Void is
			do
			end

		operation visitTemplateableElement(visitable : TemplateableElement) : Void is
			do
			end

		operation visitTemplateBinding(visitable : TemplateBinding) : Void is
			do
			end

		operation visitTemplateSignature(visitable : TemplateSignature) : Void is
			do
			end

		operation visitTemplateParameter(visitable : TemplateParameter) : Void is
			do
			end

		operation visitParameterableElement(visitable : ParameterableElement) : Void is
			do
			end

		operation visitTemplateParameterSubstitution(visitable : TemplateParameterSubstitution) : Void is
			do
			end

		operation visitGeneralization(visitable : Generalization) : Void is
			do
			end

		operation visitGeneralizationSet(visitable : GeneralizationSet) : Void is
			do
			end

		operation visitFeature(visitable : Feature) : Void is
			do
			end

		operation visitSubstitution(visitable : Substitution) : Void is
			do
			end

		operation visitRealization(visitable : Realization) : Void is
			do
			end

		operation visitAbstraction(visitable : Abstraction) : Void is
			do
			end

		operation visitOpaqueExpression(visitable : OpaqueExpression) : Void is
			do
			end

		operation visitParameter(visitable : Parameter) : Void is
			do
			end

		operation visitMultiplicityElement(visitable : MultiplicityElement) : Void is
			do
			end

		operation visitConnectableElement(visitable : ConnectableElement) : Void is
			do
			end

		operation visitConnectableElementTemplateParameter(visitable : ConnectableElementTemplateParameter) : Void is
			do
			end

		operation visitConnectorEnd(visitable : ConnectorEnd) : Void is
			do
			end

		operation visitProperty(visitable : Property) : Void is
			do
			end

		operation visitDeploymentTarget(visitable : DeploymentTarget) : Void is
			do
			end

		operation visitDeployment(visitable : Deployment) : Void is
			do
			end

		operation visitDeployedArtifact(visitable : DeployedArtifact) : Void is
			do
			end

		operation visitDeploymentSpecification(visitable : DeploymentSpecification) : Void is
			do
			end

		operation visitArtifact(visitable : Artifact) : Void is
			do
			end

		operation visitManifestation(visitable : Manifestation) : Void is
			do
			end

		operation visitOperation(visitable : Operation) : Void is
			do
			end

		operation visitBehavioralFeature(visitable : BehavioralFeature) : Void is
			do
			end

		operation visitBehavior(visitable : Behavior) : Void is
			do
			end

		operation visitClass(visitable : Class) : Void is
			do
			end

		operation visitBehavioredClassifier(visitable : BehavioredClassifier) : Void is
			do
			end

		operation visitInterfaceRealization(visitable : InterfaceRealization) : Void is
			do
			end

		operation visitInterface(visitable : Interface) : Void is
			do
			end

		operation visitReception(visitable : Reception) : Void is
			do
			end

		operation visitSignal(visitable : Signal) : Void is
			do
			end

		operation visitProtocolStateMachine(visitable : ProtocolStateMachine) : Void is
			do
			end

		operation visitStateMachine(visitable : StateMachine) : Void is
			do
			end

		operation visitRegion(visitable : Region) : Void is
			do
			end

		operation visitVertex(visitable : Vertex) : Void is
			do
			end

		operation visitTransition(visitable : Transition) : Void is
			do
			end

		operation visitTrigger(visitable : Trigger) : Void is
			do
			end

		operation visitEvent(visitable : Event) : Void is
			do
			end

		operation visitPort(visitable : Port) : Void is
			do
			end

		operation visitState(visitable : State) : Void is
			do
			end

		operation visitConnectionPointReference(visitable : ConnectionPointReference) : Void is
			do
			end

		operation visitPseudostate(visitable : Pseudostate) : Void is
			do
			end

		operation visitProtocolConformance(visitable : ProtocolConformance) : Void is
			do
			end

		operation visitEncapsulatedClassifier(visitable : EncapsulatedClassifier) : Void is
			do
			end

		operation visitStructuredClassifier(visitable : StructuredClassifier) : Void is
			do
			end

		operation visitConnector(visitable : Connector) : Void is
			do
			end

		operation visitExtension(visitable : Extension) : Void is
			do
			end

		operation visitExtensionEnd(visitable : ExtensionEnd) : Void is
			do
			end

		operation visitStereotype(visitable : Stereotype) : Void is
			do
			end

		operation visitImage(visitable : Image) : Void is
			do
			end

		operation visitProfile(visitable : Profile) : Void is
			do
			end

		operation visitModel(visitable : Model) : Void is
			do
			end

		operation visitParameterSet(visitable : ParameterSet) : Void is
			do
			end

		operation visitDataType(visitable : DataType) : Void is
			do
			end

		operation visitOperationTemplateParameter(visitable : OperationTemplateParameter) : Void is
			do
			end

		operation visitStructuralFeature(visitable : StructuralFeature) : Void is
			do
			end

		operation visitCollaborationUse(visitable : CollaborationUse) : Void is
			do
			end

		operation visitCollaboration(visitable : Collaboration) : Void is
			do
			end

		operation visitUseCase(visitable : UseCase) : Void is
			do
			end

		operation visitInclude(visitable : Include) : Void is
			do
			end

		operation visitExtend(visitable : Extend) : Void is
			do
			end

		operation visitExtensionPoint(visitable : ExtensionPoint) : Void is
			do
			end

		operation visitRedefinableTemplateSignature(visitable : RedefinableTemplateSignature) : Void is
			do
			end

		operation visitClassifierTemplateParameter(visitable : ClassifierTemplateParameter) : Void is
			do
			end

		operation visitStringExpression(visitable : StringExpression) : Void is
			do
			end

		operation visitExpression(visitable : Expression) : Void is
			do
			end

		operation visitUsage(visitable : Usage) : Void is
			do
			end

		operation visitPackageMerge(visitable : PackageMerge) : Void is
			do
			end

		operation visitProfileApplication(visitable : ProfileApplication) : Void is
			do
			end

		operation visitEnumeration(visitable : Enumeration) : Void is
			do
			end

		operation visitEnumerationLiteral(visitable : EnumerationLiteral) : Void is
			do
			end

		operation visitInstanceSpecification(visitable : InstanceSpecification) : Void is
			do
			end

		operation visitSlot(visitable : Slot) : Void is
			do
			end

		operation visitPrimitiveType(visitable : PrimitiveType) : Void is
			do
			end

		operation visitLiteralSpecification(visitable : LiteralSpecification) : Void is
			do
			end

		operation visitLiteralInteger(visitable : LiteralInteger) : Void is
			do
			end

		operation visitLiteralString(visitable : LiteralString) : Void is
			do
			end

		operation visitLiteralBoolean(visitable : LiteralBoolean) : Void is
			do
			end

		operation visitLiteralNull(visitable : LiteralNull) : Void is
			do
			end

		operation visitInstanceValue(visitable : InstanceValue) : Void is
			do
			end

		operation visitLiteralUnlimitedNatural(visitable : LiteralUnlimitedNatural) : Void is
			do
			end

		operation visitOpaqueBehavior(visitable : OpaqueBehavior) : Void is
			do
			end

		operation visitFunctionBehavior(visitable : FunctionBehavior) : Void is
			do
			end

		operation visitOpaqueAction(visitable : OpaqueAction) : Void is
			do
			end

		operation visitAction(visitable : Action) : Void is
			do
			end

		operation visitExecutableNode(visitable : ExecutableNode) : Void is
			do
			end

		operation visitActivityNode(visitable : ActivityNode) : Void is
			do
			end

		operation visitStructuredActivityNode(visitable : StructuredActivityNode) : Void is
			do
			end

		operation visitActivityGroup(visitable : ActivityGroup) : Void is
			do
			end

		operation visitActivity(visitable : Activity) : Void is
			do
			end

		operation visitVariable(visitable : Variable) : Void is
			do
			end

		operation visitActivityEdge(visitable : ActivityEdge) : Void is
			do
			end

		operation visitActivityPartition(visitable : ActivityPartition) : Void is
			do
			end

		operation visitInterruptibleActivityRegion(visitable : InterruptibleActivityRegion) : Void is
			do
			end

		operation visitExceptionHandler(visitable : ExceptionHandler) : Void is
			do
			end

		operation visitObjectNode(visitable : ObjectNode) : Void is
			do
			end

		operation visitOutputPin(visitable : OutputPin) : Void is
			do
			end

		operation visitPin(visitable : Pin) : Void is
			do
			end

		operation visitInputPin(visitable : InputPin) : Void is
			do
			end

		operation visitCallAction(visitable : CallAction) : Void is
			do
			end

		operation visitInvocationAction(visitable : InvocationAction) : Void is
			do
			end

		operation visitSendSignalAction(visitable : SendSignalAction) : Void is
			do
			end

		operation visitCallOperationAction(visitable : CallOperationAction) : Void is
			do
			end

		operation visitCallBehaviorAction(visitable : CallBehaviorAction) : Void is
			do
			end

		operation visitSequenceNode(visitable : SequenceNode) : Void is
			do
			end

		operation visitControlNode(visitable : ControlNode) : Void is
			do
			end

		operation visitControlFlow(visitable : ControlFlow) : Void is
			do
			end

		operation visitInitialNode(visitable : InitialNode) : Void is
			do
			end

		operation visitActivityParameterNode(visitable : ActivityParameterNode) : Void is
			do
			end

		operation visitValuePin(visitable : ValuePin) : Void is
			do
			end

		operation visitMessage(visitable : Message) : Void is
			do
			end

		operation visitMessageEnd(visitable : MessageEnd) : Void is
			do
			end

		operation visitInteraction(visitable : Interaction) : Void is
			do
			end

		operation visitInteractionFragment(visitable : InteractionFragment) : Void is
			do
			end

		operation visitLifeline(visitable : Lifeline) : Void is
			do
			end

		operation visitPartDecomposition(visitable : PartDecomposition) : Void is
			do
			end

		operation visitInteractionUse(visitable : InteractionUse) : Void is
			do
			end

		operation visitGate(visitable : Gate) : Void is
			do
			end

		operation visitGeneralOrdering(visitable : GeneralOrdering) : Void is
			do
			end

		operation visitOccurrenceSpecification(visitable : OccurrenceSpecification) : Void is
			do
			end

		operation visitInteractionOperand(visitable : InteractionOperand) : Void is
			do
			end

		operation visitInteractionConstraint(visitable : InteractionConstraint) : Void is
			do
			end

		operation visitExecutionSpecification(visitable : ExecutionSpecification) : Void is
			do
			end

		operation visitStateInvariant(visitable : StateInvariant) : Void is
			do
			end

		operation visitActionExecutionSpecification(visitable : ActionExecutionSpecification) : Void is
			do
			end

		operation visitBehaviorExecutionSpecification(visitable : BehaviorExecutionSpecification) : Void is
			do
			end

		operation visitExecutionEvent(visitable : ExecutionEvent) : Void is
			do
			end

		operation visitCreationEvent(visitable : CreationEvent) : Void is
			do
			end

		operation visitDestructionEvent(visitable : DestructionEvent) : Void is
			do
			end

		operation visitSendOperationEvent(visitable : SendOperationEvent) : Void is
			do
			end

		operation visitMessageEvent(visitable : MessageEvent) : Void is
			do
			end

		operation visitSendSignalEvent(visitable : SendSignalEvent) : Void is
			do
			end

		operation visitMessageOccurrenceSpecification(visitable : MessageOccurrenceSpecification) : Void is
			do
			end

		operation visitExecutionOccurrenceSpecification(visitable : ExecutionOccurrenceSpecification) : Void is
			do
			end

		operation visitReceiveOperationEvent(visitable : ReceiveOperationEvent) : Void is
			do
			end

		operation visitReceiveSignalEvent(visitable : ReceiveSignalEvent) : Void is
			do
			end

		operation visitActor(visitable : Actor) : Void is
			do
			end

		operation visitCallEvent(visitable : CallEvent) : Void is
			do
			end

		operation visitChangeEvent(visitable : ChangeEvent) : Void is
			do
			end

		operation visitSignalEvent(visitable : SignalEvent) : Void is
			do
			end

		operation visitAnyReceiveEvent(visitable : AnyReceiveEvent) : Void is
			do
			end

		operation visitForkNode(visitable : ForkNode) : Void is
			do
			end

		operation visitFlowFinalNode(visitable : FlowFinalNode) : Void is
			do
			end

		operation visitFinalNode(visitable : FinalNode) : Void is
			do
			end

		operation visitCentralBufferNode(visitable : CentralBufferNode) : Void is
			do
			end

		operation visitMergeNode(visitable : MergeNode) : Void is
			do
			end

		operation visitDecisionNode(visitable : DecisionNode) : Void is
			do
			end

		operation visitActivityFinalNode(visitable : ActivityFinalNode) : Void is
			do
			end

		operation visitComponentRealization(visitable : ComponentRealization) : Void is
			do
			end

		operation visitComponent(visitable : Component) : Void is
			do
			end

		operation visitNode(visitable : Node) : Void is
			do
			end

		operation visitDevice(visitable : Device) : Void is
			do
			end

		operation visitExecutionEnvironment(visitable : ExecutionEnvironment) : Void is
			do
			end

		operation visitCommunicationPath(visitable : CommunicationPath) : Void is
			do
			end

		operation visitCombinedFragment(visitable : CombinedFragment) : Void is
			do
			end

		operation visitContinuation(visitable : Continuation) : Void is
			do
			end

		operation visitConsiderIgnoreFragment(visitable : ConsiderIgnoreFragment) : Void is
			do
			end

		operation visitCreateObjectAction(visitable : CreateObjectAction) : Void is
			do
			end

		operation visitDestroyObjectAction(visitable : DestroyObjectAction) : Void is
			do
			end

		operation visitTestIdentityAction(visitable : TestIdentityAction) : Void is
			do
			end

		operation visitReadSelfAction(visitable : ReadSelfAction) : Void is
			do
			end

		operation visitStructuralFeatureAction(visitable : StructuralFeatureAction) : Void is
			do
			end

		operation visitReadStructuralFeatureAction(visitable : ReadStructuralFeatureAction) : Void is
			do
			end

		operation visitWriteStructuralFeatureAction(visitable : WriteStructuralFeatureAction) : Void is
			do
			end

		operation visitClearStructuralFeatureAction(visitable : ClearStructuralFeatureAction) : Void is
			do
			end

		operation visitRemoveStructuralFeatureValueAction(visitable : RemoveStructuralFeatureValueAction) : Void is
			do
			end

		operation visitAddStructuralFeatureValueAction(visitable : AddStructuralFeatureValueAction) : Void is
			do
			end

		operation visitLinkAction(visitable : LinkAction) : Void is
			do
			end

		operation visitLinkEndData(visitable : LinkEndData) : Void is
			do
			end

		operation visitQualifierValue(visitable : QualifierValue) : Void is
			do
			end

		operation visitReadLinkAction(visitable : ReadLinkAction) : Void is
			do
			end

		operation visitLinkEndCreationData(visitable : LinkEndCreationData) : Void is
			do
			end

		operation visitCreateLinkAction(visitable : CreateLinkAction) : Void is
			do
			end

		operation visitWriteLinkAction(visitable : WriteLinkAction) : Void is
			do
			end

		operation visitDestroyLinkAction(visitable : DestroyLinkAction) : Void is
			do
			end

		operation visitLinkEndDestructionData(visitable : LinkEndDestructionData) : Void is
			do
			end

		operation visitClearAssociationAction(visitable : ClearAssociationAction) : Void is
			do
			end

		operation visitBroadcastSignalAction(visitable : BroadcastSignalAction) : Void is
			do
			end

		operation visitSendObjectAction(visitable : SendObjectAction) : Void is
			do
			end

		operation visitValueSpecificationAction(visitable : ValueSpecificationAction) : Void is
			do
			end

		operation visitTimeExpression(visitable : TimeExpression) : Void is
			do
			end

		operation visitObservation(visitable : Observation) : Void is
			do
			end

		operation visitDuration(visitable : Duration) : Void is
			do
			end

		operation visitDurationInterval(visitable : DurationInterval) : Void is
			do
			end

		operation visitInterval(visitable : Interval) : Void is
			do
			end

		operation visitTimeConstraint(visitable : TimeConstraint) : Void is
			do
			end

		operation visitIntervalConstraint(visitable : IntervalConstraint) : Void is
			do
			end

		operation visitTimeInterval(visitable : TimeInterval) : Void is
			do
			end

		operation visitDurationConstraint(visitable : DurationConstraint) : Void is
			do
			end

		operation visitTimeObservation(visitable : TimeObservation) : Void is
			do
			end

		operation visitDurationObservation(visitable : DurationObservation) : Void is
			do
			end

		operation visitFinalState(visitable : FinalState) : Void is
			do
			end

		operation visitTimeEvent(visitable : TimeEvent) : Void is
			do
			end

		operation visitVariableAction(visitable : VariableAction) : Void is
			do
			end

		operation visitReadVariableAction(visitable : ReadVariableAction) : Void is
			do
			end

		operation visitWriteVariableAction(visitable : WriteVariableAction) : Void is
			do
			end

		operation visitClearVariableAction(visitable : ClearVariableAction) : Void is
			do
			end

		operation visitAddVariableValueAction(visitable : AddVariableValueAction) : Void is
			do
			end

		operation visitRemoveVariableValueAction(visitable : RemoveVariableValueAction) : Void is
			do
			end

		operation visitRaiseExceptionAction(visitable : RaiseExceptionAction) : Void is
			do
			end

		operation visitActionInputPin(visitable : ActionInputPin) : Void is
			do
			end

		operation visitInformationItem(visitable : InformationItem) : Void is
			do
			end

		operation visitInformationFlow(visitable : InformationFlow) : Void is
			do
			end

		operation visitReadExtentAction(visitable : ReadExtentAction) : Void is
			do
			end

		operation visitReclassifyObjectAction(visitable : ReclassifyObjectAction) : Void is
			do
			end

		operation visitReadIsClassifiedObjectAction(visitable : ReadIsClassifiedObjectAction) : Void is
			do
			end

		operation visitStartClassifierBehaviorAction(visitable : StartClassifierBehaviorAction) : Void is
			do
			end

		operation visitReadLinkObjectEndAction(visitable : ReadLinkObjectEndAction) : Void is
			do
			end

		operation visitReadLinkObjectEndQualifierAction(visitable : ReadLinkObjectEndQualifierAction) : Void is
			do
			end

		operation visitCreateLinkObjectAction(visitable : CreateLinkObjectAction) : Void is
			do
			end

		operation visitAcceptEventAction(visitable : AcceptEventAction) : Void is
			do
			end

		operation visitAcceptCallAction(visitable : AcceptCallAction) : Void is
			do
			end

		operation visitReplyAction(visitable : ReplyAction) : Void is
			do
			end

		operation visitUnmarshallAction(visitable : UnmarshallAction) : Void is
			do
			end

		operation visitReduceAction(visitable : ReduceAction) : Void is
			do
			end

		operation visitJoinNode(visitable : JoinNode) : Void is
			do
			end

		operation visitDataStoreNode(visitable : DataStoreNode) : Void is
			do
			end

		operation visitObjectFlow(visitable : ObjectFlow) : Void is
			do
			end

		operation visitConditionalNode(visitable : ConditionalNode) : Void is
			do
			end

		operation visitClause(visitable : Clause) : Void is
			do
			end

		operation visitLoopNode(visitable : LoopNode) : Void is
			do
			end

		operation visitExpansionNode(visitable : ExpansionNode) : Void is
			do
			end

		operation visitExpansionRegion(visitable : ExpansionRegion) : Void is
			do
			end

		operation visitProtocolTransition(visitable : ProtocolTransition) : Void is
			do
			end

		operation visitAssociationClass(visitable : AssociationClass) : Void is
			do
			end

	}
	
	abstract class TopDownVisitor inherits Visitor
	{
		method visitComment(visitable : Comment) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitElement(visitable : Element) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitPackage(visitable : Package) : Void from uml::visitors::Visitor is
			do
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.packageMerge.each{e | e.accept(self)}
				visitable.packagedElement.each{e | e.accept(self)}
				visitable.profileApplication.each{e | e.accept(self)}
			end

		method visitPackageableElement(visitable : PackageableElement) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitNamedElement(visitable : NamedElement) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
			end

		method visitDependency(visitable : Dependency) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDirectedRelationship(visitable : DirectedRelationship) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitRelationship(visitable : Relationship) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitNamespace(visitable : Namespace) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
			end

		method visitElementImport(visitable : ElementImport) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitPackageImport(visitable : PackageImport) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitConstraint(visitable : Constraint) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.specification.isNotEqual(void) then
					visitable.specification.accept(self)

				end
			end

		method visitValueSpecification(visitable : ValueSpecification) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitTypedElement(visitable : TypedElement) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitType(visitable : Type) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitAssociation(visitable : Association) : Void from uml::visitors::Visitor is
			do
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedEnd.each{e | e.accept(self)}
			end

		method visitClassifier(visitable : Classifier) : Void from uml::visitors::Visitor is
			do
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
			end

		method visitRedefinableElement(visitable : RedefinableElement) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitTemplateableElement(visitable : TemplateableElement) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
			end

		method visitTemplateBinding(visitable : TemplateBinding) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.parameterSubstitution.each{e | e.accept(self)}
			end

		method visitTemplateSignature(visitable : TemplateSignature) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedParameter.each{e | e.accept(self)}
			end

		method visitTemplateParameter(visitable : TemplateParameter) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.ownedParameteredElement.isNotEqual(void) then
					visitable.ownedParameteredElement.accept(self)

				end
				if visitable.ownedDefault.isNotEqual(void) then
					visitable.ownedDefault.accept(self)

				end
			end

		method visitParameterableElement(visitable : ParameterableElement) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitTemplateParameterSubstitution(visitable : TemplateParameterSubstitution) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedActual.each{e | e.accept(self)}
			end

		method visitGeneralization(visitable : Generalization) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitGeneralizationSet(visitable : GeneralizationSet) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitFeature(visitable : Feature) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitSubstitution(visitable : Substitution) : Void from uml::visitors::Visitor is
			do
				if visitable.mapping.isNotEqual(void) then
					visitable.mapping.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitRealization(visitable : Realization) : Void from uml::visitors::Visitor is
			do
				if visitable.mapping.isNotEqual(void) then
					visitable.mapping.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitAbstraction(visitable : Abstraction) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.mapping.isNotEqual(void) then
					visitable.mapping.accept(self)

				end
			end

		method visitOpaqueExpression(visitable : OpaqueExpression) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitParameter(visitable : Parameter) : Void from uml::visitors::Visitor is
			do
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.defaultValue.isNotEqual(void) then
					visitable.defaultValue.accept(self)

				end
			end

		method visitMultiplicityElement(visitable : MultiplicityElement) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
			end

		method visitConnectableElement(visitable : ConnectableElement) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitConnectableElementTemplateParameter(visitable : ConnectableElementTemplateParameter) : Void from uml::visitors::Visitor is
			do
				if visitable.ownedParameteredElement.isNotEqual(void) then
					visitable.ownedParameteredElement.accept(self)

				end
				if visitable.ownedDefault.isNotEqual(void) then
					visitable.ownedDefault.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitConnectorEnd(visitable : ConnectorEnd) : Void from uml::visitors::Visitor is
			do
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitProperty(visitable : Property) : Void from uml::visitors::Visitor is
			do
				visitable.deployment.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.defaultValue.isNotEqual(void) then
					visitable.defaultValue.accept(self)

				end
				visitable.qualifier.each{e | e.accept(self)}
			end

		method visitDeploymentTarget(visitable : DeploymentTarget) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.deployment.each{e | e.accept(self)}
			end

		method visitDeployment(visitable : Deployment) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.configuration.each{e | e.accept(self)}
			end

		method visitDeployedArtifact(visitable : DeployedArtifact) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDeploymentSpecification(visitable : DeploymentSpecification) : Void from uml::visitors::Visitor is
			do
				visitable.nestedArtifact.each{e | e.accept(self)}
				visitable.manifestation.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitArtifact(visitable : Artifact) : Void from uml::visitors::Visitor is
			do
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.nestedArtifact.each{e | e.accept(self)}
				visitable.manifestation.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
			end

		method visitManifestation(visitable : Manifestation) : Void from uml::visitors::Visitor is
			do
				if visitable.mapping.isNotEqual(void) then
					visitable.mapping.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitOperation(visitable : Operation) : Void from uml::visitors::Visitor is
			do
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitBehavioralFeature(visitable : BehavioralFeature) : Void from uml::visitors::Visitor is
			do
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
			end

		method visitBehavior(visitable : Behavior) : Void from uml::visitors::Visitor is
			do
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
			end

		method visitClass(visitable : Class) : Void from uml::visitors::Visitor is
			do
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
			end

		method visitBehavioredClassifier(visitable : BehavioredClassifier) : Void from uml::visitors::Visitor is
			do
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
			end

		method visitInterfaceRealization(visitable : InterfaceRealization) : Void from uml::visitors::Visitor is
			do
				if visitable.mapping.isNotEqual(void) then
					visitable.mapping.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInterface(visitable : Interface) : Void from uml::visitors::Visitor is
			do
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				if visitable.protocol.isNotEqual(void) then
					visitable.protocol.accept(self)

				end
			end

		method visitReception(visitable : Reception) : Void from uml::visitors::Visitor is
			do
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitSignal(visitable : Signal) : Void from uml::visitors::Visitor is
			do
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
			end

		method visitProtocolStateMachine(visitable : ProtocolStateMachine) : Void from uml::visitors::Visitor is
			do
				visitable.region.each{e | e.accept(self)}
				visitable.connectionPoint.each{e | e.accept(self)}
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.conformance.each{e | e.accept(self)}
			end

		method visitStateMachine(visitable : StateMachine) : Void from uml::visitors::Visitor is
			do
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.region.each{e | e.accept(self)}
				visitable.connectionPoint.each{e | e.accept(self)}
			end

		method visitRegion(visitable : Region) : Void from uml::visitors::Visitor is
			do
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.subvertex.each{e | e.accept(self)}
				visitable.transition.each{e | e.accept(self)}
			end

		method visitVertex(visitable : Vertex) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitTransition(visitable : Transition) : Void from uml::visitors::Visitor is
			do
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.effect.isNotEqual(void) then
					visitable.effect.accept(self)

				end
				visitable.trigger.each{e | e.accept(self)}
			end

		method visitTrigger(visitable : Trigger) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitEvent(visitable : Event) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitPort(visitable : Port) : Void from uml::visitors::Visitor is
			do
				if visitable.defaultValue.isNotEqual(void) then
					visitable.defaultValue.accept(self)

				end
				visitable.qualifier.each{e | e.accept(self)}
				visitable.deployment.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitState(visitable : State) : Void from uml::visitors::Visitor is
			do
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.connection.each{e | e.accept(self)}
				visitable.connectionPoint.each{e | e.accept(self)}
				if visitable.stateInvariant.isNotEqual(void) then
					visitable.stateInvariant.accept(self)

				end
				if visitable.entry.isNotEqual(void) then
					visitable.entry.accept(self)

				end
				if visitable.exit.isNotEqual(void) then
					visitable.exit.accept(self)

				end
				if visitable.doActivity.isNotEqual(void) then
					visitable.doActivity.accept(self)

				end
				visitable.deferrableTrigger.each{e | e.accept(self)}
				visitable.region.each{e | e.accept(self)}
			end

		method visitConnectionPointReference(visitable : ConnectionPointReference) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitPseudostate(visitable : Pseudostate) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitProtocolConformance(visitable : ProtocolConformance) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitEncapsulatedClassifier(visitable : EncapsulatedClassifier) : Void from uml::visitors::Visitor is
			do
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitStructuredClassifier(visitable : StructuredClassifier) : Void from uml::visitors::Visitor is
			do
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
			end

		method visitConnector(visitable : Connector) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.~end.each{e | e.accept(self)}
			end

		method visitExtension(visitable : Extension) : Void from uml::visitors::Visitor is
			do
				visitable.ownedEnd.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitExtensionEnd(visitable : ExtensionEnd) : Void from uml::visitors::Visitor is
			do
				if visitable.defaultValue.isNotEqual(void) then
					visitable.defaultValue.accept(self)

				end
				visitable.qualifier.each{e | e.accept(self)}
				visitable.deployment.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitStereotype(visitable : Stereotype) : Void from uml::visitors::Visitor is
			do
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.icon.each{e | e.accept(self)}
			end

		method visitImage(visitable : Image) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitProfile(visitable : Profile) : Void from uml::visitors::Visitor is
			do
				visitable.packageMerge.each{e | e.accept(self)}
				visitable.packagedElement.each{e | e.accept(self)}
				visitable.profileApplication.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitModel(visitable : Model) : Void from uml::visitors::Visitor is
			do
				visitable.packageMerge.each{e | e.accept(self)}
				visitable.packagedElement.each{e | e.accept(self)}
				visitable.profileApplication.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitParameterSet(visitable : ParameterSet) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.condition.each{e | e.accept(self)}
			end

		method visitDataType(visitable : DataType) : Void from uml::visitors::Visitor is
			do
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
			end

		method visitOperationTemplateParameter(visitable : OperationTemplateParameter) : Void from uml::visitors::Visitor is
			do
				if visitable.ownedParameteredElement.isNotEqual(void) then
					visitable.ownedParameteredElement.accept(self)

				end
				if visitable.ownedDefault.isNotEqual(void) then
					visitable.ownedDefault.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitStructuralFeature(visitable : StructuralFeature) : Void from uml::visitors::Visitor is
			do
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCollaborationUse(visitable : CollaborationUse) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.roleBinding.each{e | e.accept(self)}
			end

		method visitCollaboration(visitable : Collaboration) : Void from uml::visitors::Visitor is
			do
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitUseCase(visitable : UseCase) : Void from uml::visitors::Visitor is
			do
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.include.each{e | e.accept(self)}
				visitable.extend.each{e | e.accept(self)}
				visitable.extensionPoint.each{e | e.accept(self)}
			end

		method visitInclude(visitable : Include) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitExtend(visitable : Extend) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.condition.isNotEqual(void) then
					visitable.condition.accept(self)

				end
			end

		method visitExtensionPoint(visitable : ExtensionPoint) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitRedefinableTemplateSignature(visitable : RedefinableTemplateSignature) : Void from uml::visitors::Visitor is
			do
				visitable.ownedParameter.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitClassifierTemplateParameter(visitable : ClassifierTemplateParameter) : Void from uml::visitors::Visitor is
			do
				if visitable.ownedParameteredElement.isNotEqual(void) then
					visitable.ownedParameteredElement.accept(self)

				end
				if visitable.ownedDefault.isNotEqual(void) then
					visitable.ownedDefault.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitStringExpression(visitable : StringExpression) : Void from uml::visitors::Visitor is
			do
				visitable.operand.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.subExpression.each{e | e.accept(self)}
			end

		method visitExpression(visitable : Expression) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.operand.each{e | e.accept(self)}
			end

		method visitUsage(visitable : Usage) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitPackageMerge(visitable : PackageMerge) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitProfileApplication(visitable : ProfileApplication) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitEnumeration(visitable : Enumeration) : Void from uml::visitors::Visitor is
			do
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.ownedLiteral.each{e | e.accept(self)}
			end

		method visitEnumerationLiteral(visitable : EnumerationLiteral) : Void from uml::visitors::Visitor is
			do
				visitable.slot.each{e | e.accept(self)}
				if visitable.specification.isNotEqual(void) then
					visitable.specification.accept(self)

				end
				visitable.deployment.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInstanceSpecification(visitable : InstanceSpecification) : Void from uml::visitors::Visitor is
			do
				visitable.deployment.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.slot.each{e | e.accept(self)}
				if visitable.specification.isNotEqual(void) then
					visitable.specification.accept(self)

				end
			end

		method visitSlot(visitable : Slot) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.~value.each{e | e.accept(self)}
			end

		method visitPrimitiveType(visitable : PrimitiveType) : Void from uml::visitors::Visitor is
			do
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitLiteralSpecification(visitable : LiteralSpecification) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitLiteralInteger(visitable : LiteralInteger) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitLiteralString(visitable : LiteralString) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitLiteralBoolean(visitable : LiteralBoolean) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitLiteralNull(visitable : LiteralNull) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInstanceValue(visitable : InstanceValue) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitLiteralUnlimitedNatural(visitable : LiteralUnlimitedNatural) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitOpaqueBehavior(visitable : OpaqueBehavior) : Void from uml::visitors::Visitor is
			do
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitFunctionBehavior(visitable : FunctionBehavior) : Void from uml::visitors::Visitor is
			do
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitOpaqueAction(visitable : OpaqueAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.inputValue.each{e | e.accept(self)}
				visitable.outputValue.each{e | e.accept(self)}
			end

		method visitAction(visitable : Action) : Void from uml::visitors::Visitor is
			do
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
			end

		method visitExecutableNode(visitable : ExecutableNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
			end

		method visitActivityNode(visitable : ActivityNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitStructuredActivityNode(visitable : StructuredActivityNode) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.variable.each{e | e.accept(self)}
				visitable.edge.each{e | e.accept(self)}
				visitable.node.each{e | e.accept(self)}
			end

		method visitActivityGroup(visitable : ActivityGroup) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitActivity(visitable : Activity) : Void from uml::visitors::Visitor is
			do
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.variable.each{e | e.accept(self)}
				visitable.node.each{e | e.accept(self)}
				visitable.edge.each{e | e.accept(self)}
				visitable.group.each{e | e.accept(self)}
			end

		method visitVariable(visitable : Variable) : Void from uml::visitors::Visitor is
			do
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitActivityEdge(visitable : ActivityEdge) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.guard.isNotEqual(void) then
					visitable.guard.accept(self)

				end
				if visitable.weight.isNotEqual(void) then
					visitable.weight.accept(self)

				end
			end

		method visitActivityPartition(visitable : ActivityPartition) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.subpartition.each{e | e.accept(self)}
			end

		method visitInterruptibleActivityRegion(visitable : InterruptibleActivityRegion) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitExceptionHandler(visitable : ExceptionHandler) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitObjectNode(visitable : ObjectNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.upperBound.isNotEqual(void) then
					visitable.upperBound.accept(self)

				end
			end

		method visitOutputPin(visitable : OutputPin) : Void from uml::visitors::Visitor is
			do
//				if (visitable.upperBound) != (void) then
//					visitable.upperBound.accept(self)
//
//				end
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitPin(visitable : Pin) : Void from uml::visitors::Visitor is
			do
//				if (visitable.upperBound) != (void) then
//					visitable.upperBound.accept(self)
//
//				end
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInputPin(visitable : InputPin) : Void from uml::visitors::Visitor is
			do
//				if (visitable.upperBound) != (void) then
//					visitable.upperBound.accept(self)
//
//				end
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCallAction(visitable : CallAction) : Void from uml::visitors::Visitor is
			do
				visitable.argument.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.~result.each{e | e.accept(self)}
			end

		method visitInvocationAction(visitable : InvocationAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.argument.each{e | e.accept(self)}
			end

		method visitSendSignalAction(visitable : SendSignalAction) : Void from uml::visitors::Visitor is
			do
				visitable.argument.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.target.isNotEqual(void) then
					visitable.target.accept(self)

				end
			end

		method visitCallOperationAction(visitable : CallOperationAction) : Void from uml::visitors::Visitor is
			do
				visitable.~result.each{e | e.accept(self)}
				visitable.argument.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.target.isNotEqual(void) then
					visitable.target.accept(self)

				end
			end

		method visitCallBehaviorAction(visitable : CallBehaviorAction) : Void from uml::visitors::Visitor is
			do
				visitable.~result.each{e | e.accept(self)}
				visitable.argument.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitSequenceNode(visitable : SequenceNode) : Void from uml::visitors::Visitor is
			do
				visitable.variable.each{e | e.accept(self)}
				visitable.edge.each{e | e.accept(self)}
				visitable.node.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.executableNode.each{e | e.accept(self)}
			end

		method visitControlNode(visitable : ControlNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitControlFlow(visitable : ControlFlow) : Void from uml::visitors::Visitor is
			do
				if visitable.guard.isNotEqual(void) then
					visitable.guard.accept(self)

				end
				if visitable.weight.isNotEqual(void) then
					visitable.weight.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInitialNode(visitable : InitialNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitActivityParameterNode(visitable : ActivityParameterNode) : Void from uml::visitors::Visitor is
			do
				if visitable.upperBound.isNotEqual(void) then
					visitable.upperBound.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitValuePin(visitable : ValuePin) : Void from uml::visitors::Visitor is
			do
//				if (visitable.upperBound) != (void) then
//					visitable.upperBound.accept(self)
//
//				end
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~value.isNotEqual(void) then
					visitable.~value.accept(self)

				end
			end

		method visitMessage(visitable : Message) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.argument.each{e | e.accept(self)}
			end

		method visitMessageEnd(visitable : MessageEnd) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInteraction(visitable : Interaction) : Void from uml::visitors::Visitor is
			do
				visitable.ownedParameter.each{e | e.accept(self)}
				visitable.ownedParameterSet.each{e | e.accept(self)}
				visitable.generalOrdering.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.lifeline.each{e | e.accept(self)}
				visitable.fragment.each{e | e.accept(self)}
				visitable.action.each{e | e.accept(self)}
				visitable.formalGate.each{e | e.accept(self)}
				visitable.message.each{e | e.accept(self)}
			end

		method visitInteractionFragment(visitable : InteractionFragment) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.generalOrdering.each{e | e.accept(self)}
			end

		method visitLifeline(visitable : Lifeline) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.selector.isNotEqual(void) then
					visitable.selector.accept(self)

				end
			end

		method visitPartDecomposition(visitable : PartDecomposition) : Void from uml::visitors::Visitor is
			do
				visitable.actualGate.each{e | e.accept(self)}
				visitable.argument.each{e | e.accept(self)}
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInteractionUse(visitable : InteractionUse) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.actualGate.each{e | e.accept(self)}
				visitable.argument.each{e | e.accept(self)}
			end

		method visitGate(visitable : Gate) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitGeneralOrdering(visitable : GeneralOrdering) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitOccurrenceSpecification(visitable : OccurrenceSpecification) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInteractionOperand(visitable : InteractionOperand) : Void from uml::visitors::Visitor is
			do
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.guard.isNotEqual(void) then
					visitable.guard.accept(self)

				end
				visitable.fragment.each{e | e.accept(self)}
			end

		method visitInteractionConstraint(visitable : InteractionConstraint) : Void from uml::visitors::Visitor is
			do
				if visitable.specification.isNotEqual(void) then
					visitable.specification.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.minint.isNotEqual(void) then
					visitable.minint.accept(self)

				end
				if visitable.maxint.isNotEqual(void) then
					visitable.maxint.accept(self)

				end
			end

		method visitExecutionSpecification(visitable : ExecutionSpecification) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitStateInvariant(visitable : StateInvariant) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.invariant.isNotEqual(void) then
					visitable.invariant.accept(self)

				end
			end

		method visitActionExecutionSpecification(visitable : ActionExecutionSpecification) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitBehaviorExecutionSpecification(visitable : BehaviorExecutionSpecification) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitExecutionEvent(visitable : ExecutionEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCreationEvent(visitable : CreationEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDestructionEvent(visitable : DestructionEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitSendOperationEvent(visitable : SendOperationEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitMessageEvent(visitable : MessageEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitSendSignalEvent(visitable : SendSignalEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitMessageOccurrenceSpecification(visitable : MessageOccurrenceSpecification) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitExecutionOccurrenceSpecification(visitable : ExecutionOccurrenceSpecification) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitReceiveOperationEvent(visitable : ReceiveOperationEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitReceiveSignalEvent(visitable : ReceiveSignalEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitActor(visitable : Actor) : Void from uml::visitors::Visitor is
			do
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCallEvent(visitable : CallEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitChangeEvent(visitable : ChangeEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.changeExpression.isNotEqual(void) then
					visitable.changeExpression.accept(self)

				end
			end

		method visitSignalEvent(visitable : SignalEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitAnyReceiveEvent(visitable : AnyReceiveEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitForkNode(visitable : ForkNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitFlowFinalNode(visitable : FlowFinalNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitFinalNode(visitable : FinalNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCentralBufferNode(visitable : CentralBufferNode) : Void from uml::visitors::Visitor is
			do
				if visitable.upperBound.isNotEqual(void) then
					visitable.upperBound.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitMergeNode(visitable : MergeNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDecisionNode(visitable : DecisionNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitActivityFinalNode(visitable : ActivityFinalNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitComponentRealization(visitable : ComponentRealization) : Void from uml::visitors::Visitor is
			do
				if visitable.mapping.isNotEqual(void) then
					visitable.mapping.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitComponent(visitable : Component) : Void from uml::visitors::Visitor is
			do
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.packagedElement.each{e | e.accept(self)}
				visitable.realization.each{e | e.accept(self)}
			end

		method visitNode(visitable : Node) : Void from uml::visitors::Visitor is
			do
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.deployment.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.nestedNode.each{e | e.accept(self)}
			end

		method visitDevice(visitable : Device) : Void from uml::visitors::Visitor is
			do
				visitable.nestedNode.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.deployment.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitExecutionEnvironment(visitable : ExecutionEnvironment) : Void from uml::visitors::Visitor is
			do
				visitable.nestedNode.each{e | e.accept(self)}
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.deployment.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCommunicationPath(visitable : CommunicationPath) : Void from uml::visitors::Visitor is
			do
				visitable.ownedEnd.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCombinedFragment(visitable : CombinedFragment) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.operand.each{e | e.accept(self)}
				visitable.cfragmentGate.each{e | e.accept(self)}
			end

		method visitContinuation(visitable : Continuation) : Void from uml::visitors::Visitor is
			do
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitConsiderIgnoreFragment(visitable : ConsiderIgnoreFragment) : Void from uml::visitors::Visitor is
			do
				visitable.operand.each{e | e.accept(self)}
				visitable.cfragmentGate.each{e | e.accept(self)}
				visitable.generalOrdering.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCreateObjectAction(visitable : CreateObjectAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitDestroyObjectAction(visitable : DestroyObjectAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.target.isNotEqual(void) then
					visitable.target.accept(self)

				end
			end

		method visitTestIdentityAction(visitable : TestIdentityAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.first.isNotEqual(void) then
					visitable.first.accept(self)

				end
				if visitable.second.isNotEqual(void) then
					visitable.second.accept(self)

				end
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitReadSelfAction(visitable : ReadSelfAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitStructuralFeatureAction(visitable : StructuralFeatureAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
			end

		method visitReadStructuralFeatureAction(visitable : ReadStructuralFeatureAction) : Void from uml::visitors::Visitor is
			do
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitWriteStructuralFeatureAction(visitable : WriteStructuralFeatureAction) : Void from uml::visitors::Visitor is
			do
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~value.isNotEqual(void) then
					visitable.~value.accept(self)

				end
			end

		method visitClearStructuralFeatureAction(visitable : ClearStructuralFeatureAction) : Void from uml::visitors::Visitor is
			do
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitRemoveStructuralFeatureValueAction(visitable : RemoveStructuralFeatureValueAction) : Void from uml::visitors::Visitor is
			do
				if visitable.~value.isNotEqual(void) then
					visitable.~value.accept(self)

				end
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.removeAt.isNotEqual(void) then
					visitable.removeAt.accept(self)

				end
			end

		method visitAddStructuralFeatureValueAction(visitable : AddStructuralFeatureValueAction) : Void from uml::visitors::Visitor is
			do
				if visitable.~value.isNotEqual(void) then
					visitable.~value.accept(self)

				end
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.insertAt.isNotEqual(void) then
					visitable.insertAt.accept(self)

				end
			end

		method visitLinkAction(visitable : LinkAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.endData.each{e | e.accept(self)}
				visitable.inputValue.each{e | e.accept(self)}
			end

		method visitLinkEndData(visitable : LinkEndData) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.qualifier.each{e | e.accept(self)}
			end

		method visitQualifierValue(visitable : QualifierValue) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitReadLinkAction(visitable : ReadLinkAction) : Void from uml::visitors::Visitor is
			do
				visitable.endData.each{e | e.accept(self)}
				visitable.inputValue.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitLinkEndCreationData(visitable : LinkEndCreationData) : Void from uml::visitors::Visitor is
			do
				visitable.qualifier.each{e | e.accept(self)}
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitCreateLinkAction(visitable : CreateLinkAction) : Void from uml::visitors::Visitor is
			do
				visitable.endData.each{e | e.accept(self)}
				visitable.inputValue.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitWriteLinkAction(visitable : WriteLinkAction) : Void from uml::visitors::Visitor is
			do
				visitable.endData.each{e | e.accept(self)}
				visitable.inputValue.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDestroyLinkAction(visitable : DestroyLinkAction) : Void from uml::visitors::Visitor is
			do
				visitable.endData.each{e | e.accept(self)}
				visitable.inputValue.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitLinkEndDestructionData(visitable : LinkEndDestructionData) : Void from uml::visitors::Visitor is
			do
				visitable.qualifier.each{e | e.accept(self)}
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitClearAssociationAction(visitable : ClearAssociationAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
			end

		method visitBroadcastSignalAction(visitable : BroadcastSignalAction) : Void from uml::visitors::Visitor is
			do
				visitable.argument.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitSendObjectAction(visitable : SendObjectAction) : Void from uml::visitors::Visitor is
			do
				visitable.argument.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.target.isNotEqual(void) then
					visitable.target.accept(self)

				end
				if visitable.request.isNotEqual(void) then
					visitable.request.accept(self)

				end
			end

		method visitValueSpecificationAction(visitable : ValueSpecificationAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~value.isNotEqual(void) then
					visitable.~value.accept(self)

				end
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitTimeExpression(visitable : TimeExpression) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitObservation(visitable : Observation) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDuration(visitable : Duration) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDurationInterval(visitable : DurationInterval) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInterval(visitable : Interval) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitTimeConstraint(visitable : TimeConstraint) : Void from uml::visitors::Visitor is
			do
				if visitable.specification.isNotEqual(void) then
					visitable.specification.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitIntervalConstraint(visitable : IntervalConstraint) : Void from uml::visitors::Visitor is
			do
				if visitable.specification.isNotEqual(void) then
					visitable.specification.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitTimeInterval(visitable : TimeInterval) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDurationConstraint(visitable : DurationConstraint) : Void from uml::visitors::Visitor is
			do
				if visitable.specification.isNotEqual(void) then
					visitable.specification.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitTimeObservation(visitable : TimeObservation) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitDurationObservation(visitable : DurationObservation) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitFinalState(visitable : FinalState) : Void from uml::visitors::Visitor is
			do
				visitable.connection.each{e | e.accept(self)}
				visitable.connectionPoint.each{e | e.accept(self)}
				if visitable.stateInvariant.isNotEqual(void) then
					visitable.stateInvariant.accept(self)

				end
				if visitable.entry.isNotEqual(void) then
					visitable.entry.accept(self)

				end
				if visitable.exit.isNotEqual(void) then
					visitable.exit.accept(self)

				end
				if visitable.doActivity.isNotEqual(void) then
					visitable.doActivity.accept(self)

				end
				visitable.deferrableTrigger.each{e | e.accept(self)}
				visitable.region.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitTimeEvent(visitable : TimeEvent) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.when.isNotEqual(void) then
					visitable.when.accept(self)

				end
			end

		method visitVariableAction(visitable : VariableAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitReadVariableAction(visitable : ReadVariableAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitWriteVariableAction(visitable : WriteVariableAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~value.isNotEqual(void) then
					visitable.~value.accept(self)

				end
			end

		method visitClearVariableAction(visitable : ClearVariableAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitAddVariableValueAction(visitable : AddVariableValueAction) : Void from uml::visitors::Visitor is
			do
				if visitable.~value.isNotEqual(void) then
					visitable.~value.accept(self)

				end
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.insertAt.isNotEqual(void) then
					visitable.insertAt.accept(self)

				end
			end

		method visitRemoveVariableValueAction(visitable : RemoveVariableValueAction) : Void from uml::visitors::Visitor is
			do
				if visitable.~value.isNotEqual(void) then
					visitable.~value.accept(self)

				end
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.removeAt.isNotEqual(void) then
					visitable.removeAt.accept(self)

				end
			end

		method visitRaiseExceptionAction(visitable : RaiseExceptionAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.exception.isNotEqual(void) then
					visitable.exception.accept(self)

				end
			end

		method visitActionInputPin(visitable : ActionInputPin) : Void from uml::visitors::Visitor is
			do
//				if (visitable.upperBound) != (void) then
//					visitable.upperBound.accept(self)
//
//				end
				if visitable.upperValue.isNotEqual(void) then
					visitable.upperValue.accept(self)

				end
				if visitable.lowerValue.isNotEqual(void) then
					visitable.lowerValue.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.fromAction.isNotEqual(void) then
					visitable.fromAction.accept(self)

				end
			end

		method visitInformationItem(visitable : InformationItem) : Void from uml::visitors::Visitor is
			do
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitInformationFlow(visitable : InformationFlow) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitReadExtentAction(visitable : ReadExtentAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitReclassifyObjectAction(visitable : ReclassifyObjectAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
			end

		method visitReadIsClassifiedObjectAction(visitable : ReadIsClassifiedObjectAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
			end

		method visitStartClassifierBehaviorAction(visitable : StartClassifierBehaviorAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
			end

		method visitReadLinkObjectEndAction(visitable : ReadLinkObjectEndAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitReadLinkObjectEndQualifierAction(visitable : ReadLinkObjectEndQualifierAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitCreateLinkObjectAction(visitable : CreateLinkObjectAction) : Void from uml::visitors::Visitor is
			do
				visitable.endData.each{e | e.accept(self)}
				visitable.inputValue.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
			end

		method visitAcceptEventAction(visitable : AcceptEventAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.~result.each{e | e.accept(self)}
				visitable.trigger.each{e | e.accept(self)}
			end

		method visitAcceptCallAction(visitable : AcceptCallAction) : Void from uml::visitors::Visitor is
			do
				visitable.~result.each{e | e.accept(self)}
				visitable.trigger.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.returnInformation.isNotEqual(void) then
					visitable.returnInformation.accept(self)

				end
			end

		method visitReplyAction(visitable : ReplyAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.returnInformation.isNotEqual(void) then
					visitable.returnInformation.accept(self)

				end
				visitable.replyValue.each{e | e.accept(self)}
			end

		method visitUnmarshallAction(visitable : UnmarshallAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.~result.each{e | e.accept(self)}
				if visitable.object.isNotEqual(void) then
					visitable.object.accept(self)

				end
			end

		method visitReduceAction(visitable : ReduceAction) : Void from uml::visitors::Visitor is
			do
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.~result.isNotEqual(void) then
					visitable.~result.accept(self)

				end
				if visitable.collection.isNotEqual(void) then
					visitable.collection.accept(self)

				end
			end

		method visitJoinNode(visitable : JoinNode) : Void from uml::visitors::Visitor is
			do
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				if visitable.joinSpec.isNotEqual(void) then
					visitable.joinSpec.accept(self)

				end
			end

		method visitDataStoreNode(visitable : DataStoreNode) : Void from uml::visitors::Visitor is
			do
				if visitable.upperBound.isNotEqual(void) then
					visitable.upperBound.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitObjectFlow(visitable : ObjectFlow) : Void from uml::visitors::Visitor is
			do
				if visitable.guard.isNotEqual(void) then
					visitable.guard.accept(self)

				end
				if visitable.weight.isNotEqual(void) then
					visitable.weight.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitConditionalNode(visitable : ConditionalNode) : Void from uml::visitors::Visitor is
			do
				visitable.variable.each{e | e.accept(self)}
				visitable.edge.each{e | e.accept(self)}
				visitable.node.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.clause.each{e | e.accept(self)}
				visitable.~result.each{e | e.accept(self)}
			end

		method visitClause(visitable : Clause) : Void from uml::visitors::Visitor is
			do
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitLoopNode(visitable : LoopNode) : Void from uml::visitors::Visitor is
			do
				visitable.variable.each{e | e.accept(self)}
				visitable.edge.each{e | e.accept(self)}
				visitable.node.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
				visitable.~result.each{e | e.accept(self)}
				visitable.loopVariableInput.each{e | e.accept(self)}
			end

		method visitExpansionNode(visitable : ExpansionNode) : Void from uml::visitors::Visitor is
			do
				if visitable.upperBound.isNotEqual(void) then
					visitable.upperBound.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitExpansionRegion(visitable : ExpansionRegion) : Void from uml::visitors::Visitor is
			do
				visitable.variable.each{e | e.accept(self)}
				visitable.edge.each{e | e.accept(self)}
				visitable.node.each{e | e.accept(self)}
				visitable.localPrecondition.each{e | e.accept(self)}
				visitable.localPostcondition.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.handler.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitProtocolTransition(visitable : ProtocolTransition) : Void from uml::visitors::Visitor is
			do
				if visitable.effect.isNotEqual(void) then
					visitable.effect.accept(self)

				end
				visitable.trigger.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

		method visitAssociationClass(visitable : AssociationClass) : Void from uml::visitors::Visitor is
			do
				visitable.nestedClassifier.each{e | e.accept(self)}
				visitable.ownedOperation.each{e | e.accept(self)}
				visitable.ownedReception.each{e | e.accept(self)}
				visitable.ownedEnd.each{e | e.accept(self)}
				visitable.ownedBehavior.each{e | e.accept(self)}
				visitable.interfaceRealization.each{e | e.accept(self)}
				visitable.ownedTrigger.each{e | e.accept(self)}
				visitable.ownedAttribute.each{e | e.accept(self)}
				visitable.ownedConnector.each{e | e.accept(self)}
				visitable.generalization.each{e | e.accept(self)}
				visitable.substitution.each{e | e.accept(self)}
				visitable.collaborationUse.each{e | e.accept(self)}
				visitable.ownedUseCase.each{e | e.accept(self)}
				visitable.elementImport.each{e | e.accept(self)}
				visitable.packageImport.each{e | e.accept(self)}
				visitable.ownedRule.each{e | e.accept(self)}
				visitable.templateBinding.each{e | e.accept(self)}
				if visitable.ownedTemplateSignature.isNotEqual(void) then
					visitable.ownedTemplateSignature.accept(self)

				end
				if visitable.nameExpression.isNotEqual(void) then
					visitable.nameExpression.accept(self)

				end
				visitable.ownedComment.each{e | e.accept(self)}
			end

	}
}

