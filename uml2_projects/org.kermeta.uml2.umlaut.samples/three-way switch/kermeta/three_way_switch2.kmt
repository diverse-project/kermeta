/* $Id: three_way_switch2.kmt,v 1.1 2007-12-14 14:17:50 vmahe Exp $
 * Creation date: May 19, 2006
 * License:
 * Copyright:
 * Authors: vmahe@irisa.fr
 */

package three_way_switch;


require kermeta
require "../../../fr.irisa.triskell.uml2.statecharts.simulator/src/kermeta/rts.kmt"

using kermeta::standard
using rts

abstract class Light {
	reference inhabitant : oset Inhabitant[1..*]
	operation switch() is abstract
	operation get_inhabitant(order : Integer) : Inhabitant is abstract
	operation add_inhabitant(new_inhabitant : Inhabitant) is abstract
}

abstract class Switch {
	reference light : Light
	operation changePosition() is abstract
	operation get_light() : Light is abstract
	operation set_light(new_light : Light) is abstract
}

abstract class Inhabitant {
	reference isEnlighted : Boolean
	reference switch : oset Switch[2..2]
	operation get_isEnlighted() : Boolean is abstract
	operation get_switch(order : Integer) : Switch is abstract
	operation set_isEnlighted(new_isEnlighted : Boolean) is abstract
	operation add_switch(new_switch : Switch) is abstract
}

class Light_impl inherits Light, ActiveStateMachine {
	reference light_in_On : Light_in_On
	reference light_in_Off : Light_in_Off
	method switch() is do
		//Empty. For state change, see proxy class
	end
	method get_inhabitant(order : Integer) : Inhabitant is do
		result := inhabitant.elementAt(order)
	end
	method add_inhabitant(new_inhabitant : Inhabitant) is do
		inhabitant.add(new_inhabitant)
	end
	operation make() is do
		inhabitant := OrderedSet<Inhabitant>.new
		light_in_On := Light_in_On.new
		light_in_On.init_activable("light_in_On")
		light_in_Off := Light_in_Off.new
		light_in_Off.init_activable("light_in_Off")
//		enter(light_in_Off)		// makes wreckage in Kermeta simulator

		// specificly needed by kermeta RTS swap of states (not in Eiffel).
		light_in_On.machine := self
		light_in_Off.machine := self
		instanceCurrentState := light_in_Off
	end
}

class Switch_impl inherits Switch, ActiveStateMachine {
	reference switch_in_Up : Switch_in_Up
	reference switch_in_Down : Switch_in_Down
	method changePosition() is do
		// Empty. For state change, see proxy class
	end
	method get_light() : Light is do
		result := light
	end
	method set_light(new_light : Light) is do
		light := new_light
	end
	operation make() is do
		switch_in_Up := Switch_in_Up.new
		switch_in_Up.init_activable("switch_in_Up")
		switch_in_Down := Switch_in_Down.new
		switch_in_Down.init_activable("switch_in_Down")
//		enter(switch_in_Up)		// makes wreckage in Kermeta simulator

		// specificly needed by kermeta RTS swap of states.
		switch_in_Up.machine := self
		switch_in_Down.machine := self
		instanceCurrentState := switch_in_Up
	end
}

class Inhabitant_impl inherits Inhabitant, ActiveStateMachine {
	reference inhabitant_in_idle : Inhabitant_in_idle
	method get_isEnlighted() : Boolean is do
		result := isEnlighted
	end
	method set_isEnlighted(new_isEnlighted : Boolean) is do
	
//		stdio.writeln("DEBUG Inhab_impl.set_isEnl : self = "+self.toString+ "\n - type = "+self.getMetaClass.toString+"\n - new_isEnl = "+new_isEnlighted.toString)
//		if new_isEnlighted.isVoid then raise "DEBUG - new_isEnlighted is void !!" end
	
		isEnlighted := new_isEnlighted
	end
	method get_switch(order : Integer) : Switch is do
		result := switch.elementAt(order)
	end
	method add_switch(new_switch : Switch) is do
		switch.add(new_switch)
	end
	operation make() is do
		inhabitant_in_idle := Inhabitant_in_idle.new
		inhabitant_in_idle.init_activable("inhabitant_in_idle")
//		enter(inhabitant_in_idle)		// makes wreckage in Kermeta simulator

		// specificly needed by kermeta RTS swap of states.
		inhabitant_in_idle.machine := self
		instanceCurrentState := inhabitant_in_idle
	end
}

class Light_top_state inherits Light_impl {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
}

class Light_in_On inherits Light_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method switch() is do
		if	// guard of statechart's transition
			true
		then
			leave(light_in_On)
			// action code of statechart's transition
			self.inhabitant.each{e|e.set_isEnlighted(false)}
			enter(light_in_Off)
		end
	end
}

class Light_in_Off inherits Light_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method switch() is do
		if	// guard of statechart's transition
			true
		then
			leave(light_in_Off)
			// action code of statechart's transition
			self.inhabitant.each{e|e.set_isEnlighted(true)}
			enter(light_in_On)
		end
	end
}

class Switch_top_state inherits Switch_impl {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
}

class Switch_in_Up inherits Switch_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method changePosition() is do
		if	// guard of statechart's transition
			true
		then
			leave(switch_in_Up)
			// action code of statechart's transition
			light.switch
			enter(switch_in_Down)
		end
	end
}

class Switch_in_Down inherits Switch_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method changePosition() is do
		if	// guard of statechart's transition
			true
		then
			leave(switch_in_Down)
			// action code of statechart's transition
			light.switch
			enter(switch_in_Up)
		end
	end
}

class Inhabitant_top_state inherits Inhabitant_impl {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
}

class Inhabitant_in_idle inherits Inhabitant_top_state {
	method entry() is do
		// Empty
	end
	method exit() is do
		// Empty
	end
	method nb_transitions() : Integer is do
		result := 2
		if not message_queue.is_empty then result := result + 1 end
	end
	method labels(n : Integer) : String is do
		if n < 2 then	// sequences begin at 0 in Kermeta
			var str : OrderedSet<String> init OrderedSet<String>.new
			str.add("switch.elementAt(0).changePosition")
			str.add("switch.elementAt(1).changePosition")
			result := "!" + str.elementAt(n)
		else
			result := message_queue.item.label
		end
	end
	method completion(n : Integer) is do
		leave(inhabitant_in_idle)
		if n == 0 then
			switch.elementAt(0).changePosition
			enter(inhabitant_in_idle)
		else
		if n == 1 then
			switch.elementAt(1).changePosition
			enter(inhabitant_in_idle)
		end
		end
	end
//	method set_isEnlighted(new_isEnlighted : Boolean) is do
//		isEnlighted := new_isEnlighted
//	end
}

class Light_proxy inherits Light, Proxy {
	method switch() is do
		var event : Light_switch_call_event init Light_switch_call_event.new
		event.make
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
	end
	method get_inhabitant(order : Integer) : Inhabitant is do
		var event : Light_get_inhabitant_call_event init Light_get_inhabitant_call_event.new
		event.make
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
		var inhabitant : Inhabitant
		inhabitant ?= event.arguments.elementAt(order)
		result := inhabitant
	end
	method add_inhabitant(new_inhabitant : Inhabitant) is do
		var event : Light_add_inhabitant_call_event init Light_add_inhabitant_call_event.new
		event.make
		event.arguments.add(new_inhabitant)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
	end
}

class Switch_proxy inherits Switch, Proxy {
	method changePosition() is do
		var event : Switch_changePosition_call_event init Switch_changePosition_call_event.new
		event.make
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
	end
	method get_light() : Light is do
		var event : Switch_get_light_call_event init Switch_get_light_call_event.new
		event.make
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
		var light : Light
		light ?= event.arguments.last
		result := light
	end
	method set_light(new_light : Light) is do
		var event : Switch_set_light_call_event init Switch_set_light_call_event.new
		event.make
		event.arguments.add(new_light)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
	end
}

class Inhabitant_proxy inherits Inhabitant, Proxy {
	method get_isEnlighted() : Boolean is do
		var event : Inhabitant_get_isEnlighted_call_event init Inhabitant_get_isEnlighted_call_event.new
		event.make
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
		var isEnlighted : Boolean
		isEnlighted ?= event.arguments.last
		result := isEnlighted
	end
	method get_switch(order : Integer) : Switch is do
		var event : Inhabitant_get_switch_call_event init Inhabitant_get_switch_call_event.new
		event.make
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
		var switch : Switch
		switch ?= event.arguments.elementAt(order)
		result := switch
	end
	method set_isEnlighted(new_isEnlighted : Boolean) is do
		var event : Inhabitant_set_isEnlighted_call_event init Inhabitant_set_isEnlighted_call_event.new
		event.make
		event.arguments.add(new_isEnlighted)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
	end
	method add_switch(new_switch : Switch) is do
		var event : Inhabitant_add_switch_call_event init Inhabitant_add_switch_call_event.new
		event.make
		event.arguments.add(new_switch)
		var serverActiveStateMachine : ActiveStateMachine
		serverActiveStateMachine ?= server
		if serverActiveStateMachine != void then
			if serverActiveStateMachine.events_from_action == void then
				serverActiveStateMachine.reset_events_from_action()
			end
			if serverActiveStateMachine.events_from_action != "" then
				serverActiveStateMachine.events_from_action.append(";")
			end
			serverActiveStateMachine.events_from_action.append(serverActiveStateMachine.identity.out)
			serverActiveStateMachine.events_from_action.append(event.label)
		end
		send(event)
	end
}

class Light_switch_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		target_as_Light.switch
	end
	method event_name() : String is do
		result := "switch"
	end
}
class Light_switch_signal {
}

class Light_get_inhabitant_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		var arg0 : Integer
		arg0 ?= arguments.elementAt(0)
		target_as_Light.get_inhabitant(arg0)
	end
	method event_name() : String is do
		result := "get_inhabitant"
	end
}
class Light_get_inhabitant_signal {
	reference order : Integer
	reference ~result : Inhabitant
}

class Light_add_inhabitant_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Light : Light
		target_as_Light ?= target
		var arg0 : Inhabitant
		arg0 ?= arguments.elementAt(0)
		target_as_Light.add_inhabitant(arg0)
	end
	method event_name() : String is do
		result := "add_inhabitant"
	end
}
class Light_add_inhabitant_signal {
	reference new_inhabitant : Inhabitant
}

class Switch_changePosition_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		target_as_Switch.changePosition
	end
	method event_name() : String is do
		result := "changePosition"
	end
}
class Switch_changePosition_signal {
}

class Switch_get_light_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		target_as_Switch.get_light
	end
	method event_name() : String is do
		result := "get_light"
	end
}
class Switch_get_light_signal {
	reference ~result : Light
}

class Switch_set_light_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Switch : Switch
		target_as_Switch ?= target
		var arg0 : Light
		arg0 ?= arguments.elementAt(0)
		target_as_Switch.set_light(arg0)
	end
	method event_name() : String is do
		result := "set_light"
	end
}
class Switch_set_light_signal {
	reference new_light : Light
}

class Inhabitant_get_isEnlighted_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Inhabitant : Inhabitant
		target_as_Inhabitant ?= target
		target_as_Inhabitant.isEnlighted
	end
	method event_name() : String is do
		result := "get_isEnlighted"
	end
}
class Inhabitant_get_isEnlighted_signal {
	reference ~result : Boolean
}

class Inhabitant_get_switch_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Inhabitant : Inhabitant
		target_as_Inhabitant ?= target
		var arg0 : Integer
		arg0 ?= arguments.elementAt(0)
		target_as_Inhabitant.get_switch(arg0)
	end
	method event_name() : String is do
		result := "get_switch"
	end
}
class Inhabitant_get_switch_signal {
	reference order : Integer
	reference ~result : Switch
}

class Inhabitant_set_isEnlighted_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Inhabitant : Inhabitant
		target_as_Inhabitant ?= target
		var arg0 : Boolean
		arg0 ?= arguments.elementAt(0)
		target_as_Inhabitant.set_isEnlighted(arg0)
	end
	method event_name() : String is do
		result := "set_isEnlighted"
	end
}
class Inhabitant_set_isEnlighted_signal {
	reference new_isEnlighted : Boolean
}

class Inhabitant_add_switch_call_event inherits Event {
	method dispatch_to(target : Object) is do
		var target_as_Inhabitant : Inhabitant
		target_as_Inhabitant ?= target
		var arg0 : Switch
		arg0 ?= arguments.elementAt(0)
		target_as_Inhabitant.add_switch(arg0)
	end
	method event_name() : String is do
		result := "add_switch"
	end
}
class Inhabitant_add_switch_signal {
	reference new_switch : Switch
}

// create initial state instances for simulation
class ThreeWaySwitch inherits CADPSimulator {
	operation make() is do
		make_CADP_simulator
	end
	operation set_proxy_on(proxy : Proxy,
	                       server : StateMachine,
	                       remote : Boolean) is do
		var port : Port
		if remote then
			port := Port.new
			port.initialize
			port.init_activable(void)
			port.connect(port)
			port.connect(server)
		else
			proxy.connect(server)
		end
	end
	// features specific to ThreeWaySwitch
	// -- class instances
	reference aMan1 : Inhabitant_impl
	reference aMan2 : Inhabitant_impl
	reference first : Switch_impl
	reference second : Switch_impl
	reference aBulb : Light_impl
	// -- association instances
	reference aMan1_first_proxy : Switch_proxy
	reference aMan1_second_proxy : Switch_proxy
	reference aMan2_first_proxy : Switch_proxy
	reference aMan2_second_proxy : Switch_proxy
	reference first_aBulb_proxy : Light_proxy
	reference second_aBulb_proxy : Light_proxy
	reference aBulb_aMan1_proxy : Inhabitant_proxy
	reference aBulb_aMan2_proxy : Inhabitant_proxy
	
	method initial_configuration() : Configuration is do
		// -- register the instances
		var configuration : Configuration init Configuration.new
		configuration.make
		
		// create implemens
		aMan1 := Inhabitant_impl.new
		configuration.register(aMan1)
		aMan1.make
		aMan1.init_activable("aMan1")
		aMan1.inhabitant_in_idle.context := configuration
		
		aMan2 := Inhabitant_impl.new
		configuration.register(aMan2)
		aMan2.make
		aMan2.init_activable("aMan2")
		aMan2.inhabitant_in_idle.context := configuration
		
		first := Switch_impl.new
		configuration.register(first)
		first.make
		first.init_activable("first")
		first.switch_in_Up.context := configuration
		first.switch_in_Down.context := configuration
		
		second := Switch_impl.new
		configuration.register(second)
		second.make
		second.init_activable("second")
		second.switch_in_Up.context := configuration
		second.switch_in_Down.context := configuration
		
		aBulb := Light_impl.new
		configuration.register(aBulb)
		aBulb.make
		aBulb.init_activable("aBulb")
		aBulb.light_in_On.context := configuration
		aBulb.light_in_Off.context := configuration
		
		// create proxies
		aMan1_first_proxy := Switch_proxy.new
		aMan1_second_proxy := Switch_proxy.new
		aMan2_first_proxy := Switch_proxy.new
		aMan2_second_proxy := Switch_proxy.new
		first_aBulb_proxy := Light_proxy.new
		second_aBulb_proxy := Light_proxy.new
		aBulb_aMan1_proxy := Inhabitant_proxy.new
		aBulb_aMan2_proxy := Inhabitant_proxy.new
		
		// set links
		aMan1.add_switch(aMan1_first_proxy)
		set_proxy_on(aMan1_first_proxy, first, false)
		
		aMan1.add_switch(aMan1_second_proxy)
		set_proxy_on(aMan1_second_proxy, second, false)
		
		aMan2.add_switch(aMan2_first_proxy)
		set_proxy_on(aMan2_first_proxy, first, false)
		
		aMan2.add_switch(aMan2_second_proxy)
		set_proxy_on(aMan2_second_proxy, second, false)
		
		first.set_light(first_aBulb_proxy)
		set_proxy_on(first_aBulb_proxy, aBulb, false)
		
		second.set_light(second_aBulb_proxy)
		set_proxy_on(second_aBulb_proxy, aBulb, false)
		
		aBulb.add_inhabitant(aBulb_aMan1_proxy)
		set_proxy_on(aBulb_aMan1_proxy, aMan1, false)
		
		aBulb.add_inhabitant(aBulb_aMan2_proxy)
		set_proxy_on(aBulb_aMan2_proxy, aMan2, false)
		
		// -- set attributes
		aMan1.set_isEnlighted(false)
		
		aMan2.set_isEnlighted(false)
		
		result := configuration
	end
}