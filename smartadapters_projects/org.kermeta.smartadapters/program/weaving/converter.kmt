/* $Id: converter.kmt,v 1.16 2008/06/17 15:35:30 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright: IRISA / INRIA Rennes Bretagne Atlantique
 * Authors: Brice Morin bmorin@irisa.fr
 */

package org::smartadapters::utils;

require kermeta

using kermeta::language::structure
using kermeta::standard 
using kermeta::utils


/**
Converts a model that conforms to MM' into a model that conforms to MM
It can be significantly improved...
*/
class Converter
{
	//Mapping MM'->MM
	reference convertTable : Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>
	//reference convertTableInverse : Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>
	reference converted : Hashtable<kermeta::language::structure::Object,kermeta::language::structure::Object>
	
	/**
	initializes the converter (~constructor)
	must be called before any other operation
	*/
	operation initConverter(convert:Hashtable<kermeta::language::structure::Class, kermeta::language::structure::Class>) is do	
		convertTable := convert
		/*convertTableInverse := Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>.new
		convertTable.keys.each{k | 
			var v : kermeta::language::structure::Class init convertTable.getValue(k)
			convertTableInverse.put(v,k)}
		*/converted := Hashtable<kermeta::language::structure::Object,kermeta::language::structure::Object>.new
	end
	
	operation deleteConverted(obj:kermeta::language::structure::Object) : Void is do
		converted.remove(obj)
	end	

	operation addEntry(key : kermeta::language::structure::Class, val : kermeta::language::structure::Class) is do
		convertTable.put(key,val)
	end
	
	operation getConverted(obj : kermeta::language::structure::Object) : kermeta::language::structure::Object is do
		result := getConvertedObject(obj)
	end
	
	/**
	returns a converted object (MM), equivalent to obj (MM')
	*/
	operation getConvertedObject(obj : kermeta::language::structure::Object) : kermeta::language::structure::Object 
	pre notVoid is obj != void
	post notVoid is result != void
	post conformance is result.getMetaClass == convertTable.getValue(obj.getMetaClass)
	is do
		var newMeta : kermeta::language::structure::Class init convertTable.getValue(obj.getMetaClass)
		if(newMeta != void) then
			if(converted.getValue(obj) == void) then
				var o : kermeta::language::structure::Object init newMeta.new
				converted.put(obj,o)
				convert(obj,o)
				result := o
			else
				result := converted.getValue(obj) 
			end
		else
			result := obj
		end
	end

/*	operation getConvertedInverse(obj : kermeta::language::structure::Object) : kermeta::language::structure::Object 
	pre notVoid is obj != void
	post notVoid is result != void
	post conformance is result.getMetaClass == convertTable.getValue(obj.getMetaClass)
	is do
		var newMeta : kermeta::language::structure::Class init convertTableInverse.getValue(obj.getMetaClass)
		if(newMeta != void) then
			if(converted.getValue(obj) == void) then
				var o : kermeta::language::structure::Object init newMeta.new
				converted.put(obj,o)
				convert(obj,o)
				result := o
			else
				result := converted.getValue(obj) 
			end
		else
			result := obj
		end
	end
*/		
	operation processProperties(obj : kermeta::language::structure::Object, conv : kermeta::language::structure::Object, properties : Set<Property>) is
	do
		properties.each{a |
			//stdio.errorln(a.name)
			if obj.get(a) != void  then
				var ob : Object init obj.get(a)
				//single property (upper bound==1)
				if(a.upper == 1 and ob != void) then
					var temp : Object
					temp := getConverted(ob)
					if(temp != void) then
						var e : EnumerationLiteral
						e ?= temp
						if e == void then					
							conv.~set(a,temp)
						else
							stdio.writeln("not converted due to a bug in Kermeta!!!"+conv.toString+"."+a.name+" := "+temp.toString)
							stdio.writeln("see testEnum::TestEnum.testReflect2")
						end
					end
				//collection property -> iteration over all the elements
				else
					var list:Collection<kermeta::language::structure::Object>
					var convertedList:Collection<kermeta::language::structure::Object>
					list ?= ob
					if((list != void).andThen{b | list.size>0}) then
						convertedList ?= conv.get(a)
						convertedList.clear
						list.each{o |
							var tmp:Object init getConverted(o)
							convertedList.add(tmp)
						}						
					end
				end
			end
		}
	end
		
	/**
	copies obj (MM') into conv (MM) thanks to the convert Hashtable
	*/	
	operation convert(obj : kermeta::language::structure::Object, conv : kermeta::language::structure::Object) : Void is do
		var c : Class init conv.getMetaClass
		var properties1 : Set<Property> init Set<Property>.new
		var properties2 : Set<Property> init Set<Property>.new
		 
		//getting all the direct attributes (containment graph)
		properties1.addAll(c.ownedAttribute.select{p | p.isComposite and not p.isDerived and not (p.name=="tags" or p.name=="ownedTags")})
		//getting all the other direct references
		properties2.addAll(c.ownedAttribute.select{p | not p.isComposite and not p.isDerived and not (p.name=="tags" or p.name=="ownedTags")})
		
		//getting iteratively all the inherited attributes and references
		var temp : Set<Class> init Set<Class>.new
		var superClasses : Set<Class> init Set<Class>.new 
		superClasses.addAll(c.superClass)
		from  not superClasses.isEmpty
		until superClasses.isEmpty
		loop
			temp.clear
 			superClasses.each{s |
 				properties1.addAll(s.ownedAttribute.select{p | p.isComposite and not p.isDerived and not (p.name=="tags" or p.name=="ownedTags")}) 
 				properties2.addAll(s.ownedAttribute.select{p | not p.isComposite and not p.isDerived and not (p.name=="tags" or p.name=="ownedTags")})
 				temp.addAll(s.superClass)
 			}
 			superClasses.clear
 			superClasses.addAll(temp)
		end
		
		//converting the containment graph
		processProperties(obj,conv,properties1)
		//converting all the other references
		processProperties(obj,conv,properties2)
	end
}