package specialize;
require kermeta
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/keyword_list.kmt"
using kermeta::standard
using kermeta::utils
using ecore
using EcoreHelpers
using kermeta::language::key
class AdaptationTemplate{
operation generate(classif:Set<EClassifier>, domainMM:String, domainMMPattern:String, shortName:String, generatePost:Boolean):String is do
var _res: StringBuffer init StringBuffer.new
_res.append("\n/* \n * Author: Brice Morin\n * Creation date: \n * License: \n * Copyright: IRISA / INRIA Rennes Bretagne Atlantique\n * Authors: Brice Morin bmorin@irisa.fr\n */\n\n/*\n * This file was automatically generated\n */\n")

var helper:EcoreHelper init EcoreHelper.new
var keyWord : KeyWordList init KeyWordList.new
keyWord.initialize
var fName : String

_res.append("\npackage org;\nrequire kermeta\nrequire \"platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt\"\nrequire \"")
_res.append(domainMM)
_res.append("\"\nrequire \"")
_res.append(domainMMPattern)
_res.append("\"\n\nusing kermeta::standard\nusing kermeta::utils\nusing patternframework\nusing org::smartadapters::core\nusing org::smartadapters::extension\nusing ecore\nusing org::smartadapters::utils\n\npackage smartadapters\n{\n\tpackage core\n\t{\n\t\taspect class Adapter \n\t\t{\n\t\t\t/**\n\t\t\t * Associates concrete meta-classes from MM\' to concrete meta-classes from MM\n\t\t\t */\n\t\t\toperation initConvert(): Void is do\n\t\t\t\tconverter := Converter.new\n\t\t\t\tconvert := Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>.new\n")

				var name:String 
				classif.each{cl |
					var c:EClass
					c?=cl
					if(c!=void) then
						if(not(c.~abstract) and not(c.interface)) then
					name:=helper.getClassifierQualifiedName(c)
_res.append("\t\t\t\tconvert.put(pattern::")
_res.append(name)
_res.append(",")
_res.append(name)
_res.append(")\n")
end
					end
					}
_res.append("\t\t\t\tconverter.initConverter(convert)\n\t\t\tend\n\t\t}\n\t\t\n\tpackage adaptations\n\t{\n")
classif.each{cl | 
		var c:EClass
		var qualifiedName:String
		qualifiedName:=helper.getClassifierQualifiedName(cl)
		c?=cl 
_res.append("\t\t \n")

		if(c!=void) then
			if(not(c.~abstract) and not(c.interface)) then
_res.append("\t\t/*\n\t\t * Adaptations dedicated to the manipulation\n\t\t * of ")
_res.append(qualifiedName)
_res.append("\n\t\t */\n\t\t\n\t\t/**\n\t\t * Creates a new ")
_res.append(qualifiedName)
_res.append(" from scratch\n\t\t * This new element is handled by refering to new")
_res.append(c.name)
_res.append("\n\t\t */\n\t\tclass Create")
_res.append(qualifiedName.replace("::",""))
_res.append(" inherits createAdaptation\n\t\t{\n\t\t\tattribute new")
_res.append(c.name)
_res.append(" : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := new")
_res.append(c.name)
_res.append(" != void\n\t\t\tend\n\t\t\t\t\t\n\t\t\tmethod execute(reverse : Boolean): Void is do\n\t\t\t\tadapter.cloneAgain(new")
_res.append(c.name)
_res.append(", void, isUnique)\t\t\t\t\t\n\t\t\tend\n\t\t}\n\n\t\t/**\n\t\t * Creates a new ")
_res.append(qualifiedName)
_res.append(" from an existing one\n\t\t * This cloned element is handled by refering to cloned")
_res.append(c.name)
_res.append("\n\t\t */\n\t\tclass Clone")
_res.append(qualifiedName.replace("::",""))
_res.append(" inherits cloneAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToClone : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\tattribute cloned")
_res.append(c.name)
_res.append(" : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToClone != void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(reverse : Boolean): Void is do\n\t\t\t\tadapter.cloneAgain(cloned")
_res.append(c.name)
_res.append(", ")
_res.append(c.name)
_res.append("ToClone, isUnique)\n\t\t\tend\t\t\t\t\t\n\t\t}\n")
end
_res.append("\n\t\t/**\n\t\t * Sets any property of ")
_res.append(qualifiedName)
_res.append("\n\t\t * All the references except ")
_res.append(c.name)
_res.append("ToSet may be void\n\t\t */\n")
 if c.eAllStructuralFeatures.size > 0 then
_res.append("\t\t\t \n\t\tclass Set")
_res.append(qualifiedName.replace("::",""))
_res.append(" inherits setAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToSet : pattern::")
_res.append(qualifiedName)
_res.append("\n")

			var card:String
			var fQualName:String
			var newObj:kermeta::language::structure::Object
			var primitive:kermeta::language::structure::PrimitiveType
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived.orElse{v | f.unsettable}).andThen{v | f.changeable}.andThen{v | not(f.name.equals("tag").orElse{w | f.name.equals("ownedTag")})}) then
					fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
					if(not(f.upperBound==1))then
_res.append("")
card:="[0..*]"
					else
_res.append("")
card:=""
					end
					if(primitive==void) then
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : pattern::")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
else
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : ")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
end
_res.append("")
end
				}
_res.append("\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToSet != void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(reverse : Boolean): Void \n")
if generatePost then
_res.append("\t\t\tpost correctlySetted")
_res.append(qualifiedName.replace("::",""))
_res.append(" is do\n\t\t\t\tvar ad : Adapter init getAdapter\n\t\t\t\tvar temp")
_res.append(c.name)
_res.append("ToSet : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp")
_res.append(c.name)
_res.append("ToSet ?= ad.getRealObject(")
_res.append(c.name)
_res.append("ToSet,false)\n\t\t\t\tvar isCorrectlySetted : Boolean init true\n\t\t\t\tvar c : Collection<kermeta::language::structure::Object>\n")
c.eAllStructuralFeatures.each{f | 
_res.append("")
if f.upperBound==1 then
_res.append("\t\t\t\tif ref")
_res.append(f.name)
_res.append(" != void then\n\t\t\t\t\tisCorrectlySetted := isCorrectlySetted.andThen{v | temp")
_res.append(c.name)
_res.append("ToSet.")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(" == ad.getRealObject(ref")
_res.append(f.name)
_res.append(",false)}\n\t\t\t \tend\n")
else
_res.append("\t\t\t\tc ?= ad.getRealObject(ref")
_res.append(f.name)
_res.append(",true)\n\t\t\t\tc.each{o | var p : ")
_res.append(helper.getClassifierQualifiedName(f.eType))
_res.append(" \n\t\t\t\t\t\tp ?= o \n\t\t\t\t\t\tisCorrectlySetted := isCorrectlySetted.andThen{v | temp")
_res.append(c.name)
_res.append("ToSet.")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(".contains(p)}}\n")
end
_res.append("")
}
_res.append("\t\t\t\tisCorrectlySetted\n\t\t\tend\n")
end
_res.append("\t\t\tis do\n\t\t\t\tvar ad : Adapter init getAdapter\n\t\t\t\tvar temp")
_res.append(c.name)
_res.append(" : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp")
_res.append(c.name)
_res.append(" ?= ad.getRealObject(")
_res.append(c.name)
_res.append("ToSet,false)\n\t\t\t\t\n")
c.eAllStructuralFeatures.each{f | 
				if(not(f.derived.orElse{v | f.unsettable}).andThen{v | f.changeable}.andThen{v | not(f.name.equals("tag").orElse{w | f.name.equals("ownedTag")})}) then
_res.append("")
if f.upperBound==1 then
_res.append("\t\t\t\ttemp")
_res.append(c.name)
_res.append(".")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(" ?= ad.setSingleProperty(ref")
_res.append(f.name)
_res.append(", temp")
_res.append(c.name)
_res.append(".")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(")\n")
else
_res.append("\t\t\t\tad.setMultipleProperty(temp")
_res.append(c.name)
_res.append(".")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(",ref")
_res.append(f.name)
_res.append(")\n")
end
_res.append("")
end
				}
_res.append("\t\t\t\t\n\t\t\t\t//Instantiating the reverse adaptation\n\t\t\t\tif(reverse) then\t\t\n\t\t\t\t\tvar unset : Unset")
_res.append(qualifiedName.replace("::",""))
_res.append(" \n\t\t\t\t\tif self.reverse == void then\n\t\t\t\t\t\tunset := Unset")
_res.append(qualifiedName.replace("::",""))
_res.append(".new\n\t\t\t\t\t\tunset.reverse := self\n\t\t\t\t\t\tself.reverse := unset\n\t\t\t\t\telse\n\t\t\t\t\t\tunset ?= self.reverse\n\t\t\t\t\tend\t\t\n\t\t\t\t\tunset.")
_res.append(c.name)
_res.append("ToUnset := self.")
_res.append(c.name)
_res.append("ToSet\n")
c.eAllStructuralFeatures.each{f | 
					if(not(f.derived.orElse{v | f.unsettable}).andThen{v | f.changeable}.andThen{v | not(f.name.equals("tag").orElse{w | f.name.equals("ownedTag")})}) then
_res.append("")
if(not(f.upperBound==1))then
_res.append("\t\t\t\t\tunset.ref")
_res.append(f.name)
_res.append(".clear\n\t\t\t\t\tunset.ref")
_res.append(f.name)
_res.append(".addAll(self.ref")
_res.append(f.name)
_res.append(")\n")
else
_res.append("\t\t\t\t\tunset.ref")
_res.append(f.name)
_res.append(" := self.ref")
_res.append(f.name)
_res.append("\n")
end
_res.append("")
end
_res.append("")
}
_res.append("\t\t\t\tend\t\n\t\t\tend\t\t\t\n\t\t}\n\t\t\n\t\t/**\n\t\t * Unsets any property of ")
_res.append(qualifiedName)
_res.append("\n\t\t * All the references except ")
_res.append(c.name)
_res.append("ToUnset may be void \n\t\t */\t\t\n\t\tclass Unset")
_res.append(qualifiedName.replace("::",""))
_res.append(" inherits unsetAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToUnset : pattern::")
_res.append(qualifiedName)
_res.append("\n")

			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived.orElse{v | f.unsettable}).andThen{v | f.changeable}.andThen{v | not(f.name.equals("tag").orElse{w | f.name.equals("ownedTag")})}) then
_res.append("")
fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
_res.append("")
if(not(f.upperBound==1))then
_res.append("")
card:="[0..*]"
_res.append("")
else
_res.append("")
card:=""
_res.append("")
end
_res.append("")
if(primitive==void) then
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : pattern::")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
else
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : ")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
end
_res.append("")
end
_res.append("")
}
_res.append("\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToUnset != void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(reverse : Boolean): Void\n")
if generatePost then
_res.append("\t\t\tpost correctlyUnsetted")
_res.append(qualifiedName.replace("::",""))
_res.append(" is do\n\t\t\t\tvar ad : Adapter init getAdapter\n\t\t\t\tvar temp")
_res.append(c.name)
_res.append("ToUnset : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp")
_res.append(c.name)
_res.append("ToUnset ?= ad.getRealObject(")
_res.append(c.name)
_res.append("ToUnset,false)\n\t\t\t\tvar isCorrectlyUnsetted : Boolean init true\n\t\t\t\tvar c : Collection<kermeta::language::structure::Object>\n")
c.eAllStructuralFeatures.each{f | 
_res.append("")
if f.upperBound==1 then
_res.append("\t\t\t\tif ref")
_res.append(f.name)
_res.append(" != void then \n\t\t\t\tif not ad.notRemovable.contains(ad.getRealObject(ref")
_res.append(f.name)
_res.append(",false)) then\n\t\t\t\t\tisCorrectlyUnsetted := isCorrectlyUnsetted.andThen{v | temp")
_res.append(c.name)
_res.append("ToUnset.")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(" == void}\n\t\t\t\tend end\n")
else
_res.append("\t\t\t\tc ?= ad.getRealObject(ref")
_res.append(f.name)
_res.append(",true)\n\t\t\t\tc.each{o | var p : ")
_res.append(helper.getClassifierQualifiedName(f.eType))
_res.append(" p?=o \n\t\t\t\t\tif not ad.notRemovable.contains(p) then\n\t\t\t\t\t\tisCorrectlyUnsetted := isCorrectlyUnsetted.andThen{v | not temp")
_res.append(c.name)
_res.append("ToUnset.")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(".contains(p)}\n\t\t\t\t\tend\n\t\t\t\t}\n")
end
_res.append("")
}
_res.append("\t\t\t\tisCorrectlyUnsetted\n\t\t\tend\n")
end
_res.append("\t\t\tis do\n\t\t\t\tvar ad : Adapter init getAdapter\n\t\t\t\tvar temp")
_res.append(c.name)
_res.append(" : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp")
_res.append(c.name)
_res.append(" ?= ad.getRealObject(")
_res.append(c.name)
_res.append("ToUnset,false)\n\t\t\t\t\n")
c.eAllStructuralFeatures.each{f | 
				if(not(f.derived.orElse{v | f.unsettable}).andThen{v | f.changeable}.andThen{v | not(f.name.equals("tag").orElse{w | f.name.equals("ownedTag")})}) then
_res.append("")
if f.upperBound==1 then
_res.append("\t\t\t\ttemp")
_res.append(c.name)
_res.append(".")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(" ?= ad.unsetSingleProperty(ref")
_res.append(f.name)
_res.append(", temp")
_res.append(c.name)
_res.append(".")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(")\n")
else
_res.append("\t\t\t\tad.unsetMultipleProperty(temp")
_res.append(c.name)
_res.append(".")
if keyWord.isKeyword(f.name) then
_res.append("~")
end
_res.append(f.name)
_res.append(",ref")
_res.append(f.name)
_res.append(")\n")
end
_res.append("")
end
				}
_res.append("\t\t\t\t\n\t\t\t\t//Instantiating the reverse adaptation\n\t\t\t\tif reverse then\n\t\t\t\t\tvar ~set : Set")
_res.append(qualifiedName.replace("::",""))
_res.append(" \n\t\t\t\t\tif self.reverse == void then\n\t\t\t\t\t\t~set := Set")
_res.append(qualifiedName.replace("::",""))
_res.append(".new\n\t\t\t\t\t\t~set.reverse := self\n\t\t\t\t\t\tself.reverse := ~set\n\t\t\t\t\telse\n\t\t\t\t\t\t~set ?= self.reverse\n\t\t\t\t\tend\n\t\t\t\t\t~set.")
_res.append(c.name)
_res.append("ToSet := self.")
_res.append(c.name)
_res.append("ToUnset\n")
c.eAllStructuralFeatures.each{f | 
					if(not(f.derived.orElse{v | f.unsettable}).andThen{v | f.changeable}.andThen{v | not(f.name.equals("tag").orElse{w | f.name.equals("ownedTag")})}) then
_res.append("")
if(not(f.upperBound==1))then
_res.append("\t\t\t\t\t~set.ref")
_res.append(f.name)
_res.append(".clear\n\t\t\t\t\t~set.ref")
_res.append(f.name)
_res.append(".addAll(self.ref")
_res.append(f.name)
_res.append(")\n")
else
_res.append("\t\t\t\t\t~set.ref")
_res.append(f.name)
_res.append(" := self.ref")
_res.append(f.name)
_res.append("\n")
end
_res.append("")
end
_res.append("")
}
_res.append("\t\t\t\tend\n\t\t\tend\n\t\t}\n")
end
_res.append("")
end
		}
_res.append("\t}\n}}")
result := _res.toString
end
}
