<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book lang="en-US">
  <bookinfo>
    <pubdate>Build date: @BUILD.DATE@</pubdate>

    <author>
      <firstname>François Tanguy, Didier Vojtisek, Cyril Faucher</firstname>

      <firstname></firstname>
    </author>

    <title>Kermeta tutorial</title>

    <date>2006-10-27T16:44:35</date>

    <keywordset>
      <keyword>Kermeta</keyword>

      <keyword>metamodeling</keyword>

      <keyword>language</keyword>
    </keywordset>

    <subtitle>How to add behavior to a metamodell</subtitle>

    <bibliomisc>Licence EPL</bibliomisc>

    <date>19/10/2006</date>

    <abstract>
      <para>This manual presents the various aspects of the Kermeta language.
      This is the reference manual for anybody who want to use Kermeta.</para>
    </abstract>

    <publisher>
      <publishername>INRIA</publishername>

      <address>
        <state>France</state>
        <otheraddr>
          <ulink url="http://www.inria.fr">http://www.inria.fr</ulink>
        </otheraddr>
      </address>
    </publisher>

    <confgroup>
      <conftitle>title</conftitle>

      <confnum>Reference</confnum>

      <confsponsor>sponsor</confsponsor>
    </confgroup>
  </bookinfo>

  <preface>
    <?print-orientation portrait?>

    <title>Preface</title>

    <para><emphasis role="strong">Kermeta is a Domain Specific Language
    dedicated to metamodel engineering. It fills the gap let by MOF which
    defines only the structure of meta-models, by adding a way to specify
    static semantic (similar to OCL) and dynamic semantic (using operational
    semantic in the operation of the metamodel). </emphasis> <emphasis
    role="strong"> <emphasis role="strong">Kermeta uses the object-oriented
    paradigm like Java or Eiffel.</emphasis> </emphasis> <emphasis
    role="strong"> This document presents various aspects of the language,
    including the textual syntax, the metamodel (which can be viewed as the
    abstract syntax) and some more advanced features typically included in its
    framework. </emphasis></para>

    <important>
       

      <emphasis role="strong">Kermeta is an evolving software and d</emphasis>

       

      <emphasis role="strong">
        <emphasis role="strong">espite that we put a lot of attention to this
        document, it may contain errors (more likely in the code samples). If
        you find any error or have some information that improves this
        document, please send it to us using the bug tracker in the
        forge:</emphasis>
      </emphasis>

       

      <ulink type="" url="http://gforge.inria.fr/tracker/?group_id=32">
        <emphasis role="strong">
          <emphasis role="strong">
            <emphasis
            role="strong">http://gforge.inria.fr/tracker/?group_id=32</emphasis>
          </emphasis>
        </emphasis>
      </ulink>

       

      <emphasis role="strong">
        <emphasis role="strong">
          <emphasis role="strong" />
        </emphasis>
      </emphasis>

       

      <emphasis role="strong">
        <emphasis role="strong">
          <emphasis role="strong">or using the developer mailing list
          (kermeta-developers@lists.gforge.inria.fr)</emphasis>
        </emphasis>
      </emphasis>

       

      <emphasis role="strong">
        <emphasis role="strong">
          <emphasis role="strong" />
        </emphasis>
      </emphasis>

       Last check: v0.2.1 
    </important>

    <tip>
       The most update version of this document is available on line from 

      <ulink type=""
      url="http://www.kermeta.org/">http://www.kermeta.org</ulink>

       . 
    </tip>
  </preface>

  <chapter>
    <?print-orientation portrait?>

    <title>Prerequisites</title>

    <para>This tutorial is one part of a bigger tutorial based on a Finite
    State Machine example. Even if some of its aspects are reexplained here,
    the reader may lack information he can find in the big tutorial.</para>

    <para>To understand this tutorial, you must be familiar with meta model
    creation. If not, please read the the dedicated tutorial on "How to create
    KerMeta meta model".</para>

    <important>
       This tutorial does not cover the study of KerMeta language. Please have a look at the KerMeta manual located at: 

      <ulink type=""
      url="http://www.kermeta.org/documents/manual/">http://www.kermeta.org/documents/manual/</ulink>

       
    </important>
  </chapter>

  <chapter>
    <title>Objectives</title>

    <para>In this tutorial, we will see some uses of KerMeta language in order
    to add behavior to KerMeta meta model. We start by remembering the reader
    the FSM specifications. And then, we explain step by step how to add
    behavior to the meta model.</para>
  </chapter>

  <chapter>
    <title>Finite State Machine Specifications</title>

    <para>We want to represent IO/state machines. Inputs and outputs can be
    attached on each transition. To illustrate finite state machine, here is a
    simple example. This state machine recognizes the "hello" motif and
    produces the "world" motif.</para>

    <para>Here, we present this finite-state machine in a specific graphical
    syntax where states are presented as squares and transitions by arrow
    between squares. Input and outputs are present above transitions. Here,
    "h/w" says that we consume an "h" to produce a "w".</para>

    <figure>
      <title></title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-How-to-add-behavior-to-a-metamodel_figures/helloWorldFSM.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>This simple state machine can be modeled and executed easily in
    Kermeta. See the following meta-model presented in a class diagram
    syntax.</para>
  </chapter>

  <chapter>
    <title>The coding view of a meta model</title>

    <para>It will be easier to add behavior to your meta model thanks the
    coding view because you can clearly see blocks of code (conditions,
    loops...).</para>

    <figure>
      <title></title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-How-to-add-behavior-to-a-metamodel_figures/fsm-metamodel.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Then have a look at the "fsm.kmt" file in the "kermeta"
    directory.</para>

    <para>The class diagram suggests that we must fill in three operations
    :</para>

    <itemizedlist>
      <listitem>
        <para>run() for FSM class,</para>
      </listitem>

      <listitem>
        <para>step(String): String for State class,</para>
      </listitem>

      <listitem>
        <para>and fire(): String for Transition class.</para>
      </listitem>
    </itemizedlist>
  </chapter>

  <chapter>
    <title>The run/step/fire operations</title>

    <itemizedlist>
      <listitem>
        <para>The run operation is used as a user interface. Thanks to this
        operation, we are going to display information about the finite state
        machine, read user input and process steps.</para>
      </listitem>

      <listitem>
        <para>The step operation is used to go to an other state depending on
        the user's input and the transitions available from the current
        state.</para>
      </listitem>

      <listitem>
        <para>The fire operation is used to change the current state and to
        get the produced string.</para>
      </listitem>
    </itemizedlist>

    <para>Let us see the behavior of these three operations.</para>

    <para>The run algorithm</para>

    <para>Behavior :</para>

    <para>1 – initialize current state</para>

    <para>2 – loop until the user's input equal to "quit"</para>

    <para>print the current state</para>

    <para>read a string</para>

    <para>process a step</para>

    <para>catch exceptions if there are some and exit the program displaying
    the error.</para>

    <para>Here is the code of the operation :</para>

    <programlisting>operation run() : Void raises FSMException is do  
  // reset if there is no current state
  if self.currentState == void then self.currentState := self.initialState end
  self
  from var str : String init "init"
  until str == "quit"
  loop
    stdio.writeln("Current state : " + self.currentState.name)
    str := stdio.read("give me a letter : ")
    if str == "quit" then
      stdio.writeln("")
      stdio.writeln("quitting ...")
    else 
      if str == "print" then
        stdio.writeln("")
      else	
        stdio.writeln(str)
        stdio.writeln("stepping...")
        do
          var textRes : String
          textRes := self.currentState.step(str)
          if( textRes == void or textRes == "" ) then
            textRes := "NC"
          end

          stdio.writeln("string produced : " + textRes)
          rescue (err : ConstraintViolatedPre)
            stdio.writeln(err.toString)
            stdio.writeln(err.message)
            str := "quit"
          rescue (err : ConstraintViolatedPost)
            stdio.writeln(err.toString)
            stdio.writeln(err.message)
            str := "quit"
          rescue(err : NonDeterminism)
            stdio.writeln(err.toString)
            str := "quit"
          rescue(err : NoTransition)
            stdio.writeln(err.toString)
            str := "quit"
          end
        end
      end
    end
end</programlisting>

    <para>The step algorithm</para>

    <para>In this operation, there are pre and post conditions. These are
    conditions checked each time the operation is called. If they are
    evaluated to false an exception is raised. You can choose to check them or
    not. Please refer to the corresponding tutorial on how to use run
    configurations.</para>

    <para>Behavior :</para>

    <para>1 – Select the possible transitions.</para>

    <para>2 – If there is none raise a NoTransition exception.</para>

    <para>If there is more than one raise a NonDeterminism exception.</para>

    <para>3 – If there is only one transition, call its fire operation and
    return its result.</para>

    <programlisting>// Go to the next state
operation step(c : String) : String raises FSMException is

  // Declaration of the pre-condition
  pre notVoidInput is
    c != void and c != ""

  do
    // Get the valid transitions
    var validTransitions : Collection&lt;Transition&gt; 
    validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
    // Check if there is one and only one valid transition
    if validTransitions.empty then raise NoTransition.new end
    if validTransitions.size &gt; 1 then raise NonDeterminism.new end

    // Fire the transition
    result := validTransitions.one.fire
  end

  // Declaration of the post-condition
  post notVoidOutput is
  result != void and result != ""</programlisting>

    <para>The fire algorithm</para>

    <para>Behavior :</para>

    <para>1 – change the current state of the FSM</para>

    <para>2 – return the produced string</para>

    <programlisting>// Fire the transition
operation fire() : String is do
  // update FSM current state
  source.owningFSM.currentState := target
  result := output
end</programlisting>
  </chapter>
</book>