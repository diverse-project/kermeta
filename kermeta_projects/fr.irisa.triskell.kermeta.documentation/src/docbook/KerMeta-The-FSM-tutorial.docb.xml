<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book lang="en-US">
  <?ooogenerator OpenOffice.org/2.0$Linux OpenOffice.org_project/680m1$Build-8990?>

  <?oooversion ?>

  <bookinfo>
    <pubdate>Build date: @BUILD.DATE@</pubdate>

    <author>
      <firstname>François Tanguy, Didier Vojtisek, Zoé Drey, Marie Gouyette</firstname>

      <firstname></firstname>
    </author>

    <title>Kermeta tutorial</title>

    <date>2006-09-25T10:35:34</date>
    

    <keywordset>
      <keyword>Kermeta</keyword>

      <keyword>metamodeling</keyword>

      <keyword>language</keyword>
    </keywordset>

    <subtitle> FSM example</subtitle>

    <bibliomisc>Licence EPL</bibliomisc>

    <date>19/07/2006</date>

    <abstract>
      <para>This tutorial is part of a serie of tutorials that explain step by step the process explained in the Processes to build a DSL document (cf hyperlien).
       In this case, it rely on the classical Finite State Machine example.
     </para>
    </abstract>

    <publisher>
      <publishername>INRIA</publishername>

      <address>
        <state>France</state>
        <otheraddr>
          <ulink url="http://www.inria.fr">http://www.inria.fr</ulink>
        </otheraddr>
      </address>
    </publisher>

    <confgroup>
      <conftitle>title</conftitle>

      <confnum>Reference</confnum>

      <confsponsor>sponsor</confsponsor>
    </confgroup>
  </bookinfo>

  <preface>
    <?print-orientation portrait?>

    <title>Preface</title>

    <para>Kermeta is a Domain Specific Language
    dedicated to metamodel engineering. It fills the gap let by MOF which
    defines only the structure of meta-models, by adding a way to specify
    static semantic (similar to OCL) and dynamic semantic (using operational
    semantic in the operation of the metamodel). Kermeta uses the object-oriented
    paradigm like Java or Eiffel.This document presents various aspects of the language,
    including the textual syntax, the metamodel (which can be viewed as the
    abstract syntax) and some more advanced features typically included in its
    framework. </para>

    <important> <para>
      Kermeta is an evolving software and 

     
       despite that we put a lot of attention to this
        document, it may contain errors (more likely in the code samples). If
        you find any error or have some information that improves this
        document, please send it to us using the bug tracker in the
        forge:
     

      <ulink type="" url="http://gforge.inria.fr/tracker/?group_id=32">
        <emphasis role="strong">
          <emphasis role="strong">
            <emphasis
            role="strong">http://gforge.inria.fr/tracker/?group_id=32</emphasis>
          </emphasis>
        </emphasis>
      </ulink>

      <emphasis role="strong">
        <emphasis role="strong">
          <emphasis role="strong" />
        </emphasis>
      </emphasis>

      or using the developer mailing list
          (kermeta-developers@lists.gforge.inria.fr)
      

      <emphasis role="strong">
        <emphasis role="strong">
          <emphasis role="strong" />
        </emphasis>
      </emphasis>

      Last check: v1.3.2
     </para></important>

    <tip><para>
       The most update version of this document is available on line from 

      <ulink type=""
      url="http://www.kermeta.org/">http://www.kermeta.org</ulink>

       . 
    </para></tip>
   
  </preface>
  
   <chapter>
    <title>Introduction</title>

    <para>This tutorial gives an overview of many concepts 
    used through KerMeta project creation. Following this tutorial should give you the knowledge : 
    to create a meta model,run configurations, add pre and post conditions and add behaviour on it. To cover all this features, we decided to start from an existing example. 
    Because it is a complete KerMeta project, you should use it as  a reference guide.
     This example is about the finite state machine which acronym is FSM. 
     Firstly, a section explains how to load files of the example in your Eclipse workspace. 
     The next section is dedicated to the finite state machine we want to model. 
     You will have access to every files. Then we present the features presented above.   </para>
  </chapter>

  <chapter>
    <title>Installation</title>
	
	<section> 
    <title> Prerequisites</title>

    <caution>
      <para>KerMeta must be installed (FSM tutorial is only available in this case). If not, please read the "<ulink type=""
      url="../KerMeta-How-to-install-KerMetaInGalileo/index.html">How to install KerMeta</ulink>" tutorial.</para>
    </caution>
    
     
    
    <section>
      <title>Required knowledge<phrase id="knowledge"/></title>
      <orderedlist continuation="restarts">
        <listitem>
          <para>People who read this document need to have some knowledge about either EMOF or ECore metamodels</para>
        </listitem>
        <listitem>
          <para>Since ecore is used, people should have a minimal knowledge, as end-users, of Eclipse development environment.</para>
        </listitem>
      </orderedlist>
    </section>
    
     <section>
      <title>Terminology and format used in this tutorial<phrase id="terminology"/></title>
      <orderedlist continuation="restarts">
        <listitem>
          <para><emphasis role="strong">meta-model</emphasis> / <emphasis role="strong">Ecore model</emphasis>: both terms are used to point to the meta-model level. “Ecore model” corresponds to the Eclipse terminology for a meta-model specified in Ecore.</para>
        </listitem>
        <listitem>
          <para><emphasis role="strong">instance</emphasis>: in the context of this tutorial, the term “instance” is used to refer to an instance of a meta-model, i.e. of an <emphasis role="strong">Ecore model</emphasis>. Sometimes we will talk about instance-model (an Ecore model which is an instance of the meta-model), so, don't get confused.</para>
        </listitem>
        <listitem>
          <para><emphasis role="strong">model object</emphasis> <emphasis role="strong">/</emphasis> <emphasis role="strong">root class</emphasis>: in the scope of the EMF dynamic editor, these terms designate the model root class that contains all other ones. This root class is the only one in a model that has no container (i.e. which has no “black-diamonded” relation pointing to it).</para>
        </listitem>
        <listitem>
          <para><emphasis role="strong">containment</emphasis>: this term designates an important property of classes attributes/references. This property has to be appropriately set, in such a way that all the elements of an instance-model should be accessed from the root class of the model, which is aimed at being the highest-level container.</para>
        </listitem>
      </orderedlist>
    </section>
    </section>
    
    <section>
    <title> Install FSM project</title>
    
    <para>We start from the main Eclipse window.</para>

    <figure>
      <title> Eclipse window</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/main_window.png" width="20.00cm" depth="18.02cm"  />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Select : "File" &gt; "New"&gt;&gt; "Example..."&gt;&gt;&gt; A window
    appears. You are asked to choose a wizard for project creation. At the
    bottom of the list, you will find "Kermeta samples" item. Browse it and
    select "FSM Demo". The "Finish" button has been enabled. Click on
    it.</para>

    <figure>
      <title> Wizard for selection</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/wizard_selection.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Thanks to the wizard creation project, a project named
    "fr.irisa.triskell.kermeta.samples.fsm.demo" appeared on the left side of
    Eclipse.</para>

    <figure>
      <title> View of the example project</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/main_window_fsm_loaded.png" width="20.00cm" depth="18.02cm" />
        </imageobject>
      </mediaobject>
    </figure>
    
    <para> Now, you have the reference project and you can follow the tutorial.The next chapter presents the metamodel used in this tutorial. </para>
    </section>
  </chapter>

 

  <chapter>
    <title>Define the FSM metamodel</title>
	<section> 
	<title> Fsm metamodel presentation</title>
    <para>We want to represent IO/state machines. Inputs and outputs can be
    attached on each transition. To illustrate finite state machine, here is a
    simple example. This state machine recognizes the "hello!" motif and
    produces the "world!" motif. Here, we present this finite-state machine in
    a specific graphical syntax where states are represented as squares and
    transitions by arrow between squares. Input and outputs are present above
    transitions. Here, "h/w" says that we consume an "h" to produce a
    "w".</para>

    <figure>
      <title> Example of IO/State machines</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/helloWorldFSM.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>This simple state machine can be modeled and executed easily in
    Kermeta. See the following meta-model presented in a class diagram syntax.
    You can retrieve this metamodel named fsmStatic.ecore into
     fr.irisa.triskell.kermeta.samples.fsm.demo/metamodels/fsmStatic.ecore
    </para>

    <figure>
      <title> FSM metamodel</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/FSMBeginningMM.png" />
        </imageobject>
      </mediaobject>
    </figure>
    </section>
    
     <section>
     <title>Create the fsm meta-model <phrase id="create_meta_model"/></title>
      <para>This section addresses people who want either to use Eclipse Modeling Framework in order to create an EMF model, 
      and/or to manipulate them using Kermeta. The use of EMF models in Kermeta is done via the following steps, 
      which some of them are optional. We will detail them in the later sections. So, creating an EMF model consists on :</para>
       <orderedlist continuation="restarts">
        <listitem>
          <para> creating a metamodel in ecore format, following a few constraints that make its instances loadable by Kermeta</para>
        </listitem>
        <listitem>
          <para> creating a model, as an instance of the above meta-model, which we call, as you noticed, EMF model</para>
        </listitem>
        <listitem>
          <para> loading this model and manipulating it with a Kermeta transformation </para>
        </listitem>
        <listitem>
          <para> saving this model, or another model created from scratch with Kermeta.</para>
        </listitem>
      </orderedlist>
      
      <para></para>
      <para>There are four ways to create the structure of a meta model. The first one is to use Kermeta textual syntax and creating a ".kmt" file.
       Using this approach you will have the sensation of "programming" your metamodel. 
       The second one is to create an Ecore file using the tools proposed by EMF. 
       (for example the EMF reflexive editor, or the ecore diagram editor from ecore tools project).  You can also use the Omondo plugin or an graphical editor for your meta model. 
       The meta model for this tutorial will be created with EMF. </para>
       <para></para>
       <para>To start with, create a new general project and use the reflexive EMF editor to create the meta model like shown in the tutorial
        <ulink type=""
      url="../KerMeta-Create-Meta-model-With-EMF/index.html">"How to create an EMF meta model?"</ulink>
    .</para> 
       <para></para>
       <para>At this stage of the tutorial, you should have the following metamodel: </para>
       
       <figure>
       <title> A simple fsm metamodel</title>

       <mediaobject>
         <imageobject>
           <imagedata fileref="KerMeta-The-FSM-tutorial_figures/fsm_metamodel2.png" />
         </imageobject>
       </mediaobject>
      </figure>   
      
     
    
    <para> Then you can use this metamodel to create instances od models conform to it.</para>
    </section>
  </chapter>


  
    <chapter>
     <title>Editor</title>
     <para>In this chapter we present how to create instances of the Fsm metamodel. </para>
    
    
    <section>
    <title>Dynamic instances<phrase id="create_model"/></title>
      <para>This is the most simple and faster way for creating an instance of a meta-model during the first development phases. Creation is accessible by right-clicking onto the root class/model object of the meta-model (in the scope of the FSM example, it is the <emphasis>Fsm</emphasis> class). Because of the containment property, classes are only available for creation through this root class.
      However, we want to save this instance whatever we want into the workspace. Indeed, if the meta-model is not registered into the EMF Package Registry, a relative path is used to link the instance file with its meta-model. So we need to register this meta model into the EMF Package Registry.
      There is two ways to do that, deploying an EMF plugin like in the following section which add permanently the meta model to the Eclipse's EMF Package Registry or register dynamically the meta model on it thanks to a KerMeta functionality. This second way will be used in this tutorial cf <link linkend="PackageRegistry_Presentation"> Package Registry</link>.</para>
  
     
      
      <para> Now you can create a dynamic instance from an Ecore file like this :</para>
    
      <figure id="refIllustration8">
        <title>Create dynamic instance from an Ecore file</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-tutorial_figures/create_dynamic_instance.png" width="9.528cm" depth="5.136cm"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para/>
       
        </section>
        
        <section> <!-- Problem -->
        <title>Tree view editor</title>
      	<para>Since it allows to customize the generated editor to match meta-model specificities. 
      	(see the end of this article: <ulink url="http://www.eclipse.org/articles/Article-Using%20EMF/using-emf.html" type=""> Eclipse Corner Article : Using EMF</ulink>), this solution should be favoured for meta-models that are relatively stable and for final development phase.</para>
      	    <section>
      	    <title>Generate the editor </title>
            <para>This is the most ergonomic – but longest – way to create an instance of a meta-model.
            Start to create a new General Project (Menu File->New->Other-> General Project) and name it fsmEditor.
             This method is here presented in its main lines:</para>
            <orderedlist continuation="restarts" numeration="arabic">
            <listitem>
            <para>Once the meta-model is created, it is possible to create a model for model generation, called <emphasis>genmodel</emphasis>:</para>
            </listitem>
            </orderedlist>
            <orderedlist continuation="restarts">
          <listitem>
            <orderedlist continuation="restarts">
              <listitem>
                <para><emphasis role="strong"><emphasis role="strong">File </emphasis></emphasis><emphasis role="strong">&gt; New &gt; </emphasis><emphasis role="strong">O</emphasis><emphasis role="strong">ther &gt; Eclipse Modeling Framework </emphasis>folder<emphasis role="strong"> &gt; EMF Models</emphasis>;</para>
              </listitem>
              <listitem>
                <para>Choose a name for your genmodel (<emphasis>fsm.genmodel</emphasis> is ok);</para>
              </listitem>
              <listitem>
                <para>Select <emphasis role="strong">Load from an EMF core model</emphasis> button, and find the meta-model file (<emphasis>fsm.ecore</emphasis>);</para>
              </listitem>
              <listitem>
                <para>Select the unique package <emphasis>fsm</emphasis>.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
        <orderedlist continuation="continues" numeration="arabic">
          <listitem>
            <para>In order to avoid weird behaviour (particularly if the current project was not set as a “Java project”) the model directory of the genmodel needs to be changed in the <emphasis role="strong">Properties</emphasis> tab of the genmodel. For this purpose, change the property called <emphasis role="strong">Model Directory</emphasis> (in the Model folder), to <emphasis>/MyFirstEMFSamples.model/src</emphasis>, so that the EMF source code is generated in a new empty project that will exclusively contain this source code.</para>
          </listitem>
          <listitem>
            <para>Right-click on the root node of the <emphasis>fsm.genmodel</emphasis>, and choose the <emphasis role="strong">Generate all</emphasis> item.</para>
          </listitem>
        </orderedlist> 
        <para> You can customize this EMF editor following the section  <link linkend="CustomizeEMF_Editor"> Customize the generated EMF editor</link>   . </para>
         </section>
         
        
         
         
        
          
         
         
         <section>
        <title>Use the editor</title>
        <orderedlist continuation="restarts" numeration="arabic">
          <listitem>
            <para>To be able to use the generated reflexive editor, a new runtime workbench has to be launched through the tool bar menu:</para>
          </listitem>
        </orderedlist>
        <orderedlist continuation="restarts">
          <listitem>
            <orderedlist continuation="restarts">
              <listitem>
                <para><emphasis role="strong">Run &gt; Run As &gt; Run-time Workbench</emphasis> (in Eclipse 3.0.2);</para>
              </listitem>
              <listitem>
                <para>or <emphasis role="strong">Run &gt; Run... &gt; Eclipse application item in the right part &gt; New</emphasis> button<emphasis role="strong"> &gt; Apply</emphasis> button<emphasis role="strong"> &gt; Run</emphasis> button at the bottom (Eclipse 3.1).</para>
              </listitem>
              <listitem>
                <para>or <emphasis role="strong">Run &gt; Open Run Dialog... &gt; Eclipse application item in the left part &gt; New</emphasis> button<emphasis role="strong"> &gt; Apply</emphasis> button<emphasis role="strong"> &gt; Run</emphasis> button at the bottom (Eclipse 3.3).</para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
        <orderedlist continuation="continues" numeration="arabic">
          <listitem>
            <para>Once the new eclipse application is launched, create a new simple project (e.g. called <emphasis>MyFirstEMFInstances</emphasis>), and select <emphasis role="strong"><emphasis role="strong">File </emphasis></emphasis><emphasis role="strong">&gt; New &gt; </emphasis><emphasis role="strong">O</emphasis><emphasis role="strong">ther &gt; Example EMF Creation Wizards </emphasis>folder<emphasis role="strong"> &gt; Fsm Model</emphasis>;</para>
          </listitem>
          <listitem>
            <para>Creation of an EMF model follows the same principles that the creation of an Ecore model. Note that the model object, which was <emphasis role="strong">EPackage</emphasis> in the meta-model creation, becomes <emphasis role="strong">Fsm</emphasis> in the EMF model creation;</para>
          </listitem>
          <listitem>
            <para>As you work in another Eclipse environment, you will probably want to copy the models that you created this way in your initial project (the one named <emphasis>MyFirstEMFSamples</emphasis>). Simply do it.</para>
          </listitem>
        </orderedlist>
      </section>
        <para> You can use another editors to create instances models such as graphical or textual editors.Thes types of editors will not be detailed into this tutorial. </para>
        </section> 
    
       
         <section>
        <title> Textual editors</title>
        <para> You can also use textuals editors like
        <ulink type=""
      url="http://www.eclipse.org/Xtext/"> XText</ulink> ,
      <ulink type=""
      url="http://www.emftext.org/index.php/EMFText"> EMFText</ulink>,
       <ulink type=""
      url="http://www.kermeta.org/sintaks/">  Sintaks   </ulink> (which is part of the Kermeta project) .
      This textuals editors are not detailed here, please refer to the logo tutorial.
       </para>
        </section>
     
  
        <section>
        <title> Graphical editors</title>
        <para> EMF metamodels can be used with tools like  <ulink 
      url="http://www.eclipse.org/modeling/gmf/"> GMF (Graphical Modelling Framework)</ulink>  or 
      <ulink type=""
      url="http://www.topcased.org/"> Topcased</ulink> 
       to create graphical editors for model instances. The tutorial  <ulink type=""
      url="../KerMeta-Create-FSM-Graphical-Editor-With-GMF/index.html"> How to create a FSM graphical editor with GMF? </ulink>
      explains the creation of an GMF editor with a very simple FSM metamodel.
      </para>
        </section>
        
        <para> You know how to create a model conform to the Fsm metamodel. The next chapter explains how to manipulate models with Kermeta.  </para>
        </chapter>
       

      <chapter>
        <title> Model manipulation in Kermeta </title>
        <para>Firstly, we present to you how to create a KerMeta file Then loading a first Kermeta program can be achieved by just copying the code provided in the following sections, following carefully the suggested instructions. Readers who want to directly load their own models should directly go to the section 5.3.5 <!--  -->  and copy the given template.</para>
        <section> 
          <title> Preparing a Kermeta program </title>
          <section>
          <title> Create a new KerMeta file</title>
          <para> You can start with opening the Kermeta perspective with Window->Open Perspective -> Other -> Kermeta </para>
          <para> To create a new Kermeta file you need to start by creating a new general empty project in Eclipse.
           Then, select in the main menu of Eclipse</para>

    <para>"File" &gt; "New" &gt;&gt; "New Kermeta File"</para>

    <para>This action opens the following window.</para>

    <figure>
      <title> Create a new Kermeta file</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/kmt-from-scratch.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Select "New Kermeta file" and press "Next &gt;".</para>

    <figure>
      <title> Wizard to create a new Kermeta file</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/kmt-file.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Give a name (MyMetamodel.kmt for instance) to the new file, select a
    location (The default one is good for us) and leave Main class and Main
    operation blank for the moment. It will be used later to run models. Click
    on "Finish".</para>

    <para>Now your main window should look like the one above. The file is
    written in KerMeta language. So you can edit this file to add some
    classes, attributes and so on using the KerMeta language (read <ulink
    type=""
    url="http://www.kermeta.org/documents/manual/">http://www.kermeta.org/documents/manual/</ulink>
    for more details on KerMeta language).</para>

    <para></para>

    <figure>
      <title> New Kermeta file</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/kmt-blank-file.png" />
        </imageobject>
      </mediaobject>
    </figure>
         
          
          <tip>
          <title> Create a Kermeta file into another perspective</title>
          <para> If you are not into the Kermeta perspective you can create a new Kermeta file with 
           File -> New -> Other -> Kermeta -> New Kermeta File</para>
          </tip>
          
          <tip>
          <title> Add the Kermeta nature to a project</title>
          <para> If your project is not a Kemeta project you can add the Kermeta nature on it.
          Right click on the project Kermeta-> Add Kermeta nature. It permit to check the .kmt files at the beginning of Eclipse.
          </para>
          </tip>
          
           </section>
        </section>
        
        <section id="PackageRegistry_Presentation">
        <title> Package registry</title>
        <para>Like shown in the section dynamic instances you can register dynamically a meta model in order to create instances of it thank to the menu 
        EPackages registration -> Register EPackages into repository.</para>
         <warning>
    <title> Dynamical EMF Registration is not permanent</title>
    <para> You need to register again the meta models for each new instance of Eclipse. </para>
    </warning>
    
     <para>The following menu EPackages registration have three entries :</para>
     <orderedlist continuation="restarts">
        <listitem>
          <para> <emphasis role="strong"> Re-Register EPackages into registry : </emphasis> unregister and register again the EPackage in order to take into account the meta model's changes  </para>
        </listitem>
        <listitem>
          <para> <emphasis role="strong"> Unregister EPackages into registry : </emphasis> remove EPackage from EMF EPackage registry </para>
        </listitem>
        <listitem>
         <para> <emphasis role="strong"> Register EPackages into registry : </emphasis> add EPackage from EMF EPackage registry </para> 
        </listitem>
      </orderedlist>
      
    <figure id="refIllustration81">
        <title>Register the meta model into the EMF EPackage Registry</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-tutorial_figures/registration1.png" />
          </imageobject>
        </mediaobject>
      </figure> 
      <para/>
        </section>
           
         <section>  
         <title> Serialization</title>
         <para> The serialization permits to save and load models thanks to the persistence library.</para>
           <section>
          	<title>The persistence library</title>
        	<para>The persistence library is inspired from the resource manager of EMF models. There is a repository (called <emphasis>EMFRepository</emphasis>), that is aimed at containing a set of resources (the <emphasis>EMFResources</emphasis>). Each resource contains a reference called <emphasis>instances</emphasis>, that contains all the root classes of the loaded model (there is usually only have one root class). So, the procedure of creation of a resource that will handle EMF models is the following (code example is provided in next sections):</para>
       		 <orderedlist continuation="restarts">
          	<listitem>
            <para>Instanciate an EMFRepository;</para>
          </listitem>
          <listitem>
            <para>Create a new EMF resource in this repository;</para>
          </listitem>
          <listitem>
            <para>Load this resource;</para>
          </listitem>
          <listitem>
            <para>Get the instances, i.e. the root class(es). All other instances can then be accessed by navigating the root class(es) properties.</para>
          </listitem>
        </orderedlist>
         </section>
         
         <section>
         <title> Load an EMF model with Kermeta </title>
         <para>The following code sample load a previously created FSM model:
        <example>
         <title> Load an EMF model with Kermeta </title>
         <programlisting>
         @mainClass "fsm_package::Main"
         @mainOperation "main"

         <emphasis role="strong">package</emphasis> fsm_package;

         <emphasis role="strong">require</emphasis> kermeta
         <emphasis role="strong">require</emphasis> "../metamodels/fsm.ecore"
         <co id="load.emfmodel.metamodelfsm.co" linkends="load.emfmodel.metamodelfsm.callout"/>
         
         <emphasis role="strong">using</emphasis> kermeta::persistence 
           <co id="load.emfmodel.using.persistence.co" linkends="load.emfmodel.using.persistence.callout"/>
           
         <emphasis role="strong">using</emphasis> kermeta::standard
         
         <emphasis role="strong">operation</emphasis> main() : Void <emphasis role="strong">is</emphasis> <emphasis role="strong">do</emphasis> 
         <emphasis>// Input fsm</emphasis>
         <emphasis role="strong">var</emphasis> fsm1 : fsm::Fsm
         <emphasis>// Create the repository, then the resource</emphasis>
         <emphasis role="strong">var</emphasis> repository : EMFRepository <emphasis role="strong">init</emphasis> EMFRepository.new
         <emphasis role="strong">var</emphasis> resource : EMFResource 
         resource ?= repository.createResource("../models/Fsm_dyn_sample1.xmi", "../metamodels/fsm.ecore")
         <co id="load.emfmodel.createResource.co" linkends="load.emfmodel.createResource.callout"/>
         resource.load

 <emphasis>// Load the fsm (we get the instance)</emphasis> 
 fsm1 ?= resource.one
 <co id="load.emfmodel.resource.co" linkends="load.emfmodel.resource.callout"/>
 <emphasis>// Check that the fsm was correctly loaded</emphasis>
 fsm1.state.each { s | stdio.writeln("-&gt; "+s.name) }
 fsm1.transition.each { t | stdio.writeln( t.source.name+ " -- " +t.target.name ) }
<emphasis role="strong">end</emphasis>
         </programlisting>
         <para>
         <calloutlist>
         <callout arearefs="load.emfmodel.metamodelfsm.co" id= "load.emfmodel.metamodelfsm.callout">
         <para> To serialize the class definition, the meta model need to be known.
         </para>
         </callout>
         
          <callout arearefs="load.emfmodel.createResource.co" id= "load.emfmodel.createResource.callout">
         <para> The persistence permits to load and save EMF models. The key word <emphasis>using</emphasis>
         is used to simplify writing code like import in Java.
         </para>
         </callout>
         
         <callout arearefs="load.emfmodel.using.persistence.co" id= "load.emfmodel.using.persistence.callout">
         <para> The second parameter of this method permit to know what exactly will be saved.
         </para>
         </callout>
         
         <callout arearefs="load.emfmodel.resource.co" id= "load.emfmodel.resource.callout">
         <para> resource is collection of instances which are in the root file. The first instance of this resource is retrieve by the method one.
         
         <tip>
         <title>Browse through the resource</title>
         <para> You can use resource.each if you want to browse through the resource.</para>
         </tip>
         
         <!--  <warning>
         <title> </title>
         <para></para>
         </warning> -->
         
         </para>
         </callout>
         </calloutlist>
         </para>
         </example>  
         
         </para>
         
          </section>
         
         
       
    <section>
      <title>Modify and save an EMF model with Kermeta</title>
      <para>At this stage, it should be interesting to be able to modify a previously loaded model using Kermeta before saving it. The procedure is very simple: do your manipulation as if your loaded FSM model is a Kermeta model (which is, in effect, the case!), and then, simply call a save method on the handling resource. For this purpose, the following code can be added at the end of the <emphasis>main</emphasis> operation defined in the above section:</para>
      <programlisting><emphasis role="strong">var</emphasis> newstate : fsm::State <emphasis role="strong">init</emphasis> fsm::State.new
newstate.name := "s_new"fsm1.state.add(newstate)
<emphasis>// save fsm1 </emphasis>
resource.save()</programlisting>
      <para>It is also possible to save the modified model in a new file instead of overwriting the initial one by using the <literal>saveWithNewURI()</literal> method. To this end, just replace the last line of above code (<literal>resource.save()</literal>) by the following one:</para>
      <programlisting>resource.saveWithNewURI("../models/modified_dyn_sample1.xmi")</programlisting>
    </section>
    
    <section>
    <title>Create a model in Kermeta, and save it as an EMF model</title>
      <para>Saving a programmatically generated model requires to use a new specific instruction that addq the created <emphasis>Fsm</emphasis> root class to the destination resource. The following code chunk creates a simple EMF model with 2 states (named “foo”, and “bar”), and 2 transitions. Saving it then consists in adding the root class (i.e. the model object) stored in the variable <literal>fsm2</literal> into the resource instances.</para>
      <programlisting><emphasis role="strong">var</emphasis> another_resource : EMFResource
another_resource ?= repository.createResource(
       "../models/Fsm_scratch_sample.xmi",
       "../metamodels/fsm.ecore")
<emphasis role="strong">var</emphasis> fsm2 : fsm::Fsm <emphasis role="strong">init</emphasis> fsm::Fsm.new
<emphasis role="strong">var</emphasis> s0 : fsm::State <emphasis role="strong">init</emphasis> fsm::State.new
<emphasis role="strong">var</emphasis> s1 : fsm::State <emphasis role="strong">init</emphasis> fsm::State.new
<emphasis role="strong">var</emphasis> t01 : fsm::Transition <emphasis role="strong">init</emphasis> fsm::Transition.new
<emphasis role="strong">var</emphasis> t11 : fsm::Transition <emphasis role="strong">init</emphasis> fsm::Transition.new
s0.name := "foo"
s1.name := "bar"
t01.source := s0
t01.target := s1
t11.source := s1
t11.target := s1
fsm2.state.add(s0)
fsm2.state.add(s1)
fsm2.transition.add(t01)
fsm2.transition.add(t11)
<emphasis>// save the from-scratch model!</emphasis>
another_resource.add(fsm2)
another_resource.save()</programlisting>
<para>This program should return the following FSM model (viewed with the reflexive editor):</para>
      <figure id="refIllustration9">
        <title>Fsm_scratch_sample view</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-tutorial_figures/fsm_scratch_sample.png" width="14.707cm" depth="9.02cm"/>
          </imageobject>
        </mediaobject>
      </figure>
       <para/>
     
    </section> 
    
    <section>
     <title>A template for a complete Kermeta program<phrase id="template"/></title>
      <para>The following short code sample provides a comprehensive code template (replace the <emphasis>&lt;words&gt;</emphasis>) for model loading. Note here that the term <emphasis>model object</emphasis> is appropriate (better than <emphasis>root class</emphasis>!): loading a model consists in getting the root class, from which, thanks to the containment property (see section, all the contained instances can be accessed.</para>
      <programlisting>@mainClass "fsm_package::Main"
@mainOperation "main"
<emphasis role="strong">package</emphasis> fsm_package;
<emphasis role="strong">require</emphasis> kermeta 
<emphasis role="strong">require</emphasis> "&lt;relative_path_of_the_metamodel&gt;" // NOTE : same as param of createResource

<emphasis role="strong">using</emphasis> kermeta::persistence
<emphasis role="strong">using</emphasis> kermeta::standard
<emphasis role="strong">class</emphasis> Main
{
 <emphasis role="strong">operation</emphasis> main() : Void is do 
      /<emphasis>/ Variable for your input EMF model</emphasis>
      <emphasis role="strong">var</emphasis> &lt;my_model_object&gt; : &lt;type_of_my_model&gt;
      <emphasis>// Create the repository, then the resource</emphasis>
      <emphasis role="strong">var</emphasis> &lt;my_rep&gt; : EMFRepository <emphasis role="strong">init</emphasis> EMFRepository.new 
      <emphasis role="strong">var</emphasis> &lt;my_resource&gt; : EMFResource 
      &lt;my_resource&gt; ?= repository.createResource(
      "&lt;relative_path_of_my_model_to_load&gt;",
      "&lt;relative_path_of_the_metamodel&gt;")
      &lt;my_resource&gt;.load
      <emphasis>// Load the emf model - get the root class </emphasis>
      &lt;my_model_object&gt; ?= resource.instances.one
     <emphasis>// You can now browse your model through its attributes/references </emphasis>
      &lt;my_model_object&gt;.&lt;an_attribute_of_it&gt;.each { o | 
         stdio.writeln("-&gt; "+o.toString) } )
     <emphasis>// Save your model in another file</emphasis>
      &lt;my_resource&gt;.saveWithNewUri("&lt;relative_path_of_a_file_where_to_save_model&gt;")
 <emphasis role="strong">end</emphasis>
}
</programlisting>
    </section>
    
    <section>
    <title> Load and save for models divided into several resources</title>
    <para> 
    
    <warning>
    <title> Depending models on the same EMFRepository</title>
    <para>  Several models which have links between them  <emphasis> must</emphasis> be saved into the same EMFRepository. 
           Be careful on saving the resources (unlike load which retrieve all the resources). </para>
    </warning>
    
    If your models have no dependancy between them, you can save them into several EMFRepository.
    </para>
    </section>
      </section>
    </chapter>
    
    
    
 
    <chapter>
    <title>Contract</title>
    <para> By contract, we mean add pre or post condition to our ecore model in order to add constraints on the Fsm's execution.
    Firstly, we present how to run configurations to parametrize this pre or post conditions. 
    Then we present examples of pre and post conditions. </para>
    <section>
     <title>Run configurations</title>

    <para></para>

    <section>
      <title>An entry point for the program</title>

      <para>We want to execute an FSM model. To do that we must call the "run"
      operation of the "FSM" class. We are going to do that thanks to a
      KerMeta script. This script will : load an instance of the FSM meta
      model stored in a file call the run operation of these instance. To
      launch a script, the interpreter must know the entry point of the
      program. That is the roles of these two statements : </para>

      <itemizedlist>
        <listitem>
          <para>@mainClass which stands for the main class,</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>@mainOperation which stands for the main operation of the main
          class.</para>
        </listitem>
      </itemizedlist>

      <para>In the FSM example, those scripts are in the "launcher" directory.
      Look at "minimization.kmt" script. Here the interpreter knows that entry
      point of the program is the operation "main" in the "Minimization"
      class.</para>

      <figure>
        <title> The launcher folder</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-tutorial_figures/launchers.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    
    <section>
    <title>Constraints checking execution or no constraints checking
      execution</title>

      <para>Using KerMeta allows you to choose between two types of executions
      : one with constraints checking and one without. A constraints checking
      execution checks every pre/post condition statements of your KerMeta
      program. If one of this pre/post conditions are violated, an exception
      is raised and the program is aborted. A none constraints checking
      execution does not check the pre/post condition statements of your
      KerMeta program. </para>
    </section>
    
    <section>
    <title>Execution without parameters</title>

      <para>Let's have a look at the file named "minimization.kmt". Open it.
      Look at the code of the main operation. There is no parameter. To run
      this script with constraint checking, right click on "minimization.kmt"
      and select "Run As" and "Kermete App with constraints". To run this
      script without constraint checking, right click on "minimization.kmt"
      and select "Run As" and "Kermeta App".</para>

      <figure>
        <title> Execution of minimization example</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-tutorial_figures/minimization-execution.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The program asks you for a filename. Put in
      "../models/sample1.fsm" for example. You are lastly asked for a filename
      which will correspond to the file generated by the program. Put in
      "../generated.fsm" and see the execution.</para>
    </section>

    <section>
      <title>Execution with parameter(s)</title>

      <para>Now if you have a look at the three others scripts
      (checkInvariants, determinization and fsmLauncher) you will notice that
      the main operation of the main class takes one argument. Let's focus on
      "fsmLauncher.kmt" launcher. The main operation takes one parameter which
      is the name of the file containing the FSM model. It loads the model,
      prints it and runs it. If you try the running method above, an exception
      is raised because the parameterized file does not exist. Indeed we did
      not specify any filename to the program. So, you cannot use the method
      above to run those kind of script. That is the reason why we are going
      to use run configurations. Then right click on "fsmLauncher.kmt" file
      and select "Run As" and "Run...". A window appears like the one below.
      Select the run configuration named "loaderFSM" and look at the different
      options. Have a special look at the file parameters : </para>

      <itemizedlist>
        <listitem>
          <para>"Location of your program file", here this is
          "fsmLauncher.kmt" filename relative to the project's root
          directory.</para>
        </listitem>

        <listitem>
          <para>"Class qualified name", that is to say the main class of the
          program.</para>
        </listitem>

        <listitem>
          <para>"Operation name", that is to say the main operation of the
          main class.</para>
        </listitem>

        <listitem>
          <para>"Operation arguments", the parameters you want to send to the
          main operation.</para>
        </listitem>
      </itemizedlist>

      <para>Here, we give the string "../models/sample1.fsm" as a parameter to
      mainLoadFSM operation to "fsm::Main" class. By clicking on "Run" button,
      it will start the execution. You can create yourself some new run
      configurations. Just by left clicking on "Kermeta Application " or
      "Kermeta Constraint Application" (depending on the constraint checking
      you want) and select "New" and fill in the required fields.</para>

      <caution>
        <para>Eclipse is slash sensible. It only accepts front slash and no
        backslash. Then
        /fr.irisa.triskell.kermeta.samples.fsm.demo/launcher/fsmLauncher.kmt
        is a valid filename whereas
        \fr.irisa.triskell.kermeta.samples.fsm.demo\launcher\fsmLauncher.kmt
        is not.</para>
      </caution>

      <figure>
        <title> Run configurations </title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-tutorial_figures/run_configuration.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    
   </section>
   
   <section> 
    <title>Constraints checking execution sample</title>

    <para>Have a look at the "step" method in the "State" class in the
    "fsm.kmt" file.</para>

    <programlisting>// Go to the next state
operation step(c : String) : String raises FSMException is

// Declaration of the pre-condition
pre notVoidInput is
   c != void and c != ""

do
   // Get the valid transitions
   var validTransitions : Collection&lt;Transition&gt; 
   validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
   // Check if there is one and only one valid transition
   if validTransitions.empty then raise NoTransition.new end
   if validTransitions.size &gt; 1 then raise NonDeterminism.new end

   // Fire the transition
   result := validTransitions.one.fire
end

// Declaration of the post-condition
post notVoidOutput is
   result != void and result != ""</programlisting>

    <para>There is a pre condition which says that the character given as a
    parameter must not be void or empty string. The post condition says that
    the result must not be void or empty string. For each "step" method call,
    the pre and post conditions will be checked. If there are evaluated as
    false, the program is aborted otherwise the program goes on. Look at the
    run configuration named "loaderFSM4prepost". Open the file
    (../models/sample1postv.fsm) used as parameter for this configuration.
    Observe the finite state diagram.</para>

    <section>
      <title>Pre condition violation</title>

      <para>Execute "loaderFSM4prepost" configuration. When you are asked for
      a letter , just press enter to send an empty string. Normally, it should
      provoke the violation of the pre condition. before loading after loading
      State : s1 Transition : s1-(c/NC)-&gt;s2 State : s2 Transition :
      s2-(x/y)-&gt;s2 Current state : s1 give me a letter : stepping...
      [kermeta::exceptions::ConstraintViolatedPre:8670] pre notVoidInput of
      operation step of class State violated</para>
    </section>

    <section>
      <title>Post condition violation</title>

      <para>Execute "loaderFSM4prepost" configuration. When you are asked for
      a letter , press c and then press enter. Normally, the post condition
      will be violated because the result will be an empty string. before
      loading after loading State : s1 Transition : s1-(c/NC)-&gt;s2 State :
      s2 Transition : s2-(x/y)-&gt;s2 Current state : s1 give me a letter : c
      c stepping... [kermeta::exceptions::ConstraintViolatedPost:9684] post
      notVoidOutput of operation step of class State violated</para>
    </section>
   </section>
   
   <para> This chapter presented the use of pre and post condition on an execution.The next chapter explain how you can simulate an execution of the modelling system thank to behaviour. </para>
  </chapter>
    

  <chapter>
    <title>Behaviour </title>
    <section>
     <title> Expected behaviour for this tutorial </title>
      <para> Adding a behaviour to the FSM meta-model consists in to make a simulation of execution with operations and an execution context represented by the current state of the FSM.
    
    That's why you need to add a currentState reference and three operation :  </para>
    <orderedlist continuation="restarts">
          <listitem>
            <para> run() for FSM class,</para>
          </listitem>
          <listitem>
            <para> step(String): String for State class,</para>
          </listitem>
          <listitem>
            <para>and fire(): String for Transition class </para>
          </listitem>
     </orderedlist>
     <para>Adding behavior to this meta model look like change the meta model according the following schema : </para>
     
     <figure>
      <title> FSM metamodel with behavior</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/FSMBehaviorMM.png" />
        </imageobject>
      </mediaobject>
    </figure>
    
    <para> The old way to add behavior in Kermeta was transform the ecore meta model into a Kermeta file and add the code for the methods. 
    This tutorial presents the new approach, use aspect to add this new operations. With aspect, you can add new elements and new operations to a fixed meta-model.
    You can also combine several aspects. </para>
    </section>
    
    <section> 
    <title> Structuration of this behavior with aspects</title>
    <para> So, this part presents the use of aspects to implement behavior.
    An aspect into a KerMeta file can be created simply with :</para>
    <para>
    <example>
    <title> Aspect  in Kermeta</title>
    <programlisting>require kermeta
     require "http://www.kermeta.org/fsm"
       <co id="add.behavior.require.co" linkends="add.behavior.require.callout"/>
       
     using fsm
       <co id="add.behavior.using.co" linkends="add.behavior.using.callout"/> 
     using kermeta::standard
      
      aspect class Transition 
      <co id="add.behavior.class.Transition.co" linkends="add.behavior.class.Transition.callout"/>
	{	
	// Fire the transition
	operation fire() : String is do
	<co id="add.behavior.operation.fire.co" linkends="add.behavior.operation.fire.callout"/>
	  [...]
	end
	}
      
     
     }
    </programlisting>
    <para>
    <calloutlist>
     <callout arearefs="add.behavior.require.co" id= "add.behavior.require.callout">
         <para> You need to load the meta model where you will weave aspects.
         </para>
         </callout>
         
          <callout arearefs="add.behavior.using.co" id= "add.behavior.using.callout">
         <para> The key word using fsm permits to simplify the writing of the elements from the  fsm meta model like
               an import in the Java language.
         </para>
         </callout>
         
         <callout arearefs="add.behavior.class.Transition.co" id= "add.behavior.class.Transition.callout">
         <para> The key word aspect is used to add attribute or operation to an existing metaclass (in this case Transition) of the loaded meta model.
         </para>
         </callout>
         
         <callout arearefs="add.behavior.operation.fire.co" id= "add.behavior.operation.fire.callout">
         <para> Now, you can add attribute or operation like in a classical Kermeta file.
         </para>
         </callout>
    </calloutlist>
    </para>
    </example>
    </para>
    
    
    <warning>
    <title></title>
    <para> None of  the elements added by aspect take part of the ecore meta model, so these elements are transient that’s why it cannot be serialized by this way. 
    If you want to serialize a new element to the meta model you need to add it into.</para>
    </warning>
    
    <para> Have a look on the Kermeta file fsm_Operationnal_Semantics.kmt in the folder kermeta/semantics. 
    You can add several aspects in the same file. So, this code is structured like this : 
     </para>
     
     <para>
     <example>
     <title> Structuration of the fsm_Operationnal_Semantics.kmt file</title>
     <programlisting> 
     package fsm;

	require kermeta
	require "http://www.kermeta.org/fsm"
	using fsm
	using kermeta::standard
	using kermeta::persistence
	using kermeta::exceptions

 
 
	aspect class FSM 
	{
	reference currentState : State
	 <co id="add.behavior.exampleAspect.reference.co" linkends="add.behavior.exampleAspect.reference.callout"/>
	 
	  
	// Operational semantic
	operation run() :  Void raises FSMException is do 
	<co id="add.behavior.exampleAspect.raises.co" linkends="add.behavior.exampleAspect.raises.callout"/>
    // [...]
     end 
     
     /** Initialize a new automaton from an existing one 
	 *  param :
	 *    p_state : the initial state
	 *    isInitComb
	 */
	operation initialize(p_state : State, isInitComb : Boolean) is do
     // [...]
     end
     
  } 
   <co id="add.behavior.exampleAspect.endAspect.co" linkends="add.behavior.exampleAspect.endAspect.callout"/>
  
  aspect class State {
  
  // Go to the next state
	operation step(c : String) : String raises FSMException
	//[...]
	end
	
  } 
  
  aspect class Transition 
{	
	
	// Fire the transition
	operation fire() : String is do
	//[...]
	end
	}
     </programlisting>
      <para>
    <calloutlist>
     <callout arearefs="add.behavior.exampleAspect.reference.co" id= "add.behavior.exampleAspect.reference.callout">
         <para> The reference currentState is added by aspect into the fsm meta model.
         </para>
         </callout>
         
          <callout arearefs="add.behavior.exampleAspect.raises.co" id= "add.behavior.exampleAspect.raises.callout">
         <para> The key word raises declare an exception that an operation can throw.
         </para>
         </callout>
         
          <callout arearefs="add.behavior.exampleAspect.endAspect.co" id= "add.behavior.exampleAspect.endAspect.callout">
         <para> Don't forget to close the brace at the and of an aspect definition.
         </para>
         </callout>
         
       
    </calloutlist>
    </para>
     
     </example>
     </para>
     <para> The next section presents the differents algorithms in details.</para>
    </section>
    
    <section>
    <title> Behavior algorithms</title>
     <para>Now, we will present in details the algorithm for the operations run(), step(String) and fire (String).</para>
     <itemizedlist>
      <listitem>
        <para>The run operation is used as a user interface. Thanks to this
        operation, we are going to display information about the finite state
        machine, read user input and process steps.</para>
      </listitem>

      <listitem>
        <para>The step operation is used to go to an other state depending on
        the user's input and the transitions available from the current
        state.</para>
      </listitem>

      <listitem>
        <para>The fire operation is used to change the current state and to
        get the produced string.</para>
      </listitem>
    </itemizedlist>

    <para>Let us see the behavior of these three operations.</para>

    <section>
    <title> Run algorithm</title>
    <para>Behavior :</para>

    <para>1 – initialize current state</para>

    <para>2 – loop until the user's input equal to "quit"</para>

    <para>print the current state</para>

    <para>read a string</para>

    <para>process a step</para>

    <para>catch exceptions if there are some and exit the program displaying
    the error.</para>

    <para>Here is the code of the operation :</para>

    <programlisting>operation run() : Void raises FSMException is do  
  // reset if there is no current state
  if self.currentState == void then self.currentState := self.initialState end
  self
  from var str : String init "init"
  until str == "quit"
  loop
    stdio.writeln("Current state : " + self.currentState.name)
    str := stdio.read("give me a letter : ")
    if str == "quit" then
      stdio.writeln("")
      stdio.writeln("quitting ...")
    else 
      if str == "print" then
        stdio.writeln("")
      else	
        stdio.writeln(str)
        stdio.writeln("stepping...")
        do
          var textRes : String
          textRes := self.currentState.step(str)
          if( textRes == void or textRes == "" ) then
            textRes := "NC"
          end

          stdio.writeln("string produced : " + textRes)
          rescue (err : ConstraintViolatedPre)
            stdio.writeln(err.toString)
            stdio.writeln(err.message)
            str := "quit"
          rescue (err : ConstraintViolatedPost)
            stdio.writeln(err.toString)
            stdio.writeln(err.message)
            str := "quit"
          rescue(err : NonDeterminism)
            stdio.writeln(err.toString)
            str := "quit"
          rescue(err : NoTransition)
            stdio.writeln(err.toString)
            str := "quit"
          end
        end
      end
    end
end</programlisting>
</section>

<section>
<title> Step algorithm </title>
   
    <para>In this operation, there are pre and post conditions. These are
    conditions checked each time the operation is called. If they are
    evaluated to false an exception is raised. You can choose to check them or
    not. The following chapter presents how to run configurations.</para>

    <para>Behavior :</para>

    <para>1 – Select the possible transitions.</para>

    <para>2 – If there is none raise a NoTransition exception.</para>

    <para>If there is more than one raise a NonDeterminism exception.</para>

    <para>3 – If there is only one transition, call its fire operation and
    return its result.</para>

    <programlisting>// Go to the next state
operation step(c : String) : String raises FSMException

  // Declaration of the pre-condition
  pre notVoidInput is
    c != void and c != ""

  // Declaration of the post-condition
  post notVoidOutput is
  result != void and result != ""
  
  is do
    // Get the valid transitions
    var validTransitions : Collection&lt;Transition&gt; 
    validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
    // Check if there is one and only one valid transition
    if validTransitions.empty then raise NoTransition.new end
    if validTransitions.size &gt; 1 then raise NonDeterminism.new end

    // Fire the transition
    result := validTransitions.one.fire
  end
</programlisting>
</section>

<section>
<title> Fire algorithm </title>

    <para>Behavior :</para>

    <para>1 – change the current state of the FSM</para>

    <para>2 – return the produced string</para>

    <programlisting>// Fire the transition
operation fire() : String is do
  // update FSM current state
  source.owningFSM.currentState := target
  result := output
end</programlisting>
</section>
    </section>
    
    </chapter>
   

 
  
  <chapter>
  <title> Check model </title>
 <para>This class permit to check all the invariants from the meta model thanks to the method checkAllInvariants.
  </para>
 <programlisting>
 class InvariantChecker
{
    operation main(input_automaton : String) : Void is do 
        var rep : EMFRepository init EMFRepository.new
        var theFSM : FSM init AutomatonHelper.new.loadEMFAutomaton(rep, input_automaton, "http://www.kermeta.org/fsm")
        
        // Uncomment to check the invariant properties : WFR
        // To check all contained elements by "theFSM"
        stdio.writeln("> call of the checkAllInvariants method")
        theFSM.checkAllInvariants
        // To check only the states that are contained in "theFSM"
        stdio.writeln("> call of the checkInvariants method")
        Main.new.checkWFR(theFSM)
	end
}
 </programlisting>
  </chapter>
  
  <chapter>
  <title> Model Transformation</title>
  <para> The files minimization.kmt and determinization.kmt from fr.irisa.triskell.kermeta.samples.fsm.demo/launcher are examples of transformation of one model to one another,let you have a look on it. 
   These examples are separated into three main steps : </para>
    <orderedlist continuation="restarts">
          <listitem>
            <para> load the model to transform and initialize the output model</para>
          </listitem>
          <listitem>
            <para> traitment of the transformation (use an algoritm to determin the new results and add it into other output model).</para>
          </listitem>
          <listitem>
            <para>save the output model</para>
          </listitem>
     </orderedlist>
   
  </chapter>
  
  <chapter>
  <title> UI improvements </title>
  <para> You can customize your user interface like shown below. For more samples please refer to the Logo sample.  </para>
  
   <section id="CustomizeEMF_Editor">
         <title> Customize the generated EMF editor</title>
         <para>   Generated code  can be modified for customization. In this tutorial we change some icons and the text presentation. </para>
         <tip>
         <title> Add custom code</title>
         <para> To keep your customized code for each generation you need to add 
         <programlisting language="Java"> 
         /**
	       * 
	       * @generated NOT
	       */
         </programlisting> just before the name of the method you want to customize.</para>
         </tip>
         
         <section>
         <title> Change the editor's icons</title>
         <para> The generation make appear three new plugins : fsmEditor.edit, fsmEditor.editor and  fsmEditor.tests. 
              To change an icon you need only to replace the icon from fsmEditor.edit/icons/full/obj16 to another with the same name and the same extension. </para>
              
              <figure>
      <title> Customize icons</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-The-FSM-tutorial_figures/CustomIcons.png" />
        </imageobject>
      </mediaobject>
    </figure>
        
         <para> You will see the change when you will use the generated editor like in the following section.</para>
         </section>
         
         <section>
         <title> Change text presentation</title>
         <para>
         In this example we want just to add the String "FSM type:" before the display text.
         Open the file FSMItemProvider.java in the plugin fsmEditor.edit and the package fsm.provider.
         Change the method getText() to 
         <programlisting language="Java">
         /**
	       * This returns the label text for the adapted class.
	       * <!-- begin-user-doc -->
	       * <!-- end-user-doc -->
	       * @generated NOT
	       */
	    @Override
	    public String getText(Object object) {
		   return "FSM type : " +  getString("_UI_FSM_type");
	}
         </programlisting>
         . </para>
         </section>
     </section>
  </chapter>
  
  <chapter>
  <title> Conclusion</title>
  <para> This tutorial give an illustration of the steps presented into the Processes to build a DSL Document (cf hyperlien), in particular it focus  on traitment of an ecore meta model into Kermeta. For more informations please refer to others tutorials available.</para>
  </chapter>
</book>