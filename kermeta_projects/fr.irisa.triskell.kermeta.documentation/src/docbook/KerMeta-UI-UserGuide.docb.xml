<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!-- $Id$ -->
<book lang="en-GB">
  <bookinfo>
    <title>How the workbench is able to help you in your metamodelling
    tasks</title>

    <pubdate>Build date: @BUILD.DATE@</pubdate>
	<date>Revision: $Date::                      $</date>
    <author>
      <firstname>Didier Vojtisek, Francois Tanguy, Cyril Faucher</firstname>
    </author>
    <mediaobject>
        <imageobject>
          <imagedata fileref="figures/FastKermeta.png" align="right" depth="25mm" format="PNG"
          />
        </imageobject>
      </mediaobject> 
  </bookinfo>

  <chapter>
    <title>Introduction</title>

    <para>Kermeta is distributed with a workbench that
    provides many features.</para>

    <para>In the bundle version 1.3.0 you have:</para>

    <itemizedlist>
      <listitem>
        <para>Text editors for kermeta textual syntax and KET (kermeta template emitter)</para>
      </listitem>
      <listitem>
        <para>an outline view</para>
      </listitem>
      <listitem>
        <para>a problems view</para>
      </listitem>
      <listitem>
        <para>an Ecore Model Editor (provided by
        Eclipse/EMF)</para>
      </listitem>
      <listitem>
        <para>an interpreter</para>
      </listitem>
      <listitem>
        <para>a debugger</para>
      </listitem>
      <listitem>
        <para>a compiler (compiles your kermeta code into an eclipse java plugin)</para>
      </listitem>
      <listitem>
        <para>Transformations to and from Kermeta.
        (especially to Ecore)</para>
      </listitem>

      <listitem>
        <para>Other helper transformations like Ecore
        merge</para>
      </listitem>

      <listitem>
        <para>Dedicated Graphic
        editor</para>
      </listitem>

      
      <listitem>
        <para>Object TouchNavigator</para>
      </listitem>
      <listitem>
        <para>KermetaDoc view (showing the documentation associated to your metamodel)</para>
      </listitem>
      
      <listitem>
        <para>Help system</para>
      </listitem>
    </itemizedlist>

    <para>Useful features needing the installation of
    an external tool:</para>

    <itemizedlist>
      <listitem>
        <para>Class diagram Ecore Model editor. This
        feature is provided by EclipseUML (Omondo) (a community edition is
        available)</para>
      </listitem>
    </itemizedlist>

    
    <para>Here is a screenshot of a typical Kermeta
    workbench.</para>

    <figure id="refIllustration0">
      <title>Kermeta workbench screenshoot (v1.2.2)</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_Workbench.png" />
        </imageobject>
      </mediaobject>
    </figure>


    <warning>
    	<para>
	       Kermeta is an evolving software and despite that we put a lot of attention to this
	        document, it may contain errors or not conform to the latest version.
	        If you find any error or have some information that improves this
	        document, please send it to us using the bugtracker in the
	        forge:
	
	       
	
	      <ulink type="" url="http://gforge.inria.fr/tracker/?group_id=32">
	        http://gforge.inria.fr/tracker/?group_id=32
	      </ulink>
	
	       Last check: v1.2.2 
       </para>
    </warning>
  </chapter>

  <chapter>
    <title>The Text Editor</title>

    <section>
      <title>The document</title>

      <para>Nowadays a textual editor is not just an editable document. Many
      informations have been provided to the user in order to get improved
      editing performances. It is quite common to find textual editor with
      coloring syntax, auto-completion and outline. These three items working
      together usually makes a good textual editor. That is the reason why the
      Kermeta platform provides such an editor. Below, you can find the global
      view of the Kermeta editor.</para>

      <figure>
        <title>The Kermeta Textual Editor</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/textualEditor.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Auto-completion</title>

      <para>To develop faster and faster, some nice helpful tools now are
      usual. One of them is the auto-completion. According to a context, a
      list of item will be proposed. Using the arrows key and the carriage
      return key, you can select quickly and easily the item you want. The
      important thing is that, the list of item is calculated in order to only
      propose some relevant items. The figure below shows the auto-completion
      for "stdio" which is a special class in Kermeta (as System for Java).
      The typed point makes the system think that you want to call a method on
      "stdio". Then all the callable methods are proposed and you can choose
      one of them.</para>

      <note>
      	<para>
        	The usual &lt;ctrl&gt;+&lt;space&gt; keyboard shortcut is used to access the code completion
      	</para> 
      </note>

      <figure>
        <title>Auto-Completion in the Kermeta Textual Editor</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/autoCompletionSmall.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Outline</title>

      <para>The outline is a structural view of your program. Code is not
      visible in this view, but the structure (packages,
      classes, attributes, methods and constraints) are visible in a tree hierarchy. Usually
      the outline position is on the top right side of the Eclipse's window.
      You can get advantages of the outline, when your program reaches a big
      size and when it is difficult to get a good visibility on the program's
      structure. Browsing the outline is much more faster than browsing the
      file. Moreover, clicking on an item (packages, classes, attributes or
      methods) brings you to that item in the file.</para>
      

      <itemizedlist>
        <title>The following buttons are available on this view :
        </title>
        <listitem>
          <para>sort features : The content of the outline is sorted
          alphabetically. </para>
        </listitem>

        <listitem>
          <para>Flatten inheritance : Show package hierarchy</para>
        </listitem>

        <listitem>
          <para>Display all the features of your classes. The inherited
          features are displayed using a specific icon set.</para>
        </listitem>

        <listitem>
          <para> Show imported types : Show all the classes that are declared
          using the require statement in this file.</para>
        </listitem>
      </itemizedlist>

      <note>
      	<para>
         	The Flatten inheritance also display the features of the Object class as all the Kermeta classes inherit from it.
        </para> 
      </note>

      <warning>
      	<para>
         	The "Show imported types" feature works on a per file basis and then it only shows the features declared using the require statement in this file and NOT all the files in your project.
         	This option is really useful when you work with kermeta aspects since it display the elements in your faile and the elements imported by aspect.  
      	</para> 
      </warning>
 	  
      
      <para>
      	In addition, the elements are colored in order to help to identify where and how
      	an element is defined.
      </para>
      <figure>
        <title>The outline in Kermeta Text Editor</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/outlineSmall.png" format="PNG" depth="550px"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <itemizedlist>
        <title>The following  meaning are assigned to the colors in this view :
        </title>
        <listitem>
          <para>Red : The element is defined in the current file. It 
          applies to : Packages, Classes, Attributes, References, Derived Properties and Operations. </para>
        </listitem>

        <listitem>
          <para>Blue : The element is defined in an imported (required) file. It 
          applies to : Packages, Classes, Attributes, References, Derived Properties and Operations. 
          On classes features, this typically represent features imported via an aspect.</para>
        </listitem>

        <listitem>
          <para>Yellow : The element is inherited from another class (regardless 
          of the containment in the file). It applies to Attribute, Reference, Derived properties and Operations</para>
        </listitem>

        <listitem>
          <para> Green : The operation is imported via an aspect and is still abstract.</para>
        </listitem>
        <listitem>
          <para> Grey : The package doesn't define any class.</para>
        </listitem>
      </itemizedlist>
      <tip>
      	<para>
      		A double click will open the editor in order to show you the selected element.
      		This feature works only if the element to display is in a kmt file.
      	</para>
      </tip>
      <tip>
      	<para>
      		If you have activated the KermetaDoc view, it will show the documentation associated to the selected element.
      	</para>
      </tip>
      <note>
      	<para>
      		In version 1.2.2, the constrains don't have a color differentiation.
      	</para>
      </note>
    </section>

    <section>
      <title>Errors reporting</title>

      <para>The textual editor is used to display extra pieces of information
      than simple text. In the figure below, a parsing error is reporting
      because of the semicolon which is not allowed in the language. The nice
      is thing is that in the Eclipse's problems view, just by double clicking
      on an error opens the erroneous file and make the cursor focusing on the
      correct line.</para>
	  <para> In addition, a list of all current errors is available in the general
	  "Problems view".
	  </para>
      <figure>
        <title>Error reporting</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/errorReportingSmall.png" />
          </imageobject>
        </mediaobject>
      </figure>
      
      
    </section>

    <section>
      <title>Debugging information</title>

      <para>Kermeta is meant an executable language and provides a debugger. So, 
      the textual editor is used to interact with the debugger. 
      </para>
      <para>
      Like in a Java style, some breakpoints can
      be added to the program by right clicking on the grey line at the left
      of the editor (as in the figure below). The breakpoint will be added in
      front of the selected line. Afterwards, when running the debugger, the
      program will halt at every breakpoint it goes through. At this moment,
      you will be able to have a look at the variables' value and run step by
      step or step into some methods.</para>
      <para>
      	See <xref linkend="chapter_debugger.link" /> for more details
      	on the debugger features.
      </para>
      <figure>
        <title>Debugging Information in the Kermeta Text Editor</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/debuggingInformationSmall.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Editor preferences</title>

      <para>You can customize your text editor by selecting Window from the
      Eclipse main menu and then Preferences. The image below shows the page
      configurator.</para>

      <figure id="refIllustration2">
        <title>TextEditor preferences</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/TextEditor_classic_preferences.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </chapter>

  <chapter id="chapter_interpreter.link">
    <title>Interpreting a Kermeta code</title>

    <para>Kermeta workbench allows to interpret and run your Kermeta code in several
    ways.</para>

    <section>
      <title>Using a Run configuration</title>

      <para>For those who already know how to run Java applications, this is a
      similar approach but for Kermeta files.</para>

      <para>You'll need to create a new run configuration from the
      "<literal>Run/Run...</literal>" menu.</para>

      <figure id="refIllustration3">
        <title>Run menu</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_RunConfigurationMenu.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <caution>
      	<para>
        	The run menu is available only with some perspectives. If you don't see the run menu, switch to the Kermeta perspective.
        </para> 
      </caution>

      <para>In the dialog, you selects the file, the main class and the main
      operation that must be run.</para>

      <para>Search buttons will help you to find these elements in your
      files.</para>

      <caution>
      	<para>
        	The search button may not work properly if your file contains errors. 
      	</para>
      </caution>

      <figure id="refIllustration4">
        <title>Kermeta run configuration - main tab</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_RunConfiguration.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para>Two optional annotations in your Kermeta code allow you to save time while
      creating run configurations. The @mainClass and @mainOperation are used
      to fill field when creating a new configuration.</para>

      <para>Ex:</para>

      <programlisting>@mainClass "fsm::Main"
@mainOperation "mainloadFSM"</programlisting>

      <para>Then, once you have your configuration, you can run it by all the
      means provided by Eclipse. Ie. "<literal>Run Last Launched</literal>", "
      <literal>Run History</literal>", ... available in the menus or in the
      toolbars.</para>

      <tip>
      	<para>
	         A shortcut allows you to quickly start a Kermeta run configuration. It is available in the popup menu of *.kmt files. The " 
	
	        <literal>Run As/Kermeta App</literal>
	
	         " button runs an existing configuration and the " 
	
	        <literal>Run As/Run...</literal>
	
	         " button opens the configuration dialog. 
         </para>
      </tip>

      <figure id="refIllustration5">
        <title>Run shortcut to run configuration on the kmt files</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_NewRunConfiguration.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The operation arguments field allow you to pass some strings as
      parameters of the operation you are launching.</para>
       <para>In this sample screenshot, the FSM take a string as teh path to the file that
       will be loaded and simulated.</para>

      <para>In addtion to this simple scenario, in the common Tab of the Kermeta run configuration,
      you can:</para>

      <itemizedlist>
        <listitem>
          <para>save your configuration in a file, so you can share it with
          other users: in "Common" tab button "Shared file"</para>
        </listitem>

        <listitem>
          <para>specify where the stdio outputs must be sent. Typically, this
          can be in the Eclipse console or in a file.</para>
        </listitem>
        <listitem>
          <para>specify additional entries in the interpreter classpath that must 
          be taken into while running this kermeta code. This is needed if you use
          "extern" call to your own jars.</para>
        </listitem>
      </itemizedlist>
      
      <tip>
      	<para>
      		If you specify the kermeta project u=in the run configuration and if this project is an eclipse
      		plugin, then the interpreter will automatically take this plugin and all its dependencies into account in tha classpath. 
      	</para>
      </tip>
    </section>

    <section>
      <title>Run the interpreter with a Java command line</title>

      <para>You can run Kermeta interpreter from the command line. For this you need to run the java class
      <classname>org.kermeta.interpreter.api.RunCommandLine</classname> which is available in <filename>fr.irisa.triskell.kermeta.interpreter</filename> 
      plugin.
      The RunCommandLine class allows to pass the name of:
      the Kermeta source file, and optionally the name of the class and the
      operation to run.</para>
	  <note><para>The package org.kermeta.interpreter.api provides different facades in order to run a
      Kermeta program with the interpreter from a java program. You can either have a look to the document
      <ulink url="http://kermeta.org/documents/deployment_manual/">Deploying Kermeta code manual</ulink> 
      or you may also have a look into class 
      <classname>RunCommandLine</classname> to see how it was implemented.</para></note>
	  <para>
	  The interpreter command line is available in two main forms : as a set of eclipse plugin (it is available with all kermeta version deployed in Eclipse,
	   or as a standalone jar (see <ulink url="http://gforge.inria.fr/frs/?group_id=32">Kermeta download page</ulink> for the various distributions).
	  </para>
	  
	  <para>
	  The standalone bundle is available in two version : all in one jar (typically <filename>kermeta_standalone_full_1.3.0.jar</filename>),
	   or only kermeta in the main jar (typically <filename>kermeta_standalone_no_thirdparty_in_main_jar.1.3.0.zip</filename>. In this second version, the thirdparty jar aren't included.
	  </para>
	  
	  
      
	  <para>Depending wether you use the standalone jars or the jar embedded in eclipse, the process
	  will be more or less simple. The simpliest is to use the standalone version because you don't need
	  to deal with the classpath.</para>
	  <example><title>Simpliest use of the standalone version on the command line</title>
        <programlisting language="tcl">java -jar kermeta_standalone.jar  -U ecore_mdk/add_observer.kmt -C pattern::AddObserver -O main<co id="standalone.sample.entry.co" linkends="standalone.sample.entry.callout"/> 
         input_models/needs_observer.ecore output_models/ Compteur Afficheur<co id="standalone.sample.options.co" linkends="standalone.sample.options.callout"/> </programlisting>
        <calloutlist>
			<callout arearefs="standalone.sample.entry.co" id="standalone.sample.entry.callout">
				<para>This sample launches the file <filename>add_observer.kmt</filename> and will start the operation
				<methodname>main</methodname> of the class <classname>pattern::AddObserver</classname>.
				</para>
			</callout>
			<callout arearefs="standalone.sample.options.co" id="standalone.sample.options.callout">
				<para>This sample kermeta programs takes 4 strings as parameters.
				</para>
			</callout>
		</calloutlist>
        </example>
	  <section>
        <title>Command line options</title>

        <para>The command line needs several options to run properly a kermeta
        program.</para>

        <para>.</para>

        <itemizedlist>
          <listitem>
            <para>-C : (takes 1 argument) Qualified name of the class to
            run</para>

            <para>ex: myPackage::MyClass</para>

            <para role="lineBreak">Note that it will not instanciate the class
            (ie. self will return void)</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>-H : (takes 0 argument) Display the help</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>-T : (takes 0 argument) Run as a test suite</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>-P : (takes 0 argument) Display Profiling info</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>-K : (takes 1 argument) Location for kermeta standard
            unit(framerwork.km) (KermetaUnit.STD_LIB_URI variable)</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>-O : (takes 1 argument) Name of the operation to run</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>-U : (takes 1 argument) URI of the unit file that must be
            loaded</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>-M : (takes 1 argument) Indicate a file containing URI_MAP
            (This is useful to solve some model loading troubles)</para>
          </listitem>
        </itemizedlist>

        <para>Other values on the command line will be passed as string to the
        operation</para>

        <example><title>Example of  a kermeta program called with the standalone version on the command line</title>
        <programlisting language="tcl">java -jar kermeta_standalone.jar  -P -U ../ModelEngineeringCourse/transfo/add_observer.kmt -C pattern_macros::Main -O main<co id="sample.entry.co" linkends="sample.entry.callout"/> 
        -K lib/framework.km<co id="k.option.co" linkends="k.option.callout"/> ../models/needs_observer.ecore Compteur Afficheur<co id="sample.options.co" linkends="sample.options.callout"/> </programlisting>
        <calloutlist>
			<callout arearefs="sample.entry.co" id="sample.entry.callout">
				<para>This sample launches the file <filename>add_observer.kmt</filename> and will start the operation
				<methodname>main</methodname> of the class <classname>pattern_macros::Main</classname>.
				</para>
			</callout>
			<callout arearefs="k.option.co" id="k.option.callout">
				<para>forces the interpreter to use a specific framework.km instead of the one inside the jar.
				</para>
			</callout>
			<callout arearefs="sample.options.co" id="sample.options.callout">
				<para>This sample kermeta programs takes 3 strings as parameters.
				</para>
			</callout>
		</calloutlist>
        </example>
        
      </section>

      <section>
        <title>About the URI map</title>

        <para>When you run a kermeta program outside of Eclipse, the uri of
        type platform:// are not resolved since this is the role of Eclipse to resolve them. So,
        when running outiside of Eclipse, you need to help this resolution.</para>
        <para>The resolution can be done using a map, whenever it find the key, it will replace it with the associated value.
        Like that you can transform platform:/plugin/ into a physical location in your disk.</para>

        <para>With RunCommandLine.java, this is the option <option>-U</option> which allow to specify a file that contains the mapping.</para>

        <para>This uri map file uses the syntax of java properties
        files.</para>

        <para>Example of uri.map file which maps some platform:// urls into
        file:// urls</para>

        <programlisting language="tcl">#Typical uri.map file
"platform:/plugin/"&nbsp;&nbsp;&nbsp;"file:/C:/eclipse3.4/eclipse/workspace_head/"
"platform:/resource/"&nbsp;"file:/C:/eclipse3.4/eclipse/workspace_head/"
"kconf:/loader/"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"file:/C:/eclipse3.4/eclipse/workspace_head/org.kermeta.io.loader/instances/" <co id="kconf.loader.co" linkends="kconf.loader.callout"/>
</programlisting>
		<calloutlist>
			<callout arearefs="kconf.loader.co" id="kconf.loader.callout">
				<para>This special uri is used by kermeta to retrieve the folder <filename>instances</filename> in the plugin <filename>org.kermeta.io.loader</filename>.
				Kermeta intepreter cannot work correctly without it.
				</para><para>Another easy way (not detailed here) would be to retrieve one of the standalone versions and run it from eclipse.
				</para>
			</callout>
		</calloutlist>
		<tip><para>With this map mechanism, you can also translate the platform uris into jar protocol. This protocol allows to search 
		within a jar. for example, <filename>jar:file:/my.jar!/src/kermeta/framework.km</filename> opens the file <filename>my.jar</filename> and pick the file 
		named <filename>framework.km</filename> into the subfolder <filename>src/kermeta</filename> in the jar.</para>
		</tip>
      </section>
	  
	  <section >
	  	<title>Run the eclipse version of the interpreter in eclipse</title>
	      <para>In this section we focus on calling the interpreter embedded in an eclipse installation.</para>
	      <note><para>This is quite an advanced use case recommanded only for people who understand how eclipse files are organized and can manually create a classpath to retreive the various jar in eclipse installation.</para></note>
	      <para>From eclipse, you create a Java application LaunchConfiguration that will
	      run the interpreter with your Kermeta file.</para>
	      <figure id="refIllustration6">
	        <title>Java run configuration main tab</title>
	
	        <mediaobject>
	          <imageobject>
	            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_RunCommandLine1.png" />
	          </imageobject>
	        </mediaobject>
	      </figure>
	
	      <para></para>
	
	      <para>Be careful, you must select "Include external jars when searching
	      for a main class".</para>
	
	      <figure id="refIllustration7">
	        <title>Java run configuration arguments</title>
	
	        <mediaobject>
	          <imageobject>
	            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_RunCommandLine_arguments.png" />
	          </imageobject>
	        </mediaobject>
	      </figure>
	
	      <para></para>
	
	      <para>The output level of interpreter traces can be set using a log4j
	      configuration file. The concrete file to use is set by the java property
	      "kermeta.log4j.configurationfile.name". A sample of log4j configuration
	      file is located in the <filename>fr.irisa.triskell.kermeta.model</filename> plugin.</para>
	
	      <para>Exemple add the following in the VM arguments box:
	      -Dkermeta.log4j.configurationfile.name= "../../plugins/fr.irisa.triskell.kermeta.model_1.3.0/kermeta_log4j_configuration.xml"</para>
	
	      <para>The classpath must be carefully set using the jar of Kermeta, the
	      jar of Ecore and of emf.</para>
	
	      <figure id="refIllustration8">
	        <title>Java run configuration classpath (using the interpreter jars in
	        the texteditor)</title>
	
	        <mediaobject>
	          <imageobject>
	            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_RunCommandLine_classpath.png" />
	          </imageobject>
	        </mediaobject>
	      </figure>
	
	      <para></para>
	
	      <tip>
	      	<para>
	         	This RunCommandLine class or one of its sibling can also be used by any of your java programs.For more information please see the Javadoc reference of RunCommandLine.
	        </para> 
	      </tip>
	
	      <warning>
	      	<para>
	         	This method need to know precisely which jar you use. If you update any of the required plugins (kermeta, emf, ecore , ...) the directory containing the jar will change because eclipse use the version number as part of the directory name. You'll have to manually change to ant file in order to reflect the update.
	        </para> 
	      </warning>
      </section>
   </section>

    
  </chapter>
	
  <chapter  id="chapter_compiler.link">
    <title>Compiling a kermeta code into java</title>

    <para>The workbench allows you to transform you kermeta code into Java-EMF code.</para>
    
    <section><title>In a nutshell</title>
		<para>The Kermeta compiler consists on a transformation from a kmt file to an Ecore file (step 1), finally the generation a plugin with the Java by using the EMF facilities (step 2).
		The resulting Java may be used both in Eclipse Application or in Java Application (standalone) and is fully compatible with EMF. A listing of dependencies is available below.
		The compiling process generates a set of files: *.km, *.traceability, *.ecore, *.simk, *.genmodel.
		A configuration file may be added: *.compiler.properties (more info. below).
		The 2nd step may be replayed by a right-click on the generated Ecore file.
		</para>
	</section>
 	
    <section><title>Calling the complier</title>
    	<section><title>Launching a compilation process</title>
			<para>Right click on a kmt file: "Compile Kmt to EMF plugin (Experimental)", then an Eclipse plugin will be generated, after that you can try to run one generated main contained in runner Java package.</para>
		</section>
		<section><title>Customizing the plugin generation</title>
			<para>You are able to add a "properties file" for customizing the plugin generation.
			This file must be in the same folder than the main kmt file and respect the naming rule: {kmt_file_name_without_the_kmt_extension}.compiler.properties
			This configuration file will be taking into account, when you are compiling from a kmt file or the generated ecore file, for this last case you are able to re-generate the plugin without redo kmt2{ecore, simk}
			The available properties are listed below, every property is optional (the values are String without quote):
			</para>
			<itemizedlist>
				<listitem><para>plugin_id = {name and id of the generated plugin}</para></listitem>
				<listitem><para>copyright_header = {header include in each file}</para></listitem>
				<listitem><para>require_bundles = {plugin dependencies if your program depends on external plugins} | String separated by comma</para></listitem>
				<listitem><para>bundle_version = {version number of your plugin like 0.1.0 instead of the default 1.0.0}</para></listitem>
				<listitem><para>main_operations = {operation qualifiedNames} | String separated by comma, e.g.: mypackage::MyClass::myMainOperation, mypackage::MyClass::myMainOperation2</para></listitem>
				<listitem><para>unzip_externs = {zip file containing the externs required to the compiled source code} | String separated by comma, the String is composed of 2 parts separated by a ";", the first part is the location of the zip file, the second one is the folder in the generated plugin, ex.: platform:/resource/MyProject/util/externs.zip;src/java</para></listitem>
				<listitem><para>enable_emf_load_initialization = {enable EMF-reflection load initialization for large model} | String equals to true or false</para></listitem>
			</itemizedlist>
		</section>
	</section>

	<section><title>Running the compiled code (RunConfiguration) </title>
		<para></para>
		<section><title>Running the compiled code inside Eclipse in development mode</title>
			<para>Right-click on the generated class containing the Java Main method or you are able to create a "Java Run Configuration" pointing the Java Main method</para>
		</section>
		<section><title>Running the compiled code inside Eclipse in deployed mode</title>
			<para>TODO</para>
		</section>
		<section><title>Running the compiled code outside Eclipse</title>
			<para>Creating a standalone version of your compiled code, required libs:</para>
			<itemizedlist>
          		<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.emf.common_2.4.0.v200808251517.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.emf.ecore.xmi_2.4.1.v200808251517.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.emf.ecore_2.4.1.v200808251517.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.core.resources_3.4.0.v20080604-1400.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.core.runtime_3.4.0.v20080512.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.emf.codegen_2.4.0.v200808251517.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.emf.ecoretools.registration_1.0.0.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.equinox.registry_3.4.0.v20080516-0950.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/fr.irisa.triskell.eclipse.util_1.2.0.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.equinox.common_3.4.0.v20080421-2006.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.core.jobs_3.4.0.v20080512.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/fr.irisa.triskell.kermeta.model_1.2.0.jar"</para></listitem>
				<listitem><para>classpathentry kind="lib" path="C:/eclipse-ganymede/eclipse/plugins/org.eclipse.osgi_3.4.0.v20080605-1900.jar"</para></listitem>
			</itemizedlist>
			<note><para>This listing is in progress. Also the exact version of the plugins used may vary depending of your version of Keremta and Eclipse.</para></note>
		</section>
	</section>
	
  </chapter>

  <chapter id="chapter_debugger.link">
  	<title>Debugging</title>

  	<para>
  		Since v0.1.0 Kermeta has a debugger. As any debugger, it
  		proposes breakpoints step over, step into, run, resume,
  		visualization of variables, etc
  	</para>

  	<section>
  		<title>Global View</title>

  		<para>
  			A debugger offers users the possibility to interpret
  			Kermeta's programs step by step, or stopping programs at
  			one moment to check the the programs' state. Above you can
  			see the global view of the editor.
  		</para>

  		<figure>
  			<title>The Debugger global view</title>

  			<mediaobject>
  				<imageobject>
  					<imagedata
  						fileref="KerMeta-UI-UserGuide_figures/debug_perspective.png" />
  				</imageobject>
  			</mediaobject>
  		</figure>
  	</section>

  	<section>
  		<title>The Watch View</title>

  		<para>
  			During programs execution, you may want to know variables'
  			values. For that purpose, you can use the watch view which
  			displays all the variables accessible in the current
  			context and their values. Moreover you can browse those
  			variables to have a deeper look inside variables.
  		</para>

  		<figure>
  			<title>The Watch View</title>

  			<mediaobject>
  				<imageobject>
  					<imagedata
  						fileref="KerMeta-UI-UserGuide_figures/watch_page.png" />
  				</imageobject>
  			</mediaobject>
  		</figure>
  	</section>

  	<section>
  		<title>The Frame View</title>

  		<para>
  			A frame is a context environment for a call method. That
  			means that for each method call, you have access to its
  			context that is to say the variables values. Obviously, it
  			is strongly related to the watch view. Clicking on one
  			frame modifies the watch view. The frame view is also nice
  			to follow the execution. For instance, in the figure
  			above, we know that the run method has called the step
  			method which has called the fire method.
  		</para>

  		<figure>
  			<title>The Frame View</title>

  			<mediaobject>
  				<imageobject>
  					<imagedata
  						fileref="KerMeta-UI-UserGuide_figures/frame_page.png" />
  				</imageobject>
  			</mediaobject>
  		</figure>
  	</section>

  	<section>
  		<title>The Editor View</title>

  		<para>
  			When debugging, you surely want to know which line of code
  			is executed. That is the reason why the Kermeta text
  			editor is displayed with the outline. The current line of
  			code is colored in green as in the following figure. This
  			green line is moving to the next instruction depending
  			your action.
  		</para>

  		<figure>
  			<title>The Editor View</title>

  			<mediaobject>
  				<imageobject>
  					<imagedata
  						fileref="KerMeta-UI-UserGuide_figures/debug_editor.png" />
  				</imageobject>
  			</mediaobject>
  		</figure>
  	</section>

  	<section>
  		<title>Debugging actions</title>

  		<para>There are three kind of actions you can execute:</para>

  		<itemizedlist>
  			<listitem>
  				<para>
  					F5 : pressing the F5 key makes the debugger
  					entering in the current operation.
  				</para>
  			</listitem>

  			<listitem>
  				<para>
  					F6 : pressing the F6 key makes the debugger
  					stepping to the next operation.
  				</para>
  			</listitem>

  			<listitem>
  				<para>
  					F8 : pressing the F8 key makes the debugger
  					executing all the operations to the next
  					breakpoint, if there is some one.
  				</para>
  			</listitem>
  		</itemizedlist>

  		<note>
  			<para>
  				A nice feature is that you can add or remove
  				breakpoints to your Kermeta file during debugging.
  			</para>
  		</note>
  	</section>
  </chapter>


  <!-- begin - of the chapter about Help -->

  <chapter>
    <title>Help</title>

    <para>The current help and many other documentation are available in the
    Eclipse Help system of your Eclipse installation: open Help -&gt; Help
    Contents</para>

    <figure id="refIllustration9">
      <title>Eclipse Help Contents for Kermeta</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/Kermeta_HelpContents.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <tip>
    	<para>
	       Alternatively, an online version of all those documents is available at 
	      <ulink type=""
	      url="http://www.kermeta.org/documents">http://www.kermeta.org/documents</ulink>
      </para>
    </tip>
  </chapter>

  <!-- end - of the chapter about Help -->

  <!-- begin - of the chapter about Transformations -->

  <chapter> 
  
    <title>Transformations</title>

    <para>The workbench provides several additional
    tools available directly on the files using the popup
    menu.</para>

    <important>
    	<para>
    		Several of the wizards provided are multipages wizards. This means
    		that several advanced options are available only after clicking on "Next"
    		instead of clicking on "Finish". So if you get an error while transforming
    		a file, make sure that none of the options (on the main page or on the "Next" pages)
    		fix the default behavior for your special need.
    	</para>
    </important>
    <section>
      <title>Actions for Ecore files</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="strong">Export functions:</emphasis> On ecore file you
          can export it into a KM (kermeta program in xmi format) or in kmt
          (Kermeta program using its textual syntax). As the ecore model may
          not be valid, the wizard provides some quick fixes. Those quick
          fixes will for example detect and propose a default solution for
          multiple operations with the same name.</para>
        </listitem>
      </itemizedlist>  
      
      <figure>
        <title>Ecore to Km transformation</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_ecore2km.png" />
          </imageobject>
        </mediaobject>
      </figure>
      
      <figure>
        <title>Ecore to Kmt transformation</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_ecore2kmt.png" />
          </imageobject>
        </mediaobject>
      </figure>


      <itemizedlist>
        <listitem>
          <para><emphasis role="strong">Merge function:</emphasis> You can merge several
          ecore files, simply select them and click "merge". Its algorithm is
          base on the names of the packages and classes. </para>
        </listitem>
        <listitem>
          <para><emphasis role="strong">Register/Unregister EPackages function:</emphasis> You can register or unregister in the EMF registry the EPackages defined in an Ecore model,
           simply select them and right-click "Register" or "Unregister".</para>
        </listitem>
      </itemizedlist>
      
      <figure>
        <title>Actions on ecore model</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_ActionsOnEcoreModel.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Actions for kmt files</title>

      <itemizedlist>
        <listitem>
          <para>From a kmt files you can export it to
          an ecore file. Each of the kermeta notion that don't have a specific
          representation in ecore are stored into ecore annotations that will
          allow to roundtrip back to kermeta.</para>
        </listitem>
     </itemizedlist>
      <figure>
        <title>Kmt to Ecore transformation</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_kmt2ecore.png" />
          </imageobject>
        </mediaobject>
      </figure>
      
	<itemizedlist>
        <listitem>
          <para>The kmt file can also be exported into
          its model version (ie. Into a XMI file conformant to kermeta
          metamodel). This is useful as this process also typecheck
          the model and thus allow to save some time when loading other file
          which rely on the km version rather than the kmt version.</para>
        </listitem>
    </itemizedlist>
      <figure>
        <title>Kmt to Km transformation</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_kmt2km.png" />
          </imageobject>
        </mediaobject>
      </figure>
      
    </section>

    <section>
      <title>Actions for km files</title>

      <itemizedlist>
        <listitem>
          <para>From a km files you can export it to
          an ecore file. Each of the kermeta notion that don't have a specific
          representation in ecore are stored into ecore annotations
          that will allow to roundtrip back to kermeta.</para>
        </listitem>
      </itemizedlist>
      
      <figure>
        <title>Km to Ecore transformation</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_km2ecore.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <itemizedlist>
        <listitem>
          <para>You can also prettyprint this model representation of a
          kermeta program into the textual representation of this
          program.</para>
        </listitem>
      </itemizedlist>
      <figure>
        <title>Km to Kmt transformation</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_km2kmt.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Traceability</title>

      <para>For many of those transformations, the
      wizard will propose you to store the traceability informations.
      </para>

      <para>This is a special metamodel that stores a
      link between the sources elements and the target element so you can
      reuse it later. For example, it will help the debugger to retrieve the
      correct line in the text version of the source file even if you are
      running the km version.</para>

      <para>This metamodel is very generic and can be
      used for any model.</para>
    </section>
    
  </chapter>

  <!-- end - of the chapter about Transformations -->

  <!-- begin - of the chapter about the Class diagram Kermeta Model editor -->

  <chapter>
    <title>Class diagram Kermeta Model editor</title>

<section>
      <title>Overview</title>

    <para>The Kermeta Graphical Editor is a view of
    the Kermeta model as a class diagram. It is generated with the tool
    "Topcased".
    The file containing the presentation informations is a *.kmdi.
    The *.kmdi is associated with a *.km file. The *.kmdi and *.km files must be in the same folder.
    </para>

    <figure>
      <title>Class diagram Kermeta Model editor - overview</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_KGEOverview.png" />
        </imageobject>
      </mediaobject>
    </figure>
    </section>
    
    <section>
      <title>Opening of a Kermeta class diagram</title>
    
    <para>
    We can open it, simply select and right-click "Open with / Kermeta class diagram"</para>

    <figure>
      <title>Opening of a Kermeta class diagram</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_OpenWithKGE.png" />
        </imageobject>
      </mediaobject>
    </figure>
    </section>
    
    <section>
      <title>Creating of a Kermeta class diagram</title>
    
    <para>In order to create a Kermeta class diagram you have 2 ways.</para>

	<itemizedlist>
        <listitem>
          <para>Create a class diagram and the Kermeta model from scratch.
          Select the project or the folder where you want create the class diagram and right-click "New / Other / Kermeta / New Kermeta class diagram".
          Change the model name if you want.
          </para>
        </listitem>
      </itemizedlist>

    <figure>
      <title>Creating of a Kermeta class diagram from scratch - 1rst step</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_CreateKGEFromANewModelS1.png" />
        </imageobject>
      </mediaobject>
    </figure>
    
    <figure>
      <title>Creating of a Kermeta class diagram from scratch - 2nd step</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_CreateKGEFromANewModelS2.png" />
        </imageobject>
      </mediaobject>
    </figure>
    
    <itemizedlist>
        <listitem>
          <para>Create a class diagram from an existing Kermeta model.
          Select the existing km file and right-click "New / Other / Kermeta / New Kermeta class diagram".
          </para>
        </listitem>
      </itemizedlist>

    <figure>
      <title>Creating of a Kermeta class diagram from an existing Kermeta model - 1rst step</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_CreateKGEFromAnExistingModelS1.png" />
        </imageobject>
      </mediaobject>
    </figure>
    <figure>
      <title>Creating of a Kermeta class diagram from an existing Kermeta model - 2nd step</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_CreateKGEFromAnExistingModelS2.png" />
        </imageobject>
      </mediaobject>
    </figure>
    </section>

  </chapter>

  <!-- end - of the chapter about the Class diagram Kermeta Model editor -->

  <!-- begin - of the chapter about the Kermeta Class TouchNavigator -->

  <chapter>
    <title>Kermeta Class TouchNavigator</title>

    <para>The Kermeta Class TouchNavigator is a view
    that dynamically focuses on the element you are viewing in the editor or
    the outline.</para>

    <para>With its damping animation, it proposes an
    original way to navigate and analyze your metamodel
    classes.</para>

    <para>>The color depends on the distance to the
    selected node.</para>

    <para>Back and Forward button allow to navigate
    the history of selected nodes.</para>

    <para>It provides several lens for smarter
    visualization. For example you can zoom, rotate, set the locality (ie. How
    much nodes you display at once depending on the distance to the selection)
    or use the hyperbolic lens (Ie. Change the edge length depending on the
    distance).</para>

    <para>If you leave your mouse over a class, it
    shows its documentation.</para>

    <figure id="refIllustration11">
      <title>Kermeta Class TouchNavigator</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="KerMeta-UI-UserGuide_figures/KerMeta_Class_TouchNavigator_View.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <tip>
    	<para>
	      It is in alpha stage, feel free to notify us
	      what you found interesting or not in this view.
	    </para>
    </tip>
  </chapter>

  <!-- end - of the chapter about the Kermeta Class TouchNavigator -->

  <!-- begin - of the chapter about the Ecore Model Editor -->

  <chapter>
    <title>Ecore Model Editor</title>

    <para>This Editor is provided by Eclipse in
    EMF.</para>

    <para>Since Kermeta metamodel is an extension of
    EMOF, it is possible to use this editor to edit Kermeta
    programs.</para>

    <para>This based on the Ecore2Kermeta and
    Kermeta2Ecore  transformations.</para>

    <para>With the Ecore representation of your
    program, you can use the Ecore Model editor (from Eclipse\EMF) or any
    other Ecore tool (for example Omondo.graphic editor)</para>


    <para>This is described with more details in the
    EMF tutorial:  <ulink type=""
    url="http://www.kermeta.org/docs/html.single/KermetaEMFTutorial/">
    <emphasis
    role="strong">http://www.kermeta.org/docs/html.single/KermetaEMFTutorial/</emphasis>
    </ulink> </para>
  </chapter>

  <!-- end - of the chapter about the Ecore Model Editor -->

  <!-- begin - of the chapter about Tip and tricks -->

  <chapter>
    <title>Tip and tricks</title>

    <tip>
    	<para>
       		This section contains many useful information about how to use the Kermeta workbench.
       	</para>  
    </tip>

    <section>
      <title>Texteditor keyboard shortcuts</title>

      <informaltable>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="8.5cm" />

          <colspec colname="c2" colwidth="8.5cm" />

          <thead>
            <row>
              <entry><?border-top 0.002cm solid #000000?><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?><para>Keyboard
              shortcut</para></entry>

              <entry align="center"><?border 0.002cm solid #000000?><para>Action</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry align="left"><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?><para>&lt;CTRL&gt;+&lt;SPACE&gt;</para></entry>

              <entry align="left"><?border-right 0.002cm solid #000000?><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?><para>Pertinent
              code completion. This work in several places in the
              code.</para></entry>
            </row>

            <row>
              <entry><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>

              <entry><?border-right 0.002cm solid #000000?><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>
            </row>

            <row>
              <entry><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>

              <entry><?border-right 0.002cm solid #000000?><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>
            </row>

            <row>
              <entry><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>

              <entry><?border-right 0.002cm solid #000000?><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>
            </row>

            <row>
              <entry><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>

              <entry><?border-right 0.002cm solid #000000?><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>
            </row>

            <row>
              <entry><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>

              <entry><?border-right 0.002cm solid #000000?><?border-bottom 0.002cm solid #000000?><?border-left 0.002cm solid #000000?></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>[TODO check with the platform tip and tricks page which eclipse
      shortcut correctly work with Kermeta editor]</para>
    </section>

    <section>
      <title>Texteditor tips</title>

      <section>
        <title>Quickdiff</title>

        <para>When working with CVS, the quickdiff is best used if it use the
        latest CVS revision as reference.</para>

        <figure id="refIllustration12">
          <title>Quickdiff recommended preferences</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-UI-UserGuide_figures/QuickDiff_preferences.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>
    </section>
  </chapter>

  <!-- end - of the chapter about Tip and tricks -->
</book>