<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book lang="en-US">
  <bookinfo>
    <pubdate>Build date: @BUILD.DATE@</pubdate>

    <author>
      <firstname>Franck Fleurey, Zoé Drey, Didier Vojtisek, Cyril
      Faucher</firstname>

      <firstname></firstname>
    </author>

    <title>Kermeta language</title>

    <date>2006-10-13T15:39:55</date>

    <keywordset>
      <keyword>Kermeta</keyword>

      <keyword>metamodeling</keyword>

      <keyword>language</keyword>
    </keywordset>

    <subtitle>Reference manual</subtitle>

    <bibliomisc>Licence EPL</bibliomisc>

    <date>19/07/2006</date>

    <abstract>
      <para>This manual presents the various aspects of the Kermeta language.
      This is the reference manual for anybody who want to use Kermeta.</para>
    </abstract>

    <publisher>
      <publishername>INRIA</publishername>

      <address>
        <state>France</state>
        <otheraddr>
          <ulink url="http://www.inria.fr">http://www.inria.fr</ulink>
        </otheraddr>
      </address>
    </publisher>

    <confgroup>
      <conftitle>title</conftitle>

      <confnum>Reference</confnum>

      <confsponsor>sponsor</confsponsor>
    </confgroup>
  </bookinfo>

  <preface>
    <?print-orientation portrait?>

    <title>Preface</title>

    <para><emphasis role="strong">Kermeta is a Domain Specific Language
    dedicated to metamodel engineering. It fills the gap let by MOF which
    defines only the structure of meta-models, by adding a way to specify
    static semantic (similar to OCL) and dynamic semantic (using operational
    semantic in the operation of the metamodel). </emphasis> <emphasis
    role="strong"> <emphasis role="strong">Kermeta uses the object-oriented
    paradigm like Java or Eiffel.</emphasis> </emphasis> <emphasis
    role="strong"> This document presents various aspects of the language,
    including the textual syntax, the metamodel (which can be viewed as the
    abstract syntax) and some more advanced features typically included in its
    framework. </emphasis></para>

    <important>
      <emphasis role="strong">Kermeta is an evolving software and d</emphasis>

      <emphasis role="strong">
        <emphasis role="strong">espite that we put a lot of attention to this
        document, it may contain errors (more likely in the code samples). If
        you find any error or have some information that improves this
        document, please send it to us using the bug tracker in the
        forge:</emphasis>
      </emphasis>

      <ulink type="" url="http://gforge.inria.fr/tracker/?group_id=32">
        <emphasis role="strong">
          <emphasis role="strong">
            <emphasis
            role="strong">http://gforge.inria.fr/tracker/?group_id=32</emphasis>
          </emphasis>
        </emphasis>
      </ulink>

      <emphasis role="strong">
        <emphasis role="strong">
          <emphasis role="strong" />
        </emphasis>
      </emphasis>

      <emphasis role="strong">
        <emphasis role="strong">
          <emphasis role="strong">or using the developer mailing list
          (kermeta-developers@lists.gforge.inria.fr)</emphasis>
        </emphasis>
      </emphasis>

      <emphasis role="strong">
        <emphasis role="strong">
          <emphasis role="strong" />
        </emphasis>
      </emphasis>

      Last check: v0.4.0
    </important>

    <tip>
      The most update version of this document is available on line from 

      <ulink type=""
      url="http://www.kermeta.org/">http://www.kermeta.org</ulink>

       .
    </tip>
  </preface>

  <chapter>
    <?print-orientation portrait?>

    <title>Introduction to Kermeta</title>

    <section>
      <title>Presentation</title>

      <para>Kermeta is a metamodeling language which allows describing both
      the structure and the behavior of models. It has been designed to be
      compliant with the OMG metamodeling language EMOF (part of the MOF 2.0
      specification) and Ecore (from Eclipse). It provides an action language
      for specifying the behavior of models.</para>

      <para>Kermeta is intended to be used as the core language of a model
      oriented platform. It has been designed to be a common basis to
      implement Metadata languages, action languages, constraint languages or
      transformation language.</para>

      <figure id="refIllustration0">
        <title>Kermeta positioning</title>

        <mediaobject>
          <imageobject>
            <imagedata 
                       fileref="KerMeta-Manual_figures/kermeta_positionning.png"
                        />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para>In a nutshell, Kermeta is :</para>

      <orderedlist continuation="restarts">
        <listitem>
          <orderedlist continuation="restarts">
            <listitem>
              <para>MOF compliant (EMOF compliant to be precise)</para>
            </listitem>

            <listitem>
              <para>Model oriented</para>
            </listitem>

            <listitem>
              <para>Imperative</para>
            </listitem>

            <listitem>
              <para>Object-Oriented</para>
            </listitem>

            <listitem>
              <para>Statically Typed (100% typesafe)</para>
            </listitem>
          </orderedlist>
        </listitem>
      </orderedlist>

      <para>In addition to these characteristics, it includes some typically
      model-oriented concepts like associations, multiplicities or object
      containment management.</para>

      <para>This document presents the main features of the Kermeta language.
      Section 2 presents the general properties of the language, section 3
      details the concrete and abstract syntax of the language and finally
      section 4 provides some simple programs in Kermeta.</para>
    </section>

    <section>
      <title>First Program<phrase id="section_first_program"></phrase></title>

      <para>Here is the traditional «&nbsp;Hello world&nbsp;» example you can
      find in every programming book.</para>

      <programlisting>@mainClass "helloworld::HelloworldExample"
@mainOperation "sayHello"
<emphasis role="strong">package</emphasis> helloworld;

<emphasis role="strong">require</emphasis> kermeta
<emphasis role="strong">using</emphasis> kermeta::standard

<emphasis role="strong">class</emphasis> HelloworldExample
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> sayHello() <emphasis
          role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdio.writeln("Hello world, ...")
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>
    </section>

    <section>
      <title>Global view</title>

      <para>The goal of the Kermeta language is to provide an action language
      for MOF models. The idea is to start from MOF, which provides the
      structure of the language, and to add an action model. Using the MOF to
      define the structure of the Kermeta language has an important impact on
      the language. In fact, as MOF concepts are Object-Oriented concepts,
      Kermeta includes most of the classical Object-Oriented mechanisms. Yet,
      MOF only defines structures, and the operational semantic corresponding
      to MOF concepts has to be defined in Kermeta. For instance MOF does not
      provide a semantic for behavior inheritance (concepts like method
      redefinition, abstract method, ... does not have any sense in the
      MOF).</para>

      <section>
        <title>Architecture</title>

        <para>Kermeta has been designed to be fully compatible with the OMG
        standard meta-data language EMOF. The metamodel of Kermeta is divided
        into two packages :</para>

        <orderedlist continuation="restarts">
          <listitem>
            <para><emphasis>structure</emphasis> which corresponds to
            EMOF</para>
          </listitem>

          <listitem>
            <para><emphasis>behavior</emphasis> which corresponds to the
            actions. This section gives an overview of these two packages and
            their relationships.</para>
          </listitem>
        </orderedlist>

        <para>Thanks to this reuse, Kermeta is fully compatible with EMOF.
        This is useful in the promotion of Kermeta as a metalanguage.</para>

        <figure id="refIllustration1">
          <title>EMOF extension and Kermeta promotion</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/kermeta_emof_promotion.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <figure id="refIllustration2">
          <title>Package kermeta::language::structure</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/kermeta_structure_package.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>Figure <link linkend="refIllustration3">4</link> presents the
        main classes of the structure package. To design this package, we
        started from EMOF and completed it to build the Kermeta language. The
        choice of EMOF is motivated by two main reasons : firstly it is
        standardized by the OMG and secondly is is well-supported by tools
        such as Eclipse/EMF.</para>

        <para>As MOF is not initially designed to be executable, several
        concepts have to be completed and slightly modified to build an
        executable language. The first and most important modification is to
        add the ability to define the behavior of operations. To achieve this
        we define an action language in the package
        <literal>behavior</literal><emphasis> </emphasis>of Kermeta. The class
        hierarchy of the package behavior is presented on Figure <link
        linkend="refIllustration3">4</link>. In practice, Kermeta expressions
        have been designed by adding model modification capabilities (like
        assignment of properties for instance) to OCL expressions.</para>

        <figure id="refIllustration3">
          <title>Package kermeta::language::behavior</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/kermeta_behavior_package.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>The link between structure and behavior is made through the
        property <literal>body</literal> of class <literal>Operation</literal>
        which allows to define the behavior of an operation using a Kermeta
        expression.</para>

        <para>A more detailed description of the architecture of Kermeta is
        presented in section <link
        linkend="section_kermeta_metamodel">5</link>.</para>
      </section>

      <section>
        <title>Object-Oriented features</title>

        <para>A MOF class can have operations but MOF does not provide any way
        to describe the behavior of these operations. Furthermore MOF does not
        provide any semantics neither for operation call nor for operation
        inheritance and redefinition. This section investigates how, while
        weaving actions into MOF, MOF semantics can be extended to support
        behavior definition and extension mechanisms provided by the action
        language. This implies answering several questions concerning
        redefinition and dispatch.</para>

        <section>
          <title>Operation redefinition</title>

          <para>MOF does not specify the notion of overriding an operation
          because from a structural point of view it does not make any sense.
          To stick to MOF structure one can argue that redefinition should be
          forbidden in an executable MOF. This is the simplest solution as it
          also solves the problem of the dynamic dispatch since a simple
          static binding policy can be used.</para>

          <para>However, operation redefinition is one of the key features of
          Object-Oriented (OO) languages. The OO paradigm has demonstrated
          that operation redefinition is a useful and powerful mechanism to
          define the behavior of objects and allow for variability. This would
          be very convenient to properly model dynamic semantic variation
          points existing in e.g. UML state-charts. For this reason we believe
          that an important feature of an executable MOF is to provide a
          precise behavior redefinition mechanism. The choice of the operation
          overriding mechanism must take into account the usual problem of
          redefinition such as method specialization and conflicting
          redefinitions related to multiple inheritance.</para>

          <table id="refTable0">
            <title>Operation redefinition in Kermeta</title>

            <tgroup cols="2">
              <colspec colname="c1" colwidth="2.2inch" />

              <colspec colname="c2" colwidth="4.5inch" />

              <tbody>
                <row>
                  <entry align="right"><?border-top 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <mediaobject>
                      <imageobject>
                        <imagedata 
                                   fileref="KerMeta-Manual_figures/operation_redefinition.png"
                                    />
                      </imageobject>
                    </mediaobject> <para></para></entry>

                  <entry><?border 0.0007inch solid #000000?> <programlisting><emphasis
                        role="strong">class</emphasis> A
{
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> m1() <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// Some behavior</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// operation m2 is abstract</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> m2() <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">abstract</emphasis>
}
</programlisting> <programlisting><emphasis role="strong">class</emphasis> B <emphasis
                        role="strong">inherits</emphasis> A
{&nbsp;&nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// method m1 inherits operation m1 from A</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">method</emphasis> m1() <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// Behavior redefinition</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">method</emphasis> m2() <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">do</emphasis> <emphasis>//</emphasis><emphasis> Implementation of the abstract method</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <orderedlist continuation="restarts"></orderedlist>

          <note>
            Notice in that sample that method redefinition uses the 

            <literal>method</literal>

             keyword instead of 

            <literal>operation.</literal>
          </note>
        </section>

        <section>
          <title>Operation specialization</title>

          <para>The issue of choosing semantics for operation overriding has
          been widely studied for the design of OO languages ( cf. M. Abadi
          and L. Cardelli, A theory of objects, Springer). However, OO
          languages have not adopted a unique solution to this problem. In
          this context, any language that defines an operation overriding
          mechanism should define precisely the solution it implements.</para>

          <para>The simplest approach to overriding is to require that an
          overriding method has exactly the same signature as the overridden
          method. That is that both the type of the parameters and the return
          type of the operation should be <emphasis>invariant</emphasis> among
          the implementations of an operation. For the sake of simplicity this
          is the solution we have chosen for the current version of
          Kermeta.</para>

          <para>However, this condition can be relaxed to allow method
          <emphasis>specialization,</emphasis> i.e. specialization on the
          types of parameters or/and return type of the operation. On one
          hand, the return type of the overriding method can be a sub-type of
          the return type of the overridden method. Method specialization is
          said to be <emphasis>covariant</emphasis> for the return types. On
          the other hand, the types of parameters of the overriding method
          might be super types of the parameters of the overridden methods.
          Method specialization is thus <emphasis>contravariant</emphasis> for
          the parameters.</para>

          <para>In practice languages can allow method specialization only on
          the return type (this is the case of Java 1.5) or both on parameters
          and return type (this is the case of Eiffel). Among these solutions,
          we may choose a less restrictive policy then strict invariance for
          future versions of Kermeta in order to improve the static type
          checking of Kermeta programs.</para>
        </section>

        <section>
          <title>Operation overloading</title>

          <para>Overloading is not allowed in Kermeta. This mechanism allows
          multiple operations taking different types of parameters to be
          defined with the same name. For each call, depending on the type of
          the actual parameters, the compiler or interpreter automatically
          calls the right one. This provides a convenient way for writing
          operations whose behaviors differ depending on the static type of
          the parameters. Overloading is extensively used is some functional
          languages such as Haskell and has been implemented in OO languages
          such as Java or C#. However it causes numerous problems in an OO
          context due to inheritance and even multiple inheritance in our case
          [REF?]. It is not implemented in some OO languages such as Eiffel
          for this reason, and that is why we chose to exclude overloading
          from Kermeta.</para>

          <programlisting><emphasis role="strong">class</emphasis> A
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">method</emphasis> m(i : Integer) <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// [...]</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end method </emphasis>m(s : String)<emphasis
              role="strong"> is do </emphasis><emphasis>// this is not allowed in Kermeta !!!</emphasis><emphasis
              role="strong"></emphasis><emphasis>// [...]</emphasis><emphasis
              role="strong">end</emphasis>
}</programlisting>
        </section>

        <section>
          <title>Conflicts related to multiple inheritance</title>

          <para>This is also a classical problem that has been solved in
          several OO languages. There are mainly two kinds of conflicts when a
          class inherits features from several super-classes:</para>

          <orderedlist continuation="restarts">
            <listitem>
              <para>Several features with the same name might be inherited
              from different super classes causing a name clash.</para>
            </listitem>

            <listitem>
              <para>Several implementations of a single operation could be
              inherited from different super classes.</para>
            </listitem>
          </orderedlist>

          <para>There are two kinds of solutions to resolve these conflicts.
          The first one is to have an implicit resolution mechanism which
          chooses the method to inherit according to an arbitrary policy. The
          second one is to include in the language constructions that allow
          the programmer to explicitly resolve conflicts. In Eiffel, for
          instance, the programmer can rename features in order to avoid name
          clashes and can select the method to inherit if several redefinition
          of an operation are inherited from parent classes.</para>

          <para>In the current version of Kermeta, we have chosen to include a
          minimal selection mechanism that allows the user to explicitly
          select the inherited method to override if several implementations
          of an operation are inherited. This mechanism does not allow
          resolving some name clashes and thus reject some ambiguous programs.
          For the future version of Kermeta we plan to include a more general
          mechanism such as <emphasis>traits</emphasis> proposed by Schärli et
          al. In any case we believe the conflict resolution mechanism should
          be explicit for the programmer.</para>

          <table id="refTable1">
            <title>Explicit selection of super operation in Kermeta</title>

            <tgroup cols="2">
              <colspec colname="c1" colwidth="2.3inch" />

              <colspec colname="c2" colwidth="4.4inch" />

              <tbody>
                <row>
                  <entry align="center"><?border-top 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <mediaobject>
                      <imageobject>
                        <imagedata 
                                   fileref="KerMeta-Manual_figures/superoperation_selection.png"
                                    />
                      </imageobject>
                    </mediaobject> <para></para></entry>

                  <entry><?border 0.0007inch solid #000000?> <programlisting><emphasis
                        role="strong">class</emphasis> O
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> m() <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">abstract</emphasis>
}
</programlisting> <programlisting><emphasis role="strong">class</emphasis> A <emphasis
                        role="strong">inherits</emphasis> O
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">method</emphasis> m() <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// [...]</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}
</programlisting> <programlisting><emphasis role="strong">class</emphasis> B <emphasis
                        role="strong">inherits</emphasis> O
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">method</emphasis> m() <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// [...]</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}
</programlisting> <programlisting><emphasis role="strong">class</emphasis> C <emphasis
                        role="strong">inherits</emphasis> A, B
{
<emphasis>// "from" : an explicit selection of the//implementation to inherit</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">method</emphasis> m() <emphasis
                        role="strong">from</emphasis> A <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// [...]</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
} 
</programlisting></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <orderedlist continuation="continues"></orderedlist>
        </section>
      </section>

      <section>
        <title>Kermeta type system</title>

        <para>One of the core characteristics of Kermeta is to be statically
        typed. In order to allow static typing of OCL-like expressions, a few
        modifications had to be made to the EMOF type system (Please refer to
        paper Weaving Executability into Object-Oriented Meta-Languages by
        P.A. Muller et al., to be presented at the Models05
        conference).</para>

        <para>As a result to these modifications genericity support has been
        added into Kermeta. Like Eiffel and Java 5 Kermeta supports generic
        classes and generic operations. This section gives on overview of
        these concepts in Kermeta.</para>

        <section>
          <title>Generic classes</title>

          <para>In Kermeta classes can have a set of type parameters. These
          type variables can be used in the implementation of the class as any
          other type. By default a type variable can take as value any type;
          but a type variable can also be constrained by a type: in that case,
          this type variable can only be substituted by a sub-type of this
          type. The following code demonstrates how to create generic
          classes.</para>

          <programlisting>// A class with a type variable G that can be bound with any type</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> Queue&lt;G&gt;
{
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> elements : oset G[*]

 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> enqueue(e : G) : <emphasis
              role="strong">Void</emphasis> <emphasis role="strong">is</emphasis> <emphasis
              role="strong">do</emphasis> 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements.add(e)
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> dequeue() : G <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := elements.first
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements.removeAt(0)
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}
</programlisting>

          <programlisting>// A class with a type variable C that can be bound with any sub-type of Comparable</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> SortedQueue&lt;C : Comparable&gt; <emphasis
              role="strong">inherits</emphasis> Queue&lt;C&gt; 
{
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">method</emphasis> enqueue(e : C) : <emphasis
              role="strong">Void</emphasis> <emphasis role="strong">is</emphasis> <emphasis
              role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> i : Integer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">from</emphasis> i := 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">until</emphasis> i == elements.size <emphasis
              role="strong">or</emphasis> e &gt; elements.elementAt(i)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">loop</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i := i + 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements.addAt(i, e)
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}
</programlisting>
        </section>

        <section>
          <title>Generic operations</title>

          <para>Kermeta operations can contain type parameters. Like type
          variables for classes these type parameters can be constrained by a
          super type. However, unlike for classes, for which the bindings to
          these type parameters are explicit, for operations the actual type
          to bind to the variable is statically inferred for each call
          according to the type of the actual parameters.</para>

          <programlisting><emphasis role="strong">class</emphasis> Utils {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> max&lt;T : Comparable&gt;(a : T, b : T) : T <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := <emphasis
              role="strong">if</emphasis> a &gt; b <emphasis role="strong">then</emphasis> a <emphasis
              role="strong">else</emphasis> b <emphasis role="strong">end</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}
</programlisting>

          <note>
            Notice in that sample that even the "if" is an expression that can return a value that is assigned here to the special variable "result".
          </note>
        </section>
      </section>

      <section>
        <title>Functions in Kermeta<phrase
        id="sec:function-types"></phrase></title>

        <para>In order to implement and statically type check OCL-like
        iterators, Kermeta includes some limited functional features by
        implementing lambda expressions.</para>

        <para>This is typically used on <literal>Collection</literal> which
        provides functions like : <literal>each</literal>,
        <literal>select</literal>, <literal>forAll</literal>,
        <literal>detect</literal>, ...</para>

        <para><emphasis role="strong">Example 1</emphasis>: the following code
        will build a collection of names of the operations that start with
        "test".</para>

        <programlisting><emphasis role="strong">var</emphasis> names : Collection&lt;String&gt;
names := <emphasis role="strong">self</emphasis>.getMetaClass.classDefinition.ownedOperation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.select{ op | op.name.indexOf("test") == 0}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect{ op | op.name }</programlisting>

        <para><emphasis role="strong">Example 2</emphasis>: Providing a time
        function on Integer</para>

        <programlisting><emphasis role="strong">operation</emphasis> times(body : &lt;Integer-&gt;Object&gt;) : Void <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">from</emphasis> <emphasis
            role="strong">var</emphasis> i : Integer <emphasis role="strong">init</emphasis> 0
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">until</emphasis> i == <emphasis
            role="strong">self</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">loop</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body(i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i := i + 1
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
<emphasis role="strong">end</emphasis> </programlisting>

        <para>this allows to write code like :</para>

        <programlisting><emphasis role="strong">var</emphasis> res : Integer
10.<emphasis role="strong">times</emphasis> { i | stdio.writeln(i.toString + ": Hello") } <emphasis>// Say 10 times Hello</emphasis></programlisting>

        <para>See sections <link
        linkend="section_lambda_expression">2.3.7</link> and <link
        linkend="section_lambda_expression_mm">5.3.6</link> for detailed
        informations.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Language Basics</title>

    <para>This section presents basic features of the Kermeta language such as
    comments, types, or instructions ... A simple "Hello world" example
    concludes this first section. More complex object-oriented features are
    explained in section <link linkend="sec:oo-features">3</link>.</para>

    <section>
      <title>Comments and keywords</title>

      <warning>
        Comments are a little bit particular in the Kermeta language because they are not all ignored by the interpreter. There are two kinds of comments: the first (syntax : // foo , /* bar 

        <emphasis role="strong">/) is only associated to the text editor view
        in which the user edits his Kermeta file, and the second one(syntax
        :</emphasis>

        /** foo */ 

        <emphasis role="strong">or</emphasis>

         @tag_name "tag value") is translated into a MOF tag linked to structures described in the Kermeta model.
      </warning>

      <section>
        <title>Simple and multi-line text comments</title>

        <para>Like in many languages, Kermeta provides two ways to add
        comments in your models:</para>

        <orderedlist continuation="restarts">
          <listitem>
            <para>simple line comments, i.e text line beginning with //</para>

            <para>// This is a single line comment</para>
          </listitem>

          <listitem>
            <para>multi-line comments, i.e text between /* */. Be careful with
            this notation : the opening syntax must not have juxtaposed stars
            ("/**"), otherwise it will be considered as a linked comment (see
            section <link linkend="sec:linked-comments">2.1.2</link>, p.<link
            linkend="sec:linked-comments">18</link>), i.e a comment that is
            part of the Kermeta program as a model.</para>

            <para>/* This a multi line comment all these lines are
            comments</para>

            <para role="lineBreak">this line too. */</para>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>Linked comments<phrase
        id="sec:linked-comments"></phrase></title>

        <para>Kermeta provides a way to define named and unnamed annotations,
        that have to be defined just above any model element among
        <literal>Package</literal>, <literal>ClassDefinition</literal>,
        <literal>Property</literal>, <literal>Operation</literal>. Such
        annotations correspond to MOF tags, and are linked to the elements
        above which they are defined.</para>

        <para>To define a named annotation, you have to use a special symbol
        "@", whereas an anonymous annotation has to be written between /** and
        */</para>

        <para><emphasis role="strong">Example 1:</emphasis> you can define an
        annotation to describe the role of a property</para>

        <programlisting>@usage "count the number of ..."
<emphasis role="strong">reference</emphasis> myCounter : Integer </programlisting>

        <para><emphasis role="strong">Example 2</emphasis>: you can document
        your classes and operation using /** ... */</para>

        <programlisting><emphasis>/** * This is a documentation tag for the class "myClass" */</emphasis>
<emphasis role="strong">class</emphasis> MyClass {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/** This is a documentation tag for myOperation */</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> myOperation() <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// Unlinked comment</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">@desc</emphasis> "This is a named annotation for thisOperation"
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> thisOperation() <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/* This is an unlinked comment */</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>
      </section>

      <section>
        <title>Keywords</title>

        <para>Kermeta textual syntax uses several keywords like
        <literal>class</literal>, <literal>attribute</literal>,
        <literal>reference</literal>, <literal>result</literal>, etc. (Please
        see the appendice at the end of this document to get the complete list
        of Kermeta keywords.)</para>

        <para>This doesn't mean you cannot use these words for your own model.
        Moreover, this is only a textual syntax limitation.</para>

        <para>So Kermeta syntax allows you to use the word you want, you
        simply have to prefix it with a tilda ~.</para>

        <para>This example is valid:</para>

        <programlisting><emphasis role="strong">require </emphasis>"./ecore.ecore"<emphasis
            role="strong">class</emphasis> ~class {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> ~attribute : Ecore::Attribute
}</programlisting>
      </section>
    </section>

    <section>
      <title>Variables and types<phrase
      id="sec:types-and-variables"></phrase></title>

      <para>A variable is defined by a name and by a datatype which determines
      the domain and operations we can apply on the variable.</para>

      <programlisting>NAME:&nbsp;&nbsp;&nbsp;&nbsp;( '~' )? 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( 'a'..'z' | 'A'..'Z' | '_' ) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( 'a'..'z' | 'A'..'Z' | '_' | DIGIT )* </programlisting>

      <para>Declaring a variable:</para>

      <programlisting><emphasis role="strong">var</emphasis> foo : String <emphasis>// This is a variable declaration</emphasis></programlisting>

      <section>
        <title>Primitive types</title>

        <para>Kermeta implements a few primitive types. By primitive types, we
        mean types that are basic to any language, i.e integer, and that have a "literal" value. See below table.</para>

        <informaltable>
          <tgroup cols="3">
            <colspec colname="c1" colwidth="1.1inch" />

            <colspec colname="c2" colwidth="3inch" />

            <colspec colname="c3" colwidth="1.8inch" />

            <thead>
              <row>
                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Name</para></entry>

                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Description</para></entry>

                <entry><?border 0.0007inch solid #000000?> <para>Literal
                Example</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Integer</para></entry>

                <entry><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>Represents
                integer numeric value like 10 or 12. («&nbsp;int&nbsp;» data
                type in Java)</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>'101', '12', '14, '-45', '-123'</para></entry>
              </row>

              <row>
                <entry><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>String</para></entry>

                <entry><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>Represents a
                string of like « helloworld&nbsp;»
                («&nbsp;String&nbsp;» data type in Java)</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>"helloworld", "this is a string !!!"</para></entry>
              </row>

              <row>
                <entry><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Boolean</para></entry>

                <entry><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>Represents a
                true/false value. («&nbsp;boolean&nbsp;» data type in
                Java)</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>true, false</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <programlisting><emphasis>// Simple datatypes examples</emphasis>
<emphasis role="strong">var</emphasis> myVar1 : Integer <emphasis
            role="strong">init</emphasis> 10
<emphasis role="strong">var</emphasis> myVar2 : Integer
<emphasis role="strong">var</emphasis> myVar4 : String <emphasis role="strong">init</emphasis> "a new string value"
<emphasis role="strong">var</emphasis> myVar5 : boolean</programlisting>
      </section>

      <section>
        <title>Enumeration types</title>

        <para>You can define enumeration types by using the following syntax.
        Note that each enumeration literal must end with a ";".</para>

        <programlisting><emphasis role="strong">enumeration</emphasis> Size { small; normal; big; huge; } </programlisting>

        <para>You can manipulate enumerated variables and literals with
        classical operators such as in the following example.</para>

        <programlisting><emphasis role="strong">var</emphasis> mySize : Size
<emphasis role="strong">if</emphasis> ( mySize == Size.small ) <emphasis
            role="strong">then</emphasis> 
 &nbsp;&nbsp;&nbsp;stdio.writeln("This is small !") 
<emphasis role="strong">end</emphasis></programlisting>

        <note>
          Enumeration are concept of the same level as classes, they must be defined in a package.
        </note>
      </section>

      <section>
        <title>Arrays and Collections<phrase
        id="array_and_collection"></phrase><phrase
        id="sec:collections"></phrase></title>

        <para>Kermeta defines some collection data types handling sets of
        values. The different available collection types are the result of a
        combination of the constraints <emphasis
        role="strong">unique</emphasis> and <emphasis
        role="strong">ordered</emphasis>.</para>

        <orderedlist continuation="restarts">
          <listitem>
            <para>Unique specifies a collection type that cannot contain
            doublet</para>
          </listitem>

          <listitem>
            <para>Ordered specifies a collection type where the position of an
            object inside the collection can be modified.</para>
          </listitem>
        </orderedlist>

        <informaltable>
          <tgroup cols="4">
            <colspec colname="c1" colwidth="0.8inch" />

            <colspec colname="c2" colwidth="3.1inch" />

            <colspec colname="c3" colwidth="1inch" />

            <colspec colname="c4" colwidth="1inch" />

            <thead>
              <row>
                <entry morerows="1" valign="middle"><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Name</para></entry>

                <entry morerows="1" valign="middle"><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Description</para></entry>

                <entry nameend="c4" namest="c3"><?border 0.0007inch solid #000000?>
                <para>Constraints</para></entry>
              </row>

              <row>
                <entry><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Unique</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Ordered</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>set</para></entry>

                <entry valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>Represents an
                unordered collection of objects with no doublet
                (Set)</para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>True</para></entry>

                <entry align="center" valign="middle"><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>False</para></entry>
              </row>

              <row>
                <entry valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>oset</para></entry>

                <entry valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>Represents an
                ordered collection of objects with no doublet
                (OrderedSet)</para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>True</para></entry>

                <entry align="center" valign="middle"><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True</para></entry>
              </row>

              <row>
                <entry valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>seq</para></entry>

                <entry valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>Represents an
                ordered collection of objects (Sequence) </para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>False</para></entry>

                <entry align="center" valign="middle"><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True</para></entry>
              </row>

              <row>
                <entry valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>bag</para></entry>

                <entry valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>Represents a
                basic collection of objects (Bag)</para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>False</para></entry>

                <entry align="center" valign="middle"><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>False</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <figure id="refIllustration4">
          <title>: The kermeta collections</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/collections.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>Another way to define set of objects would have been to use
        arrays. In fact, Kermeta does not define explicitly the concept of
        array, but it provides a multiplicity concept which can be used
        instead. Multiplicities are a way to define a lower and upper bound on
        a collection. Syntactically, lower and upper bounds are defined
        between brackets and are separated by two dots. Bounds can be an
        integer literal value or a star to specify there's no upper
        bound.</para>

        <para><emphasis role="strong">Example 1</emphasis>: how to declare
        collections</para>

<programlisting>
	<emphasis>// Collection with multiplicities</emphasis>
	<emphasis role="strong">var</emphasis> myCol1 : <emphasis role="strong">set</emphasis> Integer[4..6]<emphasis> // At least 4 elements and never more than 6</emphasis>
	<emphasis role="strong">var</emphasis> myCol3 : <emphasis role="strong">seq</emphasis> String[2..*]<emphasis> // At least two strings in the sequence</emphasis>
	<emphasis role="strong">var</emphasis> myCol4 : <emphasis role="strong">set</emphasis> String[1..*]<emphasis> // An non empty set</emphasis>
	<emphasis role="strong">var</emphasis> myCol5 : String[1..*]<emphasis> // If you don't specify any keyword, it is an ordered set</emphasis>
</programlisting>

<programlisting>
    <emphasis>// This way of declaring a variable is recommended</emphasis>
	<emphasis role="strong">var</emphasis> myColA : Set&lt;Integer&gt; <emphasis>// this is equivalent to saying set Integer[0..*]</emphasis>
</programlisting>

        <para>There is currently no way to define a collection by extension
        like you can do in C or Java. You must initialize your collection
        either by calling <literal>new</literal><emphasis role="strong">
        </emphasis>(Kermeta constructor operation) on your collection type, or
        initialize by copy.</para>

        <para><emphasis role="strong">Example 2</emphasis>: initialize
        collections</para>

        <programlisting><emphasis>// Example of declaration of variables as Collections. All those syntaxes are valid</emphasis>
<phrase id="DDE_LINK1"></phrase><emphasis role="strong">var</emphasis> myCol1 : <emphasis
            role="strong">set</emphasis> Integer[0..*]&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">init</emphasis> kermeta::standard::Set&lt;Integer&gt;.new
<emphasis>// Fill in myCol1</emphasis>
myCol1.add(10)
myCol1.add(50)

<emphasis role="strong">var</emphasis> myCol2 : <emphasis role="strong">oset</emphasis> String[0..*]&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">init</emphasis> kermeta::standard::OrderedSet&lt;String&gt;.new
<emphasis role="strong">var</emphasis> myCol3 : <emphasis role="strong">bag</emphasis> Boolean[0..*]&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">init</emphasis> kermeta::standard::Bag&lt;Boolean&gt;.new
<emphasis role="strong">var</emphasis> myCol4 : <emphasis role="strong">seq</emphasis> Integer[0..*]&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">init</emphasis> kermeta::standard::Sequence&lt;Integer&gt;.new
<emphasis>// if no keyword specified, and multiplicity is set, it is an OrderedSet</emphasis></programlisting>

        <programlisting><emphasis role="strong">var</emphasis> myCol4 : String[0..*]<emphasis
            role="strong">init</emphasis> kermeta::standard::OrderedSet&lt;String&gt;.new
</programlisting>

        <programlisting><emphasis role="strong">var</emphasis> myCol1a : <emphasis
            role="strong">seq</emphasis> Integer[0..*]&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">init</emphasis> myCol1
<emphasis role="strong">var</emphasis> myCol2a : <emphasis role="strong">oset</emphasis> String[0..*]&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">init</emphasis> myCol2
<emphasis role="strong">var</emphasis> myCol3a : kermeta::standard::Bag&lt;Boolean&gt; <emphasis
            role="strong">init</emphasis> myCol3
<emphasis role="strong">var</emphasis> myCol3a : kermeta::standard::Sequence&lt;Integer&gt; <emphasis
            role="strong">init</emphasis> myCol4</programlisting>

        <note>
          Conclusion : in most cases, you don't need to use this special syntax, you can simply use the generic collection names (Set&lt;Something&gt;, OrderedSet&lt;Something&gt;, etc.) available in Kermeta framework. Moreover, lower and upper bounds aren’t checked yet by Kermeta type checker and interpreter.
        </note>
      </section>

      <section>
        <title>Local datatype using "alias"<phrase
        id="section_alias"></phrase></title>

        <para>In Kermeta, you can define your own datatype based on existing
        types without a hard dependency like inheritance.</para>

        <para>This is done using the alias syntax.</para>

        <para>Ex:</para>

        <programlisting><emphasis role="strong">alias</emphasis> MyString : kermeta::standard::String;</programlisting>

        <para>In this sample, MyString has all the behavior of
        kermeta::standard::String but is declared locally. This means that you
        don't have any dependency to the framework, even to the String in the
        framework.</para>

        <para>Obviously you can reuse existing type names :</para>

        <programlisting><emphasis role="strong">alias</emphasis> String : kermeta::standard::String;</programlisting>

        <para>This will create a new type String in your package with the
        behavior of String in the framework.</para>

        <para>The definition of an alias is different from the use of "using"
        statement (as defined in section <link
        linkend="section_using">3.4.2</link>), when you write</para>

        <para><emphasis role="strong">using</emphasis>
        kermeta::standard</para>

        <para role="lineBreak">you simply defined a syntactical shortcut
        allowing you to access any definition in this package from within this
        file.</para>

        <para>Wheras defining an alias allows you to access this new
        definition from another package if needed.</para>

        <tip>
          It is interesting to redefine your own datatype for all the standard type you use in your metamodel, so when you convert the file into ecore in order to have serialisation, you won't have any dependency to framework.ecore (which is the ecore version of the framework where kermeta standard type) This allow a lazy coupling of the type definitions.
        </tip>
      </section>

      <section>
        <title>Operators</title>

        <informaltable>
          <tgroup cols="4">
            <colspec colname="c1" colwidth="0.6inch" />

            <colspec colname="c2" colwidth="0.9inch" />

            <colspec colname="c3" colwidth="1.2inch" />

            <colspec colname="c4" colwidth="3.2inch" />

            <thead>
              <row>
                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Priority</para></entry>

                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Operator</para></entry>

                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Operand types</para></entry>

                <entry><?border 0.0007inch solid #000000?>
                <para>Semantic</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>1</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>+</literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>Numeric</para>
                <para>String</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Add two numeric values</para> <para>Concatenate two
                strings</para></entry>
              </row>

              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>1</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>-</literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Numeric</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Subtract two numerous values</para></entry>
              </row>

              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>2</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>*</literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Numeric</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Multiply two numeric values</para></entry>
              </row>

              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>2</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>/</literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Numeric</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Divide the first operand by the second</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Notice that most of these arithmetic operators are only defined
        for numeric primitive types like Integer. Except the +
        operator which is a concatenation operator for String, they are not
        applicable on String, Boolean nor collections</para>

        <informaltable>
          <tgroup cols="4">
            <colspec colname="c1" colwidth="0.6inch" />

            <colspec colname="c2" colwidth="0.9inch" />

            <colspec colname="c3" colwidth="1.2inch" />

            <colspec colname="c4" colwidth="3.2inch" />

            <thead>
              <row>
                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Priority</para></entry>

                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Operators</para></entry>

                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Operand Types</para></entry>

                <entry><?border 0.0007inch solid #000000?>
                <para>Semantics</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>3</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>==</literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Primitives</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True, if op1 value's is the same that op2
                value's</para></entry>
              </row>

              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>3</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>!=</literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Primitives</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True if op1 value's is different of op2
                value's</para></entry>
              </row>

              <row>
                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>3</para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>&lt;</literal> </para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Numeric</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True if op1value's is strictly smaller than op2
                value's</para></entry>
              </row>

              <row>
                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>3</para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>&lt;=</literal> </para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Numeric</para></entry>

                <entry valign="middle"><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True if op1 value's is smaller or equals than op2
                value's</para></entry>
              </row>

              <row>
                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>3</para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>&gt;</literal> </para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Numeric</para></entry>

                <entry valign="middle"><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True if op1 value's is strictly greater than op2
                value's</para></entry>
              </row>

              <row>
                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>3</para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>&gt;=</literal> </para></entry>

                <entry align="center" valign="middle"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Numeric</para></entry>

                <entry valign="middle"><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True if op1 value's is greater or equals than op2
                value's</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <informaltable>
          <tgroup cols="4">
            <colspec colname="c1" colwidth="0.6inch" />

            <colspec colname="c2" colwidth="0.9inch" />

            <colspec colname="c3" colwidth="1.2inch" />

            <colspec colname="c4" colwidth="3.2inch" />

            <thead>
              <row>
                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Priority</para></entry>

                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Operators</para></entry>

                <entry><?border-top 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>Operands Types</para></entry>

                <entry><?border 0.0007inch solid #000000?>
                <para>Semantics</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>4</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para> <literal>and
                </literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Boolean</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True if op1 and op2 are evaluated to true</para></entry>
              </row>

              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>4</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para>
                <literal>or</literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Boolean</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True if one of the operators is evaluated to
                true</para></entry>
              </row>

              <row>
                <entry align="center" valign="bottom"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>4</para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?> <para> <literal>not
                </literal> </para></entry>

                <entry align="center"><?border-bottom 0.0007inch solid #000000?>
                <?border-left 0.0007inch solid #000000?>
                <para>Boolean</para></entry>

                <entry><?border-right 0.0007inch solid #000000?>
                <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                <para>True if op is false.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
    </section>

    <section>
      <title>Basic instructions</title>

      <section>
        <title>Defining operations</title>

        <para>Kermeta provides a way to add operational (==action) semantics
        to your metamodels. For that, you can define operations with their
        body, as in a classical programming language. You can also specify
        abstract operations (they have no body). Kermeta requires that every
        class that contains an abstract operation must be declared as an
        abstract class.</para>

        <para>There are some limitations in regards to Java. For example, you
        cannot define nested classes in Kermeta. Kermeta offers the same
        structural concepts than MOF language.</para>

        <para>In the following example, we define some operations, based on a
        visitor pattern implementation</para>

        <programlisting><emphasis role="strong">class</emphasis> Inventory 
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> visitLibrary(l : Library) <emphasis
            role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeln("Inventory : ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.books.each(b : Book | b.accept(<emphasis
            role="strong">self</emphasis>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeln("----")
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> visitBook(b : Book) <emphasis
            role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdio.write("Book : ", b.title, " by ")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.authors.each(a : Author | a.accept(<emphasis
            role="strong">self</emphasis>))
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> visitAuthor(a : Author) <emphasis
            role="strong">is</emphasis> 
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdio.write(a.name, " ", a.lastName)
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Library {
&nbsp;&nbsp;&nbsp;&nbsp;// ...
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
            role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitor.visitLibrary(self)
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Book
{
&nbsp;&nbsp;&nbsp;&nbsp;// ...
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
            role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitor.visitBook(self)
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Author
{
&nbsp;&nbsp;&nbsp;&nbsp;// ...
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
            role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitor.visitAuthor(self)
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>

        <para>In this small example we define an <literal>Inventory</literal>
        class which can go over the library structure and print books
        informations. For that, we apply the visitor GoF pattern's on the
        library structure defining an <literal>accept</literal> method in
        every library structures.</para>

        <section>
          <title>Result</title>

          <para>The special variable <literal>result</literal> is used to
          store the value that will be returned by the operation.</para>

          <programlisting><emphasis role="strong">operation</emphasis> getName() : String<emphasis
              role="strong"> is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := <emphasis
              role="strong">self</emphasis>.name
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis></programlisting>

          <note>
            This is different of the 

            <literal>return</literal>

             in java, since it doesn't end the block. Other instruction can be used after the 

            <literal>result</literal>

             assignment.
          </note>
        </section>

        <section>
          <title>Operations as main entry point.</title>

          <para>When you run a Kermeta program you'll start from an operation.
          The main operation that you want to run can have any number of
          parameters, whose types must be only and only String. For operations
          that are <emphasis role="strong">not</emphasis> intended to be run,
          you can put any type of parameters.</para>

          <para>Technically, if you use kermeta inside Eclipse, when you will
          ask it to run your operation, the interpreter will implicitely
          instanciate the class containing this operation, and then will call
          this operation.</para>

          <para><emphasis role="strong">Example</emphasis>: 3 different kinds
          of "runnable" operations</para>

          <programlisting><emphasis role="strong">class</emphasis> A{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> main0() <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// do something</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> main1( arg1 : String) <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// do something with 1rst argument</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> main3( arg1 : String, arg2 : String) <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// do something with 1st and 2nd arguments</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}
<emphasis>// If you ask to launch main0, kermeta interpereter will create an instance of A and will run main0 on it.</emphasis></programlisting>
        </section>
      </section>

      <section>
        <title>Block statement</title>

        <para>Kermeta provides a block notion to manage scope of variable.
        Instruction of the block have to be inserted between
        <literal>do</literal> and <literal>end</literal> keywords. Theses two
        keywords may be omitted for the conditional and for the loop
        structures.</para>

        <para>A variable could only be accessed in the block where it was
        defined and in its sub blocks:</para>

        <programlisting><emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> v1 : Integer <emphasis
            role="strong">init</emphasis> 3
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> v2 : Integer <emphasis
            role="strong">init</emphasis> 2
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> v3 : Integer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v3 := v1 + v2</programlisting>

        <programlisting>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">var</emphasis> v2 : Integer <emphasis>// error : v2 is already declared in the upper block</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> v4 : Integer <emphasis
            role="strong">init</emphasis> v3 <emphasis>// error : v3 is unknown here</emphasis>
<emphasis role="strong">end</emphasis></programlisting>
      </section>

      <section>
        <title>Conditional statement</title>

        <para>Kermeta's conditional statement is composed of at least two
        elements : a boolean expression and a block that is executed if the
        boolean is evaluated to <literal>true</literal>. You can add a third
        element, with the <literal>else</literal> keyword, that is executed if
        the boolean expression is evaluated to
        <literal>false</literal>.</para>

        <para><emphasis role="strong">Example 1</emphasis>: if..then..else
        block</para>

        <programlisting><emphasis role="strong">var</emphasis> v1 : Integer <emphasis
            role="strong">init</emphasis> 2
<emphasis role="strong">var</emphasis> v2 : String <emphasis role="strong">init</emphasis> "blah"

<emphasis role="strong">if</emphasis> v1 &gt; 5 <emphasis role="strong">then</emphasis> v1 := v1-5

<emphasis role="strong">if</emphasis> v1 == 2 <emphasis role="strong">then</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;v2 := v1
&nbsp;&nbsp;&nbsp;&nbsp;v1 := v2 + v1
<emphasis role="strong">else</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;v1 := 0
<emphasis role="strong">end</emphasis></programlisting>

        <para>The <literal>if</literal> statement is an expression (see
        section <link linkend="section_kermeta_metamodel">5</link>). As any
        expression in Kermeta, it can return a value. The return type of the
        <literal>if</literal> statement must be a super type of the values
        "returned" by both <literal>then</literal> and <literal>else</literal>
        blocks (otherwise the type checker will send an error). The values
        considered as the result of the evaluation (the "returned" values) of
        the <literal>if</literal> statement are the last evaluated statement
        inside <literal>then</literal> or <literal>else</literal> block</para>

        <para><emphasis role="strong">Example 2</emphasis>: conditional is an
        expression</para>

        <programlisting><emphasis role="strong">var</emphasis> s : String
&nbsp;&nbsp;&nbsp;&nbsp;s := <emphasis role="strong">if false then</emphasis> "a" <emphasis
            role="strong">else</emphasis> "b" <emphasis role="strong">end</emphasis></programlisting>

        <para>Example 3: a more complex conditional</para>

        <programlisting><emphasis role="strong">var</emphasis> x : String
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> y : Integer <emphasis
            role="strong">init</emphasis> 5 
&nbsp;&nbsp;&nbsp;&nbsp;x := <emphasis role="strong">if </emphasis>y &lt; 3<emphasis
            role="strong"> then</emphasis> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdio.writeln("hello")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "a" 
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">else</emphasis> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "b"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "c" 
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis> <emphasis>// The String "c" will be the value of x</emphasis></programlisting>
      </section>

      <section>
        <title>Loop Statement</title>

        <para>Here is a sample of a typical loop in Kermeta.</para>

        <programlisting><emphasis role="strong">var</emphasis> v1 : Integer <emphasis
            role="strong">init</emphasis> 3
<emphasis role="strong">var</emphasis> v2 : Integer <emphasis role="strong">init</emphasis> 6

<emphasis role="strong">from</emphasis> <emphasis role="strong">var</emphasis> i : Integer <emphasis
            role="strong">init</emphasis> 0
<emphasis role="strong">until</emphasis> i == 10
<emphasis role="strong">loop</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;i := i + 1
<emphasis role="strong">end</emphasis></programlisting>

        <note>
          There is no exit or continue function in current version of Kermeta, nor a proper way to make an infinite loop
        </note>
      </section>

      <section>
        <title>Exception handling</title>

        <para>Kermeta provides also an exception mechanism. You can define a
        "rescue" block to manage errors occurring during the execution of
        another block. Exception mechanism is very close to the Java Exception
        mechanism.</para>

        <para><emphasis role="strong">Example 1</emphasis>: a simple exception
        raising</para>

        <programlisting><emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> excep : Exception
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;excep := Exception.new
&nbsp;&nbsp;&nbsp;&nbsp;stdio.writeln("Throwing an exception ! ")
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">raise</emphasis> excep
<emphasis role="strong">end</emphasis></programlisting>

        <para>Any block can then rescue exceptions.</para>

        <para><emphasis role="strong">Example 2</emphasis>: rescue
        block</para>

        <programlisting><emphasis role="strong">var</emphasis> v1 : Integer <emphasis
            role="strong">init</emphasis> 2
<emphasis role="strong">var</emphasis> v2 : Integer <emphasis role="strong">init</emphasis> 3

<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;var v3 : Integer
&nbsp;&nbsp;&nbsp;&nbsp;v3 := v1 + v2
<emphasis role="strong">rescue</emphasis> (myError : Exception)
&nbsp;&nbsp;&nbsp;&nbsp;// something with myError
&nbsp;&nbsp;&nbsp;&nbsp;// ...
<emphasis role="strong">end</emphasis></programlisting>
      </section>

      <section>
        <title>Using Variables</title>

        <para>In the following example, we define 3 variables of type integer.
        The first is initialized with the "14" literal value, the second is
        initialized with an expression using v1. For the last variable, we use
        a multiplicity notation to specify an ordered set of integer.</para>

        <programlisting><emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> v1 : Integer <emphasis
            role="strong">init</emphasis> 14
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> v2 : Integer <emphasis
            role="strong">init</emphasis> 145 * v1

&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> tab : Integer[0..*]
&nbsp;&nbsp;&nbsp;&nbsp;v1 := v2/v1
<emphasis role="strong">end</emphasis></programlisting>
      </section>

      <section>
        <title>Lambda Expressions and functions</title>

        <para><phrase id="section_lambda_expression"></phrase>Kermeta proposes
        a cheap implementation of lambda expressions, that is mainly useful
        for implementing OCL-like functions.</para>

        <note>
          Limitations of lambda expressions usage:An operation with a function as parameter : if you define an operation which has a function as a parameter ( ex: 

          <literal>operation op( func : &lt;Integer-&gt;Object&gt;)</literal>

           ), then you cannot put more parameters : only one parameter is allowed in such a case.
        </note>

        <section>
          <title>Syntax<phrase id="sec:function-syntax"></phrase></title>

          <para>Here is a definition of function syntax (this is not a formal
          representation)</para>

          <orderedlist continuation="restarts">
            <listitem>
              <para>Signature of an operation defined as a function:</para>
            </listitem>
          </orderedlist>

          <programlisting><emphasis>// With one parameter</emphasis>
<emphasis role="strong">operation</emphasis> FUNCTION_NAME ( LAMBDA_NAME : &lt;TYPE-&gt;RETURN_TYPE&gt; )
<emphasis>// With many parameters</emphasis>
<emphasis role="strong">operation</emphasis> FUNCTION_NAME ( LAMBDA_NAME : &lt;[TYPE_1, TYPE_2, ...]-&gt;RETURN_TYPE&gt; )</programlisting>

          <orderedlist continuation="restarts">
            <listitem>
              <para>Call of a function:</para>
            </listitem>
          </orderedlist>

          <programlisting>anInstance.FUNCTION_NAME ( TYPE | SOME_CODE )
anInstance.FUNCTION_NAME ( TYPE_1, TYPE_2 | SOME_CODE )</programlisting>

          <orderedlist continuation="restarts">
            <listitem>
              <para>Declaring and defining an "anonymous" function inside an
              operation body</para>
            </listitem>
          </orderedlist>

          <programlisting><emphasis role="strong">var</emphasis> f : &lt;TYPE -&gt; RETURN_TYPE&gt;<emphasis
              role="strong"></emphasis>f := <emphasis role="strong">function</emphasis> { VAR_NAME : TYPE | SOME_CODE_WITH_RETURN_TYPE_RESULT }

<emphasis role="strong">var</emphasis> f : &lt;[ TYPE_1, TYPE_2,... ] -&gt; RETURN_TYPE&gt;f := <emphasis
              role="strong">function</emphasis> { VAR_NAME_1 : TYPE_1, VAR_NAME_2 : TYPE_2,... | SOME_CODE_WITH_RETURN_TYPE_RESULT }</programlisting>

          <para>Next in this section, you will find many examples of
          declarations, definitions, and uses of functions.</para>
        </section>

        <section>
          <title>Some existing useful functions</title>

          <para>The collections in Kermeta implement several functions based
          on lambda expression. These ones are very useful for model
          navigation.</para>

          <para><emphasis role="strong">Example 1:</emphasis> closure
          definitions for collection manipulation in Kermeta</para>

          <programlisting>aCollection.<emphasis role="strong">each</emphasis> { e | 
 &nbsp;&nbsp;&nbsp;<emphasis>/* do something with each element e of this collection */</emphasis>
}
</programlisting>

          <programlisting>aBoolean := aCollection.<emphasis role="strong">forAll</emphasis> { e | <emphasis>/* put here a condition */</emphasis>
} <emphasis>// return true if the condition is true for all elements in the collection.</emphasis></programlisting>

          <programlisting>aCollection2 := aCollection.<emphasis role="strong">select</emphasis> { e | 
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/* put here a condition that returns true for elements that must  be included in the resulting Collection */</emphasis>
}
</programlisting>

          <programlisting>aCollection2 := aCollection.<emphasis role="strong">reject</emphasis> { e | 
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/* put here a condition that returns true for elements that must  be exclude in the resulting Collection */</emphasis>
}
</programlisting>

          <programlisting><emphasis>// return a new collection which size is the same as in the original // collection, and which element types is the type of the result of the expression.</emphasis>
aCollection2 := aCollection.<emphasis role="strong">collect</emphasis> { e | 
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/* put here an expression, for example e.name */</emphasis>
} 
</programlisting>

          <programlisting>anObject := aCollection.<emphasis role="strong">detect</emphasis> { e | <emphasis>/* a condition */</emphasis>} // returns the first element that fullfil the condition.</programlisting>

          <programlisting>aBoolean := aCollection.<emphasis role="strong">exists</emphasis> { e | <emphasis>/* a condition */</emphasis>} // returns true if at least one element fulfill the condition.</programlisting>

          <para><emphasis role="strong">Example 2:</emphasis> another useful
          function that is defined on Integer : the function times</para>

          <programlisting>10.<emphasis role="strong">times</emphasis> { i | stdio.writeln(i.toString) } <emphasis>// prints 0 to 9</emphasis> </programlisting>

          <para>Notice that you can also write some complex code in the
          function, using internal variables, etc. In such a case, the last
          statement evaluation will be the returned result of the lambda
          expression (provided it is declared to return something)</para>

          <para><emphasis role="strong">Example 3</emphasis>: complex code in
          a lambda expression</para>

          <programlisting>aCollection.<emphasis role="strong">each</emphasis> { e | 
 &nbsp;&nbsp;&nbsp;<emphasis>stdio.writeln("I am complex code!" stdio.writeln("Element : " + e.toString)</emphasis></programlisting>

          <programlisting><emphasis>var i : Integer init 5 i := i + 132458</emphasis>
}</programlisting>
        </section>

        <section>
          <title>Defining new functions in a class</title>

          <para>You can also define your own functions, by declaring an
          operation, with a parameter as a function using the syntax described
          in section <link linkend="sec:function-syntax">2.3.7.1</link>,
          p.<link linkend="sec:function-syntax">27</link></para>

          <para><emphasis role="strong">Example</emphasis>: definition of
          functions for collections</para>

          <programlisting><emphasis role="strong">abstract</emphasis> <emphasis
              role="strong">class</emphasis> Collection&lt;G&gt;
{ &nbsp;&nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/** * runs func on each element of the collection */</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> each(func : &lt;G -&gt; Object&gt;) : Void <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">from</emphasis> <emphasis
              role="strong">var</emphasis> it : Iterator&lt;G&gt; <emphasis
              role="strong">init</emphasis> iterator
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">until</emphasis> it.isOff
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">loop</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func(it.next)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis></programlisting>

          <programlisting>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/** * checks that the condition is true on all the element of the collection * returns true if the collection is empty */</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> forAll(func : &lt;G -&gt; Boolean&gt;) : Boolean <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> test : Boolean <emphasis
              role="strong">init</emphasis> true
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">from</emphasis> <emphasis
              role="strong">var</emphasis> it : Iterator&lt;G&gt; init iterator
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">until</emphasis> it.isOff
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">loop</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test := test <emphasis
              role="strong">and</emphasis> func(it.next)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := test
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>
        </section>

        <section>
          <title>Defining lambda expression variables</title>

          <para>You can also define lambda expression as variable. This can be
          useful if you don't want to ( or can't) modify the class.</para>

          <orderedlist continuation="restarts">
            <listitem>
              <para>A basic lambda expression</para>
            </listitem>
          </orderedlist>

          <para>With one Integer argument and returning an Integer.</para>

          <programlisting><emphasis role="strong">var</emphasis> aLambdaExp : &lt;Integer-&gt;Integer&gt;
<emphasis role="strong">var</emphasis> aLambdaResult : Integer
aLambdaExp := <emphasis role="strong">function</emphasis> { i : Integer | i.plus(4) }
<emphasis>// aLambdaResult equals 7</emphasis>
aLambdaResult := aLambdaExp(3)</programlisting>

          <orderedlist continuation="restarts">
            <listitem>
              <para>A lambda expression with several parameters</para>
            </listitem>
          </orderedlist>

          <programlisting><emphasis role="strong">var</emphasis> aLambdaExp : &lt;[Integer, Integer]-&gt;Integer&gt;
<emphasis role="strong">var</emphasis> aLambdaResult : Integer
aLambdaExp := <emphasis role="strong">function</emphasis> { i : Integer, j : Integer | i * j }
<emphasis>// aLambdaResult equals 12</emphasis>
aLambdaResult := aLambdaExp(3, 4)</programlisting>

          <orderedlist continuation="restarts">
            <listitem>
              <para>A lambda expression on a collection</para>
            </listitem>
          </orderedlist>

          <programlisting><emphasis role="strong">var</emphasis> sequence : Sequence&lt;Integer&gt; <emphasis
              role="strong">init</emphasis> Sequence
<emphasis role="strong">var</emphasis> init_set : Set&lt;Integer&gt; <emphasis
              role="strong">init</emphasis> Set&lt;Integer&gt;.new
init_set.add(32)
init_set.add(23)
init_set.add(41)

<emphasis>// This sequence equals : [320, 230, 41]</emphasis>
sequence := init_set.collect { element | element*10}</programlisting>

          <para>The code within the function can be as complex as you want,
          using internal variables, etc.</para>

          <programlisting>&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> factoExp : &lt;Integer-&gt;Integer&gt;
&nbsp;&nbsp;&nbsp;&nbsp;factoExp := <emphasis role="strong">function</emphasis> { n : Integer | 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> fact : Integer <emphasis
              role="strong">init</emphasis> 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">from</emphasis> var x : Integer <emphasis
              role="strong">init</emphasis> 1 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">until</emphasis> x &gt; n 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">loop</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fact := fact * x 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:=x+1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fact <emphasis>// return fact as the result of the function</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>//shorter alternative ;-)... if n&lt;=1 then 1 else factoExp(n -1) * n end</emphasis>

&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> cnkExp : &lt;[Integer, Integer]-&gt;Integer&gt;
&nbsp;&nbsp;&nbsp;&nbsp;cnkExp := <emphasis role="strong">function</emphasis> { n : Integer, k : Integer |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factoExp(n) / (factoExp(k) * factoExp(n-k))
&nbsp;&nbsp;&nbsp;&nbsp;}</programlisting>
        </section>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>More object-oriented features<phrase
    id="sec:oo-features"></phrase></title>

    <section>
      <title>Classes, properties and methods</title>

      <section>
        <title>Classes</title>

        <para>As introduced in the "Hello world" example (see section <link
        linkend="section_first_program">1.2</link>), Kermeta is an
        object-oriented language and operations are part of classes. Kermeta
        provides all MOF concepts like properties, attributes, package.</para>

        <para>Classes and abstract classes can be defined in a Java-like way.
        Class definition must be placed into brackets as it is in the
        following example.</para>

        <programlisting><emphasis>// an empty simple class</emphasis>
<emphasis role="strong">class</emphasis> myFirstClass 
{

}

<emphasis>// a simple abstract class</emphasis>
<emphasis role="strong">abstract</emphasis> <emphasis role="strong">class</emphasis> MyAbstractClass
{

}</programlisting>

        <para>Additionally, for better code robustness, and more user-friendly
        programming, classes can use the genericity mechanisms.</para>

        <programlisting><emphasis>// This is a parametric class</emphasis>
<emphasis role="strong">class</emphasis> A&lt;G&gt; {
}

<emphasis>// This is the type variable binding : G is binded with Integer</emphasis>
<emphasis role="strong">var</emphasis> a : A&lt;Integer&gt;
a := A&lt;Integer&gt;.new
</programlisting>
      </section>

      <section>
        <title>Properties<phrase id="sec:properties"></phrase></title>

        <para>A property can be expressed in three ways : as a reference, an
        attribute, or a derived property. In Kermeta, each kind of these
        properties has a dedicated syntax, which is <emphasis
        role="strong">attribute </emphasis>(for attribute), <emphasis
        role="strong">reference</emphasis> (for reference), <emphasis
        role="strong">property</emphasis> (for derived property)</para>

        <para role="lineBreak">References and attributes can have <emphasis
        role="strong">opposite</emphasis> properties. This last concept is
        explained in the following subsection.</para>

        <para>Unlike UML, there is no concept of visibility in kermeta, so
        every property is visible</para>

        <section>
          <title>Attributes <emphasis>(attribute)</emphasis>, references
          <emphasis>(reference)</emphasis> <phrase
          id="sec:properties-opposite"></phrase></title>

          <para>We introduce here the 2 first cases, which are relationships
          between two concrete entities.</para>

          <orderedlist continuation="restarts">
            <listitem>
              <para><emphasis>attribute</emphasis>: an attribute defines a
              <emphasis>composition </emphasis>(e.g the black diamond) between
              two entities. The diamond-ed association end is navigable by
              definition</para>
            </listitem>
          </orderedlist>

          <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
              role="strong">attribute</emphasis> x : <emphasis role="strong">set</emphasis> X[0..*] } 
<emphasis role="strong">class</emphasis> X {}</programlisting>

          <note>
            NOTE : a bi-composition is not valid in MOF. So, only one entity can be the component of the other.
          </note>

          <orderedlist continuation="restarts">
            <listitem>
              <para><emphasis>reference</emphasis>: a reference defines an
              association between two entities.</para>
            </listitem>
          </orderedlist>

          <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
              role="strong">reference</emphasis> x : set X[0..*] } 
<emphasis role="strong">class</emphasis> X {}</programlisting>
        </section>

        <section>
          <title>opposite properties i.e associations (#)<phrase
          id="sec:opposite"></phrase></title>

          <para>The opposite [property] of a property defines an association
          (bidirectional link) between two entities. An opposite is expressed
          by a sharp #. In the following example, <literal>a</literal> is the
          opposite property of the entity of type B, and <literal>b</literal>
          is mutually the opposite property of the entity of type A.</para>

          <caution>
            A property whose type is a DataType (i.e String, Boolean, Integer) cannot have an opposite!
          </caution>

          <para><emphasis role="strong">Example 1</emphasis>: definition of an
          attribute, a reference, and an opposite property</para>

          <orderedlist continuation="restarts"></orderedlist>

          <para>This means that a can be accessed from b. Subsequently, if you
          modify the property b of an instance of A, it will mutually update
          its opposite property, i.e the property a of the instance of B
          contained in property b. You can make a test with the following
          example of code.</para>

          <para><emphasis role="strong">Example 2</emphasis>: navigability of
          opposite properties</para>

          <programlisting><emphasis role="strong">var</emphasis> a1 : A <emphasis
              role="strong">init</emphasis> A.new</programlisting>

          <programlisting>a1.name := "a1"</programlisting>

          <programlisting><emphasis role="strong">var</emphasis> b1 : B <emphasis
              role="strong">init</emphasis> C.new</programlisting>

          <programlisting>a1.b := b1</programlisting>

          <programlisting>stdio.writeln("b1 opposite : " + b1.a.name) <emphasis>// This prints "a1"!</emphasis></programlisting>

          <para>The following paragraph shows a set of examples of attributes
          and references.</para>

          <figure id="refIllustration5">
            <title>Attributes and references</title>

            <mediaobject>
              <imageobject>
                <imagedata 
                           fileref="KerMeta-Manual_figures/properties.png"
                            />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis role="strong">Example 3</emphasis>: a set of
          attributes and references, with multiplicities and opposites.</para>

          <programlisting><emphasis role="strong">package</emphasis> root;

<emphasis role="strong">class</emphasis> A {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> b : B[0..*] 
}
<emphasis role="strong">class</emphasis> B {}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A2 {}
<emphasis role="strong">class</emphasis> B2 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A2 
}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A3 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> b : B3#a
}
<emphasis role="strong">class</emphasis> B3 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A3#b
}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A4 {}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A5 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> b : B5#a
}
<emphasis role="strong">class</emphasis> B5 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A5[1..1]#b
}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A6 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> b : B6[0..*]#a
}
<emphasis role="strong">class</emphasis> B6 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A6#b 
}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A7 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> b : B7#a 
}
<emphasis role="strong">class</emphasis> B7 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A7[0..*]#b
}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A8 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> b : B8[1..1]#a
}
<emphasis role="strong">class</emphasis> B8 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A8#b
}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A9 {}
<emphasis role="strong">class</emphasis> B9 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A9[1..1]
}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> A4bis {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a4bis : A4bis#a4bis
}</programlisting>

          <note>
            For every case where the upper bound of a property is upper to 1, the type of the property is 

            <literal>OrderedSet</literal>

            . The reader will refer to the Language basics chapter 

            <link linkend="sec:collections">2.2.3</link>

            , p.

            <link linkend="sec:collections">20</link>

             (except the bag type) to have the available types for a [m..n](n&gt;1) multiplicity property.
          </note>
        </section>

        <section>
          <title>Derived properties <emphasis>(property)</emphasis></title>

          <para>In a class definition, a derived property is a property that
          is derived or calculated, i.e it contains a body, like operations.
          Usually, such properties are calculated from other properties
          available from its owning class definition. In practice, you can
          define the code that you want inside a derived property.</para>

          <para>In other words it does not reference to a concrete entity: it
          is calculated, through the accessor operations getter and
          setter.</para>

          <para>Let's take the following class definitions :</para>

          <programlisting><emphasis>// readonly property : it has no setter</emphasis>
<emphasis role="strong">class</emphasis> A 
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> length : Integer
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> width : Integer
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">property</emphasis> <emphasis
              role="strong">readonly</emphasis> surface : Integer <emphasis>// property : keyword for derived property</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">getter</emphasis> <emphasis
              role="strong">is</emphasis> do
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
              role="strong">result</emphasis> := length*width
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}
<emphasis>// modifiable property :</emphasis>
<emphasis role="strong">class</emphasis> B 
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> length : Integer
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> width : Integer
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">property</emphasis> surface : Integer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">getter</emphasis> <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
              role="strong">result</emphasis> := length*width
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">setter</emphasis> <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;period := length*width
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>

          <para>Properties are accessed or modified as classical properties.
          See next subsection for examples.</para>
        </section>

        <section>
          <title>How to access and control the properties in Kermeta</title>

          <para><emphasis role="strong">Example 1</emphasis>: let's take the
          example with A6 and B6 :</para>

          <programlisting><emphasis role="strong">class</emphasis> A6 {
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> b : B6[0..*]#a
}

<emphasis role="strong">class</emphasis> B6 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A6#b 
}</programlisting>

          <informaltable>
            <tgroup cols="2">
              <colspec colname="c1" colwidth="1.5inch" />

              <colspec colname="c2" colwidth="5.2inch" />

              <thead>
                <row>
                  <entry><?border-top 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <para>Access</para></entry>

                  <entry><?border 0.0007inch solid #000000?> <para>Kermeta
                  expression</para></entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Get the
                  attribute of an instance</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis role="strong">var</emphasis> a6 : A6 <emphasis
                        role="strong">init</emphasis> A6.new
<emphasis role="strong">var</emphasis> b6 : OrderedSet&lt;B6&gt;
<emphasis>// get the b attribute</emphasis>
b6 := a6.b</programlisting></entry>
                </row>

                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Add an
                  element to a property with multiplicity [m..n],
                  n&gt;1</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis role="strong">var</emphasis> a6 : A6 init A6.new
<emphasis role="strong">var</emphasis> b6 : B6 init B6.new
<emphasis>// add b6 to the attribute b of A.</emphasis> 
<emphasis>// </emphasis><emphasis>Note : you don’t have to initialize b! done through A6.new</emphasis>
a6.b.add(b6)</programlisting></entry>
                </row>

                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Remove an
                  element from a property</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis>// OrderedSet owns a method that removes an element given its// index in the set. For unordered sets, use "remove" method</emphasis>
a6.b.removeAt(0)
<emphasis>// Also valid : a6.b.remove(b6)</emphasis></programlisting></entry>
                </row>

                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Get the
                  opposite of a property</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis role="strong">var</emphasis> a6 : A6 init A6.new
<emphasis role="strong">var</emphasis> b6 : B6 init B6.new
a6.b.add(b6)
<emphasis>// this assertion is true. Moreover, any instance in a6.b will// have a6 as their opposite since b is a collection</emphasis>
assert(b6.a == a6)</programlisting></entry>
                </row>

                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Get the
                  container of a property</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis role="strong">var</emphasis> a6 : A6 <emphasis
                        role="strong">init</emphasis> A6.new
<emphasis role="strong">var</emphasis> b6 : B6 <emphasis role="strong">init</emphasis> B6.new
<emphasis>// add ab6 to the attribute "b"</emphasis>
a6.b.add(b6)</programlisting> <programlisting><emphasis role="strong">var</emphasis> a6c : A6 <emphasis
                        role="strong">init</emphasis> b6.container()
<emphasis>// this assertion is true</emphasis>
assert(a6c.equals(a6))</programlisting></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>It is not different with references that have a [m..1] (m=0 or
          m=1) multiplicity:</para>

          <para><emphasis role="strong">Example 2</emphasis>: the A5 B5
          case</para>

          <programlisting><emphasis role="strong">class</emphasis> A5 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> b : B5#a <emphasis>// no multiplicity means [0..1]</emphasis>
}
<emphasis role="strong">class</emphasis> B5 {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> a : A5[1..1]#b
}</programlisting>

          <informaltable>
            <tgroup cols="2">
              <colspec colname="c1" colwidth="1.5inch" />

              <colspec colname="c2" colwidth="5.2inch" />

              <thead>
                <row>
                  <entry><?border-top 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <para>Access</para></entry>

                  <entry><?border 0.0007inch solid #000000?> <para>Kermeta
                  expression</para></entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Get the
                  attribute of an instance</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis role="strong">var</emphasis> a5 : A5 <emphasis
                        role="strong">init</emphasis> A5.new
<emphasis role="strong">var</emphasis> b5 : B5
<emphasis>// get the b attribute</emphasis>
b5 := a5.b</programlisting></entry>
                </row>

                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Set a
                  property (with multiplicity [m..1], m≤1)</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis role="strong">var</emphasis> a5 : A5 init A5.new
<emphasis role="strong">var</emphasis> b5 : B5 init B5.new
<emphasis>// set b5 to the attribute b of A.</emphasis>
a5.b := b5</programlisting></entry>
                </row>

                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Unset a
                  property</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting>a5.b := void</programlisting></entry>
                </row>

                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Get the
                  opposite of a property</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis role="strong">var</emphasis> a5 : A5 init A5.new
<emphasis role="strong">var</emphasis> b5 : B5 init B5.new
a5.b := b5
<emphasis>// this assertion is true.</emphasis>
assert(b5.a == a5)</programlisting></entry>
                </row>

                <row>
                  <entry><?border-bottom 0.0007inch solid #000000?>
                  <?border-left 0.0007inch solid #000000?> <para>Get the
                  container of a property</para></entry>

                  <entry><?border-right 0.0007inch solid #000000?>
                  <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
                  <programlisting><emphasis role="strong">var</emphasis> a5 : A5 <emphasis
                        role="strong">init</emphasis> A5.new
<emphasis role="strong">var</emphasis> b5 : B5 <emphasis role="strong">init</emphasis> B5.new
<emphasis>// add b5 to the attribute "b"</emphasis>
a5.b := b5</programlisting> <programlisting><emphasis role="strong">var</emphasis> a5c : A5 <emphasis
                        role="strong">init</emphasis> b5.container()
<emphasis>// this assertion is true</emphasis>
assert(a5c.equals(a5))</programlisting></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>

        <section>
          <title>Assignment behavior for attribute (and reference)</title>

          <para>Attribute and reference have one main behavior
          difference.</para>

          <para>Attribute has a notion of containment that reference
          hasn't.</para>

          <para>This has some implication on the behavior of the assignment
          because an attribute cannot be owned by more than one object at a
          time.</para>

          <para>There is an exception for attributes which type is a primitive
          type (String, Integer, Boolean) : since those types or particular
          (they are not concerned by the composition, opposite concepts!), the
          assignment does not impact any value but the assigned one.</para>

          <para><emphasis role="strong">Example 1</emphasis>: Assignment
          behavior for attribute</para>

          <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
              role="strong">attribute</emphasis> c1 : C }
<emphasis role="strong">class</emphasis> B { <emphasis role="strong">attribute</emphasis> c2 : C }
<emphasis role="strong">class</emphasis> C { }
aA.c1 := C.new
aB.c2 := aA.c1 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// now aA.c1 == void !!!</emphasis></programlisting>

          <para><emphasis role="strong">Example 2</emphasis>: Assignment
          behavior for reference</para>

          <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
              role="strong">reference</emphasis> c1 : C }
<emphasis role="strong">class</emphasis> B {<emphasis role="strong"> reference</emphasis> c2 : C }
<emphasis role="strong">class</emphasis> C { }

aA.c1 := C.new
aB.c2 := aA.c1 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// aB.c2 == aA.c1 and aA.c1 keeps its value !!!</emphasis></programlisting>

          <para><emphasis role="strong">Example 3</emphasis>: Assignment
          behavior for attribute which type is String</para>

          <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
              role="strong">reference</emphasis> c1 : String }<emphasis
              role="strong">class</emphasis> B {<emphasis role="strong"> reference</emphasis> c2 : String }aA.c1 := "Robert"aB.c2 := aA.c1 // aB.c2 == aA.c1 == "Robert"</programlisting>

          <note>
            The assignment into a 

            <literal>variable</literal>

             or a 

            <literal>reference</literal>

             is not a problem because it doesn't change the owner of the assigned object.
          </note>
        </section>

        <section>
          <title>Cloning objects</title>

          <para>As we saw in previous sections, properties can be defined as
          attribute or reference. An attribute cannot be shared between two or
          more objects whereas a reference can be. Let's consider a class
          "<literal>Family</literal>" with a property
          "<literal>father</literal>" (of type "<literal>Person</literal>")
          defined as an attribute. In the following example, we defined two
          objects of type <literal>Family</literal> and we want to define the
          <literal>father</literal> attribute of the second with the
          <literal>father</literal> of the first. To do that, we need to clone
          the object Person which represents the father of
          "<literal>family1</literal>" because, as said in above subsection,
          it could not be shared between the two objects, by definition of
          attribute (in "technical" words, 2 containers cannot contain the
          same object).</para>

          <programlisting><emphasis role="strong">class</emphasis> Person 
{
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> name : String
}</programlisting>

          <programlisting><emphasis role="strong">class</emphasis> Family
{
 &nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> father : Person
}

<emphasis role="strong">class</emphasis> Main
{
 &nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> run() <emphasis
              role="strong">is</emphasis>
 &nbsp;&nbsp;&nbsp;<emphasis role="strong">do var</emphasis> family1 : Family <emphasis
              role="strong">init</emphasis> Family.new
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> p1 : Person <emphasis
              role="strong">init</emphasis> Person.new
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p1.name := "Robert"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;family1.father := p1
 <emphasis role="strong">var</emphasis> family2 : Family <emphasis
              role="strong">init</emphasis> Family.new

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// ERROR 1 : this assigns p1 to family2.father, which // is already owned by family1.father, so it unsets family1.father // family2.father := p1</emphasis>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// ERROR 2 : this assigns family1.father's value to family2.father, // , so it unsets family1.father // family2.father := family1.father</emphasis>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// This is correct! family2.father keeps its value</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;family2.father := Person.clone(p1)
 &nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>

          <para>The "<literal>clone</literal>" method creates a copy of the
          object that it receives as input. If it is a complex object, a deep
          clone is performed for each attribute of its meta-class and a
          shallow clone is performed for each reference.</para>

          <caution>
            Reminder : be very careful with the use of the assignment operator on object. Most of the time, you need to use the "clone" feature. Using assignment on attributes break the previous link between objects. So, In the previous example, p1 has no more name after the assignment !There is one exception to this behavior : when the type of attributes are DataType, i.e, in Kermeta, String, Integer, Boolean, the assignment behaves as if those entities were defined as references.
          </caution>
        </section>

        <section>
          <title>Objects comparison</title>

          <para>Kermeta users could be confused about <emphasis>==</emphasis>
          operator and <emphasis>equals</emphasis> method. These are two ways
          to compare objects. In Kermeta we kept the Java semantic. The
          operator <emphasis>==</emphasis> is used as identity comparison and
          <emphasis>equals</emphasis> method is used for contents
          comparison.</para>

          <section>
            <title>isSameAs method</title>

            <para>We said in introduction that the operator
            <emphasis>==</emphasis> is mapped to <emphasis>isSameAs</emphasis>
            method. This method compares two references. If they are the same,
            <emphasis>isSameAs</emphasis> returns true (false otherwise).
            Then, both pieces of code below behaves EXACTLY the same.</para>

            <programlisting>// assuming class A has been declared
var a1 : A init A.new
var a2 : A init A.new
assert ( not a1.isSameAs(a2) )

var a3 : A init A.new 
var a4 : A init a3
assert ( a1.isSameAs(a2) )</programlisting>

            <programlisting>// assuming class A has been declared
var a1 : A init A.new
var a2 : A init A.new
assert ( not a1 == a2 )

var a3 : A init A.new
var a4 : A init a3
assert ( a1 == a2 )</programlisting>
          </section>

          <section>
            <title>equals method</title>

            <para>The <emphasis>equals</emphasis> method behaves the same way
            as in java. This means that if you want to compare the contents of
            two objects of the same class, you MUST rewrite the
            <emphasis>equals</emphasis> method. Look at the example (it
            results in printing "a1 does not equal a2" and 'a1 equals a2")
            :</para>

            <programlisting>@mainClass "root::NewPrimitiveType"
@mainOperation "main"

package root;

require kermeta

using kermeta::standard

class A {

  reference x : Integer

  method equals(compared : Object) : Boolean is do
    var castedCompared : A
    castedCompared ?= compared
    result := x.equals (castedCompared.x)
  end

}


class NewPrimitiveType {

  operation main() : Void is do

    var a1 : A init A.new
    var a2 : A init A.new
 
    a1.x := 10
    a2.x := 20

    if ( a1.equals(a2) ) then
      stdio.writeln("a1 equals a2")
    else
      stdio.writeln("a1 does not equal a2")
    end

    a2.x := 10
 
    if ( a1.equals(a2) ) then
      stdio.writeln("a1 equals a2")
    else
      stdio.writeln("a1 does not equal a2")
    end

  end

}</programlisting>
          </section>

          <section>
            <title>Comparison for Primitive Types</title>

            <para>In Kermeta language, there is a notion of primitive type.
            Here is the list of primitive types :</para>

            <itemizedlist>
              <listitem>
                <para>Boolean</para>
              </listitem>
   
              <listitem>
                <para>Integer</para>
              </listitem>

              <listitem>
                <para>String</para>
              </listitem>
            </itemizedlist>

            <para>These classes have a special property. We do not want two
            Integer objects with the same value to be different. What we want
            is to use <emphasis>==</emphasis> operator to compare values of
            primitive types. Then we can write this code :</para>

            <programlisting>var i1 : Integer init 10
var i2 : Integer init 10
assert (i1.isSameAs(i2))

var i3 : Integer init 10
var i4 : Integer init 10
assert (i3 == i4)</programlisting>

            <important>
              <para>All you have to remember is that for primitive types,
              <emphasis>==</emphasis> operator behaves the same as
              <emphasis>equals</emphasis> method</para>
            </important>

            <para>In fact, it is very simple. We just rewrite the
            <emphasis>equals</emphasis> method from
            <emphasis>Object</emphasis> class like this :</para>

            <programlisting>method isSameAs(element : Object) : Boolean is do
  // instead of comparing references, let us compare the values !
  result := self.equals(element)
end</programlisting>
          </section>
        </section>
      </section>

      <section>
        <title>A first concrete example of a Kermeta model</title>

        <para>MOF defines the concept of "Property" which generalizes the
        notions of attributes, and associations (composite or not) that you
        can find in UML. Kermeta syntax also distinguishes these two notions
        as introduced in section <link linkend="sec:properties">3.1.2</link>,
        p.<link linkend="sec:properties">30</link>.</para>

        <para>As a reminder, the <literal>attribute</literal> keyword defines
        a link with containment (a composite association) whereas the
        <literal>reference</literal> keyword just defines an association. As
        you can see, property declarations are very close to variable
        declarations introduced in section <link
        linkend="sec:types-and-variables">2.2</link>, p.<link
        linkend="sec:types-and-variables">19</link>). Each reference may be
        explicitly linked to another reference (it is the
        <literal>opposite</literal> concept in MOF terminology – see also
        section <link linkend="sec:properties-opposite">3.1.2.1</link>,
        p.<link linkend="sec:properties-opposite">31</link>).</para>

        <programlisting><emphasis role="strong">class</emphasis> Library
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> books : set Book[0..*]
}

<emphasis role="strong">class</emphasis> Book
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> title : String
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> subtitle : String

&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> authors : oset Author[1..*]#works
}


<emphasis role="strong">class</emphasis> Author
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> name : String
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> lastName : String
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> works : set Books[0..*]#authors
}</programlisting>

        <para>If we represent our Kermeta model in a graphical syntax we
        obtain the following diagram (<link
        linkend="refIllustration6">Illustration 7A concrete example : a
        library</link>).</para>

        <figure id="refIllustration6">
          <title>A concrete example : a library</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/library.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>
    </section>

    <section>
      <title>Inheritance</title>

      <section>
        <title>Using simple inheritance<phrase
        id="set:simple-inheritance"></phrase></title>

        <programlisting><emphasis role="strong">abstract</emphasis> <emphasis
            role="strong">class</emphasis> Person
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> name : string
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> lastName : string

&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> father : Male#children 
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> mother : Female#children
}

<emphasis role="strong">class</emphasis> Male <emphasis role="strong">inherits</emphasis> Person
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> children : oset Person[0..*]#father
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> wife : Female[0..1]#husband
}

class Female <emphasis role="strong">inherits</emphasis> Person
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> children : oset Person[0..*]#mother
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> husband : Male[0..1]#wife
}</programlisting>

        <para>In this example, we define a simple model which represent
        simples family trees. Here, persons are defined by their name and last
        name. Each person have a father and mother and respectively might have
        children. The figure representing this example is <link
        linkend="refIllustration7">Illustration 8A simple family tree
        model</link></para>

        <figure id="refIllustration7">
          <title>A simple family tree model</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/person.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>

      <section>
        <title>Using multiple inheritance</title>

        <programlisting><emphasis role="strong">class</emphasis> Parent
{
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> children : oset Child[0..*]#parent
}

<emphasis role="strong">class</emphasis> Child
{
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> parent : Parent#children</programlisting>

        <programlisting>}

<emphasis role="strong">class</emphasis> Male { }

<emphasis role="strong">class</emphasis> GrandFather <emphasis role="strong">inherits</emphasis> Parent, Male
{
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">boolean</emphasis> healthy : Boolean
}</programlisting>

        <para>The above example defines a class "GrandFather" that inherits at
        the same time the class "Parent", and the class "Male". Its graphical
        representation is shown in below figure.</para>

        <figure id="refIllustration8">
          <title>: multiple inheritance</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/KMM_multiple_inheritance.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>

      <section>
        <title>Overriding behavior with methods</title>

        <para>In the following sample, when an operation is declared for the
        first time (in the parent class Person), it uses the
        <literal>operation</literal> keyword. Then, whenever you override it,
        you will have to use the <literal>method</literal> keyword.</para>

        <note>
          In the sample,Person and adopt are abstract, but this has no influence on the operation-method keywords rule, it would have been the same even if Person was not abstract or if adopt had a behavior in this class.
        </note>

        <programlisting><emphasis role="strong">abstract class</emphasis> Person
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> name : String
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> father : Male#children 
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> mother : Female#children
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> adopt(child : Person) <emphasis
            role="strong">is</emphasis> <emphasis role="strong">abstract</emphasis>}</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> Male <emphasis
            role="strong">inherits</emphasis> Person 
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> wife : Female#husband
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> children : oset Person[0..*]#father<emphasis></emphasis>&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">method</emphasis> adopt(child : Person) <emphasis
            role="strong">is</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">do</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children.add(child)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">if</emphasis> <emphasis
            role="strong">not</emphasis> wife.children.contains(child) <emphasis
            role="strong">then</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.father := <emphasis
            role="strong">self</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wife.adopt(child)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">end</emphasis>}</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> Female <emphasis
            role="strong">inherits</emphasis> Person
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> husband : Male#wife
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">reference</emphasis> children : oset Person[0..*]#mother<emphasis></emphasis>&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">method</emphasis> adopt(child : Person) <emphasis
            role="strong">is</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">do</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children.add(child)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">if</emphasis> <emphasis
            role="strong">not</emphasis> husband.children.contains(child) <emphasis
            role="strong">then</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.mother := <emphasis
            role="strong">self</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;husband.adopt(child)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>&nbsp;&nbsp;&nbsp;&nbsp;<emphasis
            role="strong">end</emphasis>}</programlisting>
      </section>
    </section>

    <section>
      <title>Packages</title>

      <para>Kermeta provides package to structure models. So you can define
      packages and sub-package as deep as you want. There are two main ways to
      do this, as shown in examples 2 and 3 (below). If you want to define
      some classes in a package you may define them in a specific file and
      start this file with a package naming directive (followed by a
      semi-colon) like in the following example<footnote id="ftn1">
          <para>Each kermeta file(.kmt) must be declared a package
          directive.</para>
        </footnote>.</para>

      <para><emphasis role="strong">Example 1</emphasis>: 1 file.kmt == 1
      package naming directive</para>

      <programlisting><emphasis>// My file</emphasis>
<emphasis role="strong">package</emphasis> MyNewPackage;

<emphasis role="strong">class</emphasis> A { 
<emphasis>// ...</emphasis> 
}</programlisting>

      <programlisting>
<emphasis role="strong">class</emphasis> B {
<emphasis>// ...</emphasis> 
}</programlisting>

      <para>Here, classes A and B are defined in a package called
      "MyNewPackage". All classes defined in this file are under the scope of
      this package.</para>

      <para>You can also define explicitly sub-packages using braces (see the
      following example):</para>

      <para role="lineBreak"><emphasis role="strong">Example 2</emphasis>:
      Defining subpackages using braces</para>

      <programlisting><emphasis>// file : MyPackage-part1.kmt</emphasis>
<emphasis role="strong">package</emphasis> MyPackage;

<emphasis role="strong">package</emphasis> subPackage1 
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">class</emphasis> A 
&nbsp;&nbsp;&nbsp;&nbsp;{
<emphasis>// ...</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;}
}

<emphasis role="strong">package</emphasis> subPackage2
{
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">class</emphasis> B
&nbsp;&nbsp;&nbsp;&nbsp;{
<emphasis>// ...</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;}
}</programlisting>

      <para>In this example, we define a main package called "MyPackage" which
      contains 2 sub-packages "subPackage1" and "subPackage2". The first one
      contains the A class and the second one the B class.</para>

      <para>If you want, you can declare the same package in several files.
      You can also directly define subpackages in the package naming directive
      of your file (see example 1 above). In the following example, we define
      a new sub-package of "MyPackage" called "subPackage3" directly in the
      file. All features defined in this file will belong to this
      sub-package.</para>

      <para><emphasis role="strong">Example 3</emphasis>: Defining subpackage
      using <literal>::</literal> syntactic sugar</para>

      <programlisting><emphasis>// file : subPackage3.kmt</emphasis>
<emphasis role="strong">package</emphasis> MyPackage::subPackage3;

<emphasis role="strong">class</emphasis> C 
{
<emphasis>// ...</emphasis>
}</programlisting>
    </section>

    <section>
      <title>File dependency</title>

      <section>
        <title>Require</title>

        <para>When you need to refer explicitly another entity defined in
        another file, you have to use the <literal>require</literal>
        primitive. It allows loading definitions of an other Kermeta file when
        file is processed. In the following example, we define a class C which
        inherits from the A class previously defined.</para>

        <programlisting><emphasis>// file : MyPackage-part2.kmt</emphasis>
<emphasis role="strong">package</emphasis> MyPackage;
</programlisting>

        <programlisting><emphasis role="strong">require</emphasis> "MyPackage-part1.kmt"</programlisting>

        <programlisting>
<emphasis role="strong">class</emphasis> C <emphasis role="strong">inherits</emphasis> subPackage1::A 
{
<emphasis></emphasis><emphasis>// ...</emphasis>
}</programlisting>
      </section>

      <section>
        <title>Using<phrase id="section_using"></phrase></title>

        <para>If a given file, when you want to use a class definition that is
        not in the scope of the current package inside which you are working,
        you have to provide the full path of this class definition to be able
        to use it. However, you can also define shortcuts to make your code
        clearer: the <literal>using</literal> primitive provides such a
        shortcut. Taking the previous example, it becomes:</para>

        <programlisting><emphasis>// file : MyPackage-part2.kmt</emphasis>
<emphasis role="strong">package</emphasis> MyPackage;

<emphasis role="strong">require</emphasis> "MyPackage-part1.kmt"

<emphasis role="strong">using</emphasis> subPackage1 <emphasis>// &lt;- "shortcut"!</emphasis> 

<emphasis role="strong">class</emphasis> C <emphasis role="strong">inherits</emphasis> A 
{
<emphasis></emphasis><emphasis>// ...</emphasis>
}</programlisting>

        <para>The using statement is a syntactical shorcut, it has no
        conterpart in kermeta metamodel.</para>

        <note>
          The using statement is different from the definition of a local datatype with an alias. (See section 

          <link linkend="section_alias">2.2.4</link>

          )
        </note>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Advanced features</title>

    <para>Here is a presentation of some of the additional features that
    Kermeta provides.</para>

    <para>For many use cases, the Kermeta framework will help you in your
    tasks.</para>

    <para>Additional information are also provided directly within the
    framework itself.</para>

    <section>
      <title>Dynamic evaluation of Kermeta expressions</title>

      <para><phrase id="dynamic_expression"></phrase>Kermeta allow you to
      evaluate dynamically a Kermeta Expression with a specific
      context.</para>

      <para><emphasis role="strong">Example 1</emphasis>: my first dynamic
      expression</para>

      <programlisting><emphasis role="strong">var</emphasis> de : DynamicExpression <emphasis
          role="strong">init</emphasis> DynamicExpression.new
de.initializeDefaults
de.formalParameters.put(<emphasis>"a"</emphasis>, String)
de.parse(<emphasis>"stdio.writeln(a)"</emphasis>)
<emphasis role="strong">var</emphasis> params : Hashtable&lt;String, Object&gt; <emphasis
          role="strong">init</emphasis> Hashtable&lt;String, Object&gt;.new
params.put(<emphasis>"a"</emphasis>, <emphasis>"hello world!"</emphasis>)
de.execute(void, params)</programlisting>

      <para>If you want to dynamically evaluate more than one statement, you
      will have to surround your set of statements with "do.. end"
      block:</para>

      <para role="lineBreak"><emphasis role="strong">Example 2</emphasis>: yet
      another example</para>

      <programlisting><emphasis>// let's get previous example and modify it </emphasis><emphasis></emphasis><emphasis>// [...] (carriage return is not necessary inside the block)</emphasis>
de.parse(<emphasis>"do stdio.writeln(a) stdio.writeln("another stdio writeln ... ") end"</emphasis>)
<emphasis>// [...]</emphasis></programlisting>

      <para><emphasis role="strong">Example 3</emphasis>: another more complex
      sample of dynamic expressions :</para>

      <programlisting><emphasis role="strong">package</emphasis> testDynamicExpression;

<emphasis role="strong">using</emphasis> kermeta::interpreter
<emphasis role="strong">using</emphasis> kermeta::utils
<emphasis role="strong">using</emphasis> kermeta::standard

<emphasis role="strong">class</emphasis> TestMain
{

 &nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> TestToto() <emphasis
          role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdio.writeln("J'ai essayé de lancer testtoto!")
 &nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

 &nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> testDynExp() <emphasis
          role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> dynExpr : DynamicExpression <emphasis
          role="strong">init</emphasis> DynamicExpression.new
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dynExpr.initializeDefaults()

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">self</emphasis>.getMetaClass.ownedOperation.select{op| <emphasis
          role="strong">not</emphasis>( op.name.indexOf("Test")==-1)
and op.name.indexOf("All")==-1}

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect{op|op.name}.each{opName|

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdio.writeln("execution de "+opName)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dynExpr.initializeDefaults
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dynExpr.parse("testDynamicExpression ::TestMain.new." +opName)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dynExpr.execute(void,Hashtable&lt;String,Object&gt;.new)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 &nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>

      <caution>
        You cannot use "self" inside a dynamic expression
      </caution>
    </section>

    <section>
      <title>How to load an EMF model in Kermeta</title>

      <para><phrase id="Loading_Models_with_kermeta"></phrase>This section
      explains how to load an EMF model in Kermeta. For this purpose, we will
      use the following small example :</para>

      <figure id="refIllustration9">
        <title>cs.ecore sample metamodel</title>

        <mediaobject>
          <imageobject>
            <imagedata 
                       fileref="KerMeta-Manual_figures/cs_ecore.gif"
                        />
          </imageobject>
        </mediaobject>
      </figure>

      <note>
        Loading and saving model has it own tutorial. It provides more information in a step by step approach. See the EMF tutorial at 

        <ulink type=""
        url="http://www.kermeta.org/documents/emfTutorial/">http://www.kermeta.org/documents/emfTutorial/</ulink>

         
      </note>

      <section>
        <title>Prepare a model</title>

        <para>The user will refer to eclipse documentation for the creation of
        an EMF model from its ECore meta-model. We suggest to use the Wizard
        samples to create, at the first hand, an ECore meta-model, and then,
        at the second hand, instances of this ECore meta-model, using the
        generated EMF reflexive editors.</para>

        <para>Once you created the ECore meta-model, please check that you
        correctly filled the property "<literal>Ns URI"</literal> of the root
        package of the Ecore meta-model, otherwise the resource load will
        fail. This NsURI must equal the real path of your metamodel. (You can
        modify this property through the Properties View of your
        meta-model)</para>
      </section>

      <section>
        <title>Load a model from an EMF Resource</title>

        <para>In the current version of the EMF resource loader, you have to
        prepare your EMF Resource following these rules :</para>

        <orderedlist continuation="restarts">
          <listitem>
            <para>At the top of the source code where you will access your
            model, don't forget to add <literal>require "your_metamodel.ecore"
            </literal>so that you can access your metamodel in Kermeta.</para>

            <para>Alternatively, you can use the Kermeta version of your
            metamodel using</para>

            <para>require "your_metamodel.kmt" or require
            "your_metamodel.km".</para>

            <para role="lineBreak">In this case, be careful that your kmt
            required metamodel is strictly equivalent to the ecore version of
            your metamodel that is used in createResource method.</para>
          </listitem>

          <listitem>
            <para>Then, create a repository and the resource that will contain
            the model instance that you want to load. In the following code
            example, <literal>uri</literal> stands for the uri (as relative or
            absolute path<footnote id="ftn2">
                <para>in the latter case, don't forget to put the protocol,
                i.e. platform:/, <ulink type="" url="//./">file:/,
                etc.</ulink></para>
              </footnote>) of the model instance, and
            <literal>mm_uri</literal> is the uri of the meta-model of the
            model instance.</para>
          </listitem>
        </orderedlist>

        <programlisting><emphasis role="strong">@mainClass</emphasis> "root::TestCSLoading"

<emphasis role="strong">@mainOperation</emphasis> "main"


<emphasis role="strong">package</emphasis> root;
<emphasis role="strong">require</emphasis> kermeta
<emphasis role="strong">require</emphasis> "cs.ecore"
<emphasis role="strong">using</emphasis> kermeta::standard

<emphasis role="strong">class</emphasis> TestCSLoading

{
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> initialize(uri : String, mm_uri : String) : Set&lt;Object&gt; <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/* Initialize the EMF repository */</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> repository &nbsp;&nbsp;&nbsp;&nbsp;: EMFRepository init EMFRepository.new
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/* Create an EMF Resource */</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> resource : EMFResource 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resource ?= repository.createResource(uri, mm_uri)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/* Load the resource */</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resource.load()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>/* Get the loaded __root__ instances (a Set&lt;Object&gt;) */</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := resource.instances
 &nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis></programlisting>

        <orderedlist continuation="restarts">
          <listitem>
            <para>Once you loaded your EMF resource, you can get its attribute
            <literal>instances</literal>, that contains all the objects that
            you created through your EMF generated reflexive editor. Now you
            can "visit" your instances, provided you "visit" them according to
            their types. In the simplest way, you can make very basic tests to
            display your instances content, as in the following example, which
            visit the objects of resource instances which types are
            <literal>cs::Template</literal> and
            <literal>cs::Decision.</literal></para>
          </listitem>
        </orderedlist>

        <programlisting><emphasis role="strong">operation</emphasis> main() <emphasis
            role="strong">is do</emphasis> <emphasis role="strong">var</emphasis> instances := self.initialize("./test.cs", "./cs.ecore") <emphasis
            role="strong">from var</emphasis> it : Iterator&lt;Object&gt; <emphasis
            role="strong">init</emphasis> instances.iterator <emphasis
            role="strong">until</emphasis> it.isOff <emphasis role="strong">loop</emphasis> <emphasis
            role="strong">var</emphasis> o : Object o := it.next <emphasis
            role="strong">if</emphasis> (o == void) <emphasis role="strong">then</emphasis> stdio.writeln("Void object!") <emphasis
            role="strong">else</emphasis> stdio.writeln("---------------------------------") stdio.writeln("Objet : " + o.getMetaClass.classDefinition.qualifiedName + " ( " +.getMetaClass.typeDefinition.ownedAttribute.size.toString+ "attr.)" ) <emphasis
            role="strong">end</emphasis> <emphasis role="strong">var</emphasis> template : cs::Template <emphasis>// Print instances which type is cs::Template</emphasis> <emphasis
            role="strong">if</emphasis> (cs::Template.isInstance(o)) <emphasis
            role="strong">then</emphasis> template ?= o stdio.writeln(" name : " + template.name) stdio.writeln(" decision : " + template.decision.toString) stdio.writeln(" content : " + template.content) stdio.writeln(" referer : " + template.referer.toString) <emphasis
            role="strong">end</emphasis> <emphasis>// Print instances which type is cs::Decision</emphasis> <emphasis
            role="strong">if</emphasis> (cs::Decision.isInstance(o)) <emphasis
            role="strong">then</emphasis> decision ?= o stdio.writeln(" name : " + decision.name) <emphasis
            role="strong">end</emphasis> <emphasis role="strong">end</emphasis>}</programlisting>
      </section>
    </section>

    <section>
      <title>Using existing java code in Kermeta</title>

      <para>If you have existing code that you want to run in a Kermeta
      program, you can use the extern call mechanism.</para>

      <para>The extern allows you to call a java static method from Kermeta.
      But, to do that, you will have firstly to create a Java wrapper, that
      will be able to manipulate correctly the Java objects, and secondly to
      add this wrapper in your java global classpath.</para>

      <para role="lineBreak">Then, from this method you can access all your
      java libraries. One task of the static method will be to convert the
      basic types like Integer or String.</para>

      <para>You'll need to refer to the Javadoc of the interpreter in order to
      know how to access the internal RuntimeObject of Kermeta.</para>

      <para><emphasis role="strong">Example 1</emphasis>: sample of Kermeta
      code using extern (io.kmt):</para>

      <programlisting><emphasis>/** * An implementation of a StdIO class in Kermeta using existing Java: standard * input/output */</emphasis>
<emphasis role="strong">class</emphasis> StdIO
{
 <emphasis>/**</emphasis> <emphasis>* write the object to standard output</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> write(object : Object) : Void <emphasis
          role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
 <emphasis role="strong">result</emphasis> ?= <emphasis role="strong">extern </emphasis>fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.write(object)
 <emphasis role="strong">end</emphasis>
 
 <emphasis>/**</emphasis> <emphasis>* writeln the object to standard output</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> writeln(object : Object) : Void <emphasis
          role="strong">is do</emphasis>
 <emphasis role="strong">result</emphasis> ?= <emphasis role="strong">extern</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.writeln(object)
 <emphasis role="strong">end</emphasis>
 
 <emphasis>/**</emphasis> <emphasis>* read an object from standard input</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> read(prompt : String) : String <emphasis
          role="strong">is do</emphasis>
 <emphasis role="strong">result</emphasis> ?= <emphasis role="strong">extern</emphasis>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.read(prompt)
 <emphasis role="strong">end</emphasis>

}
</programlisting>

      <para><emphasis role="strong">Example 2</emphasis>: sample of Java code
      ("wrapper") called by the Kermeta extern:</para>

      <programlisting><emphasis>/** Implementation of input and output methods */</emphasis><emphasis
          role="strong">public</emphasis> <emphasis role="strong">class</emphasis> StdIO{ // Implementation of method write called as : // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.write(output) <emphasis
          role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject write(RuntimeObject output) { output.getFactory().getKermetaIOStream() .print(output.getData().get("StringValue")); <emphasis
          role="strong">return</emphasis> output.getFactory().getMemory().voidINSTANCE; } // Implementation of method writeln called as : // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.writeln(output) <emphasis
          role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject writeln(RuntimeObject output) { <emphasis>write</emphasis>(output); output.getFactory().getKermetaIOStream().print("\n"); <emphasis
          role="strong">return</emphasis> output.getFactory().getMemory().voidINSTANCE; } // Implementation of method writeln called as : // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.read(output) <emphasis
          role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject read(RuntimeObject prompt) { java.lang.String input = <emphasis
          role="strong">null</emphasis>; // We also have our own String wrapper <emphasis
          role="strong">if</emphasis> (String.<emphasis>getValue</emphasis>(prompt).length()&gt;0) prompt.getFactory().getKermetaIOStream().print(String.<emphasis>getValue</emphasis>(prompt)); // <emphasis
          role="strong">FIXME</emphasis> : dirty cast.. read returns a String or could return smthg else? input = (java.lang.String)prompt.getFactory().getKermetaIOStream().read( String.<emphasis>getValue</emphasis>(prompt)); RuntimeObject result = String.<emphasis>create</emphasis>(input, prompt.getFactory()); <emphasis
          role="strong">return</emphasis> result; }</programlisting>

      <tip>
        This method is used to implement Kermeta framework. You'll find much more code samples of extern call in its sources.
      </tip>
    </section>

    <section>
      <title>Design by contract (pre, post, inv contraints)</title>

      <para>In Kermeta, a contract is specified by "pre" and "post" conditions
      and by the "invariant" constraint too.</para>

      <section>
        <title>Writing a contract</title>

        <section>
          <title>pre – post conditions syntax</title>

          <para>A pre or a post condition is a boolean expression that may be
          a simple equality checking or a lambda expression. The Kermeta
          interpreter evaluates the body content like a boolean result</para>

          <para>The "pre condition" is declared just after the operation
          signature.</para>

          <para>The "post condition" is declared just after the last "end" of
          the operation body.</para>

          <programlisting><emphasis role="strong">operation</emphasis> opName(c : String) : String <emphasis
              role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// Declaration of the pre-condition</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">pre</emphasis> notVoidInput <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c != <emphasis role="strong">void</emphasis> and c != ""
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operation body
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// Declaration of the post-condition</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">post</emphasis> notVoidOutput <emphasis
              role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> != <emphasis
              role="strong">void</emphasis> and <emphasis role="strong">result</emphasis> != ""</programlisting>

          <tip>
            If the body contains only one expression, the block declaration "do ... end" is not mandatory. If your block contains several instructions, the latest one will be evaluated as a boolean expression.
          </tip>
        </section>

        <section>
          <title>Invariant constraint syntax</title>

          <para>An invariant constraint is declared anywhere in a
          ClassDefinition block.</para>

          <para>An invariant declaration is a boolean expression that may be a
          simple equality checking or a lambda expression. The Kermeta
          interpreter evaluates the body content like a boolean result.</para>

          <para>A very simple example :</para>

          <programlisting><emphasis role="strong">class</emphasis> className {

&nbsp;&nbsp;&nbsp;&nbsp;...

&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">inv</emphasis> nameOfTheInvariant <emphasis
              role="strong">is do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">self</emphasis>.name != ""
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

&nbsp;&nbsp;&nbsp;&nbsp;...
}</programlisting>

          <tip>
            If the body contains only one instruction, the block declaration "do ... end" is not mandatory.
          </tip>

          <programlisting><emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
<emphasis role="strong">inv</emphasis> nameOfTheInvariant <emphasis
              role="strong">is</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">self</emphasis>.name != ""</programlisting>

          <para>The lambda expression into an invariant declaration can be
          used :</para>

          <programlisting><emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
<emphasis role="strong">inv</emphasis> deterministicTransition <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">self</emphasis>.outgoingTransition.forAll{tr1 |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">self</emphasis>.outgoingTransition.forAll{ tr2 |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( tr2.input==tr1.input ) == (tr1==tr2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
<emphasis role="strong">end</emphasis></programlisting>
        </section>
      </section>

      <section>
        <title>Checking your constraints</title>

        <section>
          <title>Checking pre – post condition</title>

          <para>The activation of the checking of the pre - post conditions
          depends of the run configuration, see the Kermeta UI user guide for
          more information.</para>

          <para>If the boolean statement is evaluated to "false" then the pre
          or post condition is violated and an exception
          <literal>ConstraintViolatedPre</literal> or
          <literal>ConstraintViolatedPost</literal> is raised.</para>
        </section>

        <section>
          <title>Checking invariant</title>

          <para>In order to check the well-formedness rules of a model
          element, there are two methods in Kermeta. The first-one :
          <literal>checkInvariants</literal>, consists to check only the
          current model element and the second-one :
          <literal>checkAllInvariants</literal>, checks recursively the
          element being a containment link with the checked element.</para>

          <programlisting>theModelElement.checkInvariants
</programlisting>

          <para>The checkAllInvariants operation is a recursive method which
          checks all the elements having a containment relation by
          transitivity with the checked element.</para>

          <para>checkAllInvariants is used especially to check the validity of
          a model fragment or a complete model.</para>

          <programlisting>theModelElement.checkAllInvariants</programlisting>

          <para>If the boolean statement is evaluated to
          "<literal>false</literal>" then the invariant constraint is violated
          and an exception <literal>ConstraintViolatedInv</literal> is raised.
          This exception can be handled by a <literal>rescue</literal>
          call.</para>

          <programlisting><emphasis>// Call the invariant verification</emphasis>
<emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;theModelElement.checkInvariants
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">rescue</emphasis> (err : ConstraintViolatedInv)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdio.writeln(err.toString)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdio.write(err.message)
<emphasis role="strong">end</emphasis></programlisting>
        </section>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Kermeta Metamodel<phrase
    id="section_kermeta_metamodel"></phrase></title>

    <para>As Kermeta is designed to be used in a model driven environment, its
    structure is given as a model. This section presents the metamodel of
    Kermeta which corresponds to the abstract syntax of Kermeta.</para>

    <para>This metamodel may be useful for many use cases. For example, you
    can use it to manipulate your Kermeta code for analysis or even generate
    some Kermeta code. This may be useful to understand how Kermeta works
    too.</para>

    <note>
      All the code samples in this section are for illustration of the given concepts.
    </note>

    <section>
      <title>Viewing Kermeta metamodel</title>

      <para>In Kermeta, you can view its metamodel by several ways.</para>

      <para>First, the ecore file kermeta_java.ecore is available in the lib
      folder of Kermeta main plugin.It is used when saving a Kermeta program
      in XMI ("Compile to XMI" function on *.kmt files). You can then load
      Kermeta program as a model, typically to transform it.</para>

      <warning>
        You should not try to execute operations on kermeta models you've just dynamically created unless you froze it. This is a feature which has not been completly tested.
      </warning>

      <para>Another typical way to access to a Kermeta model and Kermeta
      metamodel is to use the reflection. All objects inherits from Object
      that defines the <literal>getMetaClass</literal> operation. This use is
      used in one of the samples of section <link
      linkend="dynamic_expression">4.1</link> (when it selects an operation to
      be executed).</para>

      <para>At last, the parse method on dynamic expression presented in
      section <link linkend="dynamic_expression">4.1</link> can give you some
      way to access a Kermeta model as it parses a Kermeta text and provides
      the corresponding model.</para>
    </section>

    <section>
      <title>Structure package</title>

      <figure id="refIllustration10">
        <title>Structure package</title>

        <mediaobject>
          <imageobject>
            <imagedata 
                       fileref="KerMeta-Manual_figures/kermeta_structure_package.png"
                        />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para>This represents the static part of the metamodel.</para>

      <para>As a reminder, the structure of Kermeta is derived from EMOF from
      the OMG. During the build process, we merge and connect it with the
      behavior part.</para>

      <para>So all the meaning of those metaclasses are very close to those
      described in the OMG standard specification.</para>
    </section>

    <section>
      <title>Behavior package</title>

      <figure id="refIllustration11">
        <title>Behavior package</title>

        <mediaobject>
          <imageobject>
            <imagedata 
                       fileref="KerMeta-Manual_figures/kermeta_behavior_package.png"
                        />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <section>
        <title>Control Structures</title>

        <para>Kermeta provides basic control structures : block, conditional
        branch, loop, and exception handling. Here there an excerpt of the
        Meta-model describing control structures. Each basic control
        structures derives from the Expression concept.</para>

        <figure id="refIllustration12">
          <title>Control structure</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/kermeta_control_struct.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>

      <section>
        <title>Variables</title>

        <figure id="refIllustration13">
          <title>Use of variables</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/kermeta_var_expressions.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>

      <section>
        <title>Call Expressions</title>

        <figure id="refIllustration14">
          <title>use of exceptions</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/kermeta_call_expressions.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <section>
          <title>CallSuperOperation</title>

          <para>In the following example, the type of
          <emphasis>super(element)</emphasis> is
          <emphasis>CallSuperOperation</emphasis>:</para>

          <programlisting><emphasis role="strong">class</emphasis> ParentClass {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> op(element : Integer) : Integer <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := element + 1
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>

}

<emphasis role="strong">class</emphasis> ChildClass {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">method</emphasis> op(element : Integer) : Integer <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := <emphasis
              role="strong">super</emphasis>(element)
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>
        </section>

        <section>
          <title>CallVariable</title>

          <para>The type of <emphasis>callvar</emphasis><emphasis
          role="strong">,</emphasis> below, is CallVariable:</para>

          <programlisting><emphasis role="strong">var</emphasis> myvar : Integer
<emphasis role="strong">var</emphasis> callvar : Integer <emphasis
              role="strong">init</emphasis> 4
// 
myvar := callvar </programlisting>

          <para>A special case, when calling a lambda expression : the type of
          <emphasis>lf</emphasis> in the assignment of res, is
          CallVariable.</para>

          <programlisting>
            <emphasis role="strong">var</emphasis>
            <emphasis> lf : &lt;Integer-&gt;Integer&gt;</emphasis>
            <emphasis role="strong">var</emphasis>
            <emphasis> res : Integerlf := </emphasis>
            <emphasis role="strong">function</emphasis>
            <emphasis> { i : Integer | i.plus(1) }</emphasis>
            <emphasis>// The type of </emphasis>
            <emphasis>lf</emphasis>
            <emphasis>, below, is CallVariable</emphasis>
            <emphasis>res := </emphasis>
            <emphasis>lf</emphasis>
            <emphasis>(4)</emphasis>
          </programlisting>
        </section>

        <section>
          <title>CallResult</title>

          <para>The type of <emphasis>result</emphasis> is
          <emphasis>CallResult</emphasis></para>

          <programlisting><emphasis role="strong">operation</emphasis> op() : Integer <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := 61
<emphasis role="strong">end</emphasis></programlisting>
        </section>

        <section>
          <title>CallFeature and SelfExpression</title>

          <orderedlist continuation="restarts">
            <listitem>
              <para>The type of <emphasis>self</emphasis> is a
              SelfExpression!</para>
            </listitem>

            <listitem>
              <para>The type of <emphasis>attr</emphasis> in the body of the
              operation myoperation is
              <emphasis>CallFeature</emphasis><emphasis role="strong">
              </emphasis>(a callfeature on <emphasis>self</emphasis>), and so
              is the type of <emphasis>myoperation(4)</emphasis> (a
              callfeature on <emphasis role="strong">a</emphasis>).</para>
            </listitem>
          </orderedlist>

          <programlisting><emphasis role="strong">class</emphasis> A {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">attribute</emphasis> attr : Integer
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> myoperation(param : Integer) : Integer <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := <emphasis
              role="strong">self</emphasis>.attr + param
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}
<emphasis role="strong">class</emphasis> B {
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">operation</emphasis> anotheroperation() : Integer <emphasis
              role="strong">is do</emphasis>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">var</emphasis> a : A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">result</emphasis> := a.myoperation(4)
&nbsp;&nbsp;&nbsp;&nbsp;<emphasis role="strong">end</emphasis>
}</programlisting>
        </section>
      </section>

      <section>
        <title>Assignment</title>

        <figure id="refIllustration15">
          <title>Kermeta assignment expression</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/kermeta_assign_expressions.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>In the following example, <emphasis>thetarget</emphasis> is of
        type <emphasis>CallExpression </emphasis>and
        <emphasis>thevalue</emphasis> is of type
        <emphasis>Expression</emphasis>.</para>

        <programlisting><emphasis role="strong">var</emphasis> num : Numeric
<emphasis role="strong">var</emphasis> thetarget : Integer
<emphasis role="strong">var</emphasis> thevalue : Integer
// assignment : <emphasis role="strong">thetarget-&gt;</emphasis><emphasis>target</emphasis>, <emphasis
            role="strong">thevalue-&gt;</emphasis><emphasis>value</emphasis>
thetarget := thevalue
// casting : <emphasis role="strong">a</emphasis> is casted into the type of <emphasis
            role="strong">num</emphasis> which is Numeric.
num ?= a</programlisting>
      </section>

      <section>
        <title>Literals</title>

        <figure id="refIllustration16">
          <title>Kermeta Literal Expression</title>

          <mediaobject></mediaobject>
        </figure>

        <para></para>

        <programlisting><emphasis role="strong">var</emphasis> i : Integer
i := 5&nbsp;&nbsp;&nbsp;&nbsp;<emphasis>// 5 is a IntegerLiteral</emphasis>
<emphasis role="strong">var</emphasis> s : String 
s := "I am a string" <emphasis>// "I am a string" is a StringLiteral</emphasis></programlisting>
      </section>

      <section>
        <title>Lambda Expression<phrase
        id="section_lambda_expression_mm"></phrase></title>

        <figure id="refIllustration17">
          <title>Kermeta lambda expressions</title>

          <mediaobject>
            <imageobject>
              <imagedata 
                         fileref="KerMeta-Manual_figures/kermeta_lambda_expressions.png"
                          />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Kermeta framework</title>

    <para>Kermeta is bundled with a framework that provides the base
    functionalities for metamodel engineering.</para>

    <tip>
      When you write 

      <literal>require kermeta</literal>

       at the head of your file, you are importing the file framework.km located in the Kermeta plugin.
    </tip>

    <para>Currently, it provides the following packages :</para>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis role="strong">kermeta::interpreter</emphasis></para>

        <para role="lineBreak">This package defines some classes related to
        Kermeta interpreter and also to Kermeta surface syntax. Some uses of
        this package are illustrated in section <link
        linkend="dynamic_expression">4.1</link>.</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis role="strong">kermeta::persistence</emphasis></para>

        <para role="lineBreak">This package defines the notion required to
        serialize and deserialize models. This is illustrated in section <link
        linkend="Loading_Models_with_kermeta">4.2</link> and in the EMF
        tutorial document ( <ulink type=""
        url="http://www.kermeta.org/documents/emfTutorial/">http://www.kermeta.org/documents/emfTutorial/</ulink>
        )</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis role="strong">kermeta::kunit</emphasis></para>

        <para role="lineBreak">This is a basic support for unitary tests (like
        Junit but for Kermeta).</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis
        role="strong">kermeta::language::structure</emphasis></para>

        <para role="lineBreak">It contains the classes of Kermeta structure.
        Note that it slightly differs from the kermeta_java.ecore due to an
        inheritance to the classes in Kermeta::reflexion. However, it proposes
        the very same functionalities.</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis
        role="strong">kermeta::language::behavior</emphasis></para>

        <para role="lineBreak">It contains the classes for the behavior of
        Kermeta.</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis role="strong">kermeta::exceptions</emphasis></para>

        <para role="lineBreak">It defines various exceptions that you can use
        in Kermeta. Inheriting from kermeta::exceptions::Exception allows to
        give more information to the end user because it will also provide a
        stack trace (which would not be available otherwise).</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis role="strong">kermeta::io</emphasis></para>

        <para role="lineBreak">This package provides basic support for
        input/output with Kermeta. It is voluntary minimal because that not
        the main role of Kermeta to provide such primitives. In the future,
        this package may even disappear and be replaced by the ability to
        directly call Java libraries.</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis role="strong">kermeta::reflection</emphasis></para>

        <para role="lineBreak">This package contains all the abstract classes
        needed for the reflexivity of Kermeta. The concrete implementation are
        in kermeta::standard or kermeta::structure.</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis role="strong">kermeta::utils</emphasis></para>

        <para role="lineBreak">This package defines various tool classes that
        cannot be part of the core of the language, but are important enough
        to be part of the framework.</para>
      </listitem>
    </orderedlist>

    <orderedlist continuation="restarts">
      <listitem>
        <para><emphasis role="strong">kermeta::standard</emphasis></para>

        <para role="lineBreak">This package defines all the basic objects
        needed for a typical Kermeta application. For example, it defines data
        types, collections, etc.</para>
      </listitem>
    </orderedlist>

    <note>
      For more details about the content of these packages, please look at the generated documentation available on line : 

      <ulink type=""
      url="http://www.kermeta.org/docs/KermetaFramework/framework.km.html">http://www.kermeta.org/docs/KermetaFramework/framework.km.html</ulink>
    </note>
  </chapter>

  <appendix>
    <title>Language keywords</title>

    <para>The following keywords are used by Kermeta textual syntax.</para>

    <note>
      If you want to name some class or property using those names, you'll need to escape them using the ~ (tilda).Ex: class ~class {}
    </note>

    <informaltable>
      <tgroup cols="2">
        <colspec colname="c1" colwidth="3.3inch" />

        <colspec colname="c2" colwidth="3.4inch" />

        <thead>
          <row>
            <entry align="left"><?border-top 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Keyword</para></entry>

            <entry align="left"><?border 0.0007inch solid #000000?>
            <para>Usage</para></entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>@pre</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Represents self before the call to this operation in the
            scope of a post condiction</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>abstract</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Modifier for class or operation</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>alias</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Defintion of a
            primitive type</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>and</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Boolean
            expression</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>attribute</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Definition of an
            attribute</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>bag</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>See <link linkend="array_and_collection">2.2.3</link> about
            collections</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>class</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Defintion of a class</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>do</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Beginning of a block</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>else</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Else part of a conditional instruction</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>end</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>End of a block</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>enumeration</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Definition of an
            enumeration</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>extern</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Call of a java static operation</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>false</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Boolean
            literal</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>from</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Loop instruction</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>function</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Declares a local function</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>getter</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Declaration of a
            property getter</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>if</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Conditional instruction</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>inherits</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Declartion of the super classes of the class</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>init</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Initialization of a
            variable</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>is</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?></entry>
          </row>

          <row>
            <entry align="left"><?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>inv</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Declaration of an invariant</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>loop</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Loop instruction</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>method</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Redefinition of an operation</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>not</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Boolean
            expression</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>operation</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Declaration of an operation</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>or</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Boolean
            expression</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>oset</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>See <link linkend="array_and_collection">2.2.3</link> about
            collections</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>package</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Declaration of
            package</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>post</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Declaration of a
            postcondition</para></entry>
          </row>

          <row>
            <entry align="left"><?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>pre</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Declaration of a precondition</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>property</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Declarion of a
            derived property</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>raise</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Throw an exception</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>raises</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Declares the
            exception that an operation can throw</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>readonly</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Modifier for
            properties</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>reference</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Declaration of a reference</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>require</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Declaration of a required file</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>rescue</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Catch an excetion</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>setter</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Declaration of
            property setter</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>self</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Special varaible representing this instances</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>set </para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>See <link linkend="array_and_collection">2.2.3</link> about
            collections</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>seq</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>See <link linkend="array_and_collection">2.2.3</link> about
            collections</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>super </para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Call to the super operation</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>then</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Then part of a conditional instruction</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>true</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Boolean literal</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>until</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Loop condition</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>using</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Shortcut used to
            avoid to write the full qualified name</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>value</para></entry>

            <entry align="left"><?border-right 0.0007inch solid #000000?>
            <?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>Special variable used in getter and setter to represent the
            actual value of the property</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>var</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Declaration of a
            variable</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>void</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Void
            literal</para></entry>
          </row>

          <row>
            <entry><?border-bottom 0.0007inch solid #000000?> <?border-left 0.0007inch solid #000000?>
            <para>result</para></entry>

            <entry><?border-right 0.0007inch solid #000000?> <?border-bottom 0.0007inch solid #000000?>
            <?border-left 0.0007inch solid #000000?> <para>Special variable
            used for the return value of an operation</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </appendix>
</book>