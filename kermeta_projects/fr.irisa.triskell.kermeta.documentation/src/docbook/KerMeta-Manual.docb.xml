<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<!-- $Id: KerMeta-Manual.docb.xml,v 1.37 2009-02-02 09:23:23 dvojtise Exp $ -->
<book lang="en-US">
  <bookinfo>
    <title>Kermeta language</title>

    <pubdate>Build date: @BUILD.DATE@</pubdate>
    <pubdate>$Date: 2009-02-02 09:23:23 $</pubdate>

    <author>
      <firstname>Zoé</firstname>
      <surname>Drey</surname>
    </author>

    <author>
      <firstname>Cyril</firstname>
      <surname>Faucher</surname>
    </author>

    <author>
      <firstname>Franck</firstname>
      <surname>Fleurey</surname>
    </author>

    <author>
      <firstname>Vincent</firstname>
      <surname>Mahé</surname>
    </author>

    <author>
      <firstname>Didier</firstname>
      <surname>Vojtisek</surname>
    </author>

    <keywordset>
      <keyword>Kermeta</keyword>
      <keyword>metamodeling</keyword>
      <keyword>language</keyword>
    </keywordset>

    <subtitle>Reference manual</subtitle>
    <bibliomisc>License EPL</bibliomisc>

    <abstract>
      <para>This manual presents the various aspects of the Kermeta language.
      This is the reference manual for anybody who want to use Kermeta.</para>
    </abstract>

    <publisher>
      <publishername>INRIA</publishername>

      <address><state>France</state>
<otheraddr><ulink url="http://www.inria.fr">http://www.inria.fr</ulink></otheraddr></address>
    </publisher>
  </bookinfo>

  <preface id="preface.link">
    <title id="preface.title.link">Preface<phrase
    id="preface"></phrase></title>

    <para>Kermeta is a Domain Specific Language dedicated to metamodel
    engineering. It fills the gap let by MOF which defines only the structure
    of meta-models, by adding a way to specify static semantic (similar to
    OCL) and dynamic semantic (using operational semantic in the operation of
    the metamodel). Kermeta uses the object-oriented paradigm like Java or
    Eiffel.</para>

    <para>This document gives beginners an <link
    linkend="chapter_introduction.link">introduction</link> to the Kermeta
    language, then it offers a <link
    linkend="chapter_reference">reference</link> of all the aspects of the
    language, including the textual syntax, the metamodeling features and some
    more advanced features. Two other chapters present the <link
    linkend="chapter_kermeta_mm">Kermeta Metamodel</link> and the <link
    linkend="chapter_framework">Kermeta framework</link>.</para>

    <important>
      <para>Kermeta is an evolving software and despite that we put a lot of attention to this document, it may contain errors (more likely in the code samples). If you find any error or have some information that improves this document, please send it to us using the bug tracker in the forge: 

      <ulink type="" url="http://gforge.inria.fr/tracker/?group_id=32">
        <emphasis
        role="strong">http://gforge.inria.fr/tracker/?group_id=32</emphasis>
      </ulink>

       or using the developer mailing list (kermeta-developers@lists.gforge.inria.fr) Last check: v1.2.0 
    </para></important>

    <tip><para>
       The most update version of this document is available on line from 

      <ulink type=""
      url="http://www.kermeta.org/">http://www.kermeta.org</ulink>

       . 
    </para></tip>
  </preface>

  <chapter id="chapter_introduction.link">
    <title id="chapter_introduction.title.link">Introduction to the
    language<phrase></phrase></title>

    <para>This chapter aims to help you to have a quick overview of most of
    the features of Kermeta. Then, it gives the pointers to the detailled
    sections in the reference chapter. It also gives some small examples that
    should help you to understand the basis of the concepts without having to
    jump to the corresponding detailled section.</para>

    <section id="sec_introduction_presentation.link">
      <title
      id="sec_introduction_presentation.title.link">Presentation</title>

      <para>Kermeta is a metamodeling language which allows describing both
      the structure and the behavior of models. It has been designed to be
      compliant with the OMG metamodeling language EMOF (part of the MOF 2.0
      specification) and Ecore (from Eclipse). It provides an action language
      for specifying the behavior of models.</para>

      <para>Kermeta is intended to be used as the core language of a model
      oriented platform. It has been designed to be a common basis to
      implement Metadata languages, action languages, constraint languages or
      transformation language. </para>
      
      <figure id="refIllustration0">
        <title>Kermeta positioning</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-Manual_figures/kermeta_positioning2.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In a nutshell, Kermeta is :</para>

      <itemizedlist>
        <listitem>
          <para>MOF compliant (EMOF compliant to be precise)</para>
        </listitem>

        <listitem>
          <para>Model oriented</para>
        </listitem>

        <listitem>
          <para>Imperative</para>
        </listitem>

        <listitem>
          <para>Object-Oriented</para>
        </listitem>

        <listitem>
          <para>Statically Typed (100% typesafe)</para>
        </listitem>
      </itemizedlist>

      <para>In addition to these characteristics, it includes some typically
      model-oriented concepts like associations, multiplicities or object
      containment management.</para>

      <para>This chapter presents the main features of the Kermeta language.
      Section 2 presents the general syntax of the language, sections 3 &amp;
      4 give details about the object-oriented and model-oriented features of
      the language and finally section 4 provides information about some extra
      concepts in Kermeta.</para>
      <para>With its workbench, it's goal is to provide a 
      support for all Language Driven Engineering activities. It will be typically 
      used to build tools useful to build software.  This includes (but is not restricted to):
      model checkers, simulators, model transformations (any kind of transformations 
      including model weavers or compilers), ...</para>
      
    </section>

    <section>
      <title>An imperative syntax</title>

      <para>Kermeta is an imperative language for modeling, with a basic
      syntax inspired from Eiffel. Code is statically type checked, and
      execution is made by an interpreter (a compiler is on the way, for
      exhausted performances).</para>

      <section id="section_first_program.link">
        <title id="section_first_program.title.link">First Program<phrase
        id="section_first_program"></phrase></title>

        <para>Even if it is not very useful in our context, since it doesn't
        show the really interresting structures of the language, here is the
        traditional " Hello world " example you can find in every programming
        book.</para>

        <programlisting>@mainClass "helloworld::HelloworldExample"
@mainOperation "sayHello"
<emphasis role="strong">package</emphasis> helloworld;

<emphasis role="strong">require</emphasis> kermeta
<emphasis role="strong">using</emphasis> kermeta::standard

<emphasis role="strong">class</emphasis> HelloworldExample
{
    <emphasis role="strong">operation</emphasis> sayHello() <emphasis
            role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        stdio.writeln("Hello world, ...")
    <emphasis role="strong">end</emphasis>
}</programlisting>
      </section>

      <section>
        <title>Classic features</title>

        <para>Kermeta language includes usual statements like blocks and
        loops, comments,...</para>

        <programlisting><emphasis>do</emphasis>
    <literal>// a loop for getting a text from an user</literal>
    <emphasis>var</emphasis> s : kermeta::standard::String
    <emphasis>from var</emphasis> found : kermeta::standard::Boolean <emphasis>init</emphasis> false
    <emphasis>until</emphasis> found
    <emphasis>loop</emphasis>
        s := stdio.read("Enter a text:\n --&gt; ")
        <emphasis>if</emphasis> s.size &gt; 0 <emphasis>then</emphasis>
            found := true
        <emphasis>else</emphasis>
            stdio.writeln("ERROR - Empty text!")
        <emphasis>end</emphasis>
    <emphasis>end</emphasis>
    stdio.writeln("\n You entered: " + s)
<emphasis>end</emphasis>
</programlisting>
      </section>

      <section>
        <title>Corresponding section in the Reference chapter</title>

        <para>All these "classic" imperative features and their syntaxes are
        described in <xref linkend="chapter_reference.link" />. More precisely
        in <itemizedlist>
            <listitem>
              <para><xref linkend="section_comments.link" />,</para>
            </listitem>

            <listitem>
              <para><xref linkend="section_statements.link" />,</para>
            </listitem>

            <listitem>
              <para><xref linkend="section_variables.link" />,</para>
            </listitem>

            <listitem>
              <para><xref linkend="section_operators.link" />,</para>
            </listitem>

            <listitem>
              <para><xref linkend="section_reserved_keywords.link" /></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>

    <section>
      <title>An object-oriented language</title>

      <para>Users of modern programming languages, like Java, would feel
      easy with object-oriented features in Kermeta: classes, inheritance,
      exceptions, and even genericity.</para>

      <programlisting>// persons who write documents
<emphasis>class</emphasis> Writer {
    <emphasis>attribute</emphasis> name : kermeta::standard::String
}

// generic concept for every document
<emphasis>abstract</emphasis> <emphasis>class</emphasis> Document {
    <emphasis>reference</emphasis> author : Writer
    <emphasis>attribute</emphasis> text : kermeta::standard::String
}

// a "Document" from the real world
<emphasis>class</emphasis> Book <emphasis>inherits</emphasis> Document {}

// a specialized "Book"
<emphasis>class</emphasis> ChildBook <emphasis>inherits</emphasis> Book {
    <emphasis>attribute</emphasis> minimalAge : kermeta::standard::Integer
}</programlisting>

      <para>Such classes can be used for verifications:</para>

      <programlisting>// a specialized Exception
<emphasis>class</emphasis> AgeException <emphasis>inherits</emphasis> kermeta::exceptions::Exception {}

<emphasis>abstract</emphasis> <emphasis>class</emphasis> Reader {
    <emphasis>operation</emphasis> read(book : ChildBook) : <emphasis>Void</emphasis> <emphasis>is</emphasis> <emphasis>abstract</emphasis>
}

<emphasis>class</emphasis> Child <emphasis>inherits</emphasis> Reader {
    <emphasis>attribute</emphasis> age :  kermeta::standard::Integer
    <emphasis>operation</emphasis> initialize(age :  kermeta::standard::Integer) : <emphasis>Void</emphasis> <emphasis>is</emphasis>
    <emphasis>do</emphasis>
        self.age := age
    <emphasis>end</emphasis>
    // an action which triggers an Exception...
    <emphasis>operation</emphasis> read(book : ChildBook) : <emphasis>Void</emphasis> <emphasis>is</emphasis>
    <emphasis>do</emphasis>
        <emphasis>if</emphasis> age &lt; book.minimalAge <emphasis>then</emphasis>
            <emphasis>raise</emphasis> AgeException.new
        <emphasis>end</emphasis>
    <emphasis>end</emphasis>
}</programlisting>

      <section>
        <title>Corresponding section in the Reference chapter</title>

        <para>You can get more informations about Kermeta object-oriented
        features in <xref linkend="chapter_reference.link" />. More precisely
        in <itemizedlist>
            <listitem>
              <para><xref linkend="section_classesandmethods.link" /></para>
            </listitem>

            <listitem>
              <para><xref linkend="section_inheritance.link" /></para>
            </listitem>

            <listitem>
              <para><xref linkend="section_genericity.link" /></para>
            </listitem>

            <listitem>
              <para><xref linkend="section_exceptions.link" /></para>
            </listitem>

            <listitem>
              <para><xref linkend="section_packages.link" /></para>
            </listitem>

            <listitem>
              <para><xref linkend="section_properties.link" /></para>
            </listitem>

            <listitem>
              <para><xref linkend="section_object_comparison.link" /></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>

    <section>
      <title>A model-oriented language</title>

      <para>As explained in the <xref endterm="preface.title.link"
      linkend="preface.link" /> and in <xref
      endterm="section_architecture.title.link"
      linkend="section_architecture.link" />, Kermeta extends the MOF. It
      provides useful means to manipulate models. The support of model introduces 
      the main difference with "more" traditionnal programming languages.</para>

      <section id="section_toward_a_first_concrete_example.link">
        <title>Associations : toward a first concrete
        example of a Kermeta model</title>

		<para>Association is one of the key concepts when using and defining models.
		It is obviously part of Kermeta.
		</para>
        <para>MOF defines the concept of "Property" which generalizes the
        notions of attributes, and associations (composite or not) that you
        can find in UML. Kermeta syntax also distinguishes these two notions
        as introduced in <xref linkend="section_properties.link" />.</para>

        <para>As a reminder, the <literal>attribute</literal> keyword defines
        a link with containment (a composite association) whereas the
        <literal>reference</literal> keyword just defines an association. As
        you can see, property declarations are very close to variable
        declarations introduced in <xref linkend="section_variables.link" />).
        Each reference may be explicitly linked to another reference (it is
        the <literal>opposite</literal> concept in MOF terminology – see also
        section <xref linkend="section_properties-opposite.link" />).</para>

        <programlisting><emphasis role="strong">class</emphasis> Library
{
    <emphasis role="strong">attribute</emphasis> books : set Book[0..*]
}

<emphasis role="strong">class</emphasis> Book
{
    <emphasis role="strong">attribute</emphasis> title : String
    <emphasis role="strong">attribute</emphasis> subtitle : String

    <emphasis role="strong">reference</emphasis> authors : oset Author[1..*]#works
}


<emphasis role="strong">class</emphasis> Author
{
    <emphasis role="strong">attribute</emphasis> name : String
    <emphasis role="strong">attribute</emphasis> lastName : String
    
    <emphasis role="strong">reference</emphasis> works : set Book[0..*]#authors
}</programlisting>

        <para>If we represent our Kermeta model in a graphical syntax we
        obtain the following class diagram (<xref
        linkend="refIllustration6" />).</para>

        <figure id="refIllustration6">
          <title>A concrete example : a library</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/library.png" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Loading an existing model</title>

        <para>Using Eclipse Modeling Framework (EMF), Kermeta can load and
        save models done with other EMF tools.</para>

        <programlisting>/* Initialize the EMF repository */
<emphasis role="strong">var</emphasis> repository : EMFRepository <emphasis
            role="strong">init</emphasis> EMFRepository.new

/* Create an EMF Resource, given model and metamodel URIs as String */
<emphasis role="strong">var</emphasis> resource : Resource <emphasis
            role="strong">init</emphasis> repository.createResource(myModelURI, itsMetamodelURI)

/* Load the resource */
resource.load

// get elements from the resource
// in this sample, you know that your root element is always a Library, 
// so you can directly get the first one
<emphasis role="strong">var</emphasis> aLibrary : Libray
aLibrary ?= resource.one // note the conditionnal assignment using the ?=, if not a Library you'll get Void</programlisting>

        <para>In the same way, you can serialize a model, or load, change and
        save an existing model.</para>

        <caution>
          <para>Your model URI MUST be of the form
          "platform:/resource/myProject/myModel" or
          "platform:/plugin/myProject/myModel".</para>

          <para>Your metamodel URI MUST be of the form
          "platform:/resource/myProject/myModel" or
          "platform:/plugin/myProject/myModel" or an URI registered in the EMF
          registry.</para>
        </caution>

        <caution>
          <para>Be aware that you CANNOT load kermeta text files (*.kmt). Only xmi
          files are allowed to be loaded. Parsing and obtaining a model from a textual syntax is not part of 
          Kermeta. This is the role of other tools (like sintaks). Technically, it is possible to create some 
          Kermeta operation that will hide this step, however, this is not the goal of this manual to explain
          this procedure.</para>
        </caution>
      </section>

      <section>
        <title>Navigation in a model</title>

        <para>Actually, navigating in a model is as simple as using objects in
        an Object Oriented program. However, several features have been added
        in order to ease this activity.</para>

        <para>For example, thanks to the lambda expressions, the collections
        of the language are easily manipulated using lexical closure (select,
        collect, each, ...). This applies to all the collections of the
        language, the one you may define directly but also the one which are
        used when an <link linkend="section_properties.link">Attribute or
        Reference</link> has a multiplicity greater than 1.</para>

		<para>Example (based on the library sample of <xref 
      linkend="section_toward_a_first_concrete_example.link" />):</para>
		<programlisting>
var smithBooks : Set&lt;Book&gt; init Set&lt;Book&gt;.new
smithBooks.addAll(
	lib.books.select{aLibraryBook | 
		aLibraryBook.authors.exists{aBookAuthor | aBookAuthor.lastName == "Smith"}})
		</programlisting>
        <para>In the example above, lib is an instance of Library. It searchs in the books, select the books
        where the author last name is "Smith".</para>
      </section>

      <section>
        <title>Model type</title>

        <para>In order to improve reuse of existing code between metamodel
        variants, the language introduces the notion of ModelType. It is based
        on the notion of conformance between two metamodels. This allows to
        write behavior that is valid for a given metamodel and that will also
        work for any conformant metamodel.</para>
        

        <para>TODO write a small illustrative example of a simple printer
        based on a ModelType : a subset of class diagram of UML</para>
      </section>

      <section>
        <title>Kermeta model reflexively available</title>

        <para>Kermeta has been developed, using MDE principles so it also
        provides its own metamodel (reflectiveley available). Details of
        Kermeta metamodel is available in <xref
        linkend="section_kermeta_metamodel.link" /></para>
      </section>

      <section>
        <title>Corresponding section in the Reference chapter</title>

        <para>You can get more informations about all Kermeta model-oriented
        features in the <xref linkend="chapter_reference.link" />. More
        precisely in <itemizedlist>
            <listitem>
              <para><xref
              linkend="section_loadingsaving_models.link" /></para>
            </listitem>

            <listitem>
              <para><xref linkend="section_kermeta_metamodel.link" /></para>
            </listitem>

            <listitem>
              <para><xref linkend="section_modeltype.link" /></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>

    <section>
      <title>Some "advanced" features</title>

      <para>Kermeta implements several "less common" or advanced features that
      helps in many situations.</para>
      <para> Typically, lambda
      expressions/functions is a well known concept, very useful in almost all
      kermeta code. Even, if you will probably not write your own function,
      you'll certainly use the existing one defined on collections.</para>

      <section>
        <title>Functions in Kermeta<phrase
        id="function-types.link"></phrase></title>

        <para>In order to implement and statically type check OCL-like
        iterators, Kermeta includes some limited functional features by
        implementing lambda expressions.</para>

        <para>This is typically used on <literal>Collection</literal> which
        provides functions like : <literal>each</literal>,
        <literal>select</literal>, <literal>forAll</literal>,
        <literal>detect</literal>, ...</para>

        <para><emphasis role="strong">Example 1</emphasis>: the following code
        will build a collection of names of the operations that start with
        "test".</para>

        <programlisting><emphasis role="strong">var</emphasis> names : Collection&lt;String&gt;
names := <emphasis role="strong">self</emphasis>.getMetaClass.classDefinition.ownedOperation
            .select{ op | op.name.indexOf("test") == 0}
            .collect{ op | op.name }</programlisting>

        <para><emphasis role="strong">Example 2</emphasis>: Providing a time
        function on Integer</para>

        <programlisting><emphasis role="strong">operation</emphasis> times(body : &lt;Integer-&gt;Object&gt;) : Void <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
    <emphasis role="strong">from</emphasis> <emphasis role="strong">var</emphasis> i : Integer <emphasis
            role="strong">init</emphasis> 0
    <emphasis role="strong">until</emphasis> i == <emphasis role="strong">self</emphasis>
    <emphasis role="strong">loop</emphasis>
        body(i)
        i := i + 1
    <emphasis role="strong">end</emphasis>
<emphasis role="strong">end</emphasis> </programlisting>

        <para>this allows to write code like :</para>

        <programlisting><emphasis role="strong">var</emphasis> res : Integer
10.<emphasis role="strong">times</emphasis> { i | stdio.writeln(i.toString + ": Hello") } <emphasis>// Say 10 times Hello</emphasis></programlisting>

        <para>See sections "<xref
        endterm="section_lambda_expression.title.link"
        linkend="section_lambda_expression.link" />" and <xref
        endterm="section_lambda_expression_mm.title.link"
        linkend="section_lambda_expression_mm.link" /> for detailed
        informations.</para>
      </section>

      <section>
        <title>Other advanced features</title>

        <section>
          <title>High level modeling</title>

          <para>Kermeta most recent versions embed advanced concepts like <xref
          endterm="section_lambda_expression.title.link"
          linkend="section_lambda_expression.link" />, <xref
          endterm="section_dynamic_expressions.title.link"
          linkend="section_dynamic_expressions.link" />, <xref
          endterm="section_contracts.title.link"
          linkend="section_contracts.link" /> or <xref
          endterm="section_weaving.title.link"
          linkend="section_weaving.link" />.</para>
        </section>

        <section>
          <title>Other technical features</title>

          <para>As Kermeta language is implemented upon Eclipse and Java, you
          can call Java code inside Kermeta code.(see <xref
          linkend="section_java_code.link" />)</para>

          <para>There is some special behavior regarding object comparison or
          cloning.</para>
        </section>
      </section>
    </section>
  </chapter>

  <chapter id="chapter_reference.link">
    <title id="chapter_reference.title.link">Reference<phrase
    id="chapter_reference"></phrase></title>

    <para>The reference sections are ordered in four parts: the imperative
    syntax (1-6), the object-oriented (7-10) and the model-oriented (11-15)
    features, the advanced concepts (16-21).</para>

    <section id="section_comments.link">
      <title id="section_comments.title.link">Comments<phrase
      id="section_comments"></phrase></title>

      <warning><para>
         Comments are a little bit particular in the Kermeta language because they are not all ignored by the interpreter. There are two kinds of comments: the first (syntax : // foo , /* bar * 

        <emphasis role="strong">/) is only associated to the text editor view
        in which the user edits his Kermeta file, and the second one(syntax
        :</emphasis>

         /** foo */ 

        <emphasis role="strong">or</emphasis>

         @tag_name "tag value") is translated into a MOF tag linked to structures described in the Kermeta model.
         The first one, is a text decoration, the second one is part of the Kermeta model. 
      </para>
      </warning>

      <section>
        <title>Simple and multi-line text comments</title>

        <para>Like in many languages, Kermeta provides two ways to add
        comments in your models:</para>

        <itemizedlist>
          <listitem>
            <para>simple line comments, i.e text line beginning with //</para>

            <programlisting>// This is a single line comment</programlisting>
          </listitem>

          <listitem>
            <para>multi-line comments, i.e text between /* */. Be careful with
            this notation : the opening syntax must not have juxtaposed stars
            ("/**"), otherwise it will be considered as a linked comment (see
            <xref linkend="section_linked-comments.link" />), i.e a comment
            that is part of the Kermeta program as a model.</para>

            <programlisting>/* This a multi line comment
all these lines are comments
this line too. */</programlisting>
          </listitem>
        </itemizedlist>
      </section>

      <section id="section_linked-comments.link">
        <title>Linked comments<phrase></phrase></title>

        <para>Kermeta provides a way to define named and unnamed annotations,
        that have to be defined just above any model element among
        <literal>Package</literal>, <literal>ClassDefinition</literal>,
        <literal>Property</literal>, <literal>Operation</literal>. Such
        annotations correspond to MOF tags, and are linked to the elements
        which immediately follows.</para>

        <para>To define a named annotation, you have to use a special symbol
        "@", whereas an anonymous annotation has to be written between /** and
        */</para>

        <para><emphasis role="strong">Example 1:</emphasis> you can define an
        annotation to describe the role of a property</para>

        <programlisting>@usage "count the number of ..."
<emphasis role="strong">reference</emphasis> myCounter : Integer </programlisting>

        <para><emphasis role="strong">Example 2</emphasis>: you can document
        your classes and operation using /** ... */</para>

        <programlisting><emphasis>/** * This is a documentation tag for the class "myClass" */</emphasis>
<emphasis role="strong">class</emphasis> MyClass {
    <emphasis>/** This is a documentation tag for myOperation */</emphasis>
    <emphasis role="strong">operation</emphasis> myOperation() <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>// Unlinked comment</emphasis>
    <emphasis role="strong">end</emphasis>
    <emphasis role="strong">@desc</emphasis> "This is a named annotation for thisOperation"
    <emphasis role="strong">operation</emphasis> thisOperation() <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>/* This is an unlinked comment */</emphasis>
    <emphasis role="strong">end</emphasis>
}</programlisting>
      </section>
    </section>

    <section id="section_reserved_keywords.link">
      <title id="section_reserved_keywords.title.link">Escaping reserved
      keywords<phrase id="section_keywords"></phrase></title>

      <para>Kermeta textual syntax uses several keywords like
      <literal>class</literal>, <literal>attribute</literal>,
      <literal>reference</literal>, <literal>result</literal>, etc. (Please
      see <xref linkend="appendix_keywords.link" /> at the end of this
      document to get the complete list of Kermeta keywords.)</para>

      <para>This doesn't mean you cannot use these words for your own model.
      Moreover, this is only a textual syntax limitation.</para>

      <para>So Kermeta syntax allows you to use the word you want, you simply
      have to prefix it with a tilda ~.</para>

      <para>This example is valid even if we use "class" and "attribute" which
      are keywords in the language:</para>

      <programlisting>
<emphasis role="strong">class</emphasis> ~class {
    <emphasis role="strong">attribute</emphasis> ~attribute : kermeta::standard::String
    <emphasis role="strong">attribute</emphasis> ~class : kermeta::standard::String
}</programlisting>
    </section>

    <section id="section_operators.link">
      <title id="section_operators.title.link">Operators<phrase
      id="section_operators"></phrase></title>

      <informaltable>
        <tgroup cols="4">
          <colspec colname="c1" colwidth="1.4cm" />

          <colspec colname="c2" colwidth="2.5cm" />

          <colspec colname="c3" colwidth="3cm" />

          <colspec colname="c4" colwidth="8.1cm" />

          <thead>
            <row>
              <entry><para>Priority</para></entry>

              <entry><para>Operator</para></entry>

              <entry><para>Operand types</para></entry>

              <entry><para>Semantic</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry align="center" valign="bottom"><para>1</para></entry>

              <entry align="center"><para> <literal>+</literal>
              </para></entry>

              <entry align="center"><para>Numeric</para>
              <para>String</para></entry>

              <entry><para>Add two numeric values</para> <para>Concatenate two
              strings</para></entry>
            </row>

            <row>
              <entry align="center" valign="bottom"><para>1</para></entry>

              <entry align="center"><para> <literal>-</literal>
              </para></entry>

              <entry align="center"><para>Numeric</para></entry>

              <entry><para>Subtract two numerous values</para></entry>
            </row>

            <row>
              <entry align="center" valign="bottom"><para>2</para></entry>

              <entry align="center"><para> <literal>*</literal>
              </para></entry>

              <entry align="center"><para>Numeric</para></entry>

              <entry><para>Multiply two numeric values</para></entry>
            </row>

            <row>
              <entry align="center" valign="bottom"><para>2</para></entry>

              <entry align="center"><para> <literal>/</literal>
              </para></entry>

              <entry align="center"><para>Numeric</para></entry>

              <entry><para>Divide the first operand by the
              second</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Notice that most of these arithmetic operators are only defined
      for numeric primitive types like Integer. Except the + operator which is
      a concatenation operator for String, they are not applicable on String,
      Boolean nor collections</para>

      <informaltable>
        <tgroup cols="4">
          <colspec colname="c1" colwidth="1.4cm" />

          <colspec colname="c2" colwidth="2.5cm" />

          <colspec colname="c3" colwidth="3cm" />

          <colspec colname="c4" colwidth="8.1cm" />

          <thead>
            <row>
              <entry><para>Priority</para></entry>

              <entry><para>Operators</para></entry>

              <entry><para>Operand Types</para></entry>

              <entry><para>Semantics</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry align="center" valign="bottom"><para>3</para></entry>

              <entry align="center"><para> <literal>==</literal>
              </para></entry>

              <entry align="center"><para>All</para></entry>

              <entry><para>True, if op1 value's is the same that op2
              value's</para></entry>
            </row>

            <row>
              <entry align="center" valign="bottom"><para>3</para></entry>

              <entry align="center"><para> <literal>!=</literal>
              </para></entry>

              <entry align="center"><para>All</para></entry>

              <entry><para>True if op1 value's is different of op2
              value's</para></entry>
            </row>

            <row>
              <entry align="center" valign="middle"><para>3</para></entry>

              <entry align="center" valign="middle"><para>
              <literal>&lt;</literal> </para></entry>

              <entry align="center"
              valign="middle"><para>Numeric</para></entry>

              <entry><para>True if op1value's is strictly smaller than op2
              value's</para></entry>
            </row>

            <row>
              <entry align="center" valign="middle"><para>3</para></entry>

              <entry align="center" valign="middle"><para>
              <literal>&lt;=</literal> </para></entry>

              <entry align="center"
              valign="middle"><para>Numeric</para></entry>

              <entry valign="middle"><para>True if op1 value's is smaller or
              equals than op2 value's</para></entry>
            </row>

            <row>
              <entry align="center" valign="middle"><para>3</para></entry>

              <entry align="center" valign="middle"><para>
              <literal>&gt;</literal> </para></entry>

              <entry align="center"
              valign="middle"><para>Numeric</para></entry>

              <entry valign="middle"><para>True if op1 value's is strictly
              greater than op2 value's</para></entry>
            </row>

            <row>
              <entry align="center" valign="middle"><para>3</para></entry>

              <entry align="center" valign="middle"><para>
              <literal>&gt;=</literal> </para></entry>

              <entry align="center"
              valign="middle"><para>Numeric</para></entry>

              <entry valign="middle"><para>True if op1 value's is greater or
              equals than op2 value's</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <informaltable>
        <tgroup cols="4">
          <colspec colname="c1" colwidth="1.4cm" />

          <colspec colname="c2" colwidth="2.5cm" />

          <colspec colname="c3" colwidth="3cm" />

          <colspec colname="c4" colwidth="8.1cm" />

          <thead>
            <row>
              <entry><?border-top 0.0007inch solid #000000?><para>Priority</para></entry>

              <entry><?border-top 0.0007inch solid #000000?><para>Operators</para></entry>

              <entry><?border-top 0.0007inch solid #000000?><para>Operands
              Types</para></entry>

              <entry><?border 0.0007inch solid #000000?><para>Semantics</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry align="center" valign="bottom"><para>4</para></entry>

              <entry align="center"><para> <literal>and </literal>
              </para></entry>

              <entry align="center"><para>Boolean</para></entry>

              <entry><para>True if op1 and op2 are evaluated to
              true</para></entry>
            </row>

            <row>
              <entry align="center" valign="bottom"><para>4</para></entry>

              <entry align="center"><para> <literal>or</literal>
              </para></entry>

              <entry align="center"><para>Boolean</para></entry>

              <entry><para>True if one of the operators is evaluated to
              true</para></entry>
            </row>

            <row>
              <entry align="center" valign="bottom"><para>4</para></entry>

              <entry align="center"><para> <literal>not </literal>
              </para></entry>

              <entry align="center"><para>Boolean</para></entry>

              <entry><para>True if op is false.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <note>
        <para>The <literal>==</literal> and <literal>!=</literal> can be
        applied to any Object, in this case, the comparison is based on the
        <literal>equals</literal> operation defined for the object and thus
        can be redefined to compare only the values of the objects. To be sure
        to compare the identity of objects even if they redefine the operation
        <literal>equals</literal>, you need to compare their
        <literal>oid</literal> (ie. their identifiers).</para>

        <para>See <xref linkend="section_object_comparison.link" /> for more
        details about object comparison.</para>
      </note>
    </section>

    <section id="section_statements.link">
      <title id="section_statements.title.link">Statements : block, condition,
      loop<phrase id="section_statements"></phrase></title>

      <section>
        <title>Block statement</title>

        <para>Kermeta provides a block notion to manage scope of variable.
        Instruction of the block have to be inserted between
        <literal>do</literal> and <literal>end</literal> keywords. Theses two
        keywords may be omitted for the conditional and for the loop
        structures.</para>

        <para>A variable could only be accessed in the block where it was
        defined and in its sub blocks:</para>

        <programlisting><emphasis role="strong">do</emphasis>
    <emphasis role="strong">var</emphasis> v1 : Integer <emphasis
            role="strong">init</emphasis> 3
    <emphasis role="strong">var</emphasis> v2 : Integer <emphasis
            role="strong">init</emphasis> 2
    <emphasis role="strong">do</emphasis>
        <emphasis role="strong">var</emphasis> v3 : Integer
        v3 := v1 + v2</programlisting>

        <programlisting>        <emphasis role="strong">var</emphasis> v2 : Integer <emphasis>// error : v2 is already declared in the upper block</emphasis>
    <emphasis role="strong">end</emphasis>
    <emphasis role="strong">var</emphasis> v4 : Integer <emphasis
            role="strong">init</emphasis> v3 <emphasis>// error : v3 is unknown here</emphasis>
<emphasis role="strong">end</emphasis></programlisting>
      </section>

      <section>
        <title>Conditional statement</title>

        <para>Kermeta's conditional statement is composed of at least two
        elements : a boolean expression and a block that is executed if the
        boolean is evaluated to <literal>true</literal>. You can add a third
        element, with the <literal>else</literal> keyword, that is executed if
        the boolean expression is evaluated to
        <literal>false</literal>.</para>

        <para><emphasis role="strong">Example 1</emphasis>: if..then..else
        block</para>

        <programlisting><emphasis role="strong">var</emphasis> v1 : Integer <emphasis
            role="strong">init</emphasis> 2
<emphasis role="strong">var</emphasis> v2 : String <emphasis role="strong">init</emphasis> "blah"

<emphasis role="strong">if</emphasis> v1 &gt; 5 <emphasis role="strong">then</emphasis> v1 := v1-5

<emphasis role="strong">if</emphasis> v1 == 2 <emphasis role="strong">then</emphasis>
    v2 := v1
    v1 := v2 + v1
<emphasis role="strong">else</emphasis>
    v1 := 0
<emphasis role="strong">end</emphasis></programlisting>

        <para>The <literal>if</literal> statement is an expression (see <xref
        linkend="section_kermeta_metamodel.link" />). As any expression in
        Kermeta, it can return a value. The return type of the
        <literal>if</literal> statement must be a super type of the values
        "returned" by both <literal>then</literal> and <literal>else</literal>
        blocks (otherwise the type checker will send an error). The values
        considered as the result of the evaluation (the "returned" values) of
        the <literal>if</literal> statement are the last evaluated statement
        inside <literal>then</literal> or <literal>else</literal> block</para>

        <para><emphasis role="strong">Example 2</emphasis>: conditional is an
        expression</para>

        <programlisting><emphasis role="strong">var</emphasis> s : String
    s := <emphasis role="strong">if false then</emphasis> "a" <emphasis
            role="strong">else</emphasis> "b" <emphasis role="strong">end</emphasis></programlisting>

        <para>Example 3: a more complex conditional</para>

        <programlisting><emphasis role="strong">var</emphasis> x : String
    <emphasis role="strong">var</emphasis> y : Integer <emphasis role="strong">init</emphasis> 5 
    x := <emphasis role="strong">if </emphasis>y &lt; 3<emphasis role="strong"> then</emphasis> 
         stdio.writeln("hello")
         "a" 
          <emphasis role="strong">else</emphasis> 
         "b"
         "c" 
          <emphasis role="strong">end</emphasis> <emphasis>// The String "c" will be the value of x</emphasis></programlisting>
      </section>

      <section>
        <title>Loop Statement</title>

        <para>Here is a sample of a typical loop in Kermeta.</para>

        <programlisting><emphasis role="strong">var</emphasis> v1 : Integer <emphasis
            role="strong">init</emphasis> 3
<emphasis role="strong">var</emphasis> v2 : Integer <emphasis role="strong">init</emphasis> 6

<emphasis role="strong">from</emphasis> <emphasis role="strong">var</emphasis> i : Integer <emphasis
            role="strong">init</emphasis> 0
<emphasis role="strong">until</emphasis> i == 10
<emphasis role="strong">loop</emphasis>
    i := i + 1
<emphasis role="strong">end</emphasis></programlisting>

        <note><para>Unlike Java, there is no exit, break or continue function in Kermeta.</para></note>

        <para>See <xref linkend="section_collections.link" /> for functions
        offering iterator-like scanning.</para>
      </section>
    </section>

    <section>
      <title>File dependency : structuring code<phrase
      id="section_files"></phrase></title>

      <para>Kermeta code can be quite large, and invloves many classes in
      different metamodels. The main mecanism used to organise your code is
      the <literal>require</literal> statement.</para>

      <section>
        <title>Require</title>

        <para>When you need to refer explicitly another entity defined in
        another file, you have to use the <literal>require</literal>
        primitive. It allows loading definitions of an other Kermeta file when
        file is processed. In the following example, we define a class C which
        inherits from the A class previously defined.</para>

        <programlisting><emphasis>// file : MyPackage-part1.kmt</emphasis>
<emphasis role="strong">package</emphasis> subPackage1;

<emphasis role="strong">class</emphasis> A 
{
<emphasis>// ...</emphasis>
}</programlisting>

        <programlisting><emphasis>// file : MyPackage-part2.kmt</emphasis>
<emphasis role="strong">package</emphasis> MyPackage;
<emphasis role="strong">require</emphasis> "MyPackage-part1.kmt"

<emphasis role="strong">class</emphasis> C <emphasis role="strong">inherits</emphasis> subPackage1::A 
{
<emphasis>// ...</emphasis>
}</programlisting>

        <note><para>
           In most case, the order of the declaration in not important. The only exception is a very rare situation related to aspects (see 

          <xref linkend="section_weaving.link" />

          ). 
        </para></note>

        <note><para>You can create cyclic dependencies of files, the environment will deal with that.</para></note>
      </section>

      <section>
        <title>Accepted require statements</title>

        <para>You can <literal>require</literal> different kind of
        entity</para>

        <para>Obvioulsy, you can <literal>require</literal> Kermeta textual
        syntax, ie. <emphasis role="strong">*.kmt files</emphasis></para>

        <para>You can <literal>require</literal> Kermeta models, ie. <emphasis
        role="strong">*.km files</emphasis>.</para>

        <para>You can <literal>require</literal> Ecore models, ie. <emphasis
        role="strong">*.ecore files</emphasis>. These models can then be used
        as if they were written in Kermeta. In order to add behavior to the
        classes defined in .ecore files you may : use the <link
        linkend="section_weaving.link">weaving</link> to dynamically weave
        behavior to the ecore, or roundtrip using the button action in the
        workbench (ecore-&gt;kmt-&gt;ecore) to statically add the behavior (as
        EAnnotations) into the ecore file.</para>

        <para>A variant of requiring an ecore file is to require <emphasis
        role="strong">registered EPackage</emphasis>. When Eclipse deploys an
        ecore model plugin, it also registers the EPackage using a unique
        identifier (nsuri) in order to retreive it quickly. In Kermeta you can
        also use this nsuri into the require statement. This approach is
        useful becauseyou can be sure that you require the very same model as
        eclispe use to load and save models of that sort. For example, instead
        of requiring ecore.ecore you may use <literal>require
        "http://www.eclipse.org/emf/2002/Ecore"</literal>. This also works for
        all other registered metamodels (Your own registered metamodel, UML
        metamodel, etc ...). <ulink
        url="http://www.kermeta.org/documents/ui_user_guide/">Kermeta user
        interface</ulink> provides a view that display all registered
        EPackages and their nsuri.</para>
        
        
        <warning><para>A special attention must be put when requiring resources. It is not allowed
        to get several versions of the same class that comes from several required files. 
        Kermeta cannot know which version it must use, so you'll get an error. </para>
        <para>A typical error, is to require both an ecore file and the registered version of it. They represent two 
        distinct resources in memory.</para><para>
        A more clever error, is when the two versions are hidden inside an erroneous ecore file which uses 
        several ways to access some metaclass and actually is not consistent... (ex: you find references to both http://www.eclipse.org/emf/2002/Ecore 
        and platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore in the ecore file or one of the dependent files)
        </para></warning>

        <para>In order to use the seamless java import (still prototype in
        v0.4.2), you can require a <emphasis role="strong">jar
        file</emphasis>. It will automatically convert the java into a Kermeta
        representation in order to be able to call java code as if it was
        written in Kermeta. see <xref linkend="section_java_code.link" /> for
        more details.</para>
      </section>

      <section>
        <title>Organizing code</title>

        <para>Kermeta lets you organise your code the way you prefer. There is
        no predefined organisation of your code, but the language and the
        workbench proposes various mecanisms and tools to structure it
        according to your needs and the style you wish for your code.
        Typically if you use kermeta internal weaver (see <xref
        linkend="section_weaving.link" />), manually transform your ecore into
        Kermeta, eventually weaving the ecore using the merge button available
        on the worbench.</para>

        <para>For example, you can put all your classes into a single file
        (like in Ecore, every classes is in the .ecore file) or you may create
        a file for each of them and then use the <literal>require</literal> to
        indicates that they must know each other You can also use an
        organisation like java, with a file per class and a directory per
        package...</para>
      </section>
    </section>

    <section id="section_variables.link">
      <title id="section_variables.title.link">Using
      Variables<phrase></phrase></title>

      <para>Whenever you need a data locally to a block because it doesn't
      goes into a class attribute or reference, you can use a local
      variable.</para>

      <para>A variable is defined by a name and by a type. If needed, the name
      of the variable can be <link
      linkend="section_reserved_keywords.link">escaped</link> using the tilda
      (~)</para>

      <para>Declaring a variable:</para>

      <programlisting><emphasis role="strong">var</emphasis> foo : String <emphasis>// This is a variable declaration</emphasis></programlisting>

      <para>In the following example, we define 3 variables of type integer.
      The first is initialized with the "14" literal value, the second is
      initialized with an expression using v1. For the last variable, we use a
      multiplicity notation to specify an ordered set of integer (see <xref
      linkend="section_collections.link" /> and <xref
      linkend="section_properties.link" /> for more information on
      sets).</para>

      <programlisting><emphasis role="strong">do</emphasis>
    <emphasis role="strong">var</emphasis> v1 : Integer <emphasis
          role="strong">init</emphasis> 14
    <emphasis role="strong">var</emphasis> v2 : Integer <emphasis
          role="strong">init</emphasis> 145 * v1

    <emphasis role="strong">var</emphasis> tab : Integer[0..*] <emphasis
          role="strong">init</emphasis> kermeta::standard::OrderedSet&lt;Integer&gt;.new
    v1 := v2/v1
<emphasis role="strong">end</emphasis></programlisting>

      <para>Be careful to the multiplicity, when you create a variable with
      multiplicity, you have to initialize it with a <link
      linkend="section_collections.link">collection</link>. Then to use its
      content, you need to use the collection operation like add, addAll,
      remove, select, etc. If you use the assignment <literal>:=</literal> it
      will replace your collection ...</para>
    </section>

    <section id="section_basic_types.link">
      <title id="section_basic_types.title.link">Basic types</title>

      <section>
        <title>Primitive types</title>

        <para>Kermeta implements a few primitive types. By primitive types, we
        mean types that are basic to any language, i.e integer, and that have
        a "literal" value. See below table.</para>

        <informaltable>
          <tgroup cols="3">
            <colspec colname="c1" colwidth="2.7cm" />

            <colspec colname="c2" colwidth="7.6cm" />

            <colspec colname="c3" colwidth="4.7cm" />

            <thead>
              <row>
                <entry><para>Name</para></entry>

                <entry><para>Description</para></entry>

                <entry><para>Literal Example</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para>Integer</para></entry>

                <entry><para>Represents integer numeric value like 10 or 12.
                (« int » data type in Java)</para></entry>

                <entry><para>101, 12, 14, -45, -123</para></entry>
              </row>

              <row>
                <entry><para>String</para></entry>

                <entry><para>Represents a string of like « helloworld »
                (« String » data type in Java)</para></entry>

                <entry><para>"helloworld", "this is a string
                !!!"</para></entry>
              </row>

              <row>
                <entry><para>Boolean</para></entry>

                <entry><para>Represents a true/false value. (« boolean » data
                type in Java)</para></entry>

                <entry><para>true, false</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <programlisting><emphasis>// Simple datatypes examples</emphasis>
<emphasis role="strong">var</emphasis> myVar1 : Integer <emphasis
            role="strong">init</emphasis> 10
<emphasis role="strong">var</emphasis> myVar2 : Integer
<emphasis role="strong">var</emphasis> myVar4 : String <emphasis role="strong">init</emphasis> "a new string value"
<emphasis role="strong">var</emphasis> myVar5 : boolean</programlisting>

        <para>Kermeta also supports some other primitive types like Float and
        Character, but they currently don't have a surface syntax for their
        literals. The way to get them is to use the convertion methods
        available on String (for both of them) or Integer (for Float).</para>
        <para>For example:</para>
<programlisting>
var c : Character init "f".elementAt(0)
var r : Real init "4.5".toReal
</programlisting>        
      </section>

      <section>
        <title>Enumeration types</title>

        <para>You can define enumerations using the following syntax.
        Note that each enumeration literal must end with a ";".</para>

        <programlisting><emphasis role="strong">enumeration</emphasis> Size { small; normal; big; huge; } </programlisting>

        <para>You can manipulate enumerated variables and literals with
        classical operators such as in the following example.</para>

        <programlisting><emphasis role="strong">var</emphasis> mySize : Size
<emphasis role="strong">if</emphasis> ( mySize == Size.small ) <emphasis
            role="strong">then</emphasis> 
    stdio.writeln("This is small !") 
<emphasis role="strong">end</emphasis></programlisting>

        <note><para>
           Enumeration is a concept of the same level as Class, they must both be defined in a package. 
        </para></note>
      </section>

      <section id="section_alias.link">
        <title id="section_alias.title.link">Local datatype using
        "alias"<phrase id="section_alias"></phrase></title>

        <para>In Kermeta, you can define your own datatype based on existing
        types without a hard dependency like inheritance.</para>

        <para>This is done using the alias syntax.</para>

        <para>Ex:</para>

        <programlisting><emphasis role="strong">alias</emphasis> MyString : kermeta::standard::String;</programlisting>

        <para>In this sample, MyString has all the behavior of
        kermeta::standard::String but is declared locally. This means that you
        don't have any dependency to the framework, even to the String in the
        framework.</para>

        <para>Obviously you can reuse existing type names :</para>

        <programlisting><emphasis role="strong">alias</emphasis> String : kermeta::standard::String;</programlisting>

        <para>This will create a new type String in your package with the
        behavior of String in the framework.</para>

        <para>The definition of an alias is different from the use of "using"
        statement (as defined in <xref linkend="section_using.link" />), when
        you write</para>

        <para><emphasis role="strong">using</emphasis>
        kermeta::standard</para>

        <para role="lineBreak">you simply defined a syntactical shortcut
        allowing you to access any definition in this package from within this
        file.</para>

        <para>Wheras defining an alias allows you to access this new
        definition from another package if needed.</para>

        <tip><para>
           It is interesting to redefine your own datatype for all the standard type you use in your metamodel, so when you convert the file into ecore in order to have serialisation, you won't have any dependency to framework.ecore (which is the ecore version of the framework where kermeta standard type) This allow a lazy coupling of the type definitions. 
        </para></tip>
      </section>
    </section>

    <section id="section_classesandmethods.link">
      <title id="section_classesandmethods.title.link">Classes and
      methods<phrase id="section_classes"></phrase></title>

      <section>
        <title>Classes</title>

        <para>As introduced in the "Hello world" example (see <xref
        linkend="section_first_program.link" />), Kermeta is an
        object-oriented language. Kermeta
        provides all MOF concepts like properties, attributes, package. 
        In addition, it provides a body to operations and derived properties.</para>

        <para>Classes and abstract classes can be defined in a Java-like way.
        Class definition must be placed into brackets as it is in the
        following example.</para>

        <programlisting><emphasis>// an empty simple class</emphasis>
<emphasis role="strong">class</emphasis> myFirstClass 
{

}

<emphasis>// a simple abstract class</emphasis>
<emphasis role="strong">abstract</emphasis> <emphasis role="strong">class</emphasis> MyAbstractClass
{

}</programlisting>

        <para>Additionally, for better code robustness, and more user-friendly
        programming, classes can use the genericity mechanisms (see <xref
        linkend="section_genericity.link" /> for more information).</para>

        <programlisting><emphasis>// This is a parametric class</emphasis>
<emphasis role="strong">class</emphasis> A&lt;G&gt; {
}

<emphasis>// This is the type variable binding : G is binded with Integer</emphasis>
<emphasis role="strong">var</emphasis> a : A&lt;Integer&gt;
a := A&lt;Integer&gt;.new
</programlisting>

        <para>There are some limitations in regards to Java. For example, you
        cannot define nested classes in Kermeta. Kermeta offers the same
        structural concepts than MOF language.</para>
      </section>

      <section id="section_defining_operations.link">
        <title>Defining operations</title>

        <para>Kermeta provides a way to add operational (action) semantics
        to your metamodels. For that, you can define operations with their
        body, as in a classical programming language. You can also specify
        abstract operations (they have no body). Kermeta requires that every
        class that contains an abstract operation must be declared as an
        abstract class.</para>

        <para>In the following example, we define some operations, based on a
        visitor pattern implementation</para>

        <programlisting><emphasis role="strong">class</emphasis> Inventory 
{
    <emphasis role="strong">operation</emphasis> visitLibrary(l : Library) <emphasis
            role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        writeln("Inventory : ");
        l.books.each(b : Book | b.accept(<emphasis role="strong">self</emphasis>))
        writeln("----")
    <emphasis role="strong">end</emphasis>

    <emphasis role="strong">operation</emphasis> visitBook(b : Book) <emphasis
            role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        stdio.write("Book : ", b.title, " by ")
        b.authors.each(a : Author | a.accept(<emphasis role="strong">self</emphasis>))
    <emphasis role="strong">end</emphasis>

    <emphasis role="strong">operation</emphasis> visitAuthor(a : Author) <emphasis
            role="strong">is</emphasis> 
    <emphasis role="strong">do</emphasis>
        stdio.write(a.name, " ", a.lastName)
    <emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Library {
    // ...
    <emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
            role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        visitor.visitLibrary(self)
    <emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Book
{
    // ...
    <emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
            role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        visitor.visitBook(self)
    <emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Author
{
    // ...
    <emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
            role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        visitor.visitAuthor(self)
    <emphasis role="strong">end</emphasis>
}</programlisting>

        <para>In this small example we define an <literal>Inventory</literal>
        class which can go over the library structure and print books
        informations. For that, we apply the visitor GoF pattern's on the
        library structure defining an <literal>accept</literal> method in
        every library structures.</para>

        <section>
          <title>Result</title>

          <para>The special variable <literal>result</literal> is used to
          store the value that will be returned by the operation.</para>

          <programlisting><emphasis role="strong">operation</emphasis> getName() : String<emphasis
              role="strong"> is</emphasis>
    <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := <emphasis role="strong">self</emphasis>.name
    <emphasis role="strong">end</emphasis></programlisting>

          <note><para>
             This is different of the 
            <literal>return</literal>
             in java, since it doesn't end the block. Other instructions can be used after the 
            <literal>result</literal>
             assignment. 
          </para></note>
        </section>

        <section>
          <title>Operations as main entry point.</title>

          <para>When you run a Kermeta program you'll start from an operation.
          The main operation that you want to run can have any number of
          parameters, whose types must be only and only String. For operations
          that are <emphasis role="strong">not</emphasis> intended to be run,
          you can put any type of parameters.</para>

          <para>Technically, if you use kermeta inside Eclipse, when you will
          ask it to run your operation, the interpreter will implicitely
          instanciate the class containing this operation, and then will call
          this operation.</para>

          <para><emphasis role="strong">Example</emphasis>: 3 different kinds
          of "runnable" operations</para>

          <programlisting><emphasis role="strong">class</emphasis> A{
    <emphasis role="strong">operation</emphasis> main0() <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>// do something</emphasis>
    <emphasis role="strong">end</emphasis>
    <emphasis role="strong">operation</emphasis> main1( arg1 : String) <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>// do something with 1rst argument</emphasis>
    <emphasis role="strong">end</emphasis>
    <emphasis role="strong">operation</emphasis> main3( arg1 : String, arg2 : String) <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>// do something with 1st and 2nd arguments</emphasis>
    <emphasis role="strong">end</emphasis>
}
<emphasis>// If you ask to launch main0, kermeta interpereter will create an instance of A and will run main0 on it.</emphasis></programlisting>
        </section>
      </section>

      <section>
        <title>Initializing classes</title>

        <para>Kermeta doesn't use constructors.</para>

        <para>However in some situation, you may need to provide some
        initialization operation. The best approach is simply to declare an
        operation which will return self after having done the initialization
        work.</para>

        <programlisting>
class A
{
	attribute name : String
	operation initialize(name : String) : A is do
		self.name := name
	end
}        
        </programlisting>

        <programlisting>
// now you can use it easily in one line
	var aA : A init A.new.initialize("hello")
        </programlisting>
      </section>

      <section>
         

        <title>Rationale</title>

         <para>Here are some explanation about some design choice of Kermeta classes. </para>

        <section>
          <title>No constructor</title>

          <para>This is because of the compatibility with EMOF and Ecore. In
          those metalanguages, the user must always be able to create object
          (except if they are declared abstract), it cannot rely on a action
          language (since they don't define one). In addition we want that all
          Meta tool be able to create the object the same way, so, as Ecore
          doesn't provide constructor with its editors, then Kermeta doesn't
          too.</para>
        </section>

         

        <section>
          <title>No operation overloading</title>

          <para>In order to simplify multiple inheritance management, Kermeta
          allows only one operation or property with the same name in a given
          class.</para>
        </section>

         
      </section>
    </section>

    <section id="section_inheritance.link">
      <title id="section_inheritance.title.link">Inheritance<phrase
      id="section_inheritance"></phrase></title>

      <para>As kermeta is Object Oriented, it supports inheritance. Like its
      basis EMOF, it support both, simple and multiple inheritance.</para>

      <section>
        <title>Using simple inheritance<phrase
        id="sec_simple-inheritance.link"></phrase></title>

        <programlisting><emphasis role="strong">abstract</emphasis> <emphasis
            role="strong">class</emphasis> Person
{
    <emphasis role="strong">attribute</emphasis> name : string
    <emphasis role="strong">attribute</emphasis> lastName : string

    <emphasis role="strong">reference</emphasis> father : Male#children 
    <emphasis role="strong">reference</emphasis> mother : Female#children
}

<emphasis role="strong">class</emphasis> Male <emphasis role="strong">inherits</emphasis> Person
{
    <emphasis role="strong">reference</emphasis> children : oset Person[0..*]#father
    <emphasis role="strong">reference</emphasis> wife : Female[0..1]#husband
}

class Female <emphasis role="strong">inherits</emphasis> Person
{
    <emphasis role="strong">reference</emphasis> children : oset Person[0..*]#mother
    <emphasis role="strong">reference</emphasis> husband : Male[0..1]#wife
}</programlisting>

        <para>In this example, we define a simple model which represent
        simples family trees. Here, persons are defined by their name and last
        name. Each person have a father and mother and respectively might have
        children. The figure representing this example is <xref
        linkend="refIllustration7" /></para>

        <figure id="refIllustration7">
          <title>A simple family tree model</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/person.png" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Cast</title>

        <para>As Kermeta is strongly typed, you cannot assign or pass
        something of the wrong type.</para>

        <para>For example :</para>

        <programlisting>
class A {
}
class SubA inherits A {
}
class AnotherSubA inherits A {
}

// ...
	var aA    : A init SubA.new
	var aSubA : SubA
	aSubA := aA  // doesn't work because not type safe
        </programlisting>

        <para>In this situation you must use one of the following methods :
        conditionnal assignment or asType</para>

        <section>
          <title>Casting using contionnal assignment</title>

          <para>The conditionnal assignment <literal>?=</literal> allows to
          assign only if the passed object is of the correct type. If not of
          the correct type, the assigned value will simply be
          <literal>Void</literal>.</para>

          <programlisting>
	aSubA ?= aA  // works
	var aAnotherSubA : AnotherSubA
	aAnotherSubA ?= aA  // works too, but has been assigned Void and not the value ...
        	</programlisting>

          <para>This still propose some control on the types and won't accept
          all kind of cast, for example, you cannot conditionnaly assign if
          you don't have a common supertype.</para>

          <programlisting>
class B {
}
// ...	
	var aB : B
	aB ?= aA  // doesn't work because not type safe
        	</programlisting>
        </section>

        <section>
          <title>Casting using asType</title>

          <para>You can also use the operation <literal>asType</literal> to
          cast your value. This one use a syntax which is shorter in some
          situation, since you don't have to create an intermediate variable
          before passing the casted value to an operation. However, the
          drawback is that, if it fails to cast, then it will raise an
          exception.</para>

          <programlisting>
class C {
	operation needASubA(sa : SubA) : Void	is do
		// do something
	end
}
	// ... typical code using ?= 
	var aC : C init C.new	
	aC.needASubA(aA.asType(SubA))
        	</programlisting>
        </section>

        <section>
          <title>Other useful function when casting</title>

          <para>In complement you can use, the <literal>isVoid</literal>
          operation (available on every object) to test the result of a
          conditionnal cast. Or you may use the <literal>isKindOf</literal>
          operation to test if the passed object is of the correct type before
          the assignment/asType.</para>
        </section>
      </section>

      <section>
        <title>Using multiple inheritance</title>

        <programlisting><emphasis role="strong">class</emphasis> Parent
{
     <emphasis role="strong">reference</emphasis> children : oset Child[0..*]#parent
}

<emphasis role="strong">class</emphasis> Child
{
     <emphasis role="strong">reference</emphasis> parent : Parent#children</programlisting>

        <programlisting>}

<emphasis role="strong">class</emphasis> Male { }

<emphasis role="strong">class</emphasis> GrandFather <emphasis role="strong">inherits</emphasis> Parent, Male
{
     <emphasis role="strong">boolean</emphasis> healthy : Boolean
}</programlisting>

        <para>The above example defines a class "GrandFather" that inherits at
        the same time the class "Parent", and the class "Male". Its graphical
        representation is shown in below figure.</para>

        <figure id="refIllustration8">
          <title>: multiple inheritance</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/KMM_multiple_inheritance.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>

      <section>
        <title>Overriding behavior with methods</title>

        <para>In the following sample, when an operation is declared for the
        first time (in the parent class Person), it uses the
        <literal>operation</literal> keyword. Then, whenever you override it,
        you will have to use the <literal>method</literal> keyword.</para>

        <note><para>
           In the sample,Person and adopt are abstract, but this has no influence on the operation-method keywords rule, it would have been the same even if Person was not abstract or if adopt had a behavior in this class. 
        </para></note>

        <programlisting><emphasis role="strong">abstract class</emphasis> Person
{
    <emphasis role="strong">attribute</emphasis> name : String
    <emphasis role="strong">reference</emphasis> father : Male#children 
    <emphasis role="strong">reference</emphasis> mother : Female#children
    <emphasis role="strong">operation</emphasis> adopt(child : Person) <emphasis
            role="strong">is</emphasis> <emphasis role="strong">abstract</emphasis>}</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> Male <emphasis
            role="strong">inherits</emphasis> Person 
{
    <emphasis role="strong">reference</emphasis> wife : Female#husband
    <emphasis role="strong">reference</emphasis> children : oset Person[0..*]#father<emphasis></emphasis>    <emphasis
            role="strong">method</emphasis> adopt(child : Person) <emphasis
            role="strong">is</emphasis>    <emphasis role="strong">do</emphasis>        children.add(child)
        <emphasis role="strong">if</emphasis> <emphasis role="strong">not</emphasis> wife.children.contains(child) <emphasis
            role="strong">then</emphasis>            child.father := <emphasis
            role="strong">self</emphasis>            wife.adopt(child)
        <emphasis role="strong">end</emphasis>    <emphasis role="strong">end</emphasis>}</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> Female <emphasis
            role="strong">inherits</emphasis> Person
{
    <emphasis role="strong">reference</emphasis> husband : Male#wife
    <emphasis role="strong">reference</emphasis> children : oset Person[0..*]#mother<emphasis></emphasis>    <emphasis
            role="strong">method</emphasis> adopt(child : Person) <emphasis
            role="strong">is</emphasis>    <emphasis role="strong">do</emphasis>        children.add(child)
        <emphasis role="strong">if</emphasis> <emphasis role="strong">not</emphasis> husband.children.contains(child) <emphasis
            role="strong">then</emphasis>            child.mother := <emphasis
            role="strong">self</emphasis>
            husband.adopt(child)
        <emphasis role="strong">end</emphasis>    <emphasis role="strong">end</emphasis>}</programlisting>
      </section>

      <section>
        <title>Some limitations</title>

        <para>A MOF class can have operations but MOF does not provide any way
        to describe the behavior of these operations. Furthermore MOF does not
        provide any semantics neither for operation call nor for operation
        inheritance and redefinition. This section investigates how, while
        weaving actions into MOF, MOF semantics can be extended to support
        behavior definition and extension mechanisms provided by the action
        language. This implies answering several questions concerning
        redefinition and dispatch.</para>

        <section>
          <title>Operation redefinition</title>

          <para>MOF does not specify the notion of overriding an operation
          because from a structural point of view it does not make any sense.
          To stick to MOF structure one can argue that redefinition should be
          forbidden in an executable MOF. This is the simplest solution as it
          also solves the problem of the dynamic dispatch since a simple
          static binding policy can be used.</para>

          <para>However, operation redefinition is one of the key features of
          Object-Oriented (OO) languages. The OO paradigm has demonstrated
          that operation redefinition is a useful and powerful mechanism to
          define the behavior of objects and allow for variability. This would
          be very convenient to properly model dynamic semantic variation
          points existing in e.g. UML state-charts. For this reason we believe
          that an important feature of an executable MOF is to provide a
          precise behavior redefinition mechanism. The choice of the operation
          overriding mechanism must take into account the usual problem of
          redefinition such as method specialization and conflicting
          redefinitions related to multiple inheritance.</para>

          <table id="refTable0">
            <title>Operation redefinition in Kermeta</title>

            <tgroup cols="2">
              <colspec colname="c1" colwidth="5.7cm" />

              <colspec colname="c2" colwidth="11.3cm" />

              <tbody>
                <row>
                  <entry align="right"><mediaobject>
                      <imageobject>
                        <imagedata depth="9.208cm"
                                   fileref="KerMeta-Manual_figures/operation_redefinition.png"
                                   width="2.29cm" />
                      </imageobject>
                    </mediaobject> <para></para></entry>

                  <entry><programlisting><emphasis role="strong">class</emphasis> A
{
     <emphasis role="strong">operation</emphasis> m1() <emphasis role="strong">is</emphasis> <emphasis
                        role="strong">do</emphasis>
         <emphasis>// Some behavior</emphasis>
     <emphasis role="strong">end</emphasis>

     <emphasis>// operation m2 is abstract</emphasis>
     <emphasis role="strong">operation</emphasis> m2() <emphasis role="strong">is</emphasis> <emphasis
                        role="strong">abstract</emphasis>
}
</programlisting> <programlisting><emphasis role="strong">class</emphasis> B <emphasis
                        role="strong">inherits</emphasis> A
{    
     <emphasis>// method m1 inherits operation m1 from A</emphasis>
     <emphasis role="strong">method</emphasis> m1() <emphasis role="strong">is</emphasis> <emphasis
                        role="strong">do</emphasis>
         <emphasis>// Behavior redefinition</emphasis>
     <emphasis role="strong">end</emphasis>

     <emphasis role="strong">method</emphasis> m2() <emphasis role="strong">is</emphasis> <emphasis
                        role="strong">do</emphasis> <emphasis>//</emphasis><emphasis> Implementation of the abstract method</emphasis>
     <emphasis role="strong">end</emphasis>
}</programlisting></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <note><para>
             Notice in that sample that method redefinition uses the 

            <literal>method</literal>

             keyword instead of 

            <literal>operation.</literal>

             
          </para></note>
        </section>

        <section>
          <title>Operation specialization</title>

          <para>The issue of choosing semantics for operation overriding has
          been widely studied for the design of OO languages ( cf. M. Abadi
          and L. Cardelli, A theory of objects, Springer). However, OO
          languages have not adopted a unique solution to this problem. In
          this context, any language that defines an operation overriding
          mechanism should define precisely the solution it implements.</para>

          <para>The simplest approach to overriding is to require that an
          overriding method has exactly the same signature as the overridden
          method. That is that both the type of the parameters and the return
          type of the operation should be <emphasis>invariant</emphasis> among
          the implementations of an operation. For the sake of simplicity this
          is the solution we have chosen for the current version of
          Kermeta.</para>

          <para>However, this condition can be relaxed to allow method
          <emphasis>specialization,</emphasis> i.e. specialization on the
          types of parameters or/and return type of the operation. On one
          hand, the return type of the overriding method can be a sub-type of
          the return type of the overridden method. Method specialization is
          said to be <emphasis>covariant</emphasis> for the return types. On
          the other hand, the types of parameters of the overriding method
          might be super types of the parameters of the overridden methods.
          Method specialization is thus <emphasis>contravariant</emphasis> for
          the parameters.</para>

          <para>In practice languages can allow method specialization only on
          the return type (this is the case of Java 1.5) or both on parameters
          and return type (this is the case of Eiffel). Among these solutions,
          we may choose a less restrictive policy then strict invariance for
          future versions of Kermeta in order to improve the static type
          checking of Kermeta programs.</para>
        </section>

        <section>
          <title>Operation overloading</title>

          <para>Overloading is not allowed in Kermeta. This mechanism allows
          multiple operations taking different types of parameters to be
          defined with the same name. For each call, depending on the type of
          the actual parameters, the compiler or interpreter automatically
          calls the right one. This provides a convenient way for writing
          operations whose behaviors differ depending on the static type of
          the parameters. Overloading is extensively used is some functional
          languages such as Haskell and has been implemented in OO languages
          such as Java or C#. However it causes numerous problems in an OO
          context due to inheritance and even multiple inheritance in our case
          [REF?]. It is not implemented in some OO languages such as Eiffel
          for this reason, and that is why we chose to exclude overloading
          from Kermeta.</para>

          <programlisting><emphasis role="strong">class</emphasis> A
{
    <emphasis role="strong">method</emphasis> m(i : Integer) <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end 
    method </emphasis>m(s : String)<emphasis role="strong"> is do </emphasis><emphasis>// this is not allowed in Kermeta !!!</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end</emphasis>
}</programlisting>
        </section>

        <section>
          <title>Conflicts related to multiple inheritance</title>

          <para>This is also a classical problem that has been solved in
          several OO languages. There are mainly two kinds of conflicts when a
          class inherits features from several super-classes:</para>

          <itemizedlist>
            <listitem>
              <para>Several features with the same name might be inherited
              from different super classes causing a name clash.</para>
            </listitem>

            <listitem>
              <para>Several implementations of a single operation could be
              inherited from different super classes.</para>
            </listitem>
          </itemizedlist>

          <para>There are two kinds of solutions to resolve these conflicts.
          The first one is to have an implicit resolution mechanism which
          chooses the method to inherit according to an arbitrary policy. The
          second one is to include in the language constructions that allow
          the programmer to explicitly resolve conflicts. In Eiffel, for
          instance, the programmer can rename features in order to avoid name
          clashes and can select the method to inherit if several redefinition
          of an operation are inherited from parent classes.</para>

          <para>In the current version of Kermeta, we have chosen to include a
          minimal selection mechanism that allows the user to explicitly
          select the inherited method to override if several implementations
          of an operation are inherited. This mechanism does not allow
          resolving some name clashes and thus reject some ambiguous programs.
          For the future version of Kermeta we plan to include a more general
          mechanism such as <emphasis>traits</emphasis> proposed by Schärli et
          al. In any case we believe the conflict resolution mechanism should
          be explicit for the programmer.</para>

          <table id="refTable1">
            <title>Explicit selection of super operation in Kermeta</title>

            <tgroup cols="2">
              <colspec colname="c1" colwidth="5.8cm" />

              <colspec colname="c2" colwidth="11.2cm" />

              <tbody>
                <row>
                  <entry align="center"><mediaobject>
                      <imageobject>
                        <imagedata depth="11.374cm"
                                   fileref="KerMeta-Manual_figures/superoperation_selection.png"
                                   width="5.636cm" />
                      </imageobject>
                    </mediaobject> <para></para></entry>

                  <entry><programlisting><emphasis role="strong">class</emphasis> O
{
    <emphasis role="strong">operation</emphasis> m() <emphasis role="strong">is</emphasis> <emphasis
                        role="strong">abstract</emphasis>
}
</programlisting> <programlisting><emphasis role="strong">class</emphasis> A <emphasis
                        role="strong">inherits</emphasis> O
{
    <emphasis role="strong">method</emphasis> m() <emphasis role="strong">is</emphasis> <emphasis
                        role="strong">do</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end</emphasis>
}
</programlisting> <programlisting><emphasis role="strong">class</emphasis> B <emphasis
                        role="strong">inherits</emphasis> O
{
    <emphasis role="strong">method</emphasis> m() <emphasis role="strong">is</emphasis> <emphasis
                        role="strong">do</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end</emphasis>
}
</programlisting> <programlisting><emphasis role="strong">class</emphasis> C <emphasis
                        role="strong">inherits</emphasis> A, B
{
<emphasis>// "from" : an explicit selection of the//implementation to inherit</emphasis>
    <emphasis role="strong">method</emphasis> m() <emphasis role="strong">from</emphasis> A <emphasis
                        role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end</emphasis>
} 
</programlisting></entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
      </section>
    </section>

    <section id="section_genericity.link">
      <title id="section_genericity.title.link">Genericity<phrase
      id="section_genericity"></phrase></title>

      <para>One of the core characteristics of Kermeta is to be statically
      typed. In order to allow static typing of OCL-like expressions, a few
      modifications had to be made to the EMOF type system (Please refer to
      paper Weaving Executability into Object-Oriented Meta-Languages by P.A.
      Muller et al., presented at the Models05 conference).</para>

      <para>As a result to these modifications genericity support has been
      added into Kermeta. Like Eiffel and Java 5, Kermeta supports generic
      classes and generic operations. This section gives on overview of these
      concepts in Kermeta.</para>

      <section>
        <title>Generic classes</title>

        <para>In Kermeta classes can have a set of type parameters. These type
        variables can be used in the implementation of the class as any other
        type. By default a type variable can take as value any type; but a
        type variable can also be constrained by a type: in that case, this
        type variable can only be substituted by a sub-type of this type. The
        following code demonstrates how to create generic classes.</para>

        <programlisting>// A class with a type variable G that can be bound with any type</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> Queue&lt;G&gt;
{
     <emphasis role="strong">reference</emphasis> elements : oset G[*]

     <emphasis role="strong">operation</emphasis> enqueue(e : G) : <emphasis
            role="strong">Void</emphasis> <emphasis role="strong">is</emphasis> <emphasis
            role="strong">do</emphasis> 
         elements.add(e)
     <emphasis role="strong">end</emphasis>
     
     <emphasis role="strong">operation</emphasis> dequeue() : G <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
         <emphasis role="strong">result</emphasis> := elements.first
         elements.removeAt(0)
     <emphasis role="strong">end</emphasis>
}
</programlisting>

        <programlisting>// A class with a type variable C that can be bound with any sub-type of Comparable</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> SortedQueue&lt;C : Comparable&gt; <emphasis
            role="strong">inherits</emphasis> Queue&lt;C&gt; 
{
     <emphasis role="strong">method</emphasis> enqueue(e : C) : <emphasis
            role="strong">Void</emphasis> <emphasis role="strong">is</emphasis> <emphasis
            role="strong">do</emphasis>
         <emphasis role="strong">var</emphasis> i : Integer
         <emphasis role="strong">from</emphasis> i := 0
         <emphasis role="strong">until</emphasis> i == elements.size <emphasis
            role="strong">or</emphasis> e &gt; elements.elementAt(i)
         <emphasis role="strong">loop</emphasis>
             i := i + 1
         <emphasis role="strong">end</emphasis>
         elements.addAt(i, e)
     <emphasis role="strong">end</emphasis>
}
</programlisting>
      </section>

      <section>
        <title>Generic operations</title>

        <para>Kermeta operations can contain type parameters. Like type
        variables for classes these type parameters can be constrained by a
        super type. However, unlike for classes, for which the bindings to
        these type parameters are explicit, for operations the actual type to
        bind to the variable is statically inferred for each call according to
        the type of the actual parameters.</para>

        <programlisting><emphasis role="strong">class</emphasis> Utils {
    <emphasis role="strong">operation</emphasis> max&lt;T : Comparable&gt;(a : T, b : T) : T <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := <emphasis role="strong">if</emphasis> a &gt; b <emphasis
            role="strong">then</emphasis> a <emphasis role="strong">else</emphasis> b <emphasis
            role="strong">end</emphasis>
    <emphasis role="strong">end</emphasis>
}
</programlisting>

        <note><para>
           Notice in that sample that even the "if" is an expression that can return a value that is assigned here to the special variable "result". 
        </para></note>
      </section>

      <section>
        <title>Type usable with genericity</title>

        <para>Actually, all types can be used as a parameter of a generic
        class or generic operation. More, the ModelType, is really useful when
        combined with generics. see <xref
        linkend="section_modeltype.link" /></para>
      </section>
    </section>

    <section id="section_exceptions.link">
      <title id="section_exceptions.title.link">Exception handling<phrase
      id="section_exceptions"></phrase></title>

      <para>Kermeta provides also an exception mechanism. You can define a
      "rescue" block to manage errors occurring during the execution of
      another block. Exception mechanism is very close to the Java Exception
      mechanism.</para>

      <para><emphasis role="strong">Example 1</emphasis>: a simple exception
      raising</para>

      <programlisting><emphasis role="strong">do</emphasis>
    <emphasis role="strong">var</emphasis> excep : Exception
    
    excep := Exception.new
    stdio.writeln("Throwing an exception ! ")
    <emphasis role="strong">raise</emphasis> excep
<emphasis role="strong">end</emphasis></programlisting>

      <para>Any block can then rescue exceptions.</para>

      <para><emphasis role="strong">Example 2</emphasis>: rescue block</para>

      <programlisting><emphasis role="strong">var</emphasis> v1 : Integer <emphasis
          role="strong">init</emphasis> 2
<emphasis role="strong">var</emphasis> v2 : Integer <emphasis role="strong">init</emphasis> 3

<emphasis role="strong">do</emphasis>
    var v3 : Integer
    v3 := v1 + v2
<emphasis role="strong">rescue</emphasis> (myConstraintError : kermeta::exceptions::ConstraintViolatedInv)
    // something with myConstraintError
    // ...
<emphasis role="strong">rescue</emphasis> (myError : Exception)
    // something with myError
    // ...
<emphasis role="strong">end</emphasis></programlisting>

      <tip><para>
        do not hesitate to create "do .. end" block into another block if you want to check for an exception only in a part of the code. This also works if you want to rescue code from within a rescue code.
      </para></tip>
    </section>

    <section id="section_loadingsaving_models.link">
      <title id="section_loadingsaving_models.title.link">Loading and saving
      models<phrase id="section_serialization"></phrase></title>

      <para>This section explains how to load and save (deserialize and
      serialize) an EMF model in Kermeta. For this purpose, we will use the
      following small example :</para>

      <figure float="" id="refIllustration9">
        <title>cs.ecore sample metamodel</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-Manual_figures/cs_ecore.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <note><para>
         Loading and saving model has it own tutorial. It provides more information in a step by step approach. See the EMF tutorial at 
        <ulink type=""
        url="http://www.kermeta.org/documents/emfTutorial/">http://www.kermeta.org/documents/emfTutorial/</ulink>
      </para></note>

      <section>
        <title>Prepare a model</title>

        <para>The user will refer to eclipse documentation for the creation of
        an EMF model from its ECore meta-model. We suggest to use the Wizard
        samples to create, at the first hand, an Ecore meta-model, and then,
        at the second hand, instances of this Ecore meta-model, using the
        generated EMF reflexive editors.</para>

        <para>Once you created the ECore meta-model, please check that you
        correctly filled the property "<literal>Ns URI"</literal> of the root
        package of the Ecore meta-model, otherwise the resource load will
        fail. This NsURI must equal the real path of your metamodel. (You can
        modify this property through the Properties View of your
        meta-model)</para>
      </section>

      <section>
        <title>Load a model from an EMF Resource</title>

        <para>In the current version of the EMF resource loader, you have to
        prepare your EMF Resource following these rules :</para>

        <itemizedlist>
          <listitem>
            <para>At the top of the source code where you will access your
            model, don't forget to add <literal>require "your_metamodel.ecore"
            </literal>so that you can access your metamodel in Kermeta.</para>

            <para>Alternatively, you can use the Kermeta version of your
            metamodel using <literal>require "your_metamodel.kmt"</literal> or
            <literal>require "your_metamodel.km"</literal>.</para>

            <para role="lineBreak">In this case, be careful that your kmt
            required metamodel is strictly equivalent to the ecore version of
            your metamodel that is used in createResource method.</para>
          </listitem>

          <listitem>
            <para>Then, create a repository and the resource that will contain
            the model instance that you want to load. In the following code
            example, <literal>uri</literal> stands for the uri (as relative or
            absolute path<footnote id="ftn2">
                <para>in this case, don't forget to put the protocol, i.e.
                platform:/, file:/, etc.</para>
              </footnote>) of the model instance, and
            <literal>mm_uri</literal> is the uri of the meta-model of the
            model instance.</para>
          </listitem>
        </itemizedlist>

        <programlisting><emphasis role="strong">@mainClass</emphasis> "root::TestCSLoading"
<emphasis role="strong">@mainOperation</emphasis> "main"

<emphasis role="strong">package</emphasis> root;

<emphasis role="strong">require</emphasis> kermeta
<emphasis role="strong">require</emphasis> "cs.ecore"

<emphasis role="strong">using</emphasis> kermeta::standard
<emphasis role="strong">using</emphasis> kermeta::persistence

<emphasis role="strong">class</emphasis> TestCSLoading
{
     <emphasis role="strong">operation</emphasis> initialize(uri : String, mm_uri : String) : Set&lt;Object&gt; <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
         <emphasis>/* Initialize the EMF repository */</emphasis>
         <emphasis role="strong">var</emphasis> repository     : EMFRepository init EMFRepository.new
         <emphasis>/* Create an EMF Resource */</emphasis>
         <emphasis role="strong">var</emphasis> resource : Resource init repository.createResource(uri, mm_uri)
         <emphasis>/* Load the resource */</emphasis>
         resource.load
         <emphasis>/* Get the loaded __root__ instances (a Set&lt;Object&gt;) */</emphasis>
         <emphasis role="strong">result</emphasis> := resource  // a resource is a collection of objects contained
     <emphasis role="strong">end</emphasis>
 </programlisting>

        <itemizedlist>
          <listitem>
            <para>Once you loaded your EMF resource, you can get its attribute
            <literal>instances</literal>, that contains all the objects that
            you created through your EMF generated reflexive editor. Now you
            can "visit" your instances, provided you "visit" them according to
            their types. In the simplest way, you can make very basic tests to
            display your instances content, as in the following example, which
            visit the objects of resource instances which types are
            <literal>cs::Template</literal> and
            <literal>cs::Decision.</literal></para>
          </listitem>
        </itemizedlist>

        <programlisting>
operation main() is do 
   var instances := self.initialize("./test.cs", "./cs.ecore") 
   from var it : Iterator&lt;Object&gt; init instances.iterator 
   until it.isOff 
   loop
      var o : Object o := it.next 
      if (o == void) then stdio.writeln("Void object!") 
      else 
         stdio.writeln("---------------------------------") 
         stdio.writeln("Objet : " + o.getMetaClass.classDefinition.qualifiedName 
            + " ( " + o.getMetaClass.typeDefinition.ownedAttribute.size.toString+ "attr.)" ) 
      end
      var template : cs::Template <emphasis>// Print instances which type is cs::Template</emphasis> 
      if (cs::Template.isInstance(o)) 
      then 
         template ?= o 
         stdio.writeln(" name : " + template.name) 
         stdio.writeln(" decision : " + template.decision.toString) 
         stdio.writeln(" content : " + template.content) stdio.writeln(" referer : " + template.referer.toString) 
      end
      <emphasis>// Print instances which type is cs::Decision</emphasis> 
      if (cs::Decision.isInstance(o)) 
      then
         decision ?= o 
         stdio.writeln(" name : " + decision.name) 
      end
   end
}</programlisting>

        <para>If your resource is dependent of other resources and that EMF
        succed to load it, the Repository that was used to load your resource
        will automatically load all these dependent resources.</para>
      </section>

      <section>
        <title>Save a model into an EMF Resource</title>

        <para>TODO : give an example.</para>
      </section>
    </section>

    <section id="section_packages.link">
      <title id="section_packages.title.link">Packages<phrase
      id="section_packages"></phrase></title>

      <section>
        <title>Definition</title>

        <para>Kermeta provides package to structure models. So you can define
        packages and sub-package as deep as you want. There are two main ways
        to do this, as shown in examples 2 and 3 (below). If you want to
        define some classes in a package you may define them in a specific
        file and start this file with a package naming directive (followed by
        a semi-colon) like in the following example<footnote id="ftn1">
            <para>Each kermeta file(.kmt) must declare a package
            directive.</para>
          </footnote>.</para>

        <para><emphasis role="strong">Example 1</emphasis>: 1 file.kmt == 1
        package naming directive</para>

        <programlisting><emphasis>// My file</emphasis>
<emphasis role="strong">package</emphasis> MyNewPackage;

<emphasis role="strong">class</emphasis> A { 
<emphasis>// ...</emphasis> 
}</programlisting>

        <programlisting>
<emphasis role="strong">class</emphasis> B {
<emphasis>// ...</emphasis> 
}</programlisting>

        <para>Here, classes A and B are defined in a package called
        "MyNewPackage". All classes defined in this file are under the scope
        of this package.</para>

        <para>You can also define explicitly sub-packages using braces (see
        the following example):</para>

        <para role="lineBreak"><emphasis role="strong">Example 2</emphasis>:
        Defining subpackages using braces</para>

        <programlisting><emphasis>// file : MyPackage-part1.kmt</emphasis>
<emphasis role="strong">package</emphasis> MyPackage;

<emphasis role="strong">package</emphasis> subPackage1 
{
    <emphasis role="strong">class</emphasis> A 
    {
<emphasis>// ...</emphasis>
    }
}

<emphasis role="strong">package</emphasis> subPackage2
{
    <emphasis role="strong">class</emphasis> B
    {
<emphasis>// ...</emphasis>
    }
}</programlisting>

        <para>In this example, we define a main package called "MyPackage"
        which contains 2 sub-packages "subPackage1" and "subPackage2". The
        first one contains the A class and the second one the B class.</para>
      </section>

      <section>
        <title>Use of packages</title>

        <para>TODO : example of use inside code (without the "using"
        primitive)</para>
      </section>

      <section id="section_using.link">
        <title id="section_using.title.link">Syntaxic sugars<phrase
        id="section_using"></phrase></title>

        <para>If you want, you can declare the same package in several files.
        You can also directly define subpackages in the package naming
        directive of your file (see example 1 above). In the following
        example, we define a new sub-package of "MyPackage" called
        "subPackage3" directly in the file. All features defined in this file
        will belong to this sub-package.</para>

        <para><emphasis role="strong">Example 3</emphasis>: Defining
        subpackage using <literal>::</literal> syntactic sugar</para>

        <programlisting><emphasis>// file : subPackage3.kmt</emphasis>
<emphasis role="strong">package</emphasis> MyPackage::subPackage3;

<emphasis role="strong">class</emphasis> C 
{
<emphasis>// ...</emphasis>
}</programlisting>

        <para>If a given file, when you want to use a class definition that is
        not in the scope of the current package inside which you are working,
        you have to provide the full path of this class definition to be able
        to use it. However, you can also define shortcuts to make your code
        clearer: the <literal>using</literal> primitive provides such a
        shortcut. Taking the previous example, it becomes:</para>

        <programlisting><emphasis>// file : MyPackage-part2.kmt</emphasis>
<emphasis role="strong">package</emphasis> MyPackage;

<emphasis role="strong">require</emphasis> "MyPackage-part1.kmt"

<emphasis role="strong">using</emphasis> subPackage1 <emphasis>// &lt;- "shortcut"!</emphasis> 

<emphasis role="strong">class</emphasis> C <emphasis role="strong">inherits</emphasis> A 
{
<emphasis></emphasis><emphasis>// ...</emphasis>
}</programlisting>

        <para>The using statement is a syntactical shorcut, it has no
        conterpart in kermeta metamodel.</para>

        <note><para>
           The using statement is different from the definition of a local datatype with an alias. (See 

          <xref endterm="section_alias.title.link"
                linkend="section_alias.link" />

           subsection ) 
        </para></note>
      </section>
    </section>

    <section id="section_collections.link">
      <title id="section_collections.title.link">Collections<phrase
      id="section_collections"></phrase></title>

      <para>Collections are widely used in kermeta not only because of their
      usual usage for collecting data in variables but also because they are
      used to represent <link linkend="section_properties.link">class
      property</link> when the multiplicity is greater than 1.</para>

      <para>Collections is one of the concept where the genericity is the most
      visible sinc it greatly helps to write more robust code.</para>

      <section>
        <title>Definition and initialization</title>

        <para>Kermeta defines some collection data types handling sets of
        values. The different available collection types are the result of a
        combination of the constraints <emphasis
        role="strong">unique</emphasis> and <emphasis
        role="strong">ordered</emphasis>.</para>

        <itemizedlist>
          <listitem>
            <para>Unique specifies a collection type that cannot contain
            doublet</para>
          </listitem>

          <listitem>
            <para>Ordered specifies a collection type where the position of an
            object inside the collection can be modified.</para>
          </listitem>
        </itemizedlist>

        <informaltable>
          <tgroup cols="4">
            <colspec colname="c1" colwidth="2.1cm" />

            <colspec colname="c2" colwidth="7.9cm" />

            <colspec colname="c3" colwidth="2.5cm" />

            <colspec colname="c4" colwidth="2.5cm" />

            <thead>
              <row>
                <entry morerows="1" valign="middle"><para>Name</para></entry>

                <entry morerows="1"
                valign="middle"><para>Description</para></entry>

                <entry nameend="c4"
                namest="c3"><para>Constraints</para></entry>
              </row>

              <row>
                <entry><para>Unique</para></entry>

                <entry><para>Ordered</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry valign="middle"><para>set</para></entry>

                <entry valign="middle"><para>Represents an unordered
                collection of objects with no doublet (Set)</para></entry>

                <entry align="center"
                valign="middle"><para>True</para></entry>

                <entry align="center"
                valign="middle"><para>False</para></entry>
              </row>

              <row>
                <entry valign="middle"><para>oset</para></entry>

                <entry valign="middle"><para>Represents an ordered collection
                of objects with no doublet (OrderedSet)</para></entry>

                <entry align="center"
                valign="middle"><para>True</para></entry>

                <entry align="center"
                valign="middle"><para>True</para></entry>
              </row>

              <row>
                <entry valign="middle"><para>seq</para></entry>

                <entry valign="middle"><para>Represents an ordered collection
                of objects (Sequence) </para></entry>

                <entry align="center"
                valign="middle"><para>False</para></entry>

                <entry align="center"
                valign="middle"><para>True</para></entry>
              </row>

              <row>
                <entry valign="middle"><para>bag</para></entry>

                <entry valign="middle"><para>Represents a basic collection of
                objects (Bag)</para></entry>

                <entry align="center"
                valign="middle"><para>False</para></entry>

                <entry align="center"
                valign="middle"><para>False</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <figure id="refIllustration4">
          <title>: The kermeta collections</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/collections.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>Another way to define set of objects would have been to use
        arrays. In fact, Kermeta does not define explicitly the concept of
        array, but it provides a multiplicity concept which can be used
        instead. Multiplicities are a way to define a lower and upper bound on
        a collection. Syntactically, lower and upper bounds are defined
        between brackets and are separated by two dots. Bounds can be an
        integer literal value or a star to specify there's no upper
        bound.</para>

        <para><emphasis role="strong">Example 1</emphasis>: how to declare
        collections</para>

        <programlisting>
using kermeta::standard		// don't need to specify it all the time
	<emphasis>// This is the simpliest and recommanded way of declaring a collection variable</emphasis>
	<emphasis role="strong">var</emphasis> myColA : Set&lt;Integer&gt; <emphasis>// this is equivalent to saying set Integer[0..*]</emphasis>
	<emphasis role="strong">var</emphasis> myColB : OrderedSet&lt;Integer&gt; <emphasis>// this is equivalent to saying oset Integer[0..*]</emphasis>
		</programlisting>

        <programlisting>
	<emphasis>// Collection with multiplicities</emphasis>
	<emphasis role="strong">var</emphasis> myCol1 : <emphasis role="strong">set</emphasis> Integer[4..6]<emphasis> // At least 4 elements and never more than 6</emphasis>
	<emphasis role="strong">var</emphasis> myCol3 : <emphasis role="strong">seq</emphasis> String[2..*]<emphasis> // At least two strings in the sequence</emphasis>
	<emphasis role="strong">var</emphasis> myCol4 : <emphasis role="strong">set</emphasis> String[1..*]<emphasis> // An non empty set</emphasis>
	<emphasis role="strong">var</emphasis> myCol5 : String[1..*]<emphasis> // If you don't specify any keyword, it is an ordered set</emphasis>
        </programlisting>

        <para>There is currently no way to define a collection by extension
        like you can do in C or Java. You must initialize your collection
        either by calling <literal>new</literal><emphasis role="strong">
        </emphasis>(Kermeta constructor operation) on your collection type, or
        initialize by copy.</para>

        <para><emphasis role="strong">Example 2</emphasis>: initialize
        collections</para>

        <programlisting><emphasis>// Example of declaration of variables as Collections. All those syntaxes are valid</emphasis>
<phrase id="DDE_LINK1"></phrase><emphasis role="strong">var</emphasis> myCol1 : <emphasis
            role="strong">set</emphasis> Integer[0..*]    <emphasis
            role="strong">init</emphasis> kermeta::standard::Set&lt;Integer&gt;.new
<emphasis>// Fill in myCol1</emphasis>
myCol1.add(10)
myCol1.add(50)

<emphasis role="strong">var</emphasis> myCol2 : <emphasis role="strong">oset</emphasis> String[0..*]    <emphasis
            role="strong">init</emphasis> kermeta::standard::OrderedSet&lt;String&gt;.new
<emphasis role="strong">var</emphasis> myCol3 : <emphasis role="strong">bag</emphasis> Boolean[0..*]    <emphasis
            role="strong">init</emphasis> kermeta::standard::Bag&lt;Boolean&gt;.new
<emphasis role="strong">var</emphasis> myCol4 : <emphasis role="strong">seq</emphasis> Integer[0..*]    <emphasis
            role="strong">init</emphasis> kermeta::standard::Sequence&lt;Integer&gt;.new
<emphasis>// if no keyword specified, and multiplicity is set, it is an OrderedSet</emphasis></programlisting>

        <programlisting><emphasis role="strong">var</emphasis> myCol4 : String[0..*]<emphasis
            role="strong">init</emphasis> kermeta::standard::OrderedSet&lt;String&gt;.new
</programlisting>

        <programlisting><emphasis role="strong">var</emphasis> myCol1a : <emphasis
            role="strong">seq</emphasis> Integer[0..*]    <emphasis
            role="strong">init</emphasis> myCol1
<emphasis role="strong">var</emphasis> myCol2a : <emphasis role="strong">oset</emphasis> String[0..*]    <emphasis
            role="strong">init</emphasis> myCol2
<emphasis role="strong">var</emphasis> myCol3a : kermeta::standard::Bag&lt;Boolean&gt; <emphasis
            role="strong">init</emphasis> myCol3
<emphasis role="strong">var</emphasis> myCol3a : kermeta::standard::Sequence&lt;Integer&gt; <emphasis
            role="strong">init</emphasis> myCol4</programlisting>

        <note><para>
           Conclusion : in most cases, you don't need to use this special syntax, you can simply use the generic collection names (Set&lt;Something&gt;, OrderedSet&lt;Something&gt;, etc.) available in Kermeta framework. Moreover, lower and upper bounds aren’t checked yet by Kermeta type checker and interpreter. 
        </para></note>
      </section>

      <section>
        <title>Some existing useful functions</title>

        <para>The collections in Kermeta implement several functions based on
        lambda expressions (see <xref
        linkend="section_lambda_expression.link" />). These ones are very
        useful for model navigation.</para>

        <para><emphasis role="strong">Example 1:</emphasis> closure
        definitions for collection manipulation in Kermeta</para>

        <programlisting>aCollection.<emphasis role="strong">each</emphasis> { e | 
    <emphasis>/* do something with each element e of this collection */</emphasis>
}
</programlisting>

        <programlisting>aBoolean := aCollection.<emphasis role="strong">forAll</emphasis> { e | <emphasis>/* put here a condition */</emphasis>
} <emphasis>// return true if the condition is true for all elements in the collection.</emphasis></programlisting>

        <programlisting>aCollection2 := aCollection.<emphasis role="strong">select</emphasis> { e | 
     <emphasis>/* put here a condition that returns true for elements that must  be included in the resulting Collection */</emphasis>
}
</programlisting>

        <programlisting>aCollection2 := aCollection.<emphasis role="strong">reject</emphasis> { e | 
     <emphasis>/* put here a condition that returns true for elements that must  be exclude in the resulting Collection */</emphasis>
}
</programlisting>

<programlisting><emphasis> // return a new collection which size is the same as in the original </emphasis>
<emphasis> // collection, and which element type is the type of the result of the expression.</emphasis>
aCollection2 := aCollection.<emphasis role="strong">collect</emphasis> { e | 
     <emphasis>/* put here an expression, for example e.name */</emphasis>
} 
</programlisting>

        <programlisting>anObject := aCollection.<emphasis role="strong">detect</emphasis> { e | <emphasis>/* a condition */</emphasis>} // returns an element (usually the first) that fulfill the condition.</programlisting>

        <programlisting>aBoolean := aCollection.<emphasis role="strong">exists</emphasis> { e | <emphasis>/* a condition */</emphasis>} // returns true if at least one element fulfill the condition.</programlisting>
      </section>
    </section>

    <section id="section_properties.link">
      <title id="section_properties.title.link">Class properties<phrase
      id="section_properties"></phrase></title>

      <para>A property of a (meta)class can be expressed in three ways : as a
      reference, an attribute, or a derived property. In Kermeta, each kind of
      these properties has a specific behavior and a dedicated syntax, which
      is <emphasis role="strong">attribute </emphasis>(for attribute),
      <emphasis role="strong">reference</emphasis> (for reference), <emphasis
      role="strong">property</emphasis> (for derived property)</para>

      <para role="lineBreak">References and attributes can have <emphasis
      role="strong">opposite</emphasis> properties. This last concept is
      explained in the following subsection.</para>

      <para>Unlike UML, there is no concept of visibility in kermeta, so every
      property is visible</para>

      <section id="section_properties-opposite.link">
        <title id="section_properties-opposite.title.link">Attributes
        <emphasis>(attribute)</emphasis>, references
        <emphasis>(reference)</emphasis> </title>

        <para>We introduce here the 2 first cases, which are relationships
        between two concrete entities.</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>attribute</emphasis>: an attribute defines a
            <emphasis>composition </emphasis>(e.g the black diamond) between
            two entities. The diamond-ed association end is navigable by
            definition</para>
          </listitem>
        </itemizedlist>

        <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
            role="strong">attribute</emphasis> x : <emphasis role="strong">set</emphasis> X[0..*] } 
<emphasis role="strong">class</emphasis> X {}</programlisting>

        <note><para>
           Composition notion also relates to containment notion. So, there are some restriction about valid model. For example, in an association, only one end can be an attribute, otherwise this means that we have an association with a diamond on both end and we cannot say who is the container of the other. 
        </para></note>

        <itemizedlist>
          <listitem>
            <para><emphasis>reference</emphasis>: a reference defines an
            association between two entities.</para>
          </listitem>
        </itemizedlist>

        <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
            role="strong">reference</emphasis> x : set X[0..*] } 
<emphasis role="strong">class</emphasis> X {}</programlisting>
      </section>

      <section>
        <title>properties modifiers</title>

        <para>Attributes, references and properties underlying collections may
        eventually be specialized. By default, they are represented by an
        OrderedSet. If you wish to be more precise and for exemple allow to
        have several item with the same value in your collection, you can use
        the collection modifiers as defined in <xref
        linkend="section_collections.link" /></para>

        <para>For example :</para>

        <programlisting>
class A {
	attribute x1 : seq String[0..*]  // allows duplicates, ordered
	attribute x2 : set String[0..*]  // doesn't allow duplicates, not ordered        
	attribute x3 : bag String[0..*]  // allows duplicates, not ordered               
	attribute x4 : oset String[0..*] // (default if no modifier) doesn't allow duplicates, ordered        
}        </programlisting>
      </section>

      <section>
        <title>Association using opposite properties</title>

        <para>The opposite [property] of a property defines an association
        (bidirectional link) between two entities. An opposite is expressed by
        a sharp #. In the following example, <literal>a</literal> is the
        opposite property of the entity of type B, and <literal>b</literal> is
        mutually the opposite property of the entity of type A.</para>

        <caution><para>
           A property whose type is a DataType (i.e String, Boolean, Integer) cannot have an opposite! 
        </para></caution>

        <para><emphasis role="strong">Example 1</emphasis>: definition of an
        attribute, a reference, and an opposite property</para>

        <para>This means that a can be accessed from b. Subsequently, if you
        modify the property b of an instance of A, it will mutually update its
        opposite property, i.e the property a of the instance of B contained
        in property b. You can make a test with the following example of
        code.</para>

        <para><emphasis role="strong">Example 2</emphasis>: navigability of
        opposite properties</para>

        <programlisting><emphasis role="strong">var</emphasis> a1 : A <emphasis
            role="strong">init</emphasis> A.new
a1.name := "a1"
<emphasis role="strong">var</emphasis> b1 : B <emphasis role="strong">init</emphasis> C.new
a1.b := b1
stdio.writeln("b1 opposite : " + b1.a.name) <emphasis>// This prints "a1"!</emphasis></programlisting>

        <para>The following paragraph shows a set of examples of attributes
        and references.</para>

        <figure id="refIllustration5">
          <title>Attributes and references</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/properties.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para><emphasis role="strong">Example 3</emphasis>: a set of
        attributes and references, with multiplicities and opposites.</para>

        <para>TODO : add an example of code using those classes !! See
        https://gforge.inria.fr/plugins/scmcvs/cvsweb.php/integration_projects/other/org.openembedd.formations/Kermeta/Basics/docs/FR_formation_Kermeta_1er_niveau.odp?cvsroot=openembedd
        for such examples (p. 21).</para>

        <programlisting><emphasis role="strong">package</emphasis> root;</programlisting>

        <programlisting>
<emphasis role="strong">class</emphasis> A1 {
    <emphasis role="strong">attribute</emphasis> b : B1[0..*] 
}
<emphasis role="strong">class</emphasis> B1 {}
			</programlisting>

        <programlisting>
<emphasis role="strong">class</emphasis> A2 {}
<emphasis role="strong">class</emphasis> B2 {
    <emphasis role="strong">reference</emphasis> a : A2 
}
			</programlisting>

        <programlisting>
<emphasis role="strong">class</emphasis> A3 {
    <emphasis role="strong">reference</emphasis> b : B3#a
}
<emphasis role="strong">class</emphasis> B3 {
    <emphasis role="strong">reference</emphasis> a : A3#b
}
			</programlisting>

        <programlisting>
<emphasis role="strong">class</emphasis> A4 {
    <emphasis role="strong">reference</emphasis> a : A4[0..*]
}</programlisting>

        <programlisting>
<emphasis role="strong">class</emphasis> A5 {
    <emphasis role="strong">attribute</emphasis> ab : A5[0..*]#aa
    <emphasis role="strong">reference</emphasis> aa : A5#ab
}</programlisting>

        <programlisting>
<emphasis role="strong">class</emphasis> A6 {
    <emphasis role="strong">attribute</emphasis> b : B6#a
}
<emphasis role="strong">class</emphasis> B6 {
    <emphasis role="strong">reference</emphasis> a : A6[1..1]#b
}</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> A7 {
    <emphasis role="strong">attribute</emphasis> b : B7[0..*]#a
}
<emphasis role="strong">class</emphasis> B7 {
    <emphasis role="strong">reference</emphasis> a : A7#b 
}</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> A8 {
    <emphasis role="strong">attribute</emphasis> b : B8[1..1]#a
}
<emphasis role="strong">class</emphasis> B8 {
    <emphasis role="strong">reference</emphasis> a : A8#b
}</programlisting>

        <programlisting><emphasis role="strong">class</emphasis> A9 {}
<emphasis role="strong">class</emphasis> B9 {
    <emphasis role="strong">reference</emphasis> a : A9[1..1]
}</programlisting>

        <note><para>
           For every case where the upper bound of a property is upper to 1, the type of the property is 

          <literal>OrderedSet</literal>

           . The reader will refer to 

          <xref linkend="section_collections.link" />

           (except the bag type) to have the available types for a [m..n](n&gt;1) multiplicity property. 
        </para></note>
      </section>

      <section id="section_derived_properties.link">
        <title id="section_derived_properties.title.link">Derived properties
        <emphasis>(property)</emphasis></title>

        <para>In a class definition, a derived property is a property that is
        derived or calculated, i.e it contains a body, like operations.
        Usually, such properties are calculated from other properties
        available from its owning class definition. In practice, you can
        define the code that you want inside a derived property.</para>

        <para>In other words it does not reference to a concrete entity: it is
        calculated, through the accessor operations getter and setter.</para>

		<para>The special parameter <literal>value</literal> is used in the setter 
		to get the value passed when calling the setter.</para>
        <para>Let's take the following class definitions :</para>

        <programlisting><emphasis>// readonly property : it has no setter</emphasis>
<emphasis role="strong">class</emphasis> A 
{
    <emphasis role="strong">attribute</emphasis> period : Real
    <emphasis role="strong">property</emphasis> <emphasis role="strong">readonly</emphasis> frequency : Real <emphasis>// property : keyword for derived property</emphasis>
        <emphasis role="strong">getter</emphasis> <emphasis role="strong">is</emphasis> do
            <emphasis role="strong">result</emphasis> := 1/period
        <emphasis role="strong">end</emphasis>
}
<emphasis>// modifiable property :</emphasis>
<emphasis role="strong">class</emphasis> B 
{
    <emphasis role="strong">attribute</emphasis> period : Real
    <emphasis role="strong">property</emphasis> frequency : Real
        <emphasis role="strong">getter</emphasis> <emphasis role="strong">is</emphasis> <emphasis
            role="strong">do</emphasis>
            <emphasis role="strong">result</emphasis> result := 1/period
        <emphasis role="strong">end</emphasis>
        <emphasis role="strong">setter</emphasis> <emphasis role="strong">is</emphasis> <emphasis
            role="strong">do</emphasis>
            period := 1/<emphasis role="strong">value</emphasis>
        <emphasis role="strong">end</emphasis>
}

// a typical use would be (with aB an instance of class B) 
<emphasis role="strong">var</emphasis> freq : Real
fred := aB.frequency // to use the getter
aB.frequency := freq + 1 // to use the setter, the period is also updated in the process 
</programlisting>

		<note><para>To understand to role of the <literal>value</literal> keyword, you can imagine 
			that in this sample the setter syntax is a shortcut syntax of :   
			
			<literal>
			setter( value : Real) is do ...
			</literal> (even if actually this syntax isn't supported). 
			</para>
		</note>
		<warning><para>
         Since derived properties aims to behave like attributes or references, if the multiplicity is greater than 1,
         it doesn't make sense to define a setter. This is because it means reassigning the internal collection which is in fact calculated. 
      </para></warning>
        <para>Properties are accessed or modified as classical properties. See
        next subsection for examples.</para>
      </section>

      <section>
        <title>How to access and control the properties in Kermeta</title>

        <para><emphasis role="strong">Example 1</emphasis>: let's take the
        example with A6 and B6 :</para>

        <programlisting><emphasis role="strong">class</emphasis> A6 {
     <emphasis role="strong">attribute</emphasis> b : B6[0..*]#a
}

<emphasis role="strong">class</emphasis> B6 {
    <emphasis role="strong">reference</emphasis> a : A6#b 
}</programlisting>

        <informaltable>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="3.8cm" />

            <colspec colname="c2" colwidth="13.2cm" />

            <thead>
              <row>
                <entry><para>Access</para></entry>

                <entry><para>Kermeta expression</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para>Get the attribute of an instance</para></entry>

                <entry><programlisting><emphasis role="strong">var</emphasis> a6 : A6 <emphasis
                      role="strong">init</emphasis> A6.new
<emphasis role="strong">var</emphasis> b6 : OrderedSet&lt;B6&gt;
<emphasis>// get the b attribute</emphasis>
<emphasis>// Note that as the attribute as a multiplicity &gt;1 it is an OrderedSet </emphasis>
b6 := a6.b</programlisting></entry>
              </row>

              <row>
                <entry><para>Add an element to a property with multiplicity
                [m..n], n&gt;1</para></entry>

                <entry><programlisting><emphasis role="strong">var</emphasis> a6 : A6 init A6.new
<emphasis role="strong">var</emphasis> b6 : B6 init B6.new
<emphasis>// add b6 to the attribute b of A.</emphasis> 
<emphasis>// </emphasis><emphasis>Note : you don’t have to initialize b! done through A6.new</emphasis>
a6.b.add(b6)</programlisting></entry>
              </row>

              <row>
                <entry><para>Remove an element from a property</para></entry>

                <entry><programlisting><emphasis>// OrderedSet owns a method that removes an element given its
     // index in the set. For unordered sets, use "remove" method</emphasis>
a6.b.removeAt(0)
<emphasis>// Also valid : a6.b.remove(b6)</emphasis></programlisting></entry>
              </row>

              <row>
                <entry><para>Get the opposite of a property</para></entry>

                <entry><programlisting><emphasis role="strong">var</emphasis> a6 : A6 init A6.new
<emphasis role="strong">var</emphasis> b6 : B6 init B6.new
a6.b.add(b6)
<emphasis>// this assertion is true. Moreover, any instance in a6.b will
// have a6 as their opposite since b is a collection</emphasis>
assert(b6.a == a6)</programlisting></entry>
              </row>

              <row>
                <entry><para>Get the container of a property</para></entry>

                <entry><programlisting><emphasis role="strong">var</emphasis> a6 : A6 <emphasis
                      role="strong">init</emphasis> A6.new
<emphasis role="strong">var</emphasis> b6 : B6 <emphasis role="strong">init</emphasis> B6.new
<emphasis>// add ab6 to the attribute "b"</emphasis>
a6.b.add(b6)</programlisting> <programlisting><emphasis role="strong">var</emphasis> a6c : A6 <emphasis
                      role="strong">init</emphasis> b6.container()
<emphasis>// this assertion is true</emphasis>
assert(a6c.equals(a6))</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>It is not different with references that have a [m..1] (m=0 or
        m=1) multiplicity:</para>

        <para><emphasis role="strong">Example 2</emphasis>: the A5 B5
        case</para>

        <programlisting><emphasis role="strong">class</emphasis> A5 {
    <emphasis role="strong">attribute</emphasis> b : B5#a <emphasis>// no multiplicity means [0..1]</emphasis>
}
<emphasis role="strong">class</emphasis> B5 {
    <emphasis role="strong">reference</emphasis> a : A5[1..1]#b
}</programlisting>

        <informaltable>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="3.8cm" />

            <colspec colname="c2" colwidth="13.2cm" />

            <thead>
              <row>
                <entry><?border-top 0.0007inch solid #000000?><para>Access</para></entry>

                <entry><?border 0.0007inch solid #000000?><para>Kermeta
                expression</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para>Get the attribute of an instance</para></entry>

                <entry><programlisting><emphasis role="strong">var</emphasis> a5 : A5 <emphasis
                      role="strong">init</emphasis> A5.new
<emphasis role="strong">var</emphasis> b5 : B5
<emphasis>// get the b attribute</emphasis>
b5 := a5.b</programlisting></entry>
              </row>

              <row>
                <entry><para>Set a property (with multiplicity [m..1],
                m≤1)</para></entry>

                <entry><programlisting><emphasis role="strong">var</emphasis> a5 : A5 init A5.new
<emphasis role="strong">var</emphasis> b5 : B5 init B5.new
<emphasis>// set b5 to the attribute b of A.</emphasis>
a5.b := b5</programlisting></entry>
              </row>

              <row>
                <entry><para>Unset a property</para></entry>

                <entry><programlisting>a5.b := void</programlisting></entry>
              </row>

              <row>
                <entry><para>Get the opposite of a property</para></entry>

                <entry><programlisting><emphasis role="strong">var</emphasis> a5 : A5 init A5.new
<emphasis role="strong">var</emphasis> b5 : B5 init B5.new
a5.b := b5
<emphasis>// this assertion is true.</emphasis>
assert(b5.a == a5)</programlisting></entry>
              </row>

              <row>
                <entry><para>Get the container of a property</para></entry>

                <entry><programlisting><emphasis role="strong">var</emphasis> a5 : A5 <emphasis
                      role="strong">init</emphasis> A5.new
<emphasis role="strong">var</emphasis> b5 : B5 <emphasis role="strong">init</emphasis> B5.new
<emphasis>// add b5 to the attribute "b"</emphasis>
a5.b := b5</programlisting> <programlisting><emphasis role="strong">var</emphasis> a5c : A5 <emphasis
                      role="strong">init</emphasis> b5.container()
<emphasis>// this assertion is true</emphasis>
assert(a5c.equals(a5))</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <note><para>
           Be careful with attributes or references ref with multiplicity greater than 1, they are automatically initialized with a reflective collection (ie. a collection that is aware of an eventual opposite). So, you cannot assign them using := If you wish to change completely its content with the one of another collection, you must use the 

          <literal>clear</literal>

           and 

          <literal>addAll</literal>

           operations. 
        </para></note>
      </section>

      <section id="section_assignment_behavior_4_attribute.link">
        <title>Assignment behavior for attribute (and reference)</title>

        <para>Attribute and reference have one main behavior
        difference.</para>

        <para>Attribute has a notion of containment that reference
        hasn't.</para>

        <para>This has some implication on the behavior of the assignment
        because an attribute cannot be owned by more than one object at a
        time.</para>

        <para>There is an exception for attributes which type is a primitive
        type (String, Integer, Boolean, Real, Char) : since those types inherit from <literal>ValueType</literal>, 
        they are not concerned by the composition, opposite concepts.
        In this case, the assignment doesn't impact any value but the assigned one.</para>

        <para><emphasis role="strong">Example 1</emphasis>: Assignment
        behavior for attribute</para>

        <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
            role="strong">attribute</emphasis> c1 : C }
<emphasis role="strong">class</emphasis> B { <emphasis role="strong">attribute</emphasis> c2 : C }
<emphasis role="strong">class</emphasis> C { }
aA.c1 := C.new
aB.c2 := aA.c1     <emphasis>// now aA.c1 == void !!!</emphasis></programlisting>

        <para><emphasis role="strong">Example 2</emphasis>: Assignment
        behavior for reference</para>

        <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
            role="strong">reference</emphasis> c1 : C }
<emphasis role="strong">class</emphasis> B {<emphasis role="strong"> reference</emphasis> c2 : C }
<emphasis role="strong">class</emphasis> C { }

aA.c1 := C.new
aB.c2 := aA.c1     <emphasis>// aB.c2 == aA.c1 and aA.c1 keeps its value !!!</emphasis></programlisting>

        <para><emphasis role="strong">Example 3</emphasis>: Assignment
        behavior for attribute which type is String</para>

        <programlisting><emphasis role="strong">class</emphasis> A { <emphasis
            role="strong">reference</emphasis> c1 : String }<emphasis
            role="strong">class</emphasis> B {<emphasis role="strong"> reference</emphasis> c2 : String }aA.c1 := "Robert"aB.c2 := aA.c1 // aB.c2 == aA.c1 == "Robert"</programlisting>

        <note><para>
           The assignment into a 

          <literal>variable</literal>

           or a 

          <literal>reference</literal>

           is not a problem because it doesn't change the owner of the assigned object. 
        </para></note>
      </section>
    </section>

    <section id="section_object_comparison.link">
      <title id="section_object_comparison.title.link">Objects
      comparison<phrase id="section_objects_comparison"></phrase></title>

      <para>Kermeta users could be confused about <literal>==</literal>
      operator and <literal>equals</literal> method. Unlike, Java they do the
      same and redefining the equals to compare the content also affects the
      <literal>==</literal>.</para>

      <para>To compare the identity of two objects you must compare the
      identifier of each object : using their oid</para>

      <section>
        <title>equals method</title>

        <para>The <emphasis>equals</emphasis> method behaves the same way as
        in java. This means that you can overwrite it, if you want to compare
        the contents of two objects of the same class.</para>

        <programlisting>@mainClass "root::Main"
@mainOperation "main"

package root;

require kermeta
using kermeta::standard
using kermeta::kunit
class A {

  reference x : Integer

  method equals(compared : Object) : Boolean is do
    var castedCompared : A
    castedCompared ?= compared
    result := x.equals (castedCompared.x)
  end

}


class Main inherits kermeta::kunit::TestCase{

  operation main() : Void is do

    var a1 : A init A.new
    var a2 : A init A.new
 
    a1.x := 10
    a2.x := 20

    assert( not a1.equals(a2) )	// objects are different with all methods
    assert( not a1 == a2 )
    assert ( a1.oid == a2.oid ) 

    a2.x := 10
 
    assert ( a1.equals(a2) ) 	// objects becomes equals
    assert ( a1 == a2  )		// also with ==
    assert ( a1.oid == a2.oid ) // but they physically are still different

  end

}</programlisting>
      </section>

      <section>
        <title>Comparison for Primitive Types</title>

        <para>In Kermeta language, there is a notion of primitive type. Here
        is the list of primitive types :</para>

        <itemizedlist>
          <listitem>
            <para>Boolean</para>
          </listitem>

          <listitem>
            <para>Integer</para>
          </listitem>

          <listitem>
            <para>String</para>
          </listitem>

          <listitem>
            <para>Character</para>
          </listitem>
          <listitem>
            <para>Real</para>
          </listitem>
        </itemizedlist>

        <para>We do not want two Integer objects with the same value to be
        different. What we want is to use <emphasis>==</emphasis> operator to
        compare values of primitive types. These classes simply redefine the
        equals. Then we can write this code :</para>

        <programlisting>var i1 : Integer init 10
var i2 : Integer init 10
assert (i1.equals(i2))

var i3 : Integer init 10
var i4 : Integer init 10
assert (i3 == i4)
</programlisting>
      </section>

      <section>
        <title>Collection comparison</title>

        <para>The method <literal>equals</literal> exists for the collections. The generic behavior
        is the following : for two collections a and b, if all elements of a
        are contained in b and vice-versa, then it returns true, false
        otherwise. This behavior is little bit different for ordered
        collection which takes into account the order of elements. Have a look
        to the following pieces of code :</para>

        <programlisting>operation test_try1() : Void is do
   var os : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os.add(1) os.add(2) os.add(3) os.add(4) os.add(5) os.add(6)

   var os2 : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os2.add(1) os2.add(2) os2.add(3) os2.add(4) os2.add(5) os2.add(6)

   assert (os.equals(os2) )
end

operation test_try2() : Void is do
   var os : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os.add(1) os.add(2) os.add(3) os.add(4) os.add(5) os.add(6)

   var os2 : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os2.add(1) os2.add(2) os2.add(3) os2.add(4) os2.add(5)

   assert ( not os.equals(os2) )
end

/**
 * An ordered set takes care about the order.
 */
operation test_try3() : Void is do
   var os : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os.add(1) os.add(2) os.add(3) os.add(4) os.add(5) os.add(6)

   var os2 : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os2.add(4) os2.add(6) os2.add(3) os2.add(1) os2.add(5) os2.add(2)

   assert ( not os.equals(os2) )
end

/**
 * A set does not care about the order.
 */
operation test_try4() : Void is do
   var os : Set&lt;Integer&gt; init Set&lt;Integer&gt;.new
   os.add(1) os.add(2) os.add(3) os.add(4) os.add(5) os.add(6)

   var os2 : Set&lt;Integer&gt; init Set&lt;Integer&gt;.new
   os2.add(4) os2.add(6) os2.add(3) os2.add(1) os2.add(5) os2.add(2)

   assert ( os.equals(os2) )
end
</programlisting>
      </section>
    </section>

    <section id="section_lambda_expression.link">
      <title id="section_lambda_expression.title.link">Lambda Expressions and
      functions<phrase id="section_lambda_expressions"></phrase></title>

      <para><phrase id="section_lambda_expression"></phrase>Kermeta proposes an
      implementation of lambda expressions, that is mainly useful for
      implementing OCL-like functions.</para>

      <note><para>
         Limitations of lambda expressions usage:An operation with a function as parameter : if you define an operation which has a function as a parameter ( ex: 

        <literal>operation op( func : &lt;Integer-&gt;Object&gt;)</literal>

         ), then you cannot put more parameters : only one parameter is allowed in such a case. 
      </para></note>

      <section id="section_function-syntax.link">
        <title id="section_function-syntax.title.link">Syntax<phrase
        id="sec:function-syntax"></phrase></title>

        <para>Here is a definition of function syntax (this is not a formal
        representation)</para>

        <itemizedlist>
          <listitem>
            <para>Signature of an operation defined as a function:</para>

            <programlisting><emphasis>// With one parameter</emphasis>
<emphasis role="strong">operation</emphasis> FUNCTION_NAME ( LAMBDA_NAME : &lt;TYPE-&gt;RETURN_TYPE&gt; )
<emphasis>// With many parameters</emphasis>
<emphasis role="strong">operation</emphasis> FUNCTION_NAME ( LAMBDA_NAME : &lt;[TYPE_1, TYPE_2, ...]-&gt;RETURN_TYPE&gt; )</programlisting>
          </listitem>

          <listitem>
            <para>Call of a function:</para>

            <programlisting>anInstance.FUNCTION_NAME ( TYPE | SOME_CODE )
anInstance.FUNCTION_NAME ( TYPE_1, TYPE_2 | SOME_CODE )</programlisting>
          </listitem>

          <listitem>
            <para>Declaring and defining an "anonymous" function inside an
            operation body</para>

            <programlisting><emphasis role="strong">var</emphasis> f : &lt;TYPE -&gt; RETURN_TYPE&gt;
<emphasis role="strong"></emphasis>f := <emphasis role="strong">function</emphasis> { VAR_NAME : TYPE | SOME_CODE_WITH_RETURN_TYPE_RESULT }

<emphasis role="strong">var</emphasis> f : &lt;[ TYPE_1, TYPE_2,... ] -&gt; RETURN_TYPE&gt;
f := <emphasis role="strong">function</emphasis> { VAR_NAME_1 : TYPE_1, VAR_NAME_2 : TYPE_2,... | SOME_CODE_WITH_RETURN_TYPE_RESULT }</programlisting>
          </listitem>
        </itemizedlist>

        <para>In the following sections, you will find many examples of
        declarations, definitions, and uses of functions.</para>
      </section>

      <section>
        <title>Some existing useful functions</title>

        <para>The collections in Kermeta implement several functions based on
        lambda expression. These ones are very useful for model
        navigation.</para>

        <para><emphasis role="strong">Example 1:</emphasis> closure definition
        for collection iterator-like in Kermeta</para>

        <programlisting>aCollection.<emphasis role="strong">each</emphasis> { e | 
    <emphasis>/* do something with each element e of this collection */</emphasis>
}
</programlisting>

        <para>See <xref linkend="section_collections.link" /> for other
        existing functions on collections.</para>

        <para><emphasis role="strong">Example 2:</emphasis> another useful
        function that is defined on Integer : the function times</para>

        <programlisting>10.<emphasis role="strong">times</emphasis> { i | stdio.writeln(i.toString) } <emphasis>// prints 0 to 9</emphasis> </programlisting>

        <para>Notice that you can also write some complex code in the
        function, using internal variables, etc. In such a case, the last
        statement evaluation will be the returned result of the lambda
        expression (provided it is declared to return something)</para>

        <para><emphasis role="strong">Example 3</emphasis>: complex code in a
        lambda expression</para>

        <programlisting>aCollection.<emphasis role="strong">each</emphasis> { e | 
    <emphasis>stdio.writeln("I am complex code!"
    stdio.writeln("Element : " + e.toString)
<emphasis>    var i : Integer init 5
    i := i + 132458</emphasis>
}</emphasis></programlisting>

		<para><emphasis role="strong">Example 4</emphasis>: postponing parameter evaluation in the andThen operation</para>
		<para>The operation andThen and orElse of Boolean use the ability of functions to postpone the parameter evaluation.
		This allows to implement the expected behavior without adding new construct to the language.
		</para>
        <programlisting>
        // this kind of code allows to avoid a cast exception on the second test
        if cl.isInstanceOf(NamedElement).andThen{f|	cl.asType(NamedElement).name == "foo"} then
        	// do something...
        end                
        </programlisting>
        <note><para>The parameter <literal>f</literal> is not used in this function. This is due to the current 
        surface syntax of Kermeta which need at least one parameter. In this case, it's value is void.
        </para></note>
      </section>

      <section>
        <title>Defining new functions in a class</title>

        <para>You can also define your own functions, by declaring an
        operation, with a parameter as a function using the syntax described
        in <xref linkend="section_function-syntax.link" />.</para>

        <para><emphasis role="strong">Example</emphasis>: definition of
        functions for collections</para>

        <programlisting><emphasis role="strong">abstract</emphasis> <emphasis
            role="strong">class</emphasis> Collection&lt;G&gt;
{     
     <emphasis>/** * runs func on each element of the collection */</emphasis>
     <emphasis role="strong">operation</emphasis> each(func : &lt;G -&gt; Object&gt;) : Void <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
         <emphasis role="strong">from</emphasis> <emphasis role="strong">var</emphasis> it : Iterator&lt;G&gt; <emphasis
            role="strong">init</emphasis> iterator
         <emphasis role="strong">until</emphasis> it.isOff
         <emphasis role="strong">loop</emphasis>
             func(it.next)
         <emphasis role="strong">end</emphasis>
      <emphasis role="strong">end</emphasis></programlisting>

        <programlisting>     <emphasis>/** * checks that the condition is true on all the element of the collection * returns true if the collection is empty */</emphasis>
     <emphasis role="strong">operation</emphasis> forAll(func : &lt;G -&gt; Boolean&gt;) : Boolean <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
         <emphasis role="strong">var</emphasis> test : Boolean <emphasis
            role="strong">init</emphasis> true
         <emphasis role="strong">from</emphasis> <emphasis role="strong">var</emphasis> it : Iterator&lt;G&gt; init iterator
         <emphasis role="strong">until</emphasis> it.isOff
         <emphasis role="strong">loop</emphasis>
            test := test <emphasis role="strong">and</emphasis> func(it.next)
         <emphasis role="strong">end</emphasis>
         <emphasis role="strong">result</emphasis> := test
     <emphasis role="strong">end</emphasis>
}</programlisting>
      </section>

      <section>
        <title>Defining lambda expression variables</title>

        <para>You can also define lambda expression as variable. This can be
        useful if you don't want to ( or can't) modify the class.</para>

        <itemizedlist>
          <listitem>
            <para>A basic lambda expression</para>
          </listitem>
        </itemizedlist>

        <para>With one Integer argument and returning an Integer.</para>

        <programlisting><emphasis role="strong">var</emphasis> aLambdaExp : &lt;Integer-&gt;Integer&gt;
<emphasis role="strong">var</emphasis> aLambdaResult : Integer
aLambdaExp := <emphasis role="strong">function</emphasis> { i : Integer | i.plus(4) }
<emphasis>// aLambdaResult equals 7</emphasis>
aLambdaResult := aLambdaExp(3)</programlisting>

        <itemizedlist>
          <listitem>
            <para>A lambda expression with several parameters</para>
          </listitem>
        </itemizedlist>

        <programlisting><emphasis role="strong">var</emphasis> aLambdaExp : &lt;[Integer, Integer]-&gt;Integer&gt;
<emphasis role="strong">var</emphasis> aLambdaResult : Integer
aLambdaExp := <emphasis role="strong">function</emphasis> { i : Integer, j : Integer | i * j }
<emphasis>// aLambdaResult equals 12</emphasis>
aLambdaResult := aLambdaExp(3, 4)</programlisting>

        <itemizedlist>
          <listitem>
            <para>A lambda expression on a collection</para>
          </listitem>
        </itemizedlist>

        <programlisting><emphasis role="strong">var</emphasis> sequence : Sequence&lt;Integer&gt; <emphasis
            role="strong">init</emphasis> Sequence
<emphasis role="strong">var</emphasis> init_set : Set&lt;Integer&gt; <emphasis
            role="strong">init</emphasis> Set&lt;Integer&gt;.new
init_set.add(32)
init_set.add(23)
init_set.add(41)

<emphasis>// This sequence equals : [320, 230, 41]</emphasis>
sequence := init_set.collect { element | element*10}</programlisting>

        <para>The code within the function can be as complex as you want,
        using internal variables, etc.</para>

        <programlisting>    <emphasis role="strong">var</emphasis> factoExp : &lt;Integer-&gt;Integer&gt;
    factoExp := <emphasis role="strong">function</emphasis> { n : Integer | 
        <emphasis role="strong">var</emphasis> fact : Integer <emphasis
            role="strong">init</emphasis> 1
        <emphasis role="strong">from</emphasis> var x : Integer <emphasis
            role="strong">init</emphasis> 1 
        <emphasis role="strong">until</emphasis> x &gt; n 
        <emphasis role="strong">loop</emphasis>
            fact := fact * x 
            x:=x+1
        <emphasis role="strong">end</emphasis>
        fact <emphasis>// return fact as the result of the function</emphasis>
        <emphasis>//shorter alternative ;-)... if n&lt;=1 then 1 else factoExp(n -1) * n end</emphasis>

    }
    <emphasis role="strong">var</emphasis> cnkExp : &lt;[Integer, Integer]-&gt;Integer&gt;
    cnkExp := <emphasis role="strong">function</emphasis> { n : Integer, k : Integer |
        factoExp(n) / (factoExp(k) * factoExp(n-k))
    }</programlisting>
      </section>
    </section>

    <section id="section_dynamic_expressions.link">
      <title id="section_dynamic_expressions.title.link">Dynamic evaluation of
      Kermeta expressions<phrase
      id="section_dynamic_expressions"></phrase></title>

      <para><phrase id="dynamic_expression"></phrase>Kermeta allow you to
      evaluate dynamically a Kermeta Expression with a specific
      context.</para>

      <para><emphasis role="strong">Example 1</emphasis>: my first dynamic
      expression</para>

      <programlisting><emphasis role="strong">var</emphasis> de : DynamicExpression <emphasis
          role="strong">init</emphasis> DynamicExpression.new
de.initializeDefaults
de.formalParameters.put(<emphasis>"a"</emphasis>, String)
de.parse(<emphasis>"stdio.writeln(a)"</emphasis>)
<emphasis role="strong">var</emphasis> params : Hashtable&lt;String, Object&gt; <emphasis
          role="strong">init</emphasis> Hashtable&lt;String, Object&gt;.new
params.put(<emphasis>"a"</emphasis>, <emphasis>"hello world!"</emphasis>)
de.execute(void, params)</programlisting>

      <para>If you want to dynamically evaluate more than one statement, you
      will have to surround your set of statements with "do.. end"
      block:</para>

      <para role="lineBreak"><emphasis role="strong">Example 2</emphasis>: yet
      another example</para>

      <programlisting><emphasis>// let's get previous example and modify it </emphasis><emphasis></emphasis><emphasis>// [...] (carriage return is not necessary inside the block)</emphasis>
de.parse(<emphasis>"do stdio.writeln(a) stdio.writeln("another stdio writeln ... ") end"</emphasis>)
<emphasis>// [...]</emphasis></programlisting>

      <para><emphasis role="strong">Example 3</emphasis>: another more complex
      sample of dynamic expressions :</para>

      <programlisting><emphasis role="strong">package</emphasis> testDynamicExpression;

<emphasis role="strong">using</emphasis> kermeta::interpreter
<emphasis role="strong">using</emphasis> kermeta::utils
<emphasis role="strong">using</emphasis> kermeta::standard

<emphasis role="strong">class</emphasis> TestMain
{

    <emphasis role="strong">operation</emphasis> TestToto() <emphasis
          role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        stdio.writeln("J'ai essayé de lancer testtoto!")
    <emphasis role="strong">end</emphasis>

    <emphasis role="strong">operation</emphasis> testDynExp() <emphasis
          role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">var</emphasis> dynExpr : DynamicExpression <emphasis
          role="strong">init</emphasis> DynamicExpression.new
        dynExpr.initializeDefaults()

        <emphasis role="strong">self</emphasis>.getMetaClass.ownedOperation.select{op| <emphasis
          role="strong">not</emphasis>( op.name.indexOf("Test")==-1)
and op.name.indexOf("All")==-1}

            .collect{op|op.name}.each{opName|

                    stdio.writeln("execution de "+opName)
                    dynExpr.initializeDefaults
                    dynExpr.parse("testDynamicExpression ::TestMain.new." +opName)
                    dynExpr.execute(void,Hashtable&lt;String,Object&gt;.new)
            }
    <emphasis role="strong">end</emphasis>
}</programlisting>

      <caution><para>
         You cannot use "self" inside a dynamic expression 
      </para></caution>
    </section>

    <section id="section_contracts.link">
      <title id="section_contracts.title.link">Design by contract (pre, post,
      inv contraints)<phrase id="section_contracts"></phrase></title>

      <para>In Kermeta, a contract is specified by "pre" and "post" conditions
      and by the "invariant" constraint too.</para>

      <section>
        <title>Writing a contract</title>

        <section id="section_pre_post_syntax.link">
          <title>pre – post conditions syntax</title>

          <para>A pre or a post condition is a boolean expression that may be
          a simple equality checking or a lambda expression. The Kermeta
          interpreter evaluates the body content like a boolean result</para>

          <para>The "pre condition" are declared just before the "is" of the
          operation body</para>

          <programlisting><emphasis role="strong">operation</emphasis> opName(c : String) : String
    
    <emphasis>// Declaration of the pre-condition</emphasis>
    <emphasis role="strong">pre</emphasis> notVoidInput <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        c != <emphasis role="strong">void</emphasis> and c != ""
    <emphasis role="strong">end</emphasis>

    <emphasis>// Declaration of the post-condition</emphasis>
    <emphasis role="strong">post</emphasis> notVoidOutput <emphasis
              role="strong">is</emphasis>
        <emphasis role="strong">result</emphasis> != <emphasis role="strong">void</emphasis> and <emphasis
              role="strong">result</emphasis> != ""

<emphasis role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        // operation body
    <emphasis role="strong">end</emphasis></programlisting>

          <tip><para>
             If the body contains only one expression, the block declaration "do ... end" is not mandatory. If your block contains several instructions, the latest one will be evaluated as a boolean expression. 
          </para></tip>
        </section>

        <section id="section_inv_syntax.link">
          <title>Invariant constraint syntax</title>

          <para>An invariant constraint is declared anywhere in a
          ClassDefinition block.</para>

          <para>An invariant declaration is a boolean expression that may be a
          simple equality checking or a lambda expression. The Kermeta
          interpreter evaluates the body content like a boolean result.</para>

          <para>A very simple example :</para>

          <programlisting><emphasis role="strong">class</emphasis> className {

    ...

    <emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
    <emphasis role="strong">inv</emphasis> nameOfTheInvariant <emphasis
              role="strong">is do</emphasis>
        <emphasis role="strong">self</emphasis>.name != ""
    <emphasis role="strong">end</emphasis>

    ...
}</programlisting>

          <tip>
            <para>If the body contains only one instruction, the block
            declaration "do ... end" is not mandatory.</para>

            <programlisting><emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
<emphasis role="strong">inv</emphasis> nameOfTheInvariant <emphasis
                role="strong">is self</emphasis>.name != ""</programlisting>
          </tip>

          <para>A lambda expression can be used into an invariant
          declaration:</para>

          <programlisting><emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
<emphasis role="strong">inv</emphasis> deterministicTransition <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
    <emphasis role="strong">self</emphasis>.outgoingTransition.forAll{tr1 |
        <emphasis role="strong">self</emphasis>.outgoingTransition.forAll{ tr2 |
            ( tr2.input==tr1.input ) == (tr1==tr2)
        }
    }
<emphasis role="strong">end</emphasis></programlisting>
        </section>
      </section>

      <section>
        <title>Checking your constraints</title>

        <section>
          <title>Checking pre – post condition</title>

          <para>The activation of the checking of the pre - post conditions
          depends of the run configuration, see the Kermeta UI user guide for
          more information.</para>

          <para>If the boolean statement is evaluated to "false" then the pre
          or post condition is violated and an exception
          <literal>ConstraintViolatedPre</literal> or
          <literal>ConstraintViolatedPost</literal> is raised.</para>
        </section>

        <section>
          <title>Checking invariant</title>

          <para>In order to check the well-formedness rules of a model
          element, there are two methods in Kermeta. The first-one :
          <literal>checkInvariants</literal>, consists to check only the
          current model element and the second-one :
          <literal>checkAllInvariants</literal>, checks recursively the
          element being a containment link with the checked element.</para>

          <programlisting>theModelElement.checkInvariants
</programlisting>

          <para>The checkAllInvariants operation is a recursive method which
          checks all the elements having a containment relation by
          transitivity with the checked element.</para>

          <para>checkAllInvariants is used especially to check the validity of
          a model fragment or a complete model.</para>

          <programlisting>theModelElement.checkAllInvariants</programlisting>

          <para>If the boolean statement is evaluated to
          "<literal>false</literal>" then the invariant constraint is violated
          and an exception <literal>ConstraintViolatedInv</literal> is raised.
          This exception can be handled by a <literal>rescue</literal>
          call.</para>

          <programlisting><emphasis>// Call the invariant verification</emphasis>
<emphasis role="strong">do</emphasis>
    theModelElement.checkInvariants
    <emphasis role="strong">rescue</emphasis> (err : ConstraintViolatedInv)
        stdio.writeln(err.toString)
        stdio.write(err.message)
<emphasis role="strong">end</emphasis></programlisting>
        </section>
      </section>
    </section>

    <section id="section_weaving.link">
      <title id="section_weaving.title.link">Weaving kermeta code<phrase
      id="section_weaving"></phrase></title>

      <para>Since version 0.4.1, it is possible to write Kermeta code using a
      simplified Aspect Oriented approach.</para>

      <para>Technically, you can declare classes as "aspects" that will
      contribute features (attributes, references, properties, operations,
      constraints) to an existing classes. In such situation, the definition
      of two classes that have the same qualified name will be merged into a
      single class in the interpreter memory.</para>

      <para>This is a great help when you want to separate the concerns into
      several files. For example, you may have one file the strictly conforms
      to the structural part of your metamodel, one file containing the
      constraints for a given purpose and another file containing the
      operation and special extension to the metamodel for an
      interpreter.</para>

      <para>Obviously, the merge will be successful only if there is no
      conflict between all the declared features.</para>
      
      <section>
        <title>Textual syntax for merging</title>

        <!-- important><para>
           Since this feature is really successful and very well accepted, the surface syntax will change in the future release v1.0.0 in order to use a dedicated keyword instead of a simple annotation. The syntax presented here is valid only for prior versions. 
        </para></important> -->

        <para>The merge is driven by the qualified name of the element to
        merge. Two classes will be merged if they have exactly the same
        qualified name (packages names + class name)</para>

        <para>In order to keep the compatibility with previous behaviour, the
        merge is allowed only if you add some keyword or tag:</para>

        <variablelist>
          <varlistentry>
            <term>aspect</term>

            <listitem>
              <para>This keyword is placed on a class, it indicates that this class is an
              aspect of another one. This allows to complement a class with
              the features of the aspect class.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@overloadable "true"</term>

            <listitem>
              <para>This tag is placed on an operation, it indicates that the body of
              the operation can be overloaded by another definition of the
              same operation in an aspect class. This is useful in some
              situation were the code expect to be overloaded.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <note><para>
           When using overloadable tag, for a given set of definition, the operation that is not tagged overlodable will overload all other definitions. If all the declaration declare to be overloadable, then the declaration order is important. The last declared will be used by the interpreter. 
        </para></note>
        <note><para>
            Since version 1.0.0, there is a dedicated keyword <emphasis>aspect</emphasis>, with previous version this feature was possible using the tag <emphasis>@aspect "true"</emphasis>
            on classes.
        </para>
      </note>
      </section>

      <section>
         

        <title>Example 1: Simple Class merge</title>

         <para>In this sample, writing:</para>

        <programlisting>// aspect1.kmt
package pack;
require kermeta
// this is the first aspect of class A
aspect class A {
	attribute decorations : Decoration[0..*]
}
// this aspect also declares a new class, visible only when requiring this aspect
class Decoration{
	attribute val : kermeta::standard::String
}</programlisting>

         

        <programlisting>// base.kmt
package pack;
require kermeta
// this is the base class
class A {
	attribute name : kermeta::standard::String
	
	 // operation in this context have access only to the base's features 
	operation getName() : kermeta::standard::String is do
		result := name
	end
}</programlisting>

         

        <programlisting>// aspect2.kmt
package pack;
require kermeta
require "base.kmt"
require "aspect1.kmt"

// is this context we have access to all the features of class A : from base, aspect1 and aspect2
aspect class A {
	attribute id : kermeta::standard::Integer
	operation getFullSpecification() : kermeta::standard::String is do
		result := name
		result := "(" + id.toString + ")"
		decorations.each{ decoration | result := result + "&lt;" + decoration.val+ "&gt;" }
	end
}</programlisting>

         

        <note><para>Please note that the visibility of the features is respected. In
        base.kmt, class A doesn't know about attributes id or
        decorators...</para></note>

		<tip>
			<para>In the previous example we aspectize a *.kmt, we could choose to aspectize the corresponding *.ecore file.</para>
			<para>In fact, the both formats are available: *.kmt or *.ecore.</para>
		</tip>         

        <para>from the point of view of aspect2.kmt (ie. any file that
        requires aspect2.kmt) is equivalent to write :</para>

         

        <programlisting>class A {
	attribute name : kermeta::standard::String
	attribute decorations : Decoration[0..*]	
	attribute id : kermeta::standard::Integer
	
	 // operation in this context have access only to the base's features 
	operation getName() : kermeta::standard::String is do
		result := name
	end
	operation getFullSpecification() : kermeta::standard::String is do
		result := name
		result := "(" + id.toString + ")"
		decorations.each{ decoration | result := result + "&lt;" + decoration.val+ "&gt;" }
	end
}
class Decoration{
	attribute val : kermeta::standard::String
}</programlisting>

         

        <note><para>When there is no conflict like in this sample, the order used to
        declare the features doesn't changes the final behavior of the
        code.</para></note>

         
      </section>

      <section>
        <title>Example 2: merge with feature redefinition</title>

        <para>This sample shows that if the signature are strictly equivalent,
        then you can redefine the same structural feature (attribute,
        reference) in several aspect class.</para>

        <para>In addition, if an operation is declared abstract, it can be an
        aspect of another one which is concrete. This is useful in order to
        add pre or post conditions to a given operation.</para>

        <para>Currently, (v1.0.0) the <link
        linkend="section_derived_properties.link">derived properties</link>
        cannot be redefined in several aspect classes.</para>

        <programlisting>aspect class A {
	//the feature is equivalent to the one define in the base class, so this is legal
	attribute name : kermeta::standard::String	
	
	// the operation has the same signature and is abstract, so this is legal
	operation getQualifiedName() : kermeta::standard::String 
		post notVoid is not result == Void
		is abstract
}</programlisting>

        <programlisting>package pack;
require kermeta
class A {

	attribute name : kermeta::standard::String
	operation getQualifiedName() : kermeta::standard::String is do
		result := name
	end
}</programlisting>
      </section>

      <section>
        <title>Example 3: merge with operation overload</title>

        <para>This sample shows the use of the overloadable tag</para>

        <programlisting>package pack;
require kermeta
aspect class A {	
	@overloadable "true"
	operation getQualifiedName() : kermeta::standard::String 
		post notVoid is not result == Void
		is abstract
}</programlisting>

        <programlisting>package pack;
require kermeta
aspect class A {	
	@overloadable "true"
	operation getQualifiedName() : kermeta::standard::String is do
		raise kermeta::exceptions::NotImplementedException.new
	end
}</programlisting>

        <programlisting>class A {
	attribute name : kermeta::standard::String
	operation getQualifiedName() : kermeta::standard::String is do
		result := name
	end
}</programlisting>

        <para>In this sample, the first declaration of the operation is adds a
        post condition to the operation. As it is abstract, it isn't in
        conflict with the other declarations.</para>

        <para>The second declaration, has a body. It implements a kind of
        default behavior for the operation that will be used if no other body
        is declared for this operation. this is useful when converting ecore
        models into kermeta for example.</para>

        <para>The last definition is the one that will be used in this
        context.</para>

        <para></para>
      </section>
      <section>
        <title>Aspect and inheritance</title>

        <para>If you define some inheritance in one of your aspects, all the aspects that require this aspect will have access to it. You
        don't need to redefine it. However, if it helps to clarify the code to write it again, it will behave the same way.</para>
      </section>
      <section>
        <title>Aspect and abstract</title>

        <para>In kermeta textual syntax, the keyword aspect must be placed before the keyword abstract.</para>
        <para>Example :</para>
        <programlisting>package pack;
require kermeta
aspect abstract class A {	
	// add something
}</programlisting>
        
      </section>
      <section>
        <title>Aspect without common base</title>

        <para>A special case of the use of AOP in Kermeta is having a ClassDefinition A defined in 2 separately 
        modeling units (*.kmt) with the keyword aspect. But the two modeling units does not require another kmt or ecore file containing the base definition of A.
        Now if there is a new Modeling Unit that requires the two previous one the available definition of A is the composition of the 2 defined aspects.</para>
       </section>
    </section>

    <section id="section_modeltype.link">
      <title id="section_modeltype.title.link">Model type</title>

      <warning><para>
         In current version of Kermeta(v1.1.0), ModelType is still a prototype. Any help, feedback, contribution is welcome to help us to finalize it. 
      </para></warning>

      <para>Kermeta is clearly a model oriented language, one of its first
      concept is a model element, because they are the manipulated objects.
      However, we often need to organise them and manipulate them as a set : a
      model. A common way to do that is to simply use a set, and a resource
      (used for load and save) is just a set. This approach is not type safe
      enough.</para>

      <para>So, Kermeta implements a clear notion of model type, in order to be
      able to typecheck this kind of model. A model type is simply the set of
      the type of all allowed model elements.</para>

      <para>In addition, it introduce a mecanism of conformance between
      modeltype that helps to reuse code from one metamodel to another.</para>

      <section>
        <title>Definition of a model type</title>

        <para>A model type is simply a set of metaclasses. Expressed in
        kermeta, this is a collection of kermeta classes.</para>

        <programlisting>
package aMetamodel;
// let's define some normal classes 
class C1 {
	attribute name : String
	attribute aC2 : C2#aC1
}
class C2 {
	reference aC1 : C1#aC2
}

// then defining a modeltype is just listing the classes of this modeltype
// here, the model type is composed of two metaclasses, C1 and C2
modeltype MainMT { aMetamodel::C1, aMetamodel::C2}
      	</programlisting>

        <tip><para>
          You can use all classic way to define classes, in kmt, but you can also require an ecore file that will contain your class definition (see require section ???) 
        </para></tip>
      </section>

      <section>
        <title>Using Model types variables</title>

        <para>Now that you have defined a ModelType, you can use it to declare
        model variables.</para>

        <programlisting>
	var aMainMT : MainMT init MainMT.new
      	</programlisting>

        <para>But, your model is still empty. As its contents is a
        (constrained) Set you simply have to fill it with your model element
        using typechecked operations like <literal>add</literal>, or using
        filtered operation like <literal>addCompatible</literal> and
        <literal>addAllCompatible</literal> (with this one you can pass any
        collection, only compatible objects will be added to the
        model).</para>

        <programlisting>
    // create a model element
	var newC1 : aMetamodel::C1 init aMetamodel::C1.new()
	newC1.name := "hello"
	// then add it to the model
	aMainMT.add(newC1)
      	</programlisting>
      </section>

      <section>
        <title>Model type serialisation</title>

        <para>As a model type is based on "normal" class definitions, loading
        and saving models mostly relies on the normal way to load resource
        (see <xref linkend="section_loadingsaving_models.link" />)</para>

        <para>A simple approach for loading is to load with the classical
        approach, then to use the operations
        <literal>addAllCompatible</literal> with the content of the resource
        or <literal>resourceToModel</literal> with the resource. That will
        fill the model with compatible objects.</para>

        <programlisting>
	// load a resource with model elements
	var res : EMFRepository init EMFRepository.new
	var resource : Resource init res.createResource(modelFileName, ecoreMetamodelFileName)
	resource.load()
       	    
	// then add them to the model
	aMainMT.addAllCompatible(resource.contents)
	// alternative
	// aMainMT.resourceToModel(resource)
      	</programlisting>

        <para>TODO sample of saving (how to put root objects of the model into
        a resource)</para>
      </section>

      <section>
        <title>Model type conformance</title>

        <para>TODO explain how Modeltype helps to reuse existing code from a
        metamodel to another</para>

        <para>Model types use a notion of conformance that allows to determine
        if a metamodel is conformant to another. The goal is to be able to
        write code that will be valid not only for models of a given
        metamodel, but will be valid for models of conformant
        metamodels.</para>

        <para>In order to be flexible, the conformity between metamodel is
        based on the properties offered by the metaclasses. It ignores the
        name of the metaclasses.</para>

        <para>As a sample, let's define a mini metamodel and its corresponding
        model type :</para>

        <programlisting>
      	</programlisting>

        <note>
          <para>We could also define a modeltype directly on top of the
          previous metamodel (and restrain it to some of its metaclasses), but
          the sample would have been less general and wouldn't have
          illustrated the fact that the name of metaclasses are
          ignored.</para>

          <programlisting>
 modeltype MiniMT_2 { aMetamodel::C1 }
      		</programlisting>
        </note>

        <warning><para>
           The current implementation works only when there is no ambiguity, if there is ambiguity between two metamodels, then they are considered as not conformant. A future version, may eventually introduce a binding mecanism that would allows to remove those ambiguity. (See Jim Steel Phd thesis for more details ???) 
        </para></warning>
      </section>

      <section>
        <title>Using Model types in generic classes/operations</title>

        <para>TODO</para>
      </section>

      <section>
        <title>A more complex example of conformance : FSM variants</title>

        <para>TODO reuse JM slides and the conformity table</para>
      </section>
    </section>

    <section id="section_java_code.link">
      <title id="section_java_code.title.link">Using existing java code in
      Kermeta</title>

      <para>If you have existing code that you want to run in a Kermeta
      program, you can use one of those two mecanisms : extern call or
      seamless require.</para>

      <para>The extern call is currently the more robust approach as it is
      used internally by Kermeta to implement some part of its framework. It
      also helps to clearly specify the border between java and
      kermeta.</para>

      <para>The seamless java require is more straitghforward to use (no
      wrapper to write) but is still in prototype (v0.4.2) and still have
      several limitations.</para>

      <section id="section_extern_java_code.link">
        <title id="section_extern_java_code.title.link">Using extern to call
        java code</title>

        <para>The extern allows you to call a java static method from Kermeta.
        But, to do that, you will have firstly to create a Java wrapper, that
        will be able to manipulate correctly the Java objects, and secondly to
        add this wrapper in your java global classpath.</para>

        <para role="lineBreak">Then, from this method you can access all your
        java libraries. One task of the static method will be to convert the
        basic types like Integer or String.</para>

        <para>You'll need to refer to the Javadoc of the interpreter in order
        to know how to access the internal RuntimeObject of Kermeta.</para>

        <para><emphasis role="strong">Example 1</emphasis>: sample of Kermeta
        code using extern (io.kmt):</para>

        <programlisting><emphasis>/** * An implementation of a StdIO class in Kermeta using existing Java: standard * input/output */</emphasis>
<emphasis role="strong">class</emphasis> StdIO
{
 <emphasis>/**</emphasis> <emphasis>* write the object to standard output</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> write(object : Object) : Void <emphasis
            role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
   <emphasis role="strong">result</emphasis> ?= <emphasis role="strong">extern </emphasis>fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.write(object)
 <emphasis role="strong">end</emphasis>
 
 <emphasis>/**</emphasis> <emphasis>* writeln the object to standard output</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> writeln(object : Object) : Void <emphasis
            role="strong">is do</emphasis>
   <emphasis role="strong">result</emphasis> ?= <emphasis role="strong">extern</emphasis> fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.writeln(object)
 <emphasis role="strong">end</emphasis>
 
 <emphasis>/**</emphasis> <emphasis>* read an object from standard input</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> read(prompt : String) : String <emphasis
            role="strong">is do</emphasis>
 <emphasis role="strong">  result</emphasis> ?= <emphasis role="strong">extern</emphasis> fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.read(prompt)
 <emphasis role="strong">end</emphasis>

}
</programlisting>

        <para><emphasis role="strong">Example 2</emphasis>: sample of Java
        code ("wrapper") called by the Kermeta extern:</para>

        <programlisting><emphasis>/** Implementation of input and output methods */</emphasis>
   <emphasis role="strong">public</emphasis> <emphasis role="strong">class</emphasis> StdIO{ 
      // Implementation of method write called as :
      // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.write(output) 
      <emphasis role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject write(RuntimeObject output) {
         output.getFactory().getKermetaIOStream().print(output.getData().get("StringValue")); 
      <emphasis role="strong">return</emphasis> output.getFactory().getMemory().voidINSTANCE; 
      } 
      // Implementation of method writeln called as : // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.writeln(output) 
      <emphasis role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject writeln(RuntimeObject output) {
         <emphasis>write</emphasis>(output); 
         output.getFactory().getKermetaIOStream().print("\n"); 
      <emphasis role="strong">return</emphasis> output.getFactory().getMemory().voidINSTANCE; 
      } 
      // Implementation of method writeln called as : // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.read(output) 
      <emphasis role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject read(RuntimeObject prompt) {
         java.lang.String input = <emphasis role="strong">null</emphasis>; 
         // We also have our own String wrapper 
      <emphasis role="strong">if</emphasis> (String.<emphasis>getValue</emphasis>(prompt).length()&gt;0) 
         prompt.getFactory().getKermetaIOStream().print(String.<emphasis>getValue</emphasis>(prompt)); 
      // <emphasis role="strong">FIXME</emphasis> : dirty cast.. read returns a String or could return smthg else? 
      input = (java.lang.String)prompt.getFactory().getKermetaIOStream().read( String.<emphasis>getValue</emphasis>(prompt)); 
      RuntimeObject result = String.<emphasis>create</emphasis>(input, prompt.getFactory()); 
      <emphasis role="strong">return</emphasis> result; 
   }</programlisting>

        <tip><para>
           This method is used to implement Kermeta framework. You'll find much more code samples of extern call in its sources. 
        </para></tip>
      </section>

      <section id="section_seamless_java_code.link">
         

        <title id="section_seamless_java_code.title.link">Requiring jar file
        to call java code</title>

         

        <warning><para>This feature is still a prototype and still have many
        limitations. The first version is already available but any help is
        welcome to help us to improve it.</para></warning>

         

        <para>The basic principle, is to simply require your jar file.</para>

         

        <programlisting> require "yourjar.jar" </programlisting>

         

        <para>Then Kermeta automatically retreive the class definition it
        contains to be used from Kermeta code. However, as java and Kermeta
        have different language constraints, some adaptation are automatically
        made.</para>

        <para>If there is several operations with the same name (as this is
        legal in Java but not in Kermeta) they are renamed. (Please use the
        outline to find the new name of the operation you want)</para>

        <para>Java contructors are generated as "initialize" operation.</para>

        <para>When creating a new java object from Kermeta, a call to new is
        not enough, you also need to call one of the "initialize" operation in
        order to correctly create it.</para>

        <para>In order to get the standard library direclty from your running
        java, you can <literal>require java_rt_jar</literal> but as this
        library is really big and as you probably don't need all java from
        Kermeta ;-) then you must use the includeFilter and
        excludeFilter.</para>
        
		<para>Sample using java.io from java Standard library</para>
		<para/>

        <programlisting> 
require kermeta

require java_rt_jar includeFilter ("java::io")   // the filter ensure we don't get all java

using java::io
using kermeta::kunit
class testRequireJava inherits kermeta::kunit::TestCase
{
	operation main() : Void is do
		var tr : TestRunner init TestRunner.new
		tr.run(testRequireJava)
		tr.printTestResult
	end	
	
	operation testmain() : Void is do 
	
		// create and initialize a File with the String
		var f : File init File.new.initialize_String("c:/temp/test.txt")
		var f2 : File
		// create and initialize a FileWriter with the File
		var fwriter : FileWriter init FileWriter.new.initialize_File(f)
		if (f.exists) then 
			stdio.writeln(f.toString + " already exists")
		else
			stdio.writeln(f.createNewFile.toString)
		end
		fwriter.write_String("Hello world") 
		fwriter.close
		stdio.writeln("file written")
		stdio.writeln(fwriter.toString)
	    	    
		stdio.writeln(f.getPath)
		stdio.writeln(f.separator)
		f2 := f
		stdio.writeln(f2.createNewFile.toString)
		stdio.writeln((f2.equals(f)).toString)
		assert( f2.equals(f))
	    
		var fwriter2 : FileWriter
		fwriter2 :=  fwriter
		stdio.writeln((fwriter2.equals(fwriter)).toString)
		assert( fwriter2.equals(fwriter))
	    
		stdio.writeln(f.getPath)
		stdio.writeln(f.toString)
		stdio.writeln("End")
	end
} 
      		</programlisting>

         

        <para><literal>includeFilter</literal> and
        <literal>excludeFilter</literal> accept a comma separated list of
        qualified name. <literal>includeFilter</literal> adds only elements
        whose qualified name start with one of the list.
        <literal>excludeFilter</literal> removes elements whose qualified name
        start with one of the list. If you use a combinaison of
        <literal>includeFilter</literal> and <literal>excludeFilter</literal>,
        then the <literal>includeFilter</literal> is applied before the
        <literal>excludeFilter</literal> (that'll remove element from the
        included one.</para>

        <para>Currently known limitations: no support for java5 generics (they
        are ignored), requiring very big jar like the full java library end up
        with out of memory error (you need to use the includefilter and
        excludeFilter), some bugs with some primitives types
        (double/float)</para>

         
      </section>
    </section>

    <section>
      <title>Cloning objects<phrase id="section_cloning"></phrase></title>

      <para>As we saw in previous sections, class properties can be defined as
      attribute or reference. An attribute cannot be shared between two or
      more objects whereas a reference can be. Let's consider a class
      "<literal>Family</literal>" with a property "<literal>father</literal>"
      (of type "<literal>Person</literal>") defined as an attribute. In the
      following example, we defined two objects of type
      <literal>Family</literal> and we want to define the
      <literal>father</literal> attribute of the second with the
      <literal>father</literal> of the first. To do that, we need to clone the
      object Person which represents the father of
      "<literal>family1</literal>" because, as said in <xref
      linkend="section_assignment_behavior_4_attribute.link" />, it could not
      be shared between the two objects, by definition of attribute (in
      "technical" words, an object cannot be contained by 2
      containers).</para>

      <programlisting><emphasis role="strong">class</emphasis> Person 
{
     <emphasis role="strong">attribute</emphasis> name : String
}</programlisting>

      <programlisting><emphasis role="strong">class</emphasis> Family
{
    <emphasis role="strong">attribute</emphasis> father : Person
}

<emphasis role="strong">class</emphasis> Main
{
    <emphasis role="strong">operation</emphasis> run() <emphasis role="strong">is</emphasis>
    <emphasis role="strong">do var</emphasis> family1 : Family <emphasis
          role="strong">init</emphasis> Family.new
       <emphasis role="strong">var</emphasis> p1 : Person <emphasis
          role="strong">init</emphasis> Person.new
       p1.name := "Robert"
       family1.father := p1
 <emphasis role="strong">var</emphasis> family2 : Family <emphasis
          role="strong">init</emphasis> Family.new

       <emphasis>// ERROR 1 : this assigns p1 to family2.father, which 
       // is already owned by family1.father, so it unsets family1.father 
       // family2.father := p1</emphasis>

       <emphasis>// ERROR 2 : this assigns family1.father's value to family2.father, 
       // so it unsets family1.father 
       // family2.father := family1.father</emphasis>

       <emphasis>// This is correct! family2.father keeps its value</emphasis>
       family2.father := Person.clone(p1)
    <emphasis role="strong">end</emphasis>
}</programlisting>

      <para>The "<literal>clone</literal>" method creates a copy of the object
      that it receives as input. If it is a complex object, a deep clone is
      performed for each attribute of its meta-class and a shallow clone is
      performed for each reference.</para>

      <caution><para>
         Reminder : be very careful with the use of the assignment operator on object. Most of the time, you need to use the "clone" feature. Using assignment on attributes break the previous link between objects. So, In the previous example, p1 has no more name after the assignment !There is one exception to this behavior : when the type of attributes are DataType, i.e, in Kermeta, String, Integer, Boolean, the assignment behaves as if those entities were defined as references. 
      </para></caution>
    </section>
  </chapter>

  <chapter id="section_kermeta_metamodel.link">
    <title id="section_kermeta_metamodel.title.link">Kermeta Metamodel<phrase
    id="chapter_kermeta_mm"></phrase></title>

    <para>As Kermeta is designed to be used in a model driven environment, its
    structure is given as a model. This section presents the metamodel of
    Kermeta which corresponds to the abstract syntax of Kermeta.</para>

    <para>This metamodel may be useful for many use cases. For example, you
    can use it to manipulate your Kermeta code for analysis or even generate
    some Kermeta code. This may be useful to understand how Kermeta works
    too.</para>

    <note><para>
       All the code samples in this section are for illustration of the given concepts. 
    </para></note>

    <para>The goal of the Kermeta language is to provide an action language
    for MOF models. The idea is to start from MOF, which provides the
    structure of the language, and to add an action model. Using the MOF to
    define the structure of the Kermeta language has an important impact on
    the language. In fact, as MOF concepts are Object-Oriented concepts,
    Kermeta includes most of the classical Object-Oriented mechanisms. Yet,
    MOF only defines structures, and the operational semantic corresponding to
    MOF concepts has to be defined in Kermeta. For instance MOF does not
    provide a semantic for behavior inheritance (concepts like method
    redefinition, abstract method, ... does not have any sense in the
    MOF).</para>

    <section id="section_architecture.link">
      <title id="section_architecture.title.link">Architecture</title>

      <para>Kermeta has been designed to be fully compatible with the OMG
      standard meta-data language EMOF. The metamodel of Kermeta is divided
      into two packages :</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>structure</emphasis> which corresponds to
          EMOF</para>
        </listitem>

        <listitem>
          <para><emphasis>behavior</emphasis> which corresponds to the
          actions. This section gives an overview of these two packages and
          their relationships.</para>
        </listitem>
      </itemizedlist>

      <para>Thanks to this reuse, Kermeta is fully compatible with EMOF. This
      is useful in the promotion of Kermeta as a metalanguage.</para>

      <figure id="refIllustration1">
        <title>EMOF extension and Kermeta promotion</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-Manual_figures/kermeta_emof_promotion.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <note><para>
        This weaving of behavior into MOF has been explained in 

        <ulink
        url="http://www.kermeta.org/documents/articles/Muller05a">Pierre-Alain
        Muller, Franck Fleurey, and Jean-Marc Jézéquel. -- Weaving
        executability into object-oriented meta-languages. -- In S. Kent L.
        Briand, editor, Proceedings of MODELS/UML'2005, volume 3713 of LNCS,
        pages 264--278, Montego Bay, Jamaica, October 2005. Springer.</ulink>
      </para></note>

      <para>The link between structure and behavior is made through the
      property <literal>body</literal> of class <literal>Operation</literal>
      which allows to define the behavior of an operation using a Kermeta
      expression.</para>

      <para>A more detailed description of the architecture of Kermeta is
      presented in next sections.</para>
    </section>

    <section>
      <title>Structure package</title>

      <figure id="refIllustration10">
        <title>Structure package</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-Manual_figures/kermeta_structure_package.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>This figure presents the main classes of the structure package. To
      design this package, we started from EMOF and completed it to build the
      Kermeta language. The choice of EMOF is motivated by two main reasons :
      firstly it is standardized by the OMG and secondly is is well-supported
      by tools such as Eclipse/EMF.</para>

      <para>As MOF is not initially designed to be executable, several
      concepts have to be completed and slightly modified to build an
      executable language. The first and most important modification is to add
      the ability to define the behavior of operations. To achieve this we
      define an action language in the package
      <literal>behavior</literal><emphasis> </emphasis>of Kermeta. The class
      hierarchy of the package behavior is presented on <xref
      linkend="refIllustration11" />. In practice, Kermeta expressions have
      been designed by adding model modification capabilities (like assignment
      of properties for instance) to OCL expressions.</para>

      <para>This represents the static part of the metamodel.</para>

      <para>As a reminder, the structure of Kermeta is derived from EMOF from
      the OMG. During the build process, we merge and connect it with the
      behavior part.</para>

      <para>So all the meaning of those metaclasses are very close to those
      described in the OMG standard specification.</para>
      <section>
      	<title>NamedElement view</title>

			<figure id="refIllustrationNamedElementView">
		        <title>NamedElement class diagram</title>		
		        <mediaobject>
		          <imageobject>
		            <imagedata fileref="figures/kermeta_ecorediag/kermeta_structure_NamedElement.png" />
		          </imageobject>
		        </mediaobject>
	      	</figure>
	
	      	<para>This figure presents the element in the structure package that have a name. 
	      	Kermeta relies on in various situation (For example in the typechecking process). 
	      	The containment hierarchy is also presented since it is used in the identification process.</para>
	      	<para>Class is a bit special, since its name is a derived property.</para>
      </section>
      <section>
      	<title>NamedElement view</title>

			<figure id="refIllustrationTypeSystemBigPictureView">
		        <title>Kermeta type system class diagram (the big picture)</title>
		        <mediaobject>
		          <imageobject>
		            <imagedata fileref="figures/kermeta_ecorediag/kermeta_structure_TypeSystemBigPicture.png" />
		          </imageobject>
		        </mediaobject>
	      	</figure>
	
	      	<para>This figure presents the global view of all the metaclasses involved in Kermeta type system.</para>
	      	<para>Basically, you can notice the split between Type and TypeDefinion needed in order to handle generics.</para>
	      	<para>The containment is also represented here.</para>
	      	<para>TODO : if time : provide a set of small diagrams that focus of some elements of the type system.</para>
      </section>
    </section>

    <section>
      <title>Behavior package</title>

      <figure id="refIllustration11">
        <title>Behavior package</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-Manual_figures/kermeta_behavior_package.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <section>
        <title>Control Structures</title>

        <para>Kermeta provides basic control structures : block, conditional
        branch, loop, and exception handling. Here there an excerpt of the
        Meta-model describing control structures. Each basic control
        structures derives from the Expression concept.</para>

        <figure id="refIllustration12">
          <title>Control structure</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/kermeta_control_struct.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>

      <section>
        <title>Variables</title>

        <figure id="refIllustration13">
          <title>Use of variables</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/kermeta_var_expressions.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </section>

      <section>
        <title>Call Expressions</title>

        <figure id="refIllustration14">
          <title>use of exceptions</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/kermeta_call_expressions.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <section>
          <title>CallSuperOperation</title>

          <para>In the following example, the type of
          <emphasis>super(element)</emphasis> is
          <emphasis>CallSuperOperation</emphasis>:</para>

          <programlisting><emphasis role="strong">class</emphasis> ParentClass {
    <emphasis role="strong">operation</emphasis> op(element : Integer) : Integer <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := element + 1
    <emphasis role="strong">end</emphasis>

}

<emphasis role="strong">class</emphasis> ChildClass {
    <emphasis role="strong">method</emphasis> op(element : Integer) : Integer <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := <emphasis role="strong">super</emphasis>(element)
    <emphasis role="strong">end</emphasis>
}</programlisting>
        </section>

        <section>
          <title>CallVariable</title>

          <para>The type of <emphasis>callvar</emphasis><emphasis
          role="strong">,</emphasis> below, is CallVariable:</para>

          <programlisting><emphasis role="strong">var</emphasis> myvar : Integer
<emphasis role="strong">var</emphasis> callvar : Integer <emphasis
              role="strong">init</emphasis> 4
// 
myvar := callvar </programlisting>

          <para>A special case, when calling a lambda expression : the type of
          <emphasis>lf</emphasis> in the assignment of res, is
          CallVariable.</para>

          <programlisting>
            <emphasis role="strong">var</emphasis>
            <emphasis> lf : &lt;Integer-&gt;Integer&gt;</emphasis>
            <emphasis role="strong">var</emphasis>
            <emphasis> res : Integerlf := </emphasis>
            <emphasis role="strong">function</emphasis>
            <emphasis> { i : Integer | i.plus(1) }</emphasis>
            <emphasis>// The type of </emphasis>
            <emphasis>lf</emphasis>
            <emphasis>, below, is CallVariable</emphasis>
            <emphasis>res := </emphasis>
            <emphasis>lf</emphasis>
            <emphasis>(4)</emphasis>
          </programlisting>
        </section>

        <section>
          <title>CallResult</title>

          <para>The type of <emphasis>result</emphasis> is
          <emphasis>CallResult</emphasis></para>

          <programlisting><emphasis role="strong">operation</emphasis> op() : Integer <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
    <emphasis role="strong">result</emphasis> := 61
<emphasis role="strong">end</emphasis></programlisting>
        </section>

        <section>
          <title>CallFeature and SelfExpression</title>

          <itemizedlist>
            <listitem>
              <para>The type of <emphasis>self</emphasis> is a
              SelfExpression!</para>
            </listitem>

            <listitem>
              <para>The type of <emphasis>attr</emphasis> in the body of the
              operation myoperation is
              <emphasis>CallFeature</emphasis><emphasis role="strong">
              </emphasis>(a callfeature on <emphasis>self</emphasis>), and so
              is the type of <emphasis>myoperation(4)</emphasis> (a
              callfeature on <emphasis role="strong">a</emphasis>).</para>
            </listitem>
          </itemizedlist>

          <programlisting><emphasis role="strong">class</emphasis> A {
    <emphasis role="strong">attribute</emphasis> attr : Integer
    <emphasis role="strong">operation</emphasis> myoperation(param : Integer) : Integer <emphasis
              role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := <emphasis role="strong">self</emphasis>.attr + param
    <emphasis role="strong">end</emphasis>
}
<emphasis role="strong">class</emphasis> B {
    <emphasis role="strong">operation</emphasis> anotheroperation() : Integer <emphasis
              role="strong">is do</emphasis>
        <emphasis role="strong">var</emphasis> a : A
        <emphasis role="strong">result</emphasis> := a.myoperation(4)
    <emphasis role="strong">end</emphasis>
}</programlisting>
        </section>
      </section>

      <section>
        <title>Assignment</title>

        <figure id="refIllustration15">
          <title>Kermeta assignment expression</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/kermeta_assign_expressions.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>In the following example, <emphasis>thetarget</emphasis> is of
        type <emphasis>CallExpression </emphasis>and
        <emphasis>thevalue</emphasis> is of type
        <emphasis>Expression</emphasis>.</para>

        <programlisting><emphasis role="strong">var</emphasis> num : Numeric
<emphasis role="strong">var</emphasis> thetarget : Integer
<emphasis role="strong">var</emphasis> thevalue : Integer
// assignment : <emphasis role="strong">thetarget-&gt;</emphasis><emphasis>target</emphasis>, <emphasis
            role="strong">thevalue-&gt;</emphasis><emphasis>value</emphasis>
thetarget := thevalue
// casting : <emphasis role="strong">a</emphasis> is casted into the type of <emphasis
            role="strong">num</emphasis> which is Numeric.
num ?= a</programlisting>
      </section>

      <section>
        <title>Literals</title>

        <figure id="refIllustration16">
          <title>Kermeta Literal Expression</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/kermeta_literal_expressions.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <programlisting><emphasis role="strong">var</emphasis> i : Integer
i := 5    <emphasis>// 5 is a IntegerLiteral</emphasis>
<emphasis role="strong">var</emphasis> s : String 
s := "I am a string" <emphasis>// "I am a string" is a StringLiteral</emphasis></programlisting>
      </section>

      <section id="section_lambda_expression_mm.link">
        <title id="section_lambda_expression_mm.title.link">Lambda
        Expression<phrase id="section_lambda_expression_mm"></phrase></title>

        <figure id="refIllustration17">
          <title>Kermeta lambda expressions</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-Manual_figures/kermeta_lambda_expressions.png" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>Viewing Kermeta metamodel</title>

      <para>In Kermeta, you can view its metamodel by several ways.</para>

      <para>First, the ecore file kermeta_java.ecore is available in the lib
      folder of Kermeta main plugin.It is used when saving a Kermeta program
      in XMI ("Compile to XMI" function on *.kmt files). You can then load
      Kermeta program as a model, typically to transform it.</para>

      <warning><para>
         You should not try to execute operations on kermeta models you've just dynamically created unless you froze it. This is a feature which has not been completly tested. 
      </para></warning>

      <para>Another typical way to access to a Kermeta model and Kermeta
      metamodel is to use the reflection. All objects inherits from Object
      that defines the <literal>getMetaClass</literal> operation. This use is
      used in one of the samples of <xref
      linkend="section_dynamic_expressions.link" /> (when it selects an
      operation to be executed).</para>

      <para>At last, the parse method on dynamic expression presented in
      section <xref endterm="section_dynamic_expressions.title.link"
      linkend="section_dynamic_expressions.link" /> can give you some way to
      access a Kermeta model as it parses a Kermeta text and provides the
      corresponding model.</para>
    </section>
  </chapter>

  <chapter>
    <title>Kermeta framework<phrase id="chapter_framework"></phrase></title>

    <para>Kermeta is bundled with a framework that provides the base
    functionalities for metamodel engineering.</para>

    <tip><para>
       When you write 

      <literal>require kermeta</literal>

       at the head of your file, you are importing the file framework.km located in the Kermeta plugin. 
    </para></tip>

    <para>Currently, it provides the following packages :</para>

    <variablelist>
      <title>Packages in Kermeta framework</title>

      <varlistentry>
        <term><emphasis role="strong"><filename
        role="strong">kermeta::interpreter</filename></emphasis></term>

        <listitem>
          <para>This package defines some classes related to Kermeta
          interpreter and also to Kermeta surface syntax. Some uses of this
          package are illustrated in <xref
          linkend="section_dynamic_expressions.link" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::persistence</filename></emphasis></term>

        <listitem>
          <para>This package defines the notion required to serialize and
          deserialize models. This is illustrated in <xref
          linkend="section_loadingsaving_models.link" /> and in the EMF
          tutorial document ( <ulink type=""
          url="http://www.kermeta.org/documents/emfTutorial/">http://www.kermeta.org/documents/emfTutorial/</ulink>
          )</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::kunit</filename></emphasis></term>

        <listitem>
          <para>This is a basic support for unitary tests (like Junit but for
          Kermeta).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::language::structure</filename></emphasis></term>

        <listitem>
          <para>It contains the classes of Kermeta structure. Note that it
          slightly differs from the kermeta_java.ecore due to an inheritance
          to the classes in Kermeta::reflexion. However, it proposes the very
          same functionalities.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::language::behavior</filename></emphasis></term>

        <listitem>
          <para>It contains the classes for the behavior of Kermeta.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::exceptions</filename></emphasis></term>

        <listitem>
          <para>It defines various exceptions that you can use in Kermeta.
          Inheriting from kermeta::exceptions::Exception allows to give more
          information to the end user because it will also provide a stack
          trace (which would not be available otherwise).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::io</filename></emphasis></term>

        <listitem>
          <para>This package provides basic support for input/output with
          Kermeta. It is voluntary minimal because that not the main role of
          Kermeta to provide such primitives. In the future, this package may
          even disappear and be replaced by the ability to directly call Java
          libraries.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::reflection</filename></emphasis></term>

        <listitem>
          <para>This package contains all the abstract classes needed for the
          reflexivity of Kermeta. The concrete implementation are in
          kermeta::standard or kermeta::structure.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::utils</filename></emphasis></term>

        <listitem>
          <para>This package defines various tool classes that cannot be part
          of the core of the language, but are important enough to be part of
          the framework.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><emphasis
        role="strong"><filename>kermeta::standard</filename></emphasis></term>

        <listitem>
          <para>This package defines all the basic objects needed for a
          typical Kermeta application. For example, it defines data types,
          collections, etc.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note><para>
       For more details about the content of these packages, please look at the generated documentation available on line: 
      <ulink type=""
      url="http://www.kermeta.org/docs/KermetaFramework/framework.km.html">http://www.kermeta.org/docs/KermetaFramework/framework.km.html</ulink>
    </para></note>
  </chapter>

  <appendix id="appendix_keywords.link">
    <title id="appendix_keywords.title.link">Language keywords</title>

    <para>The following keywords are used by Kermeta textual syntax.</para>

    <note>
      <para>If you want to name some class or property using those names,
      you'll need to escape them using the ~ (tilda).Ex: <literal>class ~class
      {}</literal></para>

      <para>(See <xref linkend="section_reserved_keywords.link" />)</para>
    </note>

    <informaltable>
      <tgroup cols="2">
        <colspec colname="c1" colwidth="1*" />

        <colspec colname="c2" colwidth="3*" />

        <thead>
          <row>
            <entry align="left"><para>Keyword</para></entry>

            <entry align="left"><para>Usage</para></entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><para>@pre</para></entry>

            <entry align="left"><para>Represents self before the call to this
            operation in the scope of a post condition. See <xref
            linkend="section_pre_post_syntax.link" /></para></entry>
          </row>

          <row>
            <entry><para>abstract</para></entry>

            <entry align="left"><para>Modifier for class or
            operation</para></entry>
          </row>

          <row>
            <entry><para>alias</para></entry>

            <entry><para>Definition of a primitive type</para></entry>
          </row>

          <row>
            <entry><para>and</para></entry>

            <entry><para>Boolean expression</para></entry>
          </row>

          <row>
            <entry><para>attribute</para></entry>

            <entry><para>Definition of an attribute</para></entry>
          </row>

          <row>
            <entry><para>bag</para></entry>

            <entry align="left"><para> See <xref
            linkend="section_collections.link" /> </para></entry>
          </row>

          <row>
            <entry><para>class</para></entry>

            <entry align="left"><para>Definition of a class</para></entry>
          </row>

          <row>
            <entry><para>do</para></entry>

            <entry align="left"><para>Beginning of a block</para></entry>
          </row>

          <row>
            <entry><para>else</para></entry>

            <entry align="left"><para>Else part of a conditional
            instruction</para></entry>
          </row>

          <row>
            <entry><para>end</para></entry>

            <entry align="left"><para>End of a block</para></entry>
          </row>

          <row>
            <entry><para>enumeration</para></entry>

            <entry><para>Definition of an enumeration</para></entry>
          </row>

          <row>
            <entry><para>extern</para></entry>

            <entry align="left"><para>Call of a java static
            operation</para></entry>
          </row>

          <row>
            <entry><para>false</para></entry>

            <entry><para>Boolean literal</para></entry>
          </row>

          <row>
            <entry><para>from</para></entry>

            <entry align="left"><para>Loop instruction</para></entry>
          </row>

          <row>
            <entry><para>function</para></entry>

            <entry align="left"><para>Declares a local function</para></entry>
          </row>

          <row>
            <entry><para>getter</para></entry>

            <entry><para>Declaration of a property getter</para></entry>
          </row>

          <row>
            <entry><para>if</para></entry>

            <entry align="left"><para>Conditional instruction</para></entry>
          </row>

          <row>
            <entry><para>inherits</para></entry>

            <entry align="left"><para>Declartion of the super classes of the
            class</para></entry>
          </row>

          <row>
            <entry><para>init</para></entry>

            <entry><para>Initialization of a variable</para></entry>
          </row>

          <row>
            <entry align="left"><para>inv</para></entry>

            <entry align="left"><para>Declaration of an invariant. See <xref
            linkend="section_inv_syntax.link" /></para></entry>
          </row>

          <row>
            <entry><para>is</para></entry>

            <entry align="left">part of the declaration of an operation or
            method. See <xref
            linkend="section_defining_operations.link" /></entry>
          </row>

          <row>
            <entry><para>loop</para></entry>

            <entry align="left"><para>Loop instruction</para></entry>
          </row>

          <row>
            <entry><para>method</para></entry>

            <entry align="left"><para>Redefinition of an operation. See <xref
            linkend="section_defining_operations.link" /></para></entry>
          </row>

          <row>
            <entry><para>modeltype</para></entry>

            <entry align="left"><para>Definition of a
            modeltype.</para></entry>
          </row>

          <row>
            <entry><para>not</para></entry>

            <entry><para>Boolean expression</para></entry>
          </row>

          <row>
            <entry><para>operation</para></entry>

            <entry align="left"><para>Declaration of an operation. See <xref
            linkend="section_defining_operations.link" /></para></entry>
          </row>

          <row>
            <entry><para>or</para></entry>

            <entry><para>Boolean expression</para></entry>
          </row>

          <row>
            <entry><para>oset</para></entry>

            <entry align="left"><para> See <xref
            linkend="section_collections.link" /> </para></entry>
          </row>

          <row>
            <entry><para>package</para></entry>

            <entry><para>Declaration of package</para></entry>
          </row>

          <row>
            <entry><para>post</para></entry>

            <entry><para>Declaration of a postcondition. See <xref
            linkend="section_pre_post_syntax.link" /></para></entry>
          </row>

          <row>
            <entry align="left"><para>pre</para></entry>

            <entry align="left"><para>Declaration of a precondition. See <xref
            linkend="section_pre_post_syntax.link" /></para></entry>
          </row>

          <row>
            <entry><para>property</para></entry>

            <entry><para>Declaration of a derived property</para></entry>
          </row>

          <row>
            <entry><para>raise</para></entry>

            <entry align="left"><para>Throw an exception</para></entry>
          </row>

          <row>
            <entry><para>raises</para></entry>

            <entry><para>Declares the exception that an operation can
            throw</para></entry>
          </row>

          <row>
            <entry><para>readonly</para></entry>

            <entry><para>Modifier for properties</para></entry>
          </row>

          <row>
            <entry><para>reference</para></entry>

            <entry align="left"><para>Declaration of a
            reference</para></entry>
          </row>

          <row>
            <entry><para>require</para></entry>

            <entry align="left"><para>Declaration of a required
            file</para></entry>
          </row>

          <row>
            <entry><para>rescue</para></entry>

            <entry align="left"><para>Catch an excetion</para></entry>
          </row>

          <row>
            <entry><para>result</para></entry>

            <entry><para>Special variable used for the return value of an
            operation. See <xref
            linkend="section_defining_operations.link" /></para></entry>
          </row>

          <row>
            <entry><para>setter</para></entry>

            <entry><para>Declaration of property setter</para></entry>
          </row>

          <row>
            <entry><para>self</para></entry>

            <entry align="left"><para>Special varaible representing this
            instances</para></entry>
          </row>

          <row>
            <entry><para>set </para></entry>

            <entry align="left"><para> See <xref
            linkend="section_collections.link" /> </para></entry>
          </row>

          <row>
            <entry><para>seq</para></entry>

            <entry align="left"><para> See <xref
            linkend="section_collections.link" /> </para></entry>
          </row>

          <row>
            <entry><para>super </para></entry>

            <entry align="left"><para>Call to the super
            operation</para></entry>
          </row>

          <row>
            <entry><para>then</para></entry>

            <entry align="left"><para>Then part of a conditional
            instruction</para></entry>
          </row>

          <row>
            <entry><para>true</para></entry>

            <entry align="left"><para>Boolean literal</para></entry>
          </row>

          <row>
            <entry><para>until</para></entry>

            <entry align="left"><para>Loop condition</para></entry>
          </row>

          <row>
            <entry><para>using</para></entry>

            <entry><para>Shortcut used to avoid to write the full qualified
            name</para></entry>
          </row>

          <row>
            <entry><para>value</para></entry>

            <entry align="left"><para>Special variable used in getter and
            setter to represent the actual value of the
            property</para></entry>
          </row>

          <row>
            <entry><para>var</para></entry>

            <entry><para>Declaration of a variable</para></entry>
          </row>

          <row>
            <entry><para>void</para></entry>

            <entry><para>Void literal</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </appendix>
</book>