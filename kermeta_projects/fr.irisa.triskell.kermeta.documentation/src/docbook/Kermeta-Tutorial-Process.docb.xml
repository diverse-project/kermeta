<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<!-- $Id$ -->
<book lang="en-US" id="process_tutorial">
    <bookinfo>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Kermeta-Tutorial-Process_figures/KermetaLogo.png" format="PNG"/>
            </imageobject>
        </mediaobject>
        <title>Kermeta Tutorial : Processes to build a DSL</title>
        <pubdate>Build date: @BUILD.DATE@</pubdate>
    	<date>$LastChangedDate::                     $</date>
        <pubdate/>
        <author>
            <firstname>Haja</firstname>
            <surname>Rambelontsalama</surname>
        </author>
        <keywordset>
            <keyword>Kermeta</keyword>
            <keyword>metamodeling</keyword>
            <keyword>language</keyword>
            <keyword>kmLogo</keyword></keywordset>
        <subtitle>Reference manual</subtitle>
        <bibliomisc>License EPL</bibliomisc>
        <abstract>
            <para>This tutorial is a step-by-step user-guide to the process of building a DSL using
                the Kermeta language.</para>
        </abstract>
        <publisher>
            <publishername>INRIA</publishername>
            <address><state>France</state>
<otheraddr><ulink url="http://www.inria.fr">http://www.inria.fr</ulink></otheraddr></address></publisher>
    </bookinfo>
    <preface id="preface.link">
        <title id="preface.title.link">Preface<phrase id="preface"/></title>
        <para>Kermeta is a Domain Specific Language dedicated to metamodel engineering. It fills the
            gap let by MOF which defines only the structure of meta-models, by adding a way to
            specify static semantic (similar to OCL) and dynamic semantic (using operational
            semantic in the operation of the metamodel). Kermeta uses the object-oriented paradigm
            like Java or Eiffel.</para>
        <para>This document is an user-guide to create a DSL using the Kermeta language. This main
            document explain the different processes to rapidly achieve this goal. For a direct
            acces to the how-to and the examples, please refer to those presented in the FSM
            Tutorial and the Logo Tutorial. For the explanation of the concepts mentioned here,
            please refer to the Kermeta manual.</para>
        <important>
            <para>Kermeta is an evolving software and despite that we put a lot of attention to this
                document, it may contain errors (more likely in the code samples). If you find any
                error or have some information that improves this document, please send it to us
                using the bug tracker in the forge: <ulink type=""
                    url="http://gforge.inria.fr/tracker/?group_id=32">
                    <emphasis role="strong">http://gforge.inria.fr/tracker/?group_id=32</emphasis>
                </ulink> or using the developer mailing list
                (kermeta-developers@lists.gforge.inria.fr) Last check: v1.4.1 </para>
        </important>
        <tip>
            <para> The most update version of this document is available on line from <ulink type=""
                    url="http://www.kermeta.org/">http://www.kermeta.org</ulink> . </para>
        </tip>
    </preface>
    <chapter id="chapter_introduction.link">
        <title id="chapter_introduction.title.link">Introduction<phrase/></title>
        <para>This document is an user-guide to create a <emphasis role="bold">Domain Specific
                Language</emphasis> (DSL) using the <emphasis role="bold">Kermeta</emphasis>
            language. This main document is a <emphasis role="italic">10 minute-reading</emphasis>
            document and explains the different processes to rapidly achieve this goal. Thanks to
            the implemented functionalities inside Kermeta language, we can easily manipulate
            models, weave an compose elements without altering the core of our model.</para>
        <important>
            <para>We recommend to the beginner to read this document till the end first. Advanced
                user might directly jump to the concrete examples : the <ulink
                    url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                        ><emphasis role="underline">FSM tutorial</emphasis></ulink> or the <ulink
                    url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                        ><emphasis role="underline">Logo Tutorial</emphasis></ulink>. </para>
        </important>
        <para>For the explanation of the concepts mentioned here, please refer to the <ulink
                url="@ONLINE.OR.LOCAL@fr.irisa.triskell.kermeta.documentation/build/@OUTPUT.VERSION@/KerMeta-Manual/index.html"
                    ><emphasis role="underline">Kermeta manual</emphasis></ulink>.</para>
        <para>The main goal of this tutorial is to describe the main processes to provide <emphasis
                role="bold">Model Development Kit</emphasis> (MDK) to your DSL. </para>
        <para>The <emphasis role="bold">big picture</emphasis> of this tutorial is illustrated in
            the figure below: <anchor id="big_picture_para"/><orderedlist>
                <listitem>
                    <para>starting <link linkend="chapter_define_abstract_syntax.link">from an ecore
                            metamodel</link>;</para>
                </listitem>
                <listitem>
                    <para>we will <link linkend="chapter_define_editor.link">provide editor</link>
                        to create its instance-model; </para>
                </listitem>
                <listitem>
                    <para>we will <link linkend="chapter_contract.link">add contracts</link>
                        (through aspect weaving with Kermeta) to manage constraints specified inside
                        the metamodel;</para>
                </listitem>
                <listitem>
                    <para>we will <link linkend="chapter_behavior.link">add some behavior</link>
                        (through aspect weaving with Kermeta) where you can bind with another
                        framework (provide GUI defined with another language - Java for example).
                    </para>
                </listitem>
            </orderedlist></para>
        <figure>
            <title>MDK overview<anchor id="mdk_big_picture"/></title>
            <mediaobject>
                <imageobject><imagedata
                        fileref="Kermeta-Tutorial-Process_figures/KermetaProcess.png"
                        id="big_picture"/></imageobject>
            </mediaobject>
        </figure>
    </chapter>
    <chapter id="chapter_define_abstract_syntax.link">
        <title id="chapter_define_abstract_syntax.title.link">Define abstract syntax</title>
        <section>
            <title>Terminology and format used in this tutorial<phrase/></title>
            <orderedlist>
                <listitem>
                    <para><emphasis role="bold">meta-model / Ecore model</emphasis>: both terms are
                        used to point to the meta-model level. “Ecore model” corresponds to the
                        Eclipse terminology for a meta-model specified in Ecore.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">instance</emphasis>: in the context of this
                        tutorial, the term “instance” is used to refer to an instance of a
                        meta-model i.e. of an Ecore model. Sometimes we will talk about
                        instance-model (an Ecore model which is an instance of the meta-model) so
                        don't get confused.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">model object / root class</emphasis>: in the scope
                        of the EMF dynamic editor, these terms designate the model root class that
                        contains all other ones. This is usually a good practice  to define a class which 
                        is the only one in a model to have
                        no container (i.e. which has no “black-diamonded” relation pointing to
                        it).<footnote>This isn't mandatory but this helps using generic tools like the EMF reflective tree editor</footnote></para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">containment</emphasis>: this term designates an
                        important property of classes associations. This property has to be
                        appropriately set<footnote>Be careful of the terminology, 
                        in ecore, this is done using a property on an <literal>EReference</literal>, in kermeta textual syntax, 
                        this is done by using the keyword <literal>attribute</literal> rather than <literal>reference</literal></footnote>, in such a way that all the elements of an instance-model
                        should be accessed from the root class of the model, which is aimed at being
                        the highest-level container.</para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>Define the metamodel<phrase/></title>
            <para>The fisrt step is to focus on the concept of the language that you want to
                implement. These concepts define the abstract syntax of the language. Usually, it is
                represented by an ecore metamodel which is the starting point of this
                tutorial.</para>
            <para>So first things first! Let's create the ecore file which is a class-diagram where
                a class represents a main concept of the language. We won't forget to set up its
                    <link linkend="sec_package_registry.link"><emphasis role="underline"
                        >nsURI</emphasis></link>. As a standard ecore file, any ecore aware tools
                can be used to visualize it. To that extent, you can choose to generate/initialize
                its <emphasis role="italic">ecorediag</emphasis> file which contains the graphical
                informations of the metamodel elements. Then, you can generate the model code
                provided by <emphasis role="italic">EMF genmodel</emphasis>.</para>
            <para>With Kermeta, you can also "program" your metamodel. Instead of designing it with
                its representation, you'll textually define the concepts of your metamodel. By
                calling the generate ecore metamodel on your Kermeta program source (.kmt), you
                obtain the ecore file.</para>
            <tip>
                <para> If you want to learn more about how to create an ecore metamodel with
                    eclipse, please refer to the <ulink
                        url="@ONLINE.OR.LOCAL@fr.irisa.triskell.kermeta.documentation/build/@OUTPUT.VERSION@/KerMeta-How-to-create-a-metamodel/index.html"
                        >"How to create metamodel tutorial"</ulink>.</para>
            </tip>
            <note>
                <para>An overview of an ecore diagram is available inside the examples below :<itemizedlist>
                        <listitem>
                            <para>section 3.2 "Create the FSM metamodel" inside the <ulink
                                    url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                                    >FSM tutorial</ulink></para>
                        </listitem>
                        <listitem>
                            <para>section 3.1 "From Ecore to genenerated code" in <ulink
                                    url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                                    >Logo Tutorial</ulink></para>
                        </listitem>
                    </itemizedlist></para>
            </note>
        </section>
    </chapter>
    <chapter id="chapter_define_editor.link">
        <title id="chapter_define_editor.title.link">Define the editor<phrase/></title>
        <para>In this task, you will learn how to provide editors to manipulate instance-model which
            conforms to your metamodel. There are many ways to do so. As these techniques are
            independant from each other, you can experiment each of them according to your
            needs.</para>
        <section id="sec_dynamic_instance.link">
            <title id="sec_dynamic_instance.title.link">Dynamic instance</title>
            <para>Before editing, you should create an instance-model with the dynamic instance.
                This is the most simple and fastest way for creating an instance of a meta-model.
                Creation is accessible by right-clicking onto the root meta-class. Because of the
                containment property, classes are only available for creation through this root
                class.</para>
            <note>
                <para>Illustrations of this technique can be seen in the dedicated part of the
                    tutorials : <itemizedlist>
                        <listitem>
                            <para>section 4.1 "Dynamic instance" inside the <ulink
                                    url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                                    >FSM tutorial</ulink></para>
                        </listitem>
                        <listitem>
                            <para>section 4.1 "Dynamic instance" in the <ulink
                                    url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                                    >Logo Tutorial</ulink></para>
                        </listitem>
                    </itemizedlist></para>
            </note>
        </section>
        <section id="sec_tree_view_edior">
            <title id="sec_tree_view_editor.title.link">Tree-view editor</title>
            <para>Then, the simplest tree view is a way to manipulate instance-model. Generally you
                can find it in the Outline view. You can populate your model by right-clicking on an
                element, this triggers a popup menu where you can choose to create child or sibling
                element.</para>
            <note>
                <para>An illustration of create metamodel using tree view is available in :<itemizedlist>
                        <listitem>
                            <para>section 4.2 "Tree view editor" of <ulink
                                    url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                                    >FSM tutorial</ulink></para>
                        </listitem>
                        <listitem>
                            <para>section 4.2 "Tree view editor" of <ulink
                                    url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                                    >Logo tutorial</ulink></para>
                        </listitem>
                    </itemizedlist></para>
            </note>
        </section>
        <section id="sec_textual_editor.link">
            <title id="sec_textual_editor.title.link">Textual editor</title>
            <para>Textual editor allows you to "program" your instance-model. Instead of designing
                it with its representation, you 'll textually define the concrete syntax of each
                concept of your metamodel. As a result, you'll get an instance-model conforms to
                your metamodel. Many tools allow us to achieve this goal such as : <ulink
                    url="http://www.xtext.org">Xtext</ulink>, <ulink url="http://www.emftext.org"
                    >EMFText</ulink>, <ulink url="http://www.kermeta.org/sintaks/">Sintax</ulink>.
                Basically, these tools connect with the metamodel to define its concrete syntax and
                generate the according code.</para>
            <note>
                <para>If you want to have an example on this technique, please refer to the example
                    in :<itemizedlist>
                        <listitem>
                            <para>section 4.3 "Textual editor" in <ulink
                                    url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                                    >Logo Tutorial</ulink></para>
                        </listitem>
                    </itemizedlist></para>
            </note>
        </section>
        <section id="sec_gmf_editor.link">
            <title id="sec_gmf_editor.title.link">GMF editor</title>
            <para>The last manipulation technique of a metamodel is to do so in a graphical
                way.</para>
            <note>
                <para>A dedicated tutorial covers the process to define such kind of editor in
                    :</para>
                <itemizedlist>
                    <listitem>
                        <para>section 4.3 "Graphical editor" section in <ulink
                                url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                                >FSM tutorial</ulink>.</para>
                    </listitem>
                </itemizedlist>
            </note>
        </section>
    </chapter>
    <chapter id="chapter_model_manipulation_kermeta.link">
        <title id="chapter_model_manipulation_kermeta.title.link">Model manipulation in Kermeta</title>
        <para>This section illustrates some importants steps in order to succesfully manipulate the
            metamodel in Kermeta. This is about <emphasis role="italic">why to register</emphasis>
            your metamodel and <emphasis role="italic">how to load/save</emphasis> it.</para>
        <section id="sec_serialisation.link">
            <title id="sec_serialisation.title.link">Serialization</title>
            <para>Thanks to the persistence library, you can serialize (save and load) models. The
                persistence library is inspired from the resource manager of <emphasis role="italic"
                    >EMF models</emphasis>. There is a repository (called EMFRepository) containing
                a set of resources (the EMFResources). Each resource contains a reference called
                instance which contains all the root classes of the loaded model (there is usually
                one root class). So, the procedure of creation of a resource that will handle
                    <emphasis role="italic">EMF models</emphasis> is the following : </para>
            <orderedlist>
                <listitem>
                    <para>Instanciate an EMFRepository;</para>
                </listitem>
                <listitem>
                    <para>Create a new EMF resource in this repository;</para>
                </listitem>
                <listitem>
                    <para>Load this resource;</para>
                </listitem>
                <listitem>
                    <para>Get the instances, i.e. the root class(es). All other instances can then
                        be accessed by navigating the root class(es) properties.</para>
                </listitem>
            </orderedlist>
            <note>
                <para><ulink
                        url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                        >FSM tutorial</ulink> provide code example (section 5.3) to illustrate this
                    model serialization in Kermeta </para>
            </note>
        </section>
        <section id="sec_package_registry.link">
            <title id="sec_package_registry.title.link">Package registry</title>
            <para>In order to link the instance file with its meta-model, a relative path (nsURI)
                should be provided. So, after the creation of the metamodel, we need to register
                this metamodel into the <emphasis role="italic">EMF Package Registry</emphasis>. In
                deployed mode (ie. in a runtime workbench), the ecore is automatically registered by
                the plugin. In development mode, you need to manually register it.</para>
            <para>There is two ways to do that :</para>
            <itemizedlist>
                <listitem>
                    <para>deploying an EMF plugin which add permanently the meta model to the
                        Eclipse's EMF Package Registry;</para>
                </listitem>
                <listitem>
                    <para>registering dynamically the meta model on it.</para>
                </listitem>
            </itemizedlist>
            <note>
                <para>Take look at the example below if you want to know how to register a matamodel :<itemizedlist>
                        <listitem>
                            <para>section 5.2 in <ulink
                                    url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                                    >FSM tutorial</ulink></para>
                        </listitem>
                    </itemizedlist></para>
            </note>
        </section>
    </chapter>
    <chapter id="chapter_contract.link">
        <title id="chapter_contract.title.link">Contracts<phrase/></title>
        <para>Once we've defined the structure of your language, this next step will show how to add
            constraints specified inside your language. Constraints on metamodels are <emphasis
                role="bold">static semantic</emphasis>. For instance you may add <emphasis
                role="italic">well formedness rules</emphasis> (contracts) to control errors made by
            users.</para>
        <para>Thanks to <emphasis role="bold">aspect weaving</emphasis>, Kermeta allows you to
            reopen ecore class definition in order to add <emphasis role="bold">pre/post
                condition</emphasis> into it so as to satisfy the specified constraints. You only
            have to weave these pre/post-conditions (for instace adding some invariants) and call
            the method <emphasis role="bold">checkAllInvariant()</emphasis> on the root element of
            the model to check the contract.</para>
        <tip>
            <para>These constraints can also be expressed in <emphasis role="bold">Object Constraint
                    Language</emphasis> (OCL) which is the <emphasis role="bold">Object Management
                    Group</emphasis> (OMG) official language. You can import them merely by calling
                these methods. Kermeta offer the same easy navigation inside existing model in OCL
                (&lt;Collection>.each, &lt;Collection>.forAll, ...). </para>
        </tip>
        <note>
            <para>Examples of how to add contract to your ecore model can be reached in the examples
                below :</para>
            <itemizedlist>
                <listitem>
                    <para><ulink
                            url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                            >FSM tutorial</ulink> : chapter 7 "Design by contract"</para>
                </listitem>
                <listitem>
                    <para>"Add Contract", chapter 6 in <ulink
                            url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                            >Logo Tutorial</ulink>.</para>
                </listitem>
            </itemizedlist>
        </note>
    </chapter>
    <chapter id="chapter_behavior.link">
        <title id="chapter_behavior.title.link">Behavior<phrase/></title>
        <para>Like adding the contracts seen on the previous chapter, some <emphasis role="bold"
                >dynamic semantics</emphasis> can be added to our metamodel through Kermeta
                <emphasis role="bold">aspect weaving</emphasis>. According to the dynamic behave
            that we want to express, we weave aspect operation inside each element of the metamodel
            where there is an action to express (i.e.: add methods that represent the action that
            you want for that element). </para>
        <para>To do so you have to define a <emphasis role="bold">virtual machine</emphasis> (VM)
            representing the application domain where you'are going to weave your methods.</para>
        <para>If needed, you can implement a Kermeta wrapper to another language or library to add
            missing feature to your VM (For example, you can call <emphasis role="bold">Java.lang.Math</emphasis>
            to perform calculation or <emphasis role="bold">Java AWT</emphasis> for drawing). </para>
        <note>
            <para>A complete example is given inside : </para>
            <itemizedlist>
                <listitem>
                    <para>chapter 8 "Behavior" in <ulink
                            url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                            >FSM tutorial</ulink>
                    </para>
                </listitem>
                <listitem>
                    <para>chapter 7 "Behavior" in <ulink
                            url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                            >Logo Tutorial</ulink></para>
                </listitem>
            </itemizedlist>
        </note>
    </chapter>
    <chapter id="chapter_model_transformation_compilation.link">
        <title id="chapter_model_transformation.title.link">Model transformation - Compilation<phrase/></title>
        <para>In this next part of the tutorial, we manage the transformation of the metamodel or
            its compilation to another environement.</para>
        <para>Through the same mechanism of <emphasis role="bold">aspect weaving</emphasis> provided
            in Kermeta, you map your language with another environment through weaving
            "compilation". </para>
        <note>
            <para>Code example on how to implement those weaving "compilation" are available at
                :</para>
            <itemizedlist>
                <listitem>
                    <para>chapter 9 "Model transformation" in <ulink
                            url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                            >FSM tutorial</ulink></para>
                </listitem>
                <listitem>
                    <para>"Model transformation - Compilation", chapter 8 in <ulink
                            url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                            >Logo Tutorial</ulink></para>
                </listitem>
            </itemizedlist>
        </note>
    </chapter>
    <chapter id="chapter_ui_improvements.link">
        <title id="chapter_ui_improvements.title.link">UI improvements</title>
        <para>The final step is deploying the DSL environment inside an eclipse GUI. These
            improvements begin with an appropriate UI for the DSL (editor, popupmenu, icon, wizard,
            ...). Then through the <emphasis role="bold">Plug-in Development Environment</emphasis>
            (PDE) offered by eclipse, ui elements are added to interact with the interpreter of our
            DSL. </para>
        <note>
            <para>An example on how to implement those ui tweaking is provided in the tutorial below
                :</para>
            <itemizedlist>
                <listitem>
                    <para>chapter 10 "UI improvements" in <ulink
                            url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                            >FSM tutorial</ulink></para>
                </listitem>
                <listitem>
                    <para>"UI improvements", chapter 9 in <ulink
                            url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                            >Logo Tutorial</ulink></para>
                </listitem>
            </itemizedlist>
        </note>
    </chapter>
    <chapter id="chapter_conclusion.link">
        <title id="chapter_conclusion.title.link">Conclusion</title>
        <para>This is the end of this tutorial, we've covered the needed processes to build a
                <emphasis role="bold">Model Development Kit</emphasis> for a <emphasis role="bold"
                >DSL</emphasis> with <emphasis role="bold">Kermeta</emphasis>. Now, using Kermeta,
            you should be able to implement your own DSL language starting from <emphasis
                role="bold">"just" an .ecore file</emphasis> (remember our first <link
                linkend="big_picture_para">illustration</link>) .</para>
        <para>You may either move on to the full examples through the <ulink
                url="@ONLINE.OR.LOCAL@/fr.irisa.triskell.kermeta.samples.fsm.documentation/build/@OUTPUT.VERSION@/KerMeta-The-FSM-example/index.html"
                    ><emphasis role="underline">FSM tutorial</emphasis></ulink> and the <ulink
                url="@ONLINE.OR.LOCAL@/org.kermeta.kmlogo.logoasm.documentation/build/@OUTPUT.VERSION@/Kermeta-Tutorial-Logo/index.html"
                    ><emphasis role="underline">Logo Tutorial</emphasis></ulink> in order to see the
            implementation of these processes or either you may play it <link
                linkend="chapter_introduction.link">back to the begining</link>.</para>
    </chapter>
</book>
