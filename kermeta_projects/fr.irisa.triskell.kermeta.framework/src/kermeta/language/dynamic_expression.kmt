/**
 * Contains a set of classes whose function is to evaluate a kermeta 
 * expression written as a string.
 * <img src="./figures/interpreter_package.png">
 */
package kermeta::interpreter;

require "../Standard.kmt"

using kermeta::standard
using kermeta::reflection
using kermeta::utils

/**
 * DynamicExpression is a class used to make dynamic calls, i.e dynamic evaluation
 * of Kermeta statements represented in a string.
 * 
 * An example :
 *   var de : DynamicExpression init DynamicExpression.new
 *   de.initializeDefaults
 *   de.formalParameters.put("a", String)
 *   de.parse("stdio.writeln(a)") // note: to execute a list of statements, you have to surround them with do..end
 *   var params : Hashtable<String, Object> init Hashtable<String, Object>.new
 *   params.put("a", "hello world!")
 *   de.execute(void, params)
 */
class DynamicExpression
{
	/**
	 * Parse errors and type errors
	 */
	reference errors : KermetaError[*]

	/**
	 * the expression
	 */
	reference expression : kermeta::language::behavior::Expression

	/**
	 * The type of the self object
	 * or void if the expression is not to be executed
	 * in the context of an object
	 */
	reference selfClass : kermeta::reflection::ClassDefinition

	/**
	 * Formal parameters of the expression (bindings between parameters' names and types)
	 */
	reference formalParameters : Hashtable<String, kermeta::reflection::Type>

	/**
	 * Initializes the formalParameters with an empty set of parameters
	 * and the self type with void
	 */
	operation initializeDefaults() is do
		formalParameters := Hashtable<String, kermeta::language::structure::Type>.new
		selfClass ?= kermeta::reflection::Object.typeDefinition
	end

	/**
	 * Parse the expression as a string
	 * and updates the expression field and errors
	 * Returns true if the expression was parsed sucessfuly
	 */
    operation parse(expression : String) : Boolean is do
    	errors.clear
    	if formalParameters == void or selfClass == void then
    		var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new
    		e.message := "parse precondition - formalParameters or selfType is void"
    		raise e
    	end
        result ?= extern fr::irisa::triskell::kermeta::runtime::language::DynamicExpression.parse(self, expression)
        
    	if errors.size != 0 then
    		var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new
    		e.message := "parse result - expression contains errors"
    		errors.each{ error |
    			e.message.append("\n"+error.message)
    		}
    		raise e
    	end
    end
    
    /**
     * Execute the expression in the given context
     */
    operation execute(selfObj : Object, actualParams : Hashtable<String, Object>) : Object is do
    	if expression == void then
    		var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new
    		e.message := "execute precondition - expression is void"
    		raise e
    	end
    	if errors.size != 0 then
    		var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new
    		e.message := "execute precondition - expression contains errors"
    		raise e
    	end
    	result := extern fr::irisa::triskell::kermeta::runtime::language::DynamicExpression.execute(self, selfObj, actualParams)
    end
    
    /**
     * Execute the expression given as a string.
     * the self type and formal parameters are supposed to be set
     * before calling this operation
     */
    operation evalString(body : String, selfObj : Object, actualParams : Hashtable<String, Object>) : Object is do
    	if not parse(body) then
    		var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new
    		e.message := "evalString - expression contains errors"
    		raise e
    	end
    	result := execute(selfObj, actualParams)
    end
}


// MOVED TO PACKAGE kermeta::exceptions
//class DynamicExpressionException inherits kermeta::exceptions::Exception {}


/**
 * To be written
 */
abstract class KermetaError {
	/**
	 * Error message
	 */
	attribute message : String
}


/**
 * To be written
 */
class ParseError inherits KermetaError {}


/**
 * To be written
 */
class TypeError inherits KermetaError {}
