/* $Id:$ 
 * Creation : September 28, 2009
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            jfalcou
 */
//@mainClass "language::Main"
//@mainOperation "main"

/* $Id:$ 
 * Creation : September 25, 2009
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            jfalcou
 */
//@mainClass "language::Main"
//@mainOperation "main"


package kermeta::language::structure;
require "../Standard.kmt"
require "../exceptions/constraint_exceptions.kmt"

using kermeta::language::structure
using kermeta::language::behavior
using kermeta::exceptions
using kermeta::standard
using kermeta::persistence



/*
 * The class PropertyConstraint extends the class Constraint in order to
 * differentiate multiplicity invariants from genuine Class invariants 
 */
class PropertyConstraint inherits Constraint {
	/**
	 * The property that is checked by this constraint
	 * Typically, it will check the lower and upper bounds
	 */
	reference ~property : Property 
}

aspect class Object
{
	/**
	 * Checks all the invariants for this object and return a complete diagnostic.
	 * This also includes the structural constraints associated to the properties.
	 */
	operation getViolatedConstraints() : kermeta::exceptions::ConstraintsDiagnostic is do
	
		// init result
		var contraintes : ConstraintsDiagnostic init ConstraintsDiagnostic.new.initialize
		stdio.writeln("        " + self.toString +".getViolatedConstraints()")
		var cd : ClassDefinition 
		cd := self.getMetaClass().classDefinition
		
		//stdio.writeln("    >> getViolatedConstraints, Class def : " + cd.name )
		
		if ( not cd.isVoid ) then
			
			// Checking properties
			cd.allAttribute.each{ prop |
				
				//stdio.writeln("  checking " + prop.name + ", composite " + prop.isComposite.toString )			
				if not prop.tag.exists{t| t.name == "ecore.isTransient"} and
				   not prop.isDerived
				then
					// build a constraint with the property
					var constraint : PropertyConstraint init PropertyConstraint.new
					constraint.name := cd.name + "_" + prop.name + "_" + prop.type.toString()
					//constraint.invOwner := cd // ajout pour les markers
					constraint.~property := prop
					
					do
						checkInvariant(constraint)
						rescue (e : ConstraintViolatedInv)
							// add the violated constraint to the report 
							contraintes.add(e)
					end		
			
					// Recursivity
					if ( prop.isComposite ) 
					then
					    var propValue : Object init self.get(prop)
					    // need to ignore ValueType and EnumerationLiteral for performance sake
					    var mustIgnoreType : Boolean init kermeta::standard::ValueType.isSuperTypeOf(prop.type) 					    	
						if not propValue.isVoid() and not mustIgnoreType
						then
							
							if propValue.getMetaClass.typeDefinition.asType(ClassDefinition).allSuperTypes.exists{ t |
								if t.isInstanceOf(ParameterizedType) 
								then
									t.asType(ParameterizedType).typeDefinition.qualifiedName=="kermeta::standard::Collection"
								else
									false
								end } 
							then
						
								var subObjInstances : kermeta::standard::Collection<Object>
								subObjInstances ?= propValue
								subObjInstances.each { aSubObjInstance |
									if not aSubObjInstance.isInstanceOf(kermeta::language::structure::EnumerationLiteral) then 
										aSubObjInstance.getViolatedConstraints
																			.setConstraints. each{v|
																				stdio.writeln("    " + v.message)
																				contraintes.add(v)}
									end 
									}
							else
								if not propValue.isInstanceOf(kermeta::language::structure::EnumerationLiteral) then
									propValue.getViolatedConstraints.setConstraints.each{v|
										stdio.writeln("    " + v.message)																				
										contraintes.add(v)}
								end
							end
						end
					end
				end
				
				
			}
			
			// Checking invariants
			cd.~inv.each{invariant |
				do
					checkInvariant(invariant)
					rescue (e : ConstraintViolatedInv) 
					    stdio.writeln("    " + e.message)
						contraintes.add(e)
				end
			}
			
		end
	
		result := contraintes
		
	end

	/**
	 * Checks a constraint invariant defined for the metaclass of the Object
	 * You can use PropertyConstraint for checking structural constraints associated to a property
	 */
	operation checkInvariant(invariant : Constraint) : Void is do 
	
	    
		// workaround for bug 8911
		var minusOne : Integer init -1
	
		var cd : ClassDefinition init self.getMetaClass.classDefinition
		
		// If the invariant is a PropertyConstraint, check the multiplicities
		if (invariant.isKindOf(PropertyConstraint))
		then
			// retrieve property
			var prop : Property init invariant.asType(PropertyConstraint).~property		
			var v : Object init self.get(prop)
			
			
			if 	v.isVoid then
				// A required property that is void raises an exception.
				if prop.lower == 1 then
					var e : ConstraintViolatedInv init ConstraintViolatedInv.new
					e.constraintAppliedTo := self
					e.message := "Invariant lower bound of " + cd.name + "_" + prop.name + "_" + prop.type.toString + " violated on " + self.toString
					e.failedConstraint := invariant
					raise e
				end
			else
				// not void
				// if this is a collection
				if v.isInstanceOf(Collection<Object>) then
					var coll : Collection<Object> init v.asType(Collection<Object>)
				
					// A collection that does not respect the defined bounds raises an exception.
					if ( prop.upper != minusOne and coll.size() > prop.upper ) then
						var e : ConstraintViolatedInv init ConstraintViolatedInv.new
						e.constraintAppliedTo := self
						e.message := "Invariant upper bound of " + cd.name + "_" + prop.name + "_" + prop.type.toString + " violated on " + self.toString
						e.failedConstraint := invariant
						raise e
					end
					if ( coll.size() < prop.lower ) then
						var e : ConstraintViolatedInv init ConstraintViolatedInv.new
						e.constraintAppliedTo := self
						e.message := "Invariant lower bound of " + cd.name + "_" + prop.name + "_" + prop.type.toString + " violated on " + self.toString
						e.failedConstraint := invariant
						raise e
					end
				end
			end				
			
		
		else // This is a Class invariant
			do
				// extern call
				@compiledJavaExtern "org.kermeta.compil.runtime.helper.language.ObjectUtil.checkInvariant(this, invariant)"
				extern fr::irisa::triskell::kermeta::runtime::language::Object.checkInvariant(self, invariant)
			end	
		end


	end

}
