/* $Id:$ 
 * Creation : September 28, 2009
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            jfalcou
 */
//@mainClass "language::Main"
//@mainOperation "main"

/* $Id:$ 
 * Creation : September 25, 2009
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            jfalcou
 */
//@mainClass "language::Main"
//@mainOperation "main"


package kermeta::language::structure;
require "../Standard.kmt"
require "../exceptions/constraint_exceptions.kmt"

using kermeta::language::structure
using kermeta::language::behavior
using kermeta::exceptions
using kermeta::standard
using kermeta::persistence



/*
 * The class PropertyConstraint extends the class Constraint in order to
 * differentiate multiplicity invariants from genuine Class invariants 
 */
class PropertyConstraint inherits Constraint {
	/**
	 * The property that is checked by this constraint
	 * Typically, it will check the lower and upper bounds
	 */
	reference ~property : Property#propertyConstraint
}

aspect class Property {
    /** special constraint that apply to this Property
     * Used by the getViolatedConstraints
     */
	attribute propertyConstraint : PropertyConstraint#~property
	attribute getViolatedConstraintsMustDrillDownCache : Boolean
	operation getViolatedConstraintsMustDrillDown() : Boolean is do
		if getViolatedConstraintsMustDrillDownCache.isVoid then
			getViolatedConstraintsMustDrillDownCache := not kermeta::standard::ValueType.isSuperTypeOf(self.type)
		end
		result := getViolatedConstraintsMustDrillDownCache
	end
}

aspect class ClassDefinition {

	/**
	 * Data structure for getCachedAllAttribute
	 */
	reference _allAttributeCache : Set<Property>
	/**
	 * returns a cached version of the derived property allAttribute
	 * It is intended to be used to optimize access on the reflexivity, 
	 * do not use this cache if you are modifying the ClassDefinition
	 */
	operation getCachedAllAttribute() : Set<Property> is do
		if _allAttributeCache.isVoid then
			_allAttributeCache := allAttribute
		end
		result := _allAttributeCache
	end
	
	/**
	 * Data structure for getCachedAllSuperTypes
	 */
	reference _allSuperTypesCache : Set<Type>
	/**
	 * returns a cached version of the derived property allSuperTypes
	 * It is intended to be used to optimize access on the reflexivity, 
	 * do not use this cache if you are modifying the ClassDefinition
	 */
	operation getCachedAllSuperTypes() : Set<Type> is do
		if _allSuperTypesCache.isVoid then
			_allSuperTypesCache := allSuperTypes
		end
		result := _allSuperTypesCache
	end
}

aspect class Object
{
	/**
	 * Checks all the invariants for this object and return a complete diagnostic.
	 * This also includes the structural constraints associated to the properties.
	 */
	operation getViolatedConstraints() : kermeta::exceptions::ConstraintsDiagnostic is do
	
		// init result
		var contraintes : ConstraintsDiagnostic init ConstraintsDiagnostic.new.initialize
		// stdio.writeln("        " + self.toString +".getViolatedConstraints()")
		var cd : ClassDefinition 
		cd := self.getMetaClass().classDefinition
		
		//stdio.writeln("    >> getViolatedConstraints, Class def : " + cd.name )
		
		if ( not cd.isVoid ) then
			
			// Checking invariants
			cd.~inv.each{invariant |
				do
					checkInvariant(invariant)
					rescue (e : ConstraintViolatedInv) 
					    stdio.writeln("    " + e.message)
						contraintes.add(e)
				end
			}
			
			
			// Checking properties and drill down into the contained objects
			cd.getCachedAllAttribute.each{ prop |
				
				//stdio.writeln("  checking " + prop.name + ", composite " + prop.isComposite.toString )			
				if not prop.tag.exists{t| t.name == "ecore.isTransient"} and
				   not prop.isDerived
				then
					// build a constraint with the property
					var constraint : PropertyConstraint init prop.propertyConstraint
					if constraint.isVoid then
						constraint := PropertyConstraint.new
						if prop.type.isInstanceOf(ParameterizedType) then
							constraint.name := cd.name + "_" + prop.name + "_" + prop.type.asType(ParameterizedType).typeDefinition.name
						else
							constraint.name := cd.name + "_" + prop.name + "_" + prop.type.toString
						end
						//constraint.invOwner := cd // ajout pour les markers
						constraint.~property := prop
					end
					do
						checkInvariant(constraint)
						rescue (e : ConstraintViolatedInv)
							// add the violated constraint to the report 
							contraintes.add(e)
					end		
			
					// Recursivity
					if ( prop.isComposite and prop.getViolatedConstraintsMustDrillDown) 
					then
					    var propValue : Object init self.get(prop)
					    // need to ignore ValueType and EnumerationLiteral for performance sake 					    	
						if not propValue.isVoid() 
						then
							
							if prop.upper.equals(1)
							then
								if not propValue.isInstanceOf(kermeta::language::structure::EnumerationLiteral) then
									propValue.getViolatedConstraints.setConstraints.each{v|
										stdio.writeln("    " + v.message)																				
										contraintes.add(v)}
								end							
							else
								var subObjInstances : kermeta::standard::Collection<Object>
								subObjInstances ?= propValue
								subObjInstances.each { aSubObjInstance |
									if not aSubObjInstance.isInstanceOf(kermeta::language::structure::EnumerationLiteral) then 
										aSubObjInstance.getViolatedConstraints
																			.setConstraints. each{v|
																				stdio.writeln("    " + v.message)
																				contraintes.add(v)}
									end 
									}
							end
						end
					end
				end
				
				
			}
			
			
			
		end
	
		result := contraintes
		
	end

	/**
	 * Checks a constraint invariant defined for the metaclass of the Object
	 * You can use PropertyConstraint for checking structural constraints associated to a property
	 */
	operation checkInvariant(invariant : Constraint) : Void is do 
	
	    
		// workaround for bug 8911
		var minusOne : Integer init -1
	
		var cd : ClassDefinition init self.getMetaClass.classDefinition
		
		// If the invariant is a PropertyConstraint, check the multiplicities
		if (invariant.isKindOf(PropertyConstraint))
		then
			// retrieve property
			var prop : Property init invariant.asType(PropertyConstraint).~property		
			var v : Object init self.get(prop)
			
			
			if 	v.isVoid then
				// A required property that is void raises an exception.
				if prop.lower == 1 then
					var e : ConstraintViolatedInv init ConstraintViolatedInv.new
					e.constraintAppliedTo := self
					e.message := "Invariant lower bound of " + cd.name + "_" + prop.name + "_" + prop.type.toString + " violated on " + self.toString
					e.failedConstraint := invariant
					raise e
				end
			else
				// not void
				// if this is a collection
				if v.isInstanceOf(Collection<Object>) then
					var coll : Collection<Object> init v.asType(Collection<Object>)
				
					// A collection that does not respect the defined bounds raises an exception.
					if ( prop.upper != minusOne and coll.size() > prop.upper ) then
						var e : ConstraintViolatedInv init ConstraintViolatedInv.new
						e.constraintAppliedTo := self
						e.message := "Invariant upper bound of " + cd.name + "_" + prop.name + "_" + prop.type.toString + " violated on " + self.toString
						e.failedConstraint := invariant
						raise e
					end
					if ( coll.size() < prop.lower ) then
						var e : ConstraintViolatedInv init ConstraintViolatedInv.new
						e.constraintAppliedTo := self
						e.message := "Invariant lower bound of " + cd.name + "_" + prop.name + "_" + prop.type.toString + " violated on " + self.toString
						e.failedConstraint := invariant
						raise e
					end
				end
			end				
			
		
		else // This is a Class invariant
			do
				// extern call
				@compiledJavaExtern "org.kermeta.compil.runtime.helper.language.ObjectUtil.checkInvariant(this, invariant)"
				extern fr::irisa::triskell::kermeta::runtime::language::Object.checkInvariant(self, invariant)
			rescue (error : RuntimeError)
				// encapsulate the error in a ConstraintViolatedInv
				var e : ConstraintViolatedInv init ConstraintViolatedInv.new
				e.constraintAppliedTo := self
				e.message := "Invariant violated on " + self.toString + "runtime error (probably due to another failed constraint or an error in the code of the constraint)"
				e.failedConstraint := invariant
				e.nestedException := error
				raise e
			end	
		end


	end
}

