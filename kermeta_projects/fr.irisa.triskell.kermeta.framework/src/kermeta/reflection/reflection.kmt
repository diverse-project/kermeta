/* $Id: reflection.kmt,v 1.43 2007-07-10 15:06:08 cfaucher Exp $
 * Project   : fr.irisa.triskell.kermeta.framework
 * File      : reflection.kmt
 * License   : EPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * ----------------------------------------------------------------------------
 * Creation date : Mar 14, 2006
 * Authors   : 
 *		Franck Fleurey <ffleurey@irisa.fr>
 *		Zoï¿½ Drey <zdrey@irisa.fr>
 * 		Didier Vojtisek <dvojtise@irisa.fr>
 */
 
/**
 * Contains all the abstract classes used in the reflection mechanism. Implements the <b>derived
 * properties</b> contained in the classes; declares the abstract operations.
 * Concrete implementation is in kermeta.language.structure.
 */
package kermeta::reflection;

require "../standard/collections.kmt"
require "../persistence/resource.kmt"

alias String : kermeta::standard::String;

/** 
 * Object type : all entities of Kermeta metamodel explicitely inherit Object.
 */
abstract class Object
{
	/** Tags are used to put comments/documentation */
	reference tag : set Tag[0..*]#object
	operation getMetaClass() : Class is abstract
	operation container() : Object is abstract
	operation checkInvariants() : Void is abstract
	operation checkAllInvariants() : Void is abstract
	/** semantic equality,
	 * if you wish to test for object identity you need to use the method oid
	 * ex: x.oid == y.oid
	 * by default, (ie. if not overloaded), the equals method for class Object implements 
	 * the most discriminating possible equivalence relation on objects; that is, for any non-null 
	 * reference values x and y, this method returns true if and only if x and y refer to the same 
	 * object (x.oid == y.oid has the value true). 
	 *
	 * note1: the operator == is mapped to this 
	 * note2: overloading this operation have some impact on the behavior on collection and hashtable that rely on it
	 */
	operation equals(element : Object) : Boolean is abstract
	operation isNotEqual(element : Object) : Boolean is abstract	
	
	/** Check if the current object is an instance of the given class.*/
	operation isKindOf(cl : Class) : Boolean is abstract
	
	/** Check if the current object conforms to the given type */
	operation isInstanceOf(type : Type) : Boolean is abstract
	
	/** Implementation of OCL like cast. It returns self if the object object conforms to the type givent as parameter. */
	operation asType(type : Class) : Object is abstract
	/** 
	 * Returns the instances of the given property for this Object.
	 *
	 * Example : 
	 * <pre>
	 * class A { reference attr : String }
	 * </pre>
	 * Using A :
	 * <pre>
	 * operation getAProp() is do
	 *    var a : A
	 *    var s : String
	 *    var the_attr : Property init self.getMetaClass.ownedAttribute.one
	 *    s ?= a.get(the_attr)
	 * end
	 * </pre>
	 * The user has to cast
	 * the result of this method according to the type and the upper multiplicity
	 * of this property. If upper multiplicity > 1, than the effective type of the 
	 * result is a Sequence<ThePropertyName>. Otherwise, the type corresponds to 
	 * the name of the given Property (i.e the type of the property instance).
	 */
	operation get(~property : Property) : Object is abstract
	operation ~set(~property : Property, element : Object) : Void is abstract
	operation isSet(~property : Property) : Boolean is abstract
	operation unset(~property : Property) : Void is abstract
	operation oid() : Integer is abstract
	operation toString() : String is abstract
	operation isFrozen() : Boolean is abstract
	operation freeze() : Void is abstract
	operation isVoid() : Boolean is abstract
	/**
	 * code used in hashtable in order to identify an object in the hashtable keys
	 * This system is similar to the hashcode used in java. Please refer to java documentation
	 * for more information about hashcode
	 */
	operation hashcode() : Integer is abstract
	
	/*operation collect<T> (collector : <Object -> T>) :  kermeta::standard::Sequence<T> is do
	*	result := kermeta::standard::Sequence<T>.new
	*		result.add( collector(self) )
	* end*/
	
	/**
	 * Returns the Resource currently containing (directly or indirectly) the object 
	 * or void if the object belongs to ne resource
	 */
	operation containingResource() : kermeta::persistence::Resource is abstract
}

/** Alias for kermeta::standard::Boolean */
alias Boolean : kermeta::standard::Boolean;
/** Alias for kermeta::standard::Integer */
alias Integer : kermeta::standard::Integer;

/** Abstraction for Parameterized types, namely, Class and ModelType*/
abstract class ParameterizedType inherits Type
{
	reference typeDefinition : GenericTypeDefinition[1..1]
	attribute typeParamBinding : set TypeVariableBinding[0..*]
	attribute virtualTypeBinding : set TypeVariableBinding[0..*]
}
/** Type corresponding to the <b>use</b> of a ClassDefinition (see ClassDefinition)
 */
abstract class Class inherits ParameterizedType
{
	/** Returns the attributes, references, and derived properties owned by
	 *  the classDefinition of this class.
	 */
	property readonly ownedAttribute : set Property[0..*]
		getter is do
			var cDef : ClassDefinition
			cDef ?= typeDefinition
			result := cDef.ownedAttribute
		end
		
	/** Returns the operations owned by the classDefinition of this class.
	 */
	property readonly ownedOperation : set Operation[0..*]
		getter is do
			var cDef : ClassDefinition
			cDef ?= typeDefinition
			result := cDef.ownedOperation
		end
		
	/** Returns the Classes of which the classDefinition of this class inherits.
	 */
	property readonly superClass : set Class[0..*]
		getter is do
			var cDef : ClassDefinition
			cDef ?= typeDefinition
			result := cDef.superType
		end
		
	/** Returns true if the classDefinition of this class is abstract.
	 */ 
	property readonly isAbstract : Boolean
		getter is do
			var cDef : ClassDefinition
			cDef ?= typeDefinition
			result := cDef.isAbstract
		end
	
	/** Returns the name of the classDefinition of this class
	 */
	property readonly name : String
		getter is do
			result := typeDefinition.name
		end
	operation new() : Object is abstract
	
	/** Returns the String representation of this class. 
	 *  Note : throws an exception if this class has no classDefinition
	 *  or if the classDefinition is not well constructed.
	 */
	method toString() : String is do
		result := self.typeDefinition.name
	end
}
/** Type of a model, consisting of a set of included type definitions */
abstract class ModelType inherits Type, TypeDefinition
{
	reference includedTypeDefinition : set TypeDefinition[0..*]
	operation new() : Model is abstract
	operation isModelTypeOf(model : Model) : Boolean is abstract
}

/** Is the holder of a set of model elements (Object) that are compatible with the ModelType that has 
 * instanciated this Model.
 */
abstract class Model inherits Object
{
	/** Contents of this model ... */
 	reference readonly contents : set Object[0..*]
 	
 	/** returns a set of all the elements of the model that are instance of the given Type */
 	operation filter(vtype : Type) : set Object[0..*] is abstract
 	
 	/** add an object to the model. According to the ModelType, the typechecker will statically verify if the object can be added or not */ 
 	operation add(obj : Object) : Void is abstract
 	
 	/** remove an object from the model */
 	operation remove(obj : Object) : Void is abstract
 	
 	/** add all the Object of the collection that are copmpatible with the ModelDefinition. Other objects are ignored.
 	 * Returns the list of Object that have been added (One can check that some element have been ignored or not)
 	 */
 	operation addAllCompatible(objectsToAdd : kermeta::standard::Collection<Object>) : kermeta::standard::Collection<Object> is abstract
 	
 	/** add the Object if it is copmpatible with the ModelDefinition. Other objects are ignored.
 	 * Returns the object if it has been added (One can check that some element have been ignored or not)
 	 *   return Void if not added
 	 */
 	operation addCompatible(objectsToAdd : Object) : Object is abstract
}
/** Model elements with a multiplicity [lower..upper] inherit this class*/
abstract class MultiplicityElement inherits TypedElement
{
	attribute isOrdered : Boolean
	attribute isUnique : Boolean
	attribute lower : Integer
	attribute upper : UnlimitedNatural
}
/** Constraint is part of a contract implementation in a Class definition or an operation.
 * Three kinds of constraints are available : pre, post, and inv (invariant constraint)
 */
abstract class Constraint inherits NamedElement
{
	reference invOwner : ClassDefinition[0..1]#~inv
	reference preOwner : Operation[0..1]#~pre
	reference postOwner : Operation[0..1]#~post
}
/** Every one knows what an operation is. */
abstract class Operation inherits MultiplicityElement
{
	attribute isAbstract : Boolean
	attribute ~pre : set Constraint[0..*]#preOwner
	attribute ~post : set Constraint[0..*]#postOwner
	
	reference superOperation : Operation
	reference owningClass : ClassDefinition#ownedOperation
	reference typeParameter : set TypeVariable[0..*]
	reference raisedException : set Type[0..*]
	attribute ownedParameter : set Parameter[0..*]#~operation
}
/** Tag is intended to be used to add documentation on a 
 * model element, or add some textual information that cannot be expressed
 * with any model element definition.
 */
abstract class Tag inherits Object
{
	reference object : set Object[1..*]#tag
	attribute name : String
	attribute ~value : String
}
/** Class representing the property definition. Kermeta<->Ecore equivalence:
 *  - Property with isComposite == true or with type is a base type (String, Integer, Boolean)  : EAttribute
 *  - Property with isComposite == false : EReference
 */
abstract class Property inherits MultiplicityElement
{
	reference owningClass : ClassDefinition#ownedAttribute
	reference opposite : Property
	attribute isReadOnly : Boolean
	attribute default : String
	attribute isComposite : Boolean
	attribute isDerived : Boolean
	attribute isID : Boolean
}
/** Phantom class : EMF reflexive editors need that any element of a metamodel 
 * has a direct or indirect containment relationship with the root model element of
 * the metamodel. This class resolves this technical requirement.
 */
abstract class TypeContainer inherits Object
{
	attribute containedType : set Type[0..*]#typeContainer
}
abstract class VirtualTypeContainer inherits Object
{
	attribute virtualType : set VirtualType[0..*]#modelType
}

/** 
 * Abstracts the definition of generic type definitions (i.e. type definitions that
 * can be parameterized), namely, for ClassDefinition and ModelTypeDefinition.
 */
abstract class GenericTypeDefinition inherits TypeDefinition
{
	attribute typeParameter : set TypeVariable[0..*]
}
/** The definition of a class definition :)
 *  <pre>class A
 *{ 
 *   attribute s : String
 *}
 *   </pre> is a class definition; in :
 * <pre>
 * main() : A is do end
 * </pre>
 * A is a <b>Class</b> : it corresponds to the <b>use</b> of the class definition of A
 */
abstract class ClassDefinition inherits TypeContainer, GenericTypeDefinition
{
	attribute isAbstract : Boolean
	
	/** Returns the attributes, references, and derived properties owned by
	 *  this class definition.
	 */
	attribute ownedAttribute : set Property[0..*]#owningClass
	
	/** Returns the operations owned by this class definition.
	 */
	attribute ownedOperation : set Operation[0..*]#owningClass
	attribute ~inv : set Constraint[0..*]#invOwner
	
	/** Returns the Classes of which this class definition inherits.
	 */
	reference superType : set Class[0..*]

	/** Returns all the attributes, references, derived properties of this 
	 *  class definition including the inherited ones
	 */
	property readonly allOwnedAttribute : set Property[0..*]
		getter is do
 		    result := kermeta::standard::Set<Property>.new
 		    result.addAll(self.ownedAttribute)
		    self.superType.each{ t | 
		    	var cDef : ClassDefinition
		    	cDef ?= t.typeDefinition
				cDef.allOwnedAttribute.each{ p | 
					result.add(p)
				}
			}
		end
		
	/** Returns only the attributes (isComposite and not isDerived)
	 *  class definition
	 */
	property readonly ownedCompositeAttribute : set Property[0..*]
		getter is do
 		    result := kermeta::standard::Set<Property>.new
 		    self.ownedAttribute.each{ oa |
 		    	if (oa.isComposite and not oa.isDerived) then
 		    		result.add(oa)
 		    	end
 		    }
		end
	
	/** Returns only all the attributes (isComposite and not isDerived)
	 *  class definition including the inherited ones
	 */
	property readonly ownedAllCompositeAttribute : set Property[0..*]
		getter is do
 		    result := kermeta::standard::Set<Property>.new
 		    self.allOwnedAttribute.each{ oa |
 		    	if (oa.isComposite and not oa.isDerived) then
 		    		result.add(oa)
 		    	end
 		    }
		end
	
	/** Returns only the references (not isComposite and not isDerived)
	 *  class definition
	 */
	property readonly ownedAttributeAsReference : set Property[0..*]
		getter is do
 		    result := kermeta::standard::Set<Property>.new
 		    self.ownedAttribute.each{ oa |
 		    	if (not oa.isComposite and not oa.isDerived) then
 		    		result.add(oa)
 		    	end
 		    }
		end
	
	/** Returns only all the references (not isComposite and not isDerived)
	 *  class definition including the inherited ones
	 */
	property readonly ownedAllAttributeAsReference : set Property[0..*]
		getter is do
 		    result := kermeta::standard::Set<Property>.new
 		    self.allOwnedAttribute.each{ oa |
 		    	if (not oa.isComposite and not oa.isDerived) then
 		    		result.add(oa)
 		    	end
 		    }
		end

	/** Returns only the properties (not isComposite and isDerived)
	 *  class definition
	 */
	property readonly ownedAttributeAsProperty : set Property[0..*]
		getter is do
 		    result := kermeta::standard::Set<Property>.new
 		    self.ownedAttribute.each{ oa |
 		    	if (not oa.isComposite and oa.isDerived) then
 		    		result.add(oa)
 		    	end
 		    }
		end
	
	/** Returns only all the properties (not isComposite and isDerived)
	 *  class definition including the inherited ones
	 */
	property readonly ownedAllAttributeAsProperty : set Property[0..*]
		getter is do
 		    result := kermeta::standard::Set<Property>.new
 		    self.allOwnedAttribute.each{ oa |
 		    	if (not oa.isComposite and oa.isDerived) then
 		    		result.add(oa)
 		    	end
 		    }
		end

	/** Returns all the operations of this 
	 *  class definition including the inherited ones
	 */
	property readonly allOwnedOperation : set Operation[0..*]
		getter is do
 		    result := kermeta::standard::Set<Operation>.new
 		    result.addAll(self.ownedOperation)
		    self.superType.each{ t | 
		    	var cDef : ClassDefinition
		    	cDef ?= t.typeDefinition
				cDef.allOwnedOperation.each{ p | 
					result.add(p)
				}
			}
		end
}

/** Abstraction of the notion of typed element : each element 
 * that is typed inherits this class. */
abstract class TypedElement inherits TypeContainer, NamedElement
{   
    /** The type of this model element */
	reference type : Type
}

/** Definition of a type variable for generic types :  
 * in class definition <pre>class AClass<X,Y> {}</pre>, X and Y are type variables.
 */
abstract class TypeVariable inherits TypeContainer, Type, NamedElement
{
	reference supertype : Type
}
abstract class ObjectTypeVariable inherits TypeContainer, TypeVariable
{
}
abstract class VirtualType inherits ObjectTypeVariable {
	reference classDefinition : ClassDefinition[1]
	reference modelType : VirtualTypeContainer[1]#virtualType
	reference typeParamBinding : TypeVariableBinding[0..*]
}
abstract class ModelTypeVariable inherits TypeVariable, VirtualTypeContainer {
}
abstract class ProductType inherits TypeContainer, Type
{
	reference type : set Type[1..*]
}
/**
 * Type used to define the use of lambda expressions.
 *  Uses :
 *  <pre>operation forAll(func : <G -> Boolean>) : Boolean is do
 *      var test : Boolean init true
 *      from var it : Iterator<G> init iterator
 *      until it.isOff
 *      loop
 *         test := test and func(it.next)
 *      end
 *      result := test
 *  end
 *  </pre>
 *
 *  In the above example, &lt;G -> Boolean&gt; is a function type f(G) -&gt; 
 *  Boolean, with a parameter of type G and a return type of type Boolean
 *  The operation <code>forAll</code> takes a lambda expression as parameter.
 */
abstract class FunctionType inherits TypeContainer, Type
{
	reference left : Type
	reference right : Type
}

/** Base class definition for the <b>use</b> of a type.
 */
abstract class Type inherits Object
{
	reference typeContainer : TypeContainer[0..1]#containedType
	operation isInstance(element : Object) : Boolean is abstract
	operation hasSubType(element : Type) : Boolean is abstract
}
abstract class TypeVariableBinding inherits TypeContainer, Object
{
	reference variable : TypeVariable[1..1]
	reference type : Type[1..1]
}
/** The class definition for kermeta aliases. Above statement defines a primitive
 * type called MyString, which instanceType is <code>kermeta::standard::String</code>
 * <pre>alias MyString : kermeta::standard::String</pre>
 */
abstract class PrimitiveType inherits TypeContainer, DataType
{
	reference instanceType : Type
}
/** Any element that contain a  name (example : Operation, Property) inherit this
* class.
 */
abstract class NamedElement inherits Object
{   
    /** Name of this named element */
	attribute name : String[1..1]
	
	/** Returns the qualified name of this named element. Qualified name is 
	 * the list of the names of the packages hierarchically ordered, delimited by
	 * a "::", followed by the name of this named element.
	 */
	operation qualifiedName() : String is do
		var elem : NamedElement init self
		result := self.name
		from elem ?= elem.container
		until elem == void 
		loop
			result := elem.name + "::" + result
			elem ?= elem.container
		end
	end
	
}

/**
 * Self type : DEPRECATED
 */
abstract class SelfType inherits Type
{
}
/** 
 * Abstraction of the notion of containment for type definitions. Now, kermeta metamodel contains one container
 * element, that is Package. In a later release, ModelTypeDefinition will be the main container for type and
 * package definition.
 */
abstract class TypeDefinitionContainer inherits NamedElement
{
	attribute ownedTypeDefinition : set TypeDefinition[0..*]
}
/**
 * Package in kermeta. Each kermeta model must have a root package. 
 */
abstract class Package inherits TypeDefinitionContainer
{
	attribute nestedPackage : set Package[0..*]#nestingPackage
	reference nestingPackage : Package#nestedPackage
	attribute uri : String
}
/**
 * Abstraction for type definitions (ClassDefinition, ModelTypeDefinition, DataType inherit
 * this class)
 */
abstract class TypeDefinition inherits NamedElement
{
	/** this boolean allows to tell if this Type definition is an aspect or not
	 * If it is an aspect, then at runtime, its definition will be merged with the definition of another
	 * TypeDefinition that has exactly the same qualified name
	 */
	attribute isAspect : Boolean
	
	/** References to the base classes */
	reference baseAspects : TypeDefinition[0..*]
}
/** Class definition for the <pre>Void</pre> type */
abstract class VoidType inherits Type
{
}
/** Special type definition for Enumeration, PrimitiveType  */
abstract class DataType inherits TypeDefinition, Type
{
}
/** Definition for enumeration */
abstract class Enumeration inherits DataType
{   /** Owned item in an enumeration */
	attribute ownedLiteral : set EnumerationLiteral[0..*]#~enumeration
}
/** Item definition for enumeration */
abstract class EnumerationLiteral inherits NamedElement
{   /* Owning enumeration */
	reference ~enumeration : Enumeration#ownedLiteral
}
/** Definition for operation parameter */
abstract class Parameter inherits MultiplicityElement
{   /** Owning operation */
	reference ~operation : Operation#ownedParameter
}
/** Alias for kermeta::standard::UnlimitedNatural */
alias UnlimitedNatural : kermeta::standard::UnlimitedNatural;

