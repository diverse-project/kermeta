/* $Id: reflection.kmt,v 1.62 2008-01-23 10:49:37 cfaucher Exp $
 * Project   : fr.irisa.triskell.kermeta.framework
 * File      : reflection.kmt
 * License   : EPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * ----------------------------------------------------------------------------
 * Creation date : Mar 14, 2006
 * Authors   : 
 *		Franck Fleurey <ffleurey@irisa.fr>
 *		Zoe Drey <zdrey@irisa.fr>
 * 		Didier Vojtisek <dvojtise@irisa.fr>
 */


/**
 * Contains all the abstract classes used in the reflection mechanism. Implements the <b>derived
 * properties</b> contained in the classes; declares the abstract operations.
 * Concrete implementation is in kermeta.language.structure.
 * <img src="platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/reflection_package.png">
 */
  @uri "http://www.kermeta.org/kermeta/reflection"
package kermeta::reflection;

require "../standard/collections.kmt"
require "../persistence/resource.kmt"

alias String : kermeta::standard::String;

/** 
 * Object definition: all entities of Kermeta metamodel explicitly inherit from Object
 */
abstract class Object
{
	/**
	 * An object can contains a Tag.  
	 * Be careful, owning a tag doesn't means that the tag applies to the Object
	 * To know which Tags apply to the object use the "tag" reference
	 */
	attribute ownedTags : set Tag[0..*]

	/**
	 * An Object can be tagged by a Tag. 
	 * They are typically used to put comments/documentation on the object
	 */
	reference tag : set Tag[0..*]#object
	
	/**
	 * Returns the Class object that is the metaclass of current Object
	 */
	operation getMetaClass() : Class is abstract
	
	/**
	 * Returns the Object that contains current Object, void if the Object has
	 * no container
	 */
	operation container() : Object is abstract
	
	/**
	 * Runs checking of invariants defined for the metaclass of the Object
	 */
	operation checkInvariants() : Void is abstract
	
	/**
	 * Recursively runs checking of invariants defined for the metaclass of the Object
	 * and its supertypes
	 */
	operation checkAllInvariants() : Void is abstract

	/**
	 * semantic equality,
	 * if you wish to test for object identity you need to use the method oid
	 * ex: x.oid == y.oid
	 * by default, (ie. if not overloaded), the equals method for class Object implements 
	 * the most discriminating possible equivalence relation on objects; that is, for any non-null 
	 * reference values x and y, this method returns true if and only if x and y refer to the same 
	 * object (x.oid == y.oid has the value true). 
	 *
	 * note1: the operator == is mapped to this 
	 * note2: overloading this operation have some impact on the behavior on collection and hashtable that rely on it
	 */
	operation equals(element : Object) : Boolean is abstract

	/**
	 * See kermeta::reflection::Object.equals(Object)
	 */
	operation isNotEqual(element : Object) : Boolean is abstract	
	
	/**
	 * Returns a Boolean stating whether the current Object is an instance of the given Class
	 */
	operation isKindOf(cl : Class) : Boolean is abstract
	
	/**
	 * Returns a Boolean stating whether the current Object conforms to given Type
	 * This means: is this object an instance of this type, or is it an instance of its subtype 
	 */
	operation isInstanceOf(type : Type) : Boolean is abstract
	
	/**
	 * Implementation of OCL like cast. It returns self if the object object conforms to the type given as parameter.
	 */
	operation asType(type : Class) : Object is abstract

	/** 
	 * Returns the instances of the given property for this Object.
	 *
	 * Example : 
	 * <pre>
	 * class A { reference attr : String }
	 * </pre>
	 * Using A :
	 * <pre>
	 * operation getAProp() is do
	 *    var a : A
	 *    var s : String
	 *    var the_attr : Property init self.getMetaClass.ownedAttribute.one
	 *    s ?= a.get(the_attr)
	 * end
	 * </pre>
	 * The user has to cast
	 * the result of this method according to the type and the upper multiplicity
	 * of this property. If upper multiplicity > 1, than the effective type of the 
	 * result is a Sequence<ThePropertyName>. Otherwise, the type corresponds to 
	 * the name of the given Property (i.e the type of the property instance).
	 */
	operation get(~property : Property) : Object is abstract

	/**
	 * Sets the <code>element</code> to the <code>~property</code> of the object 
	 */
	operation ~set(~property : Property, element : Object) : Void is abstract

	/**
	 * True if the <code>~property</code> of the object has been set
	 */
	operation isSet(~property : Property) : Boolean is abstract

	/**
	 * Remove the element set as the <code>~property</code> of the object.
	 * The <code>isSet(~property)</code> method will then return False
	 */
	operation unset(~property : Property) : Void is abstract

	/**
	 * Returns the unique Oid of the Object
	 */
	operation oid() : Integer is abstract

	/**
	 * Returns the String representation of the Object
	 */
	operation toString() : String is abstract

	/**
	 * Returns a Boolean stating whether the Object is currently in a
	 * frozen state
	 */
	operation isFrozen() : Boolean is abstract

	/**
	 * Freeze the Object
	 */
	operation freeze() : Void is abstract

	/**
	 * Returns a Boolean stating whether the Object is Void
	 */
	operation isVoid() : Boolean is abstract

	/**
	 * code used in hashtable in order to identify an object in the hashtable keys
	 * This system is similar to the hashcode used in java. Please refer to java documentation
	 * for more information about hashcode
	 */
	operation hashcode() : Integer is abstract
	
	/*operation collect<T> (collector : <Object -> T>) :  kermeta::standard::Sequence<T> is do
	*	result := kermeta::standard::Sequence<T>.new
	*		result.add( collector(self) )
	* end*/
	
	/**
	 * Returns the Resource currently containing (directly or indirectly) the Object 
	 * or void if the object belongs to no Resource
	 */
	operation containingResource() : kermeta::persistence::Resource is abstract
}


/** Alias for kermeta::standard::Boolean */
alias Boolean : kermeta::standard::Boolean;
/** Alias for kermeta::standard::Integer */
alias Integer : kermeta::standard::Integer;
/** Alias for kermeta::standard::UnlimitedNatural */
alias UnlimitedNatural : kermeta::standard::UnlimitedNatural;


/**
 * Abstraction for Parameterized types, namely, Class and ModelType
 */
abstract class ParameterizedType inherits Type
{
	/**
	 * Definition of the Type
	 */
	reference typeDefinition : GenericTypeDefinition[1..1]

	/**
	 * Bindings between type variables and provided types 
	 */
	attribute typeParamBinding : set TypeVariableBinding[0..*]

	/**
	 * To be written #################################
	 */
	attribute virtualTypeBinding : set TypeVariableBinding[0..*]
}


/**
 * Type corresponding to the <b>use</b> of a ClassDefinition (see ClassDefinition)
 */
abstract class Class inherits ParameterizedType
{
	/**
	 * Returns the Attributes, References, and derived Properties owned by
	 * the ClassDefinition of this Class.
	 */
	property readonly ownedAttribute : set Property[0..*]
		getter is do
			var cDef : ClassDefinition
			cDef ?= typeDefinition
			result := cDef.ownedAttribute
		end
		
	/**
	 * Returns the Operations owned by the ClassDefinition of this Class.
	 */
	property readonly ownedOperation : set Operation[0..*]
		getter is do
			var cDef : ClassDefinition
			cDef ?= typeDefinition
			result := cDef.ownedOperation
		end
		
	/**
	 * Returns the Classes of which the ClassDefinition of this Class inherits.
	 */
	property readonly superClass : set Class[0..*]
		getter is do
			var cDef : ClassDefinition
			cDef ?= typeDefinition
			result := cDef.superType
		end
		
	/**
	 * Returns a Boolean stating whether ClassDefinition of this Class is abstract.
	 */ 
	property readonly isAbstract : Boolean
		getter is do
			var cDef : ClassDefinition
			cDef ?= typeDefinition
			result := cDef.isAbstract
		end
		
	/**
	 * Returns the ClassDefinition for this class
	 */
	property readonly classDefinition : ClassDefinition
		getter is do
			result ?= typeDefinition
		end
	
	/**
	 * Returns the name of the ClassDefinition of this Class
	 */
	property readonly name : String
		getter is do
			result := typeDefinition.name
		end
	
	/**
	 * Instantiates a new occurence for this Class
	 */
	operation new() : Object is abstract
	
	/**
	 * Returns the String representation of this class. 
	 *  Note : throws an exception if this class has no classDefinition
	 *  or if the classDefinition is not well constructed.
	 */
	method toString() : String is do
		result := self.typeDefinition.name
	end
}


/**
 * Type of a model, consisting of a set of included type definitions
 */
abstract class ModelType inherits Type, TypeDefinition
{
	/**
	 * To be written #######################################
	 */
	reference includedTypeDefinition : set TypeDefinition[0..*]

	/**
	 * To be written ##########################################
	 */
	operation new() : Model is abstract

	/**
	 * To be written ############################################
	 */
	operation isModelTypeOf(model : Model) : Boolean is abstract
}


/**
 * Is the holder of a set of model elements (Object) that are compatible with the ModelType that has 
 * instantiated this Model.
 */
abstract class Model inherits Object
{
	/**
	 * Contents of this model ...
	 */
 	reference readonly contents : set Object[0..*]
 	
 	/**
 	 * Returns a set of all the elements of the model that are instance of the given Type
 	 */
 	operation filter(vtype : Type) : set Object[0..*] is abstract
 	
 	/**
 	 * Add an object to the model. According to the ModelType, the typechecker will statically verify if the object can be added or not
 	 */ 
 	operation add(obj : Object) : Void is abstract
 	
 	/**
 	 * Remove an object from the model
 	 */
 	operation remove(obj : Object) : Void is abstract
 	
 	/**
 	 * Add all the Object of the collection that are copmpatible with the ModelDefinition. Other objects are ignored.
 	 * Returns the list of Object that have been added (One can check that some element have been ignored or not)
 	 */
 	operation addAllCompatible(objectsToAdd : kermeta::standard::Collection<Object>) : kermeta::standard::Collection<Object> is abstract
 	
 	/**
 	 * Add the Object if it is copmpatible with the ModelDefinition. Other objects are ignored.
 	 * Returns the object if it has been added (One can check that some element have been ignored or not)
 	 * return Void if not added
 	 */
 	operation addCompatible(objectsToAdd : Object) : Object is abstract
}


/**
 *  Model elements with a multiplicity [lower..upper] inherit this class
 */
abstract class MultiplicityElement inherits TypedElement
{
	/**
	 * Boolean stating whether the element is ordered
	 */
	attribute isOrdered : Boolean

	/**
	 * Boolean stating whether duplicated elements are allowed
	 */
	attribute isUnique : Boolean

	/**
	 * Min cardinality of the element
	 */
	attribute lower : Integer

	/**
	 * Max cardinality of the element, '-1' for '*'
	 */
	attribute upper : UnlimitedNatural
}


/**
 * Constraint is part of a contract implementation in a Class definition or an operation.
 * Three kinds of constraints are available : pre, post, and inv (invariant constraint)
 */
abstract class Constraint inherits NamedElement
{
	/**
	 * Owning ClassDefinition if Constraint corresponds to invariant
	 */
	reference invOwner : ClassDefinition[0..1]#~inv

	/**
	 * Owning Operation if Constraint corresponds to pre-condition
	 */
	reference preOwner : Operation[0..1]#~pre

	/**
	 * Owning Operation if Constraint corresponds to post-condition
	 */
	reference postOwner : Operation[0..1]#~post
}


/**
 * Every one knows what an operation is.
 */
abstract class Operation inherits MultiplicityElement
{
	/**
	 * Boolean stating whether the Operation is abstract
	 */
	attribute isAbstract : Boolean

	/**
	 * Pre-conditions of the Operation
	 */
	attribute ~pre : set Constraint[0..*]#preOwner

	/**
	 * Post-conditions of the Operation
	 */
	attribute ~post : set Constraint[0..*]#postOwner

	/**
	 * Super-operation of the Operation, if any
	 */	
	reference superOperation : Operation

	/**
	 * ClassDefinition owning the Operation
	 */
	reference owningClass : ClassDefinition[1]#ownedOperation

	/**
	 * TypeParameters of the Operation
	 */
	reference typeParameter : set TypeVariable[0..*]

	/**
	 * Exceptions raised by the Operation
	 */
	reference raisedException : set Type[0..*]

	/**
	 * Parameters of the Operation
	 */
	attribute ownedParameter : oset Parameter[0..*]#~operation
}


/**
 * Tag is intended to be used to add documentation on a  model element,
 * or add some textual information that cannot be expressed with any
 * model element definition.
 */
abstract class Tag inherits Object
{
	/**
	 * Objects to which the Tag is attached to
	 */
	reference object : set Object[1..*]#tag

	/**
	 * Name of the Tag
	 */
	attribute name : String

	/**
	 * String value of the Tag
	 */
	attribute ~value : String
}


/**
 * Class representing the property definition. Kermeta<->Ecore equivalence:
 *  - Property with isComposite == true or with type is a base type (String, Integer, Boolean)  : EAttribute
 *  - Property with isComposite == false : EReference
 */
abstract class Property inherits MultiplicityElement
{
	/**
	 * ClassDefinition that owns the Property
	 */
	reference owningClass : ClassDefinition#ownedAttribute

	/**
	 * Opposite Property of the Property, void if the Property has no opposite
	 */
	reference opposite : Property

	/**
	 * Boolean stating whether the Property is read-only
	 */
	attribute isReadOnly : Boolean

	/**
	 * To be written #######################################
	 */
	attribute default : String

	/**
	 * Boolean stating whether the Property has a containment role
	 */
	attribute isComposite : Boolean

	/**
	 * If True, the value of the property is not stored but computed from other properties
	 */
	attribute isDerived : Boolean

	/**
	 * Boolean stating whether the property allows to identify its containing Object
	 */
	attribute isID : Boolean
	
	/**
	 * Boolean stating wether the getter is abstract.
	 */
	attribute isGetterAbstract : Boolean
	
	/**
	 * Boolean stating wether the setter is abstract.
	 */
	attribute isSetterAbstract : Boolean
	
}


/**
 * Phantom class : EMF reflexive editors need that any element of a metamodel 
 * has a direct or indirect containment relationship with the root model element of
 * the metamodel. This class resolves this technical requirement.
 */
abstract class TypeContainer inherits Object
{
	/**
	 * Contained types
	 */
	attribute containedType : set Type[0..*]#typeContainer
}


/**
 * To be written #################################
 */
abstract class VirtualTypeContainer inherits Object
{
	/**
	 * To be written ##########################################
	 */
	attribute virtualType : set VirtualType[0..*]#modelType
}


/** 
 * Abstracts the definition of generic type definitions (i.e. type definitions that
 * can be parameterized), namely, for ClassDefinition and ModelTypeDefinition.
 */
abstract class GenericTypeDefinition inherits TypeDefinition
{
	/**
	 * Type variables defined for the GenericTypeDefinition
	 */
	attribute typeParameter : set TypeVariable[0..*]
}


/**
 * The definition of a class definition :)
 *  <pre>class A
 *{ 
 *   attribute s : String
 *}
 *   </pre> is a class definition; in :
 * <pre>
 * main() : A is do end
 * </pre>
 * A is a <b>Class</b> : it corresponds to the <b>use</b> of the class definition of A
 */
abstract class ClassDefinition inherits TypeContainer, GenericTypeDefinition
{
	/**
	 * Boolean stating whether the ClassDefinition is abstract (which means that
	 * no instance can be allocated)
	 */
	attribute isAbstract : Boolean
	
	/**
	 * Attributes, References, and derived Properties owned by this ClassDefinition.
	 */
	attribute ownedAttribute : set Property[0..*]#owningClass
	
	/**
	 * Operations owned by this ClassDefinition.
	 */
	attribute ownedOperation : set Operation[0..*]#owningClass

	/**
	 * Invariants defined for this ClassDefinition
	 */
	attribute ~inv : set Constraint[0..*]#invOwner
	
	/**
	 * Classes from which this ClassDefinition inherits.
	 */
	reference superType : set Class[0..*]

	/**
	 * Returns all the Attributes, References, derived Properties of this 
	 * ClassDefinition including the inherited ones
	 */
	property readonly allAttribute : set Property[0..*]
		getter is do
 		    result := kermeta::standard::Set<Property>.new
 		    result.addAll(self.ownedAttribute)
		    self.superType.each{ t | 
		    	var cDef : ClassDefinition
		    	cDef ?= t.typeDefinition
				cDef.allAttribute.each{ p | 
					result.add(p)
				}
			}
		end


	/**
	 * Returns all the Operations of this ClassDefinition
	 * including the inherited ones
	 */
	property readonly allOperation : set Operation[0..*]
		getter is do
 		    result := kermeta::standard::Set<Operation>.new
 		    result.addAll(self.ownedOperation)
		    self.superType.each{ t | 
		    	var cDef : ClassDefinition
		    	cDef ?= t.typeDefinition
				cDef.allOperation.each{ p | 
					result.add(p)
				}
			}
	end
}


/**
 * Abstraction of the notion of typed element : each element 
 * that is typed inherits this class.
 */
abstract class TypedElement inherits TypeContainer, NamedElement
{   
    /**
     * Type of the model element
     */
	reference type : Type[1]
}

/**
 * Definition of a type variable for generic types :  
 * in class definition <pre>class AClass<X,Y> {}</pre>, X and Y are type variables.
 */
abstract class TypeVariable inherits TypeContainer, Type, NamedElement
{
	/**
	 * Reference to the supertype, if any
	 */
	reference supertype : Type
}


/**
 * To be written ######################################
 */
abstract class ObjectTypeVariable inherits TypeContainer, TypeVariable
{
}


/**
 * To be written ######################################
 */
abstract class VirtualType inherits ObjectTypeVariable {

	/**
	 * To be written ######################################
	 */
	reference classDefinition : ClassDefinition[1]

	/**
	 * To be written ######################################
	 */
	reference modelType : VirtualTypeContainer[1]#virtualType

	/**
	 * To be written ######################################
	 */
	reference typeParamBinding : TypeVariableBinding[0..*]
}


/**
 * To be written ######################################
 */
abstract class ModelTypeVariable inherits TypeVariable, VirtualTypeContainer {
}


/**
 * Type corresponding to a set of Types
 * Only used in the context of FunctionType
 */
abstract class ProductType inherits TypeContainer, Type
{
	/**
	 * Types 
	 */
	reference type : set Type[1..*]
}


/**
 * Type used to define the use of lambda expressions.
 *  Uses :
 *  <pre>operation forAll(func : <G -> Boolean>) : Boolean is do
 *      var test : Boolean init true
 *      from var it : Iterator<G> init iterator
 *      until it.isOff
 *      loop
 *         test := test and func(it.next)
 *      end
 *      result := test
 *  end
 *  </pre>
 *
 *  In the above example, &lt;G -> Boolean&gt; is a function type f(G) -&gt; 
 *  Boolean, with a parameter of type G and a return type of type Boolean
 *  The operation <code>forAll</code> takes a lambda expression as parameter.
 */
abstract class FunctionType inherits TypeContainer, Type
{
	inv resultType is not right.isKindOf(ProductType)

	/**
	 * Parameters of the function (a ProductType for multiple parameters)
	 */
	reference left : Type[1]

	/**
	 * Result type of the function
	 */
	reference right : Type
}

/**
 * Base class definition for the <b>use</b> of a type.
 */
abstract class Type inherits Object
{
	/**
	 * Owning TypeContainer, if any
	 */
	reference typeContainer : TypeContainer[0..1]#containedType

	/**
	 * Returns a boolean stating if <code>element</code> is an instance of the type
	 */
	operation isInstance(element : Object) : Boolean is abstract

	/**
	 * Returns true if element is a supertype of self
	 */
	operation isSuperTypeOf(element : Type) : Boolean is abstract
	
	/**
	 * Returns true if element is a subtype of self
	 */
	operation isSubTypeOf(element : Type) : Boolean is abstract
}


/**
 * Definition of a binding between a TypeVariable and a Type
 */
abstract class TypeVariableBinding inherits TypeContainer, Object
{
	/**
	 * TypeVariable
	 */
	reference variable : TypeVariable[1..1]

	/**
	 * Assigned Type
	 */
	reference type : Type[1..1]
}


/**
 * The class definition for kermeta aliases. Above statement defines a primitive
 * type called MyString, which instanceType is <code>kermeta::standard::String</code>
 * <pre>alias MyString : kermeta::standard::String</pre>
 */
abstract class PrimitiveType inherits TypeContainer, DataType
{
	/**
	 * The type the primitive type is linked with
	 */
	reference instanceType : Type
}


/**
 * Any element that contain a  name (example : Operation, Property) inherit this
 * class.
 */
abstract class NamedElement inherits Object
{   
    /**
     * Name of this named element
     */
	attribute name : String[1..1]
	
	/**
	 * Returns the qualified name of this named element. Qualified name is 
	 * the list of the names of the packages hierarchically ordered, delimited by
	 * a "::", followed by the name of this named element.
	 */
	operation qualifiedName() : String is do
		var elem : NamedElement init self
		result := self.name
		from elem ?= elem.container
		until elem == void 
		loop
			result := elem.name + "::" + result
			elem ?= elem.container
		end
	end
}

/**
 * Self type : DEPRECATED
 */
abstract class SelfType inherits Type
{
}


/** 
 * Abstraction of the notion of containment for type definitions. Now, kermeta metamodel contains one container
 * element, that is Package. In a later release, ModelTypeDefinition will be the main container for type and
 * package definition.
 */
abstract class TypeDefinitionContainer inherits NamedElement
{
	/**
	 * Contained TypeDefinitions
	 */
	attribute ownedTypeDefinition : set TypeDefinition[0..*]
}


/**
 * Package in kermeta. Each kermeta model must have a root package. 
 */
abstract class Package inherits TypeDefinitionContainer
{
	/**
	 * Nested Packages contained by the Package
	 */
	attribute nestedPackage : set Package[0..*]#nestingPackage

	/**
	 * Owning Package, if any
	 */
	reference nestingPackage : Package#nestedPackage

	/**
	 * Uri of the Package
	 */
	attribute uri : String
}


/**
 * The modeling unit is the root of any kermeta model. It contains packages, requires and usings.
 * It also reference others modeling unit.
 */
abstract class ModelingUnit inherits Object
{
	/**
	 * root packages contained by this ModelingUnit
	 */
	attribute packages : set Package[0..*]

	/**
	 * Set of "require" statements associated with this ModelingUnit. Ie. list of the other
	 * files required to run this unit
	 */
	attribute requires : set Require[0..*]

	/**
	 * Set of "using" statement associated with this ModelingUnit. Ie. list of "syntatic shortcut"
	 * that can be used within this unit.
	 */
	attribute usings : set Using[0..*]

	/**
	 * To be written
	 */
	reference referencedModelingUnits : set ModelingUnit[0..*]
	
	/**
	 * list of filters that apply to this modeling unit.
	 * This means that if the same unit was loaded without this filters, it would have loaded more content
	 * only element whose qualified name begins with one of these filter will be loaded in the unit
	 */
	attribute includeFilters : Filter[0..*]
	
	/**
	 * list of filters that apply to this modeling unit.
	 * This means that if the same unit was loaded without this filters, it would have loaded more content
	 * element whose qualified name begins with one of these filter will NOT be loaded in the unit
	 */
	attribute excludeFilters : Filter[0..*]
}

/**
 * Filter is the class that represent a filter on a ModelingUnit.
 * the qualifiedName represent the beginning of the matched names
 */
abstract class Filter inherits Object
{
	attribute qualifiedName : String
}

/**
 * To be written
 */
abstract class Require inherits Object
{
	/**
	 * To be written
	 */
	attribute uri : String
}


/**
 * To be written
 */
abstract class Using inherits Object
{
	/**
	 * To be written
	 */
	attribute qualifiedName : String
}


/**
 * Abstraction for type definitions (ClassDefinition, ModelTypeDefinition, DataType inherit
 * this class)
 */
abstract class TypeDefinition inherits NamedElement
{
	/**
	 * This boolean allows to tell if this Type definition is an aspect or not
	 * If it is an aspect, then at runtime, its definition will be merged with the definition of another
	 * TypeDefinition that has exactly the same qualified name
	 */
	attribute isAspect : Boolean
	
	/**
	 * References to the base classes
	 */
	reference baseAspects : TypeDefinition[0..*]
}


/**
 * Class definition for the <pre>Void</pre> type
 */
abstract class VoidType inherits Type
{
}


/**
 * Special type definition for Enumeration, PrimitiveType
 */
abstract class DataType inherits TypeDefinition, Type
{
}


/**
 * Definition for Enumeration
 */
abstract class Enumeration inherits DataType
{
	/**
	 * Owned items in an Enumeration
	 */
	attribute ownedLiteral : set EnumerationLiteral[0..*]#~enumeration
}


/**
 * Item definition for enumeration
 */
abstract class EnumerationLiteral inherits NamedElement
{   
	/**
	 * Owning Enumeration
	 */
	reference ~enumeration : Enumeration[1]#ownedLiteral
}


/**
 * Definition for operation parameter
 */
abstract class Parameter inherits MultiplicityElement
{
	/**
	 * Owning operation
	 */
	reference ~operation : Operation#ownedParameter
}

