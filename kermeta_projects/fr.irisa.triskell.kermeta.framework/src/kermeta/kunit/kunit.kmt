/* *****************************************************************************
 * $Id: kunit.kmt,v 1.20 2006-08-07 09:17:30 zdrey Exp $
 * Zoe Drey - 14/02/2005
 * Triskell Research Group
 * IRISA / INRIA / University of Rennes 1 (France)
 * Distributed under the terms of the GPL licence
 */
 
/**
 * Contains the implementation of a unit test tool. This is a clone of
 * JUnit architecture.
 * Reference : http://junit.sourceforge.net/doc/cookstour/cookstour.htm
 *
 * Usage example of kunit can be found in fr.irisa.triskell.kermeta.samples project.
 * You can also find a little example if you go to TestRunner documentation.
 */
package kermeta::kunit;

require "../Standard.kmt"
using kermeta::standard
using kermeta::language::structure
using kermeta::utils
/**
 * AssertionViolatedException are raised when assertions are violated
 */
class AssertionFailedError inherits kermeta::exceptions::Exception 
{
	
}


/**
 * The abstract class assert defines a set of convinient operations
 * to assert expected behavior and give the rank of failed assert
 */
abstract class Assert
{
	attribute rank : Integer
	
	/**
	 * Fails if bool is false
	 */
	operation assert(bool : Boolean) : Void is do
		var number : Integer init order()
		if not bool then fail("assert number " + number.toString + " failed") end
	end
	
	/**
	 * will fail if bool is false
	 */
	operation assertTrue(bool : Boolean) : Void is do
		var number : Integer init order()
		if not bool then fail("assertTrue number " + number.toString + " failed") end
	end
	
	/**
	 * will fail if bool is false
	 */
	operation assertTrueWithMsg(bool : Boolean, msg : String) : Void is do
		var number : Integer init order()
		if not bool then fail("assertTrueWithMsg number " + number.toString + " failed : " + msg) end 
	end
	
	/**
	 * will fail if bool is true
	 */
	operation assertFalse(bool : Boolean) : Void is do
		var number : Integer init order()
		if bool then fail("assertTrue number " + number.toString + " failed") end
	end
	
	/**
	 * will fail if bool is true
	 */
	operation assertFalseWithMsg(bool : Boolean, msg : String) : Void is do
		var number : Integer init order()
		if bool then fail("assertTrueWithMsg number " + number.toString + " failed : " + msg) end 
	end
	
	/**
	 * raise a AssertionViolatedException with the provided message
	 */
	operation fail(msg : kermeta::standard::String) : Void is do
		var exception : AssertionFailedError init AssertionFailedError.new
		exception.message := msg
		raise exception
	end
	
	/**
	 * give the order number of the failed assert
	 */
	 operation order () : Integer is do
	 	if rank.isVoid then rank := 0 end
	 	rank := rank + 1
	 	result := rank
	 end
}

/**
 * Abstract class Test. Interface for single and composite object (TestCase and TestSuite)
 */
abstract class Test inherits Assert
{
	/**
	 * Run the test
	 */
	operation run(r : TestResult) : Void is abstract
	
	/** Called before a test is run to set up the needed environment */
	operation setUp() : Void is do
	end
	
	/** Called each time a test is run so that the testing environment is always
	 * tidy. */	
	operation tearDown() : Void is do
	end
	
	/** The main method that the testes has to implement for his specific tests */
	operation runTest() : Void is abstract
}

/**
 * A test case
 * pattern : Command
 */
class TestCase inherits Test
{
	/** A name for the test case so that we know which one failed 
	 *  This is a "pluggable" selector
	*/
	attribute name : String
	
	/**
	 * Initialize the test case
	 * params : 
	 *   - name : the name of the test case : must be the name of the testOperation
	 */
	operation initialize(name : String) : Void is do
		self.name := name
	end

	/**
	 * Execute the test case
	 */
	method run(r : TestResult) : Void is do
		if (r == void) then r := createDefaultTestResult end
		r.startTest(self)
//		setUp() // this is now put into dynamic expression of runTest method (otherwise not included in dynamic context!)
		runTest()
//		tearDown()
		rescue (e : AssertionFailedError)
			r.addFailure(self, e)
		rescue (e : kermeta::exceptions::Exception)
			r.addError(self, e)
	end
	
	
	/**
	 * This method is an adapter that uses the pluggable selector TestCase.name to know which 
	 * test to run
	*/
	method runTest() : Void is do
		var cDef : ClassDefinition
		cDef ?= self.getMetaClass.typeDefinition
		if cDef.ownedOperation.detect { o | o.name == name } == void 
		then
			raise kermeta::exceptions::CallOnVoidTarget.new 
		else
			var de : kermeta::interpreter::DynamicExpression init kermeta::interpreter::DynamicExpression.new
			de.initializeDefaults
			// get self class name
			var selfClassName : String init cDef.qualifiedName
			de.parse(
				"do var test : " + selfClassName + " init " + selfClassName + ".new\n"
			+   "test.setUp " +  "\ntest."+name + "\ntest.tearDown end")
			de.execute(void, Hashtable<String, kermeta::standard::Object>.new)
		end
	end	
	
	operation createDefaultTestResult() : TestResult is do
		result := TestResult.new
		result.initialize
	end
}

/**
 * Get the number of run tests, errors and failures that resulted from the launch of a 
 * Test. (This is a minimal but functional class that can be improved)
 * pattern : Collecting parameter
 */
class TestResult
{
	/** number of test that were run */
	reference runtests : Integer
	/** tests which assertions failed */
	reference failures : set TestFailure[*]
	/** tests which errors were not assertion failures */
	reference errors : set TestFailure[*]
	
	/** Set the runtests to 0 */
	operation initialize() : Void is do
		runtests := 0
	end
	
	/** Increments the runtests counter */
	operation startTest(test : Test) : Void is do
		runtests := 1 + runtests
	end
	
	/** Adds a failed test to the list of failed tests */
	operation addFailure(test : Test, e : AssertionFailedError) : Void is do
		failures.add(createTestFailure(test, e)) 
	end
	
	operation addError(test : Test, e : kermeta::exceptions::Exception) : Void is do
		errors.add(createTestFailure(test, e))
	end
	
	operation createTestFailure(test : Test, e : kermeta::exceptions::Exception) : TestFailure is do
		result := TestFailure.new
		result.failedTest := test
		result.raised := e
	end
}

/**
 * An instance of this class is created when an assertion failed or an exception
 * was raised.
*/
class TestFailure
{
	reference failedTest : Test
	reference raised     : kermeta::exceptions::Exception
}

/** 
 * A test suite is composed of a set of tests (which can inherit either of TestSuite
 * or TestCase)
 * pattern : Composite
 */
class TestSuite inherits Test
{
	/**
	 * The set of contained tests
	 */
	reference tests : Test[0..*]


	/**
	 * Execute all tests of the suite
	 */
	method run(test_result : TestResult) : Void is do
		tests.each{ t | t.run(test_result) }
	end
	
	operation addTest(test : Test) : Void is do
		tests.add(test)
	end
}


/** */
class TestLoader
{
	attribute methodPrefix : String
	reference suiteClass   : Class
	
	operation initialize() is do
		methodPrefix := "test"
		suiteClass := TestSuite
	end
	
	/** 
	 * load in the testSuiteClass all the methods prefixed by test
	 * params :
	 *    - testCaseClass : the TestCase class where we get the testOperations
	 * // FIXME / I would like to do "TestType inherits TestCase"
	 */	
	operation loadTestMethodsFromTestCase(test_type : Class) : Set<Test> is do
		result := Set<Test>.new
		// par le nom de TestType
		var test_case : TestCase // TODO : check that test_type inherits TestCase
		//test_case := TestType.new 
		//result := Set<Test>.new
		// select the testMethods [indexOutOfBound?] 
		var test_ops : Sequence<kermeta::reflection::Operation> 
		test_ops := test_type.ownedOperation.select { o |  
			o.name.size>=4 and // then!
			o.name.substring(0, 4)==methodPrefix
		}
		// create a test for each of them
		test_ops.each { o | 
			test_case ?= test_type.new
			test_case.initialize(o.name)
			result.add(test_case)
		}
	end
}

/** 
 * User instanciates this class to run a test suite/case 
 * 
 * Usage : 
 * 
 * Create a file, and add in the "require" place :
 * <pre>require "the_file_that_contains_the_tests.kmt"</pre>
 *
 * Create a class, which will be the one that you will launch :
 * <pre>
 * class MyTesterClass
 * {
 *   operation main() is do
 *     var testRunner : kermeta::kunit::TestRunner init kermeta::kunit::TestRunner.new
 *     // Here, we run our test case class called "TestClass", 
 *     // contained in the_file_that_contains_the_tests.kmt.
 *     // TestClass must inherit TestCase
 *	   testRunner.run(TestClass)
 *	   testRunner.printTestResult
 *	end
 * }
 * </pre>
 */
class TestRunner
{
	reference testClass : Class
	reference testResult : TestResult
	
	operation initialize() is do
	end

	operation createTestResult() : TestResult is do
		result := TestResult.new
		result.initialize
	end
	
	operation createTestLoader() : TestLoader is do
		result := TestLoader.new
		result.initialize
	end

	/** Run a test suite from the given test case (test_class should be a class
	 * that inherits TestCase
	 */
	operation run(test_class : Class) is do
		var test_loader : TestLoader init createTestLoader
		testResult := createTestResult
		// Set<any kindOf TestCase> should be better
		if not test_class.superClass.contains(TestCase) then
			var msg : String init "ERROR : the given class '"+test_class.typeDefinition.name + "' should inherit TestCase" 
			stdio.writeln(msg)
		else
			var test_ops : Set<Test> init test_loader.loadTestMethodsFromTestCase(test_class)
			var test_suite : TestSuite init TestSuite.new
			test_suite.tests.addAll(test_ops)
			test_suite.run(testResult)
		end
	end
	
	/**
	 * Prints in a text format the result of the tests launches 
	 * TODO : a specific set of class that inherit TestResult and display
	 * it according to a specific format
	 */
	operation printTestResult() is do
		stdio.writeln(
		"\n================================== TEST RESULTS ==================================\n")

		stdio.writeln(" Number of launched tests : " + testResult.runtests.toString)
		stdio.writeln(" Number of failures : " + testResult.failures.size.toString)
		stdio.writeln(" Number of errors : " +  testResult.errors.size.toString)
		stdio.writeln("\n Failed : ")
		testResult.failures.each { f | 
			var tc : kermeta::kunit::TestCase
			tc ?= f.failedTest
			stdio.writeln("    ->" + tc.name + "( raised : "+ f.raised.message + ")")}
		stdio.writeln(" Errors : ")	
		testResult.errors.each { e | 
			var tc : kermeta::kunit::TestCase
			tc ?= e.failedTest
			stdio.writeln("    -> " + tc.name + "( raised : "+e.raised.toString + ")")}
		stdio.writeln("\n==================================================================================\n")
	end
}
