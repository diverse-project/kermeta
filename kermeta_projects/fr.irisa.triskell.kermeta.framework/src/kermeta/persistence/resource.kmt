/**
 * Contains the classes that handle the serialization of models, in particular
 * EMF models.
 */
package kermeta::persistence;

using kermeta::standard

/* ****************************************************************************
 * $Id: resource.kmt,v 1.16 2006-05-23 12:26:46 zdrey Exp $
 * Project : Kermeta (First iteration)
 * Creation date :  
 * File : resource.kmt
 * License : GPL
 * Copyright : IRISA / Universite de Rennes 1
 * Creation date : Mar 14, 2005
 * Author : zdrey
 */


/**
 * The main class that handle a loaded/saved model.
 * There are a few important things to note for the developper :
 * 
 * - load a Resource : this loads a Collection of instances corresponding to the
 *   objects in the loaded model. If the Collection of instances is empty, than 
 *	 a ResourceLoadException is raised
 *
 * - save a Resource : this saves the collection of instances in a new file. This can
 *   be correctly done if and only if the instances saved are conform to the metamodel
 *   linked to this resource (this link does not need to be explicit. It is normally retrieved
 *   through the EMF model -- see Java wrapping "Resource.java").
 * 
 * - add/remove an instance to the Resource : this adds an element in the resource. It cannot
 *   be "simply" added because of the following potential errors :
 *
 *   - The object added is not conform to the metamodel -> Error
 *   - The object was already added in the resource -> Not a real error : we do nothing
 *   - The object to remove does not exist -> redirect to a collection-specific error
 *   - The object to remove is attached to an object in the collection -> "dependency-violation" exception?

 */
abstract class Resource
{
	/** The uri of the model-instance to load */
	reference uri : String
	/** The uri of the meta-model of the model-instance to load */
	reference metaModelURI : String
	/** The includedResource if the model-instance "inter-depends" on other instances*/
	reference includedResources : set String[*] 
	/** The entities contained in the model-instance, that are provided when user loads a resource 
	 *  instances == rootContents
	 */
	reference instances : set Object[*]
	/** The repository used to create this resource */
	reference repository : Repository#resources
	/** The hashtable that contains the contents loaded by the resource.
	 *  It is composed of 4 entries : "rootContents", "allRootContents", "contents", "allContents"
	 *  The two last ones will be kept empty since resource-heavy
	 *  - rootContents : only the root elements of the "main model" hosted by the given resource
	 *  - allRootContents : the root elements of the main model
	 */
	 reference contentMap : kermeta::utils::Hashtable<String, Set<Object>>
	
	/**
	 * Description of the derived properties :
	 *  - returns the rootContents of the model saved in/loaded from the given uri, excluding
	 *  the models from the dependent resources
	 ** - returns the rootContents of the model saved in/loaded from the given uri, including
	 *  the models from the dependent resources
 	 ** - returns all the model elements hosted by this resource, excluding elements from the
 	 * dependent resources
 	 ** - returns all the model elements hosted by this resource, including elements from the
 	 * dependent resources */
	property readonly rootContents : set Object[0..*]
		getter is do result:=contentMap.getValue("rootContents") end
	property readonly allRootContents : set Object[0..*] 
		getter is do result:=contentMap.getValue("allRootContents") end
	property readonly contents : set Object[0..*] 
		getter is do result:=contentMap.getValue("contents") end
	property readonly allContents : set Object[0..*] 
		getter is do result:=contentMap.getValue("allContents") end
	
	/** Save a model instance, in the file specified by the initial uri 
	 * Overrides the old version.
	 */
	operation save() : Void is abstract
	operation saveWithNewURI(new_uri : String) : Void is do end
	operation load() : Void is abstract
	/** add an instance, return it if success, otherwise return null */
	operation add(instance : Object) : Void is abstract  
	/** remove the instance, return it if success, otherwise return null */
	operation remove(instance : Object) : Object is abstract
	
/*	operation setInstances(p_instances : Set<Object>) : kermeta::standard::~Void is do
		instances := p_instances
	end*/
}

class EMFResource inherits Resource
{
	/** 
	 * Create an hashtable with appropriates keys and empty collections. This method 
	 * should not be called by the end-user
	 */
	 operation initializeContentMap() is do
	 	contentMap := kermeta::utils::Hashtable<String, Set<Object>>.new
	 	contentMap.put("rootContents", Set<Object>.new)
	 	contentMap.put("allRootContents", Set<Object>.new)
	 	contentMap.put("contents", Set<Object>.new)
	 	contentMap.put("allContents", Set<Object>.new)
	 end

	/** Save a resource in the uri associated to it */
	method saveWithNewURI(new_uri : String) : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			new_uri, metaModelURI, "EMF", instances
		)
	end
	
	/** Save a resource in the uri given by its 'uri' attribute. */
	method save() : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			self.uri, metaModelURI, "EMF", instances
		)
	end
	
	/** Loads a resource */
	method load() : Void is do
		var e : ResourceLoadException init ResourceLoadException.new
		contentMap ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.load(
			uri, metaModelURI, "EMF", contentMap
		)
		// If load failed
		if (contentMap.getValue("allRootContents").size == 0) then
			stdio.writeln("Resource load failed!")
			raise e
		end
		instances.clear
		instances.addAll(rootContents)
	end
	


	/** Add an instance to the Resource ( this is only a shortcut to instances.add call)*/
	method add(instance : Object) : Void is do
		instances.add(instance)
	end
	
	/** Remove an instance from the Resource */
	method remove(instance : Object) : Object is do
		if instances.contains(instance) then 
			instances.remove(instance)
			result := instance
		else
			result := void
		end
	end
	
	/**
	 * Helper that returns true if new_instance type is in the tparam Set, false otherwise
	 * FIXME : Loop-and-cast done in order to temporarily get round the type 
	 * system limits for reflection
	*/
	operation isInTypeDefSet(tparams : Set<kermeta::reflection::TypeDefinition>, new_instance : Object) : Boolean is do
		result := false
		from var it : Iterator<kermeta::reflection::TypeDefinition> init tparams.iterator
		until (it.isOff or result == true)
		loop
			var next : kermeta::language::structure::TypeDefinition
			next ?= it.next 
			// Note :  test with  "qualifiedName" is easier. is it a proper way?
			if (next.qualifiedName.equals(new_instance.getMetaClass.typeDefinition.qualifiedName)) then
				result := true
			end
		end
	end

}

class KMResource inherits Resource
{
	method save() : Void is do
		//TODO: implement operation save
	end
	method load() : Void is do
		//TODO: implement operation load
	end
	method add(instance : Object) : Void is do
		//TODO: implement operation load
	end
	method remove(instance : Object) : Object is do
		//TODO: implement operation load
		result := void
	end
}
abstract class Repository
{
	/** The resources created by this repository */
	attribute resources : set Resource [*]#repository
	/**
	 * Create a resource with given uri. 
	 * params : 
	 *    - uri : the uri where to save the model handled by the resource
	 *    - mm_uri : the uri of the metamodel of which model is an instance
	 * User must provide the mm_uri if he creates a new model from scratch.
	 */
	operation createResource(uri : String, mm_uri : String) : Resource is abstract
	/**
	 * Get the resource of model that is stored in the given uri. Silently create
	 * and load a new one if a resource with this uri was not found.
	 */
	operation getResource(uri : String) : Resource is do
		from var it : Iterator<Resource> init resources.iterator
		until it.isOff
		loop
			var next : Resource init it.next
			if (uri.equals(next.uri)) then
				result := next
			end
		end
		// If result is null then we create a new resource. With a null
		// URI. we assume that the user calls "getResource" when he already has 
		// a serialized model stored at the given URI 
		// NOT TESTED YET!
		if result == void then
			stdio.writeln("Warning : resource + <"+uri+"> does not exist yet. Trying to create one.")
			result := self.createResource(uri, "")
			result.load()
		end
	end
}

/**
 * Repository that stores and manages resources that come from EMF
 */
class EMFRepository inherits Repository
{
	/**
	 * Create a new empty resource from the model given by its uri, 
	 * which meta-model is stored in file given by mm_uri
	 */
	method createResource(uri : String, mm_uri : String) : Resource is do
		var new_resource : EMFResource init EMFResource.new
//		var instances    : kermeta::standard::Set<Object> init kermeta::standard::Set<Object>.new
//		new_resource.instances := instances
		new_resource.uri := uri
		new_resource.metaModelURI := mm_uri
		new_resource.repository := self
		new_resource.initializeContentMap
		result := new_resource
	end
	// Override so that specialized types are fixed ...hum cast is not excellent
	/**
	 * Get the resource of model that is stored in the given uri. Silently create
	 * and load a new one if a resource with this uri was not found.
	 */
	method getResource(uri : String) : Resource is do
		result := super(uri)
	end
	
}

/**
 * Repository that stores and manages XMI files representing Kermeta models
 */
class KMRepository inherits Repository
{
	method createResource(uri : String, mm_uri : String) : Resource is do
		//TODO: implement operation createResource
	end
	method getResource(uri : String) : Resource is do
		//TODO: implement operation getResource
	end 
}

/** Specialized exceptions */
class ResourceLoadException inherits kermeta::exceptions::Exception { }
class ResourceSaveException inherits kermeta::exceptions::Exception { }
/** Raised when user tries to add an object that is not conform to the metamodel */
class ResourceUnconformityException inherits kermeta::exceptions::Exception { }

