package kermeta::persistence;

using kermeta::standard

/*****************************************************************************
 * $Id: resource.kmt,v 1.10 2006-02-06 15:38:57 zdrey Exp $
 * Project : Kermeta (First iteration)
 * Creation date :  
 * File : resource.kmt
 * License : GPL
 * Copyright : IRISA / Universite de Rennes 1
 * Creation date : Mar 14, 2005
 * Author : zdrey
 * Description :  
 *      This file contains the classes that handle the serialization of models.
 *
 *
 ****************************************************************************/

/**
 * The main class that handle a loaded/saved model.
 * There are a few important things to note for the developper :
 * 
 * - load a Resource : this loads a Collection of instances corresponding to the
 *   objects in the loaded model. If the Collection of instances is empty, than 
 *	 a ResourceLoadException is raised
 *
 * - save a Resource : this saves the collection of instances in a new file. This can
 *   be correctly done if and only if the instances saved are conform to the metamodel
 *   linked to this resource (this link does not need to be explicit. It is normally retrieved
 *   through the EMF model -- see Java wrapping "Resource.java").
 * 
 * - add/remove an instance to the Resource : this adds an element in the resource. It cannot
 *   be "simply" added because of the following potential errors :
 *
 *   - The object added is not conform to the metamodel -> Error
 *   - The object was already added in the resource -> Not a real error : we do nothing
 *   - The object to remove does not exist -> redirect to a collection-specific error
 *   - The object to remove is attached to an object in the collection -> "dependency-violation" exception?

 */
abstract class Resource
{
	/** The uri of the model-instance to load */
	reference uri : String
	/** The uri of the meta-model of the model-instance to load */
	reference metaModelURI : String
	/** The includedResource if the model-instance "inter-depends" on other instances*/
	reference includedResources : set String[*] 
	/** The entities contained in the model-instance, that are provided when user loads a resource */
	reference instances : set Object[*]
	/** The repository used to create this resource */
	reference repository : Repository#resources
	
	/** Save a model instance, in the file specified by the initial uri 
	 * Overrides the old version.
	 */
	operation save() : Void is abstract
	operation saveWithNewURI(new_uri : String) : Void is do end
	operation load() : Void is abstract
	/** add an instance, return it if success, otherwise return null */
	operation add(instance : Object) : Void is abstract  
	/** remove the instance, return it if success, otherwise return null */
	operation remove(instance : Object) : Object is abstract
	/**
	 * return the root elements of the resource. Root elements are elements
	 * that have no container
	 */
	operation getRootElements() : Set<Object> is abstract
	
/*	operation setInstances(p_instances : Set<Object>) : kermeta::standard::~Void is do
		instances := p_instances
	end*/
}
class EMFResource inherits Resource
{
	/**
	 * Constructor "patch" TODO : only one should be needed
	 */
	operation initialize_3(model_uri : String , mm_uri : String , inc_resources : Set<String> ) is do
		uri := model_uri
		metaModelURI := mm_uri
		includedResources := inc_resources
	end
	operation initialize_2(model_uri : String , inc_resources : Set<String> ) is do
		uri := model_uri
		includedResources := inc_resources
	end
	operation initialize(model_uri : String) is do
		uri := model_uri
		metaModelURI := ""
	end

	/** Save a resource in the uri associated to it */
	method saveWithNewURI(new_uri : String) : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			new_uri, metaModelURI, "EMF", instances
		)
	end
	
	/** Save a resource in the uri given by its 'uri' attribute. */
	method save() : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			self.uri, metaModelURI, "EMF", instances
		)
	end
	
	/** Loads a resource */
	method load() : Void is do
		var e : ResourceLoadException init ResourceLoadException.new
		// Todo : extern load should return a Reflective Set?
		var inst_set : Set<Object> init Set<Object>.new
		inst_set ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.load(
			uri, metaModelURI, "EMF", inst_set
		)
		// If load failed
		if (inst_set.size == 0) then
			stdio.writeln("Resource load failed!")
			raise e
		end
		// FIXME : should I directly create a ReflectiveSet instead of that ?
		from var it : Iterator<Object> init inst_set.iterator
		until (it.isOff)
		loop
			instances.add(it.next)
		end
/*		instances ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.load(
			uri, metaModelURI, "EMF", instances
		)
		*/
	end

	/** Add an instance to the Resource*/
	method add(instance : Object) : Void is do
		// Exception
		var e : ResourceUnconformityException init ResourceUnconformityException.new
		// Is the object conform to the metamodel?
		if self.isConform(instance) then
			instances.add(instance)
		else
			raise e
		end
	end
	
	/** Remove an instance from the Resource */
	method remove(instance : Object) : Object is do
		if instances.contains(instance) then 
			instances.remove(instance)
			result := instance
		else
			result := void
		end
	end
	
	/** 
	 * Return true if instance type is conform to the metamodel of the model loaded,
	 * false otherwise 
	 */
	operation isConform(instance : Object) : Boolean is do
		// Get on eof the isntances loaded (supposed to be conform!)
		var valid_instance : Object init instances.one
		// We use reflection to get the meta model classes .. 
		var o : Object init valid_instance.getMetaClass.classDefinition
		var container : Object
		var i : Integer init 0
		from var b : Boolean init true //(cdef.container != void or i<=10)
		 // *very* temporary patch for unexp. infinite loop : invalid models?
		until o.container == void or i==10
		loop
			o := o.container
		end
		// TODO : a robustness test? o instnaceof Package?
		var p : kermeta::language::structure::Package
		p ?= o
		result := isInTypeDefSet(p.ownedTypeDefinition, instance)
	end
	
	/**
	 * Helper that returns true if new_instance type is in the tparam Set, false otherwise
	 * FIXME : Loop-and-cast done in order to temporarily get round the type 
	 * system limits for reflection
	*/
	operation isInTypeDefSet(tparams : Set<kermeta::reflection::TypeDefinition>, new_instance : Object) : Boolean is do
		result := false
		from var it : Iterator<kermeta::reflection::TypeDefinition> init tparams.iterator
		until (it.isOff or result == true)
		loop
			var next : kermeta::language::structure::TypeDefinition
			next ?= it.next 
			// Note :  test with  "qualifiedName" is easier. is it a proper way?
			if (next.qualifiedName.equals(new_instance.getMetaClass.classDefinition.qualifiedName)) then
				result := true
			end
		end
	end
	
	/**
	 * Get the root element(s) of the EMF model loaded in this resource
	 */ 
	method getRootElements() : Set<Object> is do
		from var it : Iterator<Object> init self.instances.iterator
		until it.isOff
		loop
			var o : Object init it.next
			if (o.container == void) then
				result.add(o)
			end
		end
	end
	

}

class KMResource inherits Resource
{
	method save() : kermeta::standard::~Void is do
		//TODO: implement operation save
	end
	method load() : kermeta::standard::~Void is do
		//TODO: implement operation load
	end
	method add(instance : Object) : Void is do
		//TODO: implement operation load
	end
	method remove(instance : Object) : Object is do
		//TODO: implement operation load
		result := void
	end
}
abstract class Repository
{
	/** The resources created by this repository */
	attribute resources : set Resource [*]#repository
	/**
	 * Create a resource with given uri. 
	 * params : 
	 *    - uri : the uri where to save the model handled by the resource
	 *    - mm_uri : the uri of the metamodel of which model is an instance
	 * User must provide the mm_uri if he creates a new model from scratch.
	 */
	operation createResource(uri : String, mm_uri : String) : Resource is abstract
	/**
	 * Get the resource of model that is stored in the given uri. Silently create
	 * and load a new one if a resource with this uri was not found.
	 */
	operation getResource(uri : String) : Resource is do
		from var it : Iterator<Resource> init resources.iterator
		until it.isOff
		loop
			var next : Resource init it.next
			if (uri.equals(next.uri)) then
				result := next
			end
		end
		// If result is null then we create a new resource. With a null
		// URI. we assume that the user calls "getResource" when he already has 
		// a serialized model stored at the given URI 
		// NOT TESTED YET!
		if result == void then
			result := self.createResource(uri, "")
			result.load()
		end
	end
}

/**
 * Repository that stores and manages resources that come from EMF
 */
class EMFRepository inherits Repository
{
	/**
	 * Create a new empty resource from the model given by its uri, 
	 * which meta-model is stored in file given by mm_uri
	 */
	method createResource(uri : String, mm_uri : String) : EMFResource is do
		var new_resource : EMFResource init EMFResource.new
//		var instances    : kermeta::standard::Set<Object> init kermeta::standard::Set<Object>.new
//		new_resource.instances := instances
		new_resource.uri := uri
		new_resource.metaModelURI := mm_uri
		new_resource.repository := self
		result := new_resource
	end
	// Override so that specialized types are fixed ...hum cast is not excellent
	/**
	 * Get the resource of model that is stored in the given uri. Silently create
	 * and load a new one if a resource with this uri was not found.
	 */
	method getResource(uri : String) : EMFResource is do
		result ?= super(uri)
	end
	
}

/**
 * Repository that stores and manages XMI files representing Kermeta models
 */
class KMRepository inherits Repository
{
	method createResource(uri : String, mm_uri : String) : KMResource is do
		//TODO: implement operation createResource
	end
	method getResource(uri : String) : Resource is do
		//TODO: implement operation getResource
	end 
}

/** Specialized exceptions */
class ResourceLoadException inherits kermeta::exceptions::Exception { }
class ResourceSaveException inherits kermeta::exceptions::Exception { }
/** Raised when user tries to add an object that is not conform to the metamodel */
class ResourceUnconformityException inherits kermeta::exceptions::Exception { }

