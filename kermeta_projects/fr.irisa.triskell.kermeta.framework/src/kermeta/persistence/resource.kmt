/**
 * Contains the classes that handle the serialization of models, in particular
 * EMF models.
 */
package kermeta::persistence;
require "../Standard.kmt"
using kermeta::standard

/* ****************************************************************************
 * $Id: resource.kmt,v 1.25 2006-12-07 09:32:46 dvojtise Exp $
 * Project : Kermeta (First iteration)
 * Creation date :  
 * File : resource.kmt
 * License : EPL
 * Copyright : IRISA / Universite de Rennes 1
 * Creation date : Mar 14, 2005
 * Author : zdrey
 */


/**
 * The main class that handle a loaded/saved model.
 * There are a few important things to note for the developer :
 * 
 * - load a Resource : this loads a Collection of instances corresponding to the
 *   objects in the loaded model. If the Collection of instances is empty, than 
 *	 a ResourceLoadException is raised
 *
 * - save a Resource : this saves the collection of instances in a new file. This can
 *   be correctly done if and only if the instances saved are conform to the metamodel
 *   linked to this resource (this link does not need to be explicit. It is normally retrieved
 *   through the EMF model -- see Java wrapping "Resource.java").
 * 
 * - add/remove an instance to the Resource : this adds an element in the resource. It cannot
 *   be "simply" added because of the following potential errors :
 *
 *   - The object added is not conform to the metamodel -> Error
 *   - The object was already added in the resource -> Not a real error : we do nothing
 *   - The object to remove does not exist -> redirect to a collection-specific error
 *   - The object to remove is attached to an object in the collection -> "dependency-violation" exception?

 */
abstract class Resource
{
	/** The uri of the model-instance to load */
	reference uri : String
	
	/** The uri of the meta-model of the model-instance to load */
	reference metaModelURI : String
	
	/** The includedResource if the model-instance "inter-depends" on other instances*/
	reference includedResources : set String[*] 
	
	/** The entities contained in the model-instance, that are provided when user loads a resource 
	 *  instances == rootContents
	 */
	reference instances : set Object[*]
	
	/** The repository used to create this resource */
	reference repository : Repository#resources
	
	/** The hashtable that contains the contents loaded by the resource.
	 *  It is composed of 4 entries : "rootContents", "allRootContents", "contents", "allContents"
	 *  The two last ones will be kept empty since resource-heavy
	 *  - rootContents : only the root elements of the "main model" hosted by the given resource
	 *  - allRootContents : the root elements of the main model
	 */
	 reference contentMap : kermeta::utils::Hashtable<String, Set<Object>>
	
 	/**
	 *  - returns the rootContents of the model saved in/loaded from the given uri, excluding
	 *  the models from the dependent resources
	 */
	property readonly rootContents : set Object[0..*]
		getter is do result:=contentMap.getValue("rootContents") end
	/** - returns the rootContents of the model saved in/loaded from the given uri, including
	 *  the models from the dependent resources */
	property readonly allRootContents : set Object[0..*] 
		getter is do result:=contentMap.getValue("allRootContents") end
    /** - returns all the model elements hosted by this resource, excluding elements from the
 	 * dependent resources */
	property readonly contents : set Object[0..*] getter is do
		result:=contentMap.getValue("contents").union(contentMap.getValue("rootContents"))
	end
    /** - returns all the model elements hosted by this resource, including elements from the
 	 * dependent resources */
	property readonly allContents : set Object[0..*] getter is do
		result:=contentMap.getValue("allContents").union(contentMap.getValue("allRootContents"))
	end
	
	/** Save a model instance, in the file specified by the initial uri 
	 * Overrides the old version.
	 */
	operation save() : Void is abstract
	
	/** Save a resource in a file referenced by this new uri. 
	    This allows to save the result of a transformation without changing the original file. */
	operation saveWithNewURI(new_uri : String) : Void is do end
	
	/** Loads a resource. Once loaded, you'll be able to query the resource for its content.  */	
	operation load() : Void is abstract
	/** add an instance, return it if success, otherwise return null
	    You need to do that for every Object that must be placed in the root of the resource when you'll save it */
	operation add(instance : Object) : Void is abstract  
	/** remove the instance, return it if success, otherwise return null */
	operation remove(instance : Object) : Object is abstract
	
/*	operation setInstances(p_instances : Set<Object>) : kermeta::standard::~Void is do
		instances := p_instances
	end*/
}

/**
 * Extension of the Resource class definition that is specific to EMF Repository.
 */
class EMFResource inherits Resource
{
	/** 
	 * Create an hashtable with appropriates keys and empty collections. This method 
	 * should not be called by the end-user
	 */
	 operation initializeContentMap() is do
	 	contentMap := kermeta::utils::Hashtable<String, Set<Object>>.new
	 	contentMap.put("rootContents", Set<Object>.new)
	 	contentMap.put("allRootContents", Set<Object>.new)
	 	contentMap.put("contents", Set<Object>.new)
	 	contentMap.put("allContents", Set<Object>.new)
	 end

	/** Save a resource in a file referenced by this new uri. 
	    This allows to save the result of a transformation without changing the original file. */
	method saveWithNewURI(new_uri : String) : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			self, new_uri, metaModelURI, "EMF", instances,false
		)
	end
	
	/** Save a resource in a file referenced by the uri associated to the resource */
	method save() : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			self, self.uri, metaModelURI, "EMF", instances, false
		)
	end

	/** save and check the resource using the EMF validation function
	 * apply the validate on all the object in the root of this resource
	 * returns true if the validation reports no error
	 * otherwise raises exceptions
	 */
	operation saveAndValidateWithEMF() : Boolean is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			self, self.uri, metaModelURI, "EMF", instances, true
		)
	end
	
	/** Loads a resource. Once loaded, you'll be able to query the resource for its instances.  */
	method load() : Void is do
		var e : ResourceLoadException init ResourceLoadException.new
		contentMap ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.load(
			uri, metaModelURI, "EMF", contentMap
		)
		// If load failed
		if (contentMap.getValue("allRootContents").size == 0) then
			stdio.writeln("Resource load failed!")
			raise e
		end
		instances.clear
		instances.addAll(rootContents)
	end
	


	/** Add an instance to the Resource ( this is only a shortcut to instances.add call)*/
	method add(instance : Object) : Void is do
		instances.add(instance)
	end
	
	/** Remove an instance from the Resource */
	method remove(instance : Object) : Object is do
		if instances.contains(instance) then 
			instances.remove(instance)
			result := instance
		else
			result := void
		end
	end
	
	/**
	 * Helper that returns true if new_instance type is in the tparam Set, false otherwise
	 * FIXME : Loop-and-cast done in order to temporarily get round the type 
	 * system limits for reflection
	*/
	operation isInTypeDefSet(tparams : Set<kermeta::reflection::TypeDefinition>, new_instance : Object) : Boolean is do
		result := false
		from var it : Iterator<kermeta::reflection::TypeDefinition> init tparams.iterator
		until (it.isOff or result == true)
		loop
			var next : kermeta::language::structure::TypeDefinition
			next ?= it.next 
			// Note :  test with  "qualifiedName" is easier. is it a proper way?
			if (next.qualifiedName.equals(new_instance.getMetaClass.typeDefinition.qualifiedName)) then
				result := true
			end
		end
	end

}

class KMResource inherits Resource
{
	method save() : Void is do
		//TODO: implement operation save
	end
	method load() : Void is do
		//TODO: implement operation load
	end
	method add(instance : Object) : Void is do
		//TODO: implement operation load
	end
	method remove(instance : Object) : Object is do
		//TODO: implement operation load
		result := void
	end
}

/** Abstract resource container, that contains a list of available loaded resources, 
 * and methods to create or get a resource given an URI.
 */
abstract class Repository
{
	/** The resources created by this repository */
	attribute resources : set Resource [*]#repository
	/**
	 * Create a resource with given uri. 
	 * params : 
	 *    - uri : the uri where to save the model handled by the resource
	 *    - mm_uri : the uri of the metamodel of which model is an instance
	 * User must provide the mm_uri if he creates a new model from scratch.
	 */
	operation createResource(uri : String, mm_uri : String) : Resource is abstract
	
	/**
	 * Get the resource of model that is stored in the given uri. 
	 * This suppose that this URI resource was already created in this Repository.
	 * If this resource wasn't already created it will silently create
	 * and load a new one. In this case, the 
	 */
	operation getResource(uri : String) : Resource is do
		from var it : Iterator<Resource> init resources.iterator
		until it.isOff
		loop
			var next : Resource init it.next
			if (uri.equals(next.uri)) then
				result := next
			end
		end
		// If result is null then we create a new resource. With a null
		// URI. we assume that the user calls "getResource" when he already has 
		// a serialized model stored at the given URI 
		// NOT TESTED YET!
		if result == void then
			//stdio.writeln("Warning : you haven't created a resource for the given uri <"+uri+"> in this Repository. Trying to create one. (you should consider using the createResource method first)")
			result := self.createResource(uri, "")
			result.load()
		end
	end
}

/**
 * Repository that stores and manages resources that come from EMF
 */
class EMFRepository inherits Repository
{
	/**
	 * Create a new resource for a model given by its uri, 
	 * which meta-model is stored in file given by mm_uri
	 * If file already exists, you'll be able to call the load method to concretly load the model
	 * otherwise, you can only call the save method
	 */
	method createResource(uri : String, mm_uri : String) : Resource is do
		var new_resource : EMFResource init EMFResource.new
//		var instances    : kermeta::standard::Set<Object> init kermeta::standard::Set<Object>.new
//		new_resource.instances := instances
		new_resource.uri := uri
		new_resource.metaModelURI := mm_uri
		new_resource.repository := self
		new_resource.initializeContentMap
		result := new_resource
	end
	// Override so that specialized types are fixed ...hum cast is not excellent
	/**
	 * Get the resource of model that is stored in the given uri. Silently create
	 * and load a new one if a resource with this uri was not found.
	 */
	method getResource(uri : String) : Resource is do
		result := super(uri)
	end
	
	/** 
	 * If true, tells to the save of the resources that they should also integrate the resources from Kermeta interpreter itself
	 * this is usefull for example to make a dependency to framework.km
	 * by default, not setting this is considered as false.
	 */
	attribute useInterpreterInternalResources : Boolean
	
}

/**
 * Repository that stores and manages XMI files representing Kermeta models
 */
class KMRepository inherits Repository
{
	method createResource(uri : String, mm_uri : String) : Resource is do
		//TODO: implement operation createResource
	end
	method getResource(uri : String) : Resource is do
		//TODO: implement operation getResource
	end 
}

/** Specialized exceptions */
class ResourceLoadException inherits kermeta::exceptions::Exception { }
class ResourceSaveException inherits kermeta::exceptions::Exception { }
/** Raised when user tries to add an object that is not conform to the metamodel */
class ResourceUnconformityException inherits kermeta::exceptions::Exception { }

