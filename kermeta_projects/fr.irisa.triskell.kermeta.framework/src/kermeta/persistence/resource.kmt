/**
 * Contains the classes that handle the serialization of models, in particular
 * EMF models.
 * <img src="platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/persistence_package.png"/>
 */
  @uri "http://www.kermeta.org/kermeta/1_2_0//kermeta/persistence"
package kermeta::persistence;
require "../Standard.kmt"
using kermeta::standard

/* ****************************************************************************
 * $Id: resource.kmt,v 1.63 2008-09-04 13:08:21 dvojtise Exp $
 * Project : Kermeta (First iteration)
 * Creation date :  
 * File : resource.kmt
 * License : EPL
 * Copyright : IRISA / Universite de Rennes 1
 * Creation date : Mar 14, 2005
 * Author : zdrey
 */


/**
 * The main class that handle a loaded/saved model.
 * There are a few important things to note for the developer :
 * 
 * - load a Resource : this loads a Collection of instances corresponding to the
 *   objects in the loaded model. If the Collection of instances is empty, than 
 *	 a ResourceLoadException is raised
 *
 * - save a Resource : this saves the collection of instances in a new file. This can
 *   be correctly done if and only if the instances saved are conform to the metamodel
 *   linked to this resource (this link does not need to be explicit. It is normally retrieved
 *   through the EMF model -- see Java wrapping "Resource.java").
 * 
 * - add/remove an instance to the Resource : this adds an element in the resource. It cannot
 *   be "simply" added because of the following potential errors :
 *
 *   - The object added is not conform to the metamodel -> Error
 *   - The object was already added in the resource -> Not a real error : we do nothing
 *   - The object to remove does not exist -> redirect to a collection-specific error
 *   - The object to remove is attached to an object in the collection -> "dependency-violation" exception?

 */
abstract class Resource inherits kermeta::standard::Set<Object>
{
	/**
	 * Uri of the Resource to load
	 */
	attribute uri : String
	
	/**
	 * Uri of the meta-model of the Resource to load
	 */
	attribute metaModelURI : String
	
	/**
	 * Indicates weither this resource will be updated when saving the repository
	 * This is useful if the repository contains some metamodels that should not be saved.
	 *
	 * Note that in the current version, it doesn't ensure that you have not modified its content (using the freeze)
	 * If you modify the elements of such resource, other resource that depend on it will be incorrectly saved 
	 */
	attribute isReadOnly : Boolean
	
	/**
	 * The entities contained in the model-instance, that are provided when user loads a resource 
	 * instances == rootContents
	 * this is a loop on Resource itself in order to get backward compatibility
	 */
	@deprecated "user should use the resource directly since this is a collection"
	operation instances() : Resource is do
		result := self
	end
	
	/**
	 * Repository used to create the Resource
	 * This feature is supposed read only, otherwise it cannot garantee that an element is contained by only 
	 * one Resource of a given Repository
	 */
	reference repository : Repository#resources
	
	/**
	 * Save a Resource in the file specified by the current value of uri 
	 */
	operation save() : Void is abstract
	
	/**
	 * Save a Resource in a file referenced by the new uri.
	 * note: this doesn't change the URI of the resource, it is only saved in another place 
	 */
	operation saveWithNewURI(new_uri : String) : Void is do end
	
	/**
	 * Loads the Resource, thus making content of the Resource browsable.
	 * Raises a ResourceLoadException in case loaded Resource is empty
	 */	
	operation load() : Void is abstract
	
	/**
	 * Loads the Resource, thus making content of the Resource browsable.
	 * Without raises a ResourceLoadException in case loaded Resource is empty
	 */
	operation loadWithoutChecking() : Void is abstract
	
	/**	
	 * Returns the set of Resources the current Resource, which must have been loaded,
	 * depends on, an empty set if current Resource has no dependency
	 */
	//TODO: should raises an exception if the Resource is not already loaded
	property readonly dependentResources : set Resource[0..*] getter is do
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.basetypes.ResourceUtil.getDependentResources(this, uri, metaModelURI, \"EMF\")"
		result ?=
			extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.getDependentResources(
				self, uri, metaModelURI, "EMF"
			)
	end
	
	/** 
	 * Returns the set of all Objects directly or indirectly contained by the Resource,
	 * or an empty set if the Resource is empty
	 * implementation note: since this derived property  build a set, it guarantees the unicity, as a drawback,
	 *  calling this property on large resources will be really slow due to this verification. some user may prefer
	 * to reimplement it using a bag.
	 */
	property readonly contents : set Object[0..*] getter is do
		var res : Set<kermeta::language::structure::Object> init Set<kermeta::language::structure::Object>.new
		res.addAll(self)
		
		var coll : Set<kermeta::language::structure::Object>
		self.each{e |
			coll ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.getAllContainedObjects(e)
			res.addAll(coll)
		}
		result := res
	end

	/**
	 * Search for elements referenced by one element contained by this resource that are not contained by this repository
	 * ie. element that EMF would claim as "not contained in a resource"
	 * checks only objects directly referenced by the element in this resource, ignores indirectly referenced objects
	 * example of use :
	 *  var report : Set&lt;DanglingDiagnostic&gt;
	 *	report := resource.findDanglingModelElements()
	 *	report.each{ diag | stdio.writeln(diag.toString ) }
	 */
	operation findDanglingModelElements() : Set<DanglingDiagnostic> is do
		result := Set<DanglingDiagnostic>.new
		self.contents.each{containedObj |
				// for all references and attribute
				var classDef : kermeta::language::structure::ClassDefinition
				classDef ?= containedObj.getMetaClass().typeDefinition
				if(not classDef.isVoid) then
     				//stdio.writeln("checking a " + classDef.name)
					classDef.allAttribute.each{prop |
						if( not prop.isDerived) then // This is weird to have a derived attribute but I don't want to crash for that
	     					//stdio.writeln("   trying property " + prop.name)
							if( prop.upper > 1 or prop.upper == -1) then
								// this is a collection
								var referencedObjs : Collection<Object> 
								referencedObjs ?= containedObj.get(prop)
								if(not referencedObjs.isVoid) then
									// check if this referenced objects are part of one of the resource of this repository
									referencedObjs.each{referencedObj |
										if(not self.repository.resources.exists{ res2 | res2.contents.contains(referencedObj) } and 
										   not (referencedObj.isKindOf(String) or
											    referencedObj.isKindOf(Integer) or
											 	referencedObj.isKindOf(Boolean))  )
										then
											var diagnostic : DanglingDiagnostic init DanglingDiagnostic.new
											diagnostic.danglingElement := referencedObj
											diagnostic.referencingElement := containedObj
											diagnostic.referencingProperty := prop
											result.add(diagnostic)								
										end	
									}
								end
							else
								var referencedObj : Object 
								referencedObj := containedObj.get(prop)
								if(not referencedObj.isVoid) then
									// check if this referenced object is part of one of the resource of this repository
									if(not self.repository.resources.exists{ res2 | res2.contents.contains(referencedObj) } and  
									   not	(referencedObj.isKindOf(String) or
										 	 referencedObj.isKindOf(Integer) or
										     referencedObj.isKindOf(Boolean)) )
									then
										var diagnostic : DanglingDiagnostic init DanglingDiagnostic.new
										diagnostic.danglingElement := referencedObj
										diagnostic.referencingElement := containedObj
										diagnostic.referencingProperty := prop
										result.add(diagnostic)								
									end	
								end
							end
						end
					}
				//else
					// not a classDefinition, should try with primitiveType and Enumetation ?					
				end
			}
		end
		
	/**
	 * Return a normalized version of the Uri of this resource
	 * in order to prevent several loading of the same file because they have diffent path that leads to them, kermeta uses normalizedURI
	 * for some of its functions (eg. repository.getResource )
	 * As EMF needs URI of the form platform:/resource or platform:/plugin, kermeta automatically
	 * normalize the uri when loading or saving. This is especially true for file:/ uri or relative uri (./ or / ) 
	 * If you wish to know what concrete uri is used by kermeta when loading and saving you can use this function
	 * to check how a given uri is normalized by kermeta
	 */
	operation normalizedUri() : String is do
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.basetypes.RepositoryUtil.normalizeUri(uri)"
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.normalizeUri(uri)
	end
}


/**
 * Extension of the Resource class definition that is specific to EMF Repository.
 * User is not supposed to directly create it. Otherwise it will not be correctly initialized
 * You must To create one 
 */
class EMFResource inherits Resource
{	
	 
	/**
	 * Overrides Resource.saveWithNewURI(String)
	 */
	method saveWithNewURI(new_uri : String) : Void is do
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.persistence.Saver.save(getValues(), new_uri, getMetaModelURI())"
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			self, new_uri, metaModelURI, "EMF", self, false
		)
	end
	
	/**
	 * Overrides Resource.save()
	 */
	method save() : Void is do
		if isReadOnly then
			var e : kermeta::exceptions::ResourceSaveException init kermeta::exceptions::ResourceSaveException.new
			e.message := "Cannot save a readonly resource. Probably this resource was indirectly loaded when loading another resource. \n" +
				"If you really intend to save this resource, you can set isReadOnly to false, but you must ensure to do so before any resource save.\n" +
				"Note : setting isReadOnly to false on the metamodel may lead to unpredictable results"
			raise e
		end
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.persistence.Saver.save(getValues(), getUri(), getMetaModelURI())"
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			self, self.uri, metaModelURI, "EMF", self, false
		)
	end

	/**
	 * Checks the Resource using the EMF validation function, and saves it if
	 * validation succeeds
	 * Applies validation to all root objects of the Resource
	 * Returns true if the validation reports no error, raises exceptions otherwise
	 */
	operation saveAndValidateWithEMF() : Boolean is do
		//FIXME CF 08-07-31 Why the extern has twice self as parameter ?
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.basetypes.ResourceUtil.save(this, this.uri, metaModelURI, \"EMF\", this, true)"
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(
			self, self.uri, metaModelURI, "EMF", self, true
		)
	end
	
	/**
	 * Overrides Resource.load()
	 * In case the metamodelURI was not previously set, metamodelURI is filled with
	 * the nsuri of the root package of the metamodel used to load the Resource after
	 * a successful load
	 */
	method load() : Void is do
		self.clear
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.persistence.Loader.load(getValues(), getUri(), getMetaModelURI())"
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.load(
		    self, uri, metaModelURI, "EMF"
		)
		// If load failed
		if(self.size == 0) then
			stdio.writeln("Resource load failed!")
			var e : kermeta::exceptions::ResourceLoadException init kermeta::exceptions::ResourceLoadException.new
			e.message := "Resource load failed, no object was created in this resource from " + uri
			raise e
		end
	end
	
	method loadWithoutChecking() : Void is do
		self.clear
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.persistence.Loader.load(getValues(), getUri(), getMetaModelURI())"
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.load(
		    self, uri, metaModelURI, "EMF"
		)
	end
	
	/**
	 * Overrides Set<Object>.add(Object)
	 * Add an instance to the Resource 
	 * Ensures that the instance is referenced by a one and only one Resource of the same Repository
	 * Ensures that the instance does not appear more than once in the Resource
	 */
	method add(instance : Object) : Void is do
		// search the instance in the other Resources of the containing Repository		
		repository.resources.select{r | r != self and r.contains(instance)}.each{r |
			stdio.writeln("DVK ! another resource of the same repository was containing this element")
			r.remove(instance)
		}
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.language.ObjectUtil.setContainingResource(instance, this)"
		extern fr::irisa::triskell::kermeta::runtime::language::Object.setContainingResource(instance, self)
		super(instance)
	end
	
	/**
	 * Overrides Set<Object>.remove(Object)
	 * Remove the instance from the Resource
	 */
	method remove(instance : Object) : Void is do
		if self.contains(instance) then
			@compiledJavaExtern "org.kermeta.compil.runtime.helper.language.ObjectUtil.unSetContainingResource(instance)"
			extern fr::irisa::triskell::kermeta::runtime::language::Object.unSetContainingResource(instance)
			super(instance)
		end
	end
}


/*
	KMResource is not used for the moment. The idea is to be able to load kmt files. So we may need such a resource in a future that would
	do the parsing and conversion.


 * NOT IMPLEMENTED
 *
class KMResource inherits Resource
{

	method save() : Void is do
		//TODO: implement operation save
	end
	

	method load() : Void is do
		//TODO: implement operation load
	end


	method add(instance : Object) : Void is do
		//TODO: implement operation load
	end


	method remove(instance : Object) : Void is do
		
	end
}
*/

/**
 * Abstract resource container, that contains a list of available loaded resources, 
 * and methods to create or get a resource given an URI.
 * A repository cannot contain 2 resources which points to the same file (ie. that have the same normalizedURI)
 */
abstract class Repository
{
	/**
	 * Resources created by this Repository 
	 * This feature is supposed read only, otherwise it cannot garantee that an element is contained by only 
	 * one Resource of a given Repository
	 */
	attribute resources : set Resource [*]#repository

	/**
	 * Creates a new Resource with given uri, and an optional mm_uri
	 * mm_uri is required when creating a new model from scratch.
	 * Raises a ResourceCreate exception in case the Repository already
	 * contains a Resource with the given uri
	 * If uri does not points to an existing model file (in the case of
	 * a model creation), calls to load() operation will fail as long as
	 * the model has not been saved once
	 */
	operation createResource(uri : String, mm_uri : String) : Resource is abstract	

	/**
	 * Returns the Resource associated with the given uri if this uri is associated with
	 * an already created Resource of the Repository.
	 * If the Repository contains no Resource associated with the given uri, creates
	 * a new Resource and loads it.
	 * In order to prevent multiple load of the same file by using variant path to the same file, all URI used by this function are normalized
	 * Raises a ResourceCreate exception if the given uri does not point to an existing
	 * model file 
	 * May also raises loading exceptions if this is the first retrieval of the resource
	 */
	operation getResource(uri : String) : Resource is do
		
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.basetypes.RepositoryUtil.initRepository(this)"
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.initRepository(self)
		
		var normalisedUri : String init normalizeUri(uri)
		from var it : Iterator<Resource> init resources.iterator
		until it.isOff
		loop
			var next : Resource init it.next
			if (normalisedUri.equals(next.normalizedUri)) then
				result := next
			end
		end
		// If result is null then we create a new resource. With a null
		// URI. we assume that the user calls "getResource" when he already has 
		// a serialized model stored at the given URI 
		// NOT TESTED YET!
		if result == void then
			//stdio.writeln("Warning : you haven't created a resource for the given uri <"+uri+"> in this Repository. Trying to create one. (you should consider using the createResource method first)")
			result := self.createResource(uri, "")
			result.load()
		end
	end
	
	
	/**
	 * Search for elements referenced by one element contained by this repository  that are not contained by this repository
	 * ie. element that EMF would claim as "not contained in a resource"
	 * example of use :
	 *  var report : Set&lt;DanglingDiagnostic&gt;
     *	report := repository.findDanglingModelElements()
     *	report.each{ diag | stdio.writeln(diag.toString ) }
	 */
	operation findDanglingModelElements() : Set<DanglingDiagnostic> is do
		result := Set<DanglingDiagnostic>.new
		var fullResContents : Set<Object> 
		self.resources.each{ res |
			if fullResContents.isVoid then
				fullResContents := res.contents
			else
				fullResContents.addAll(res.contents)
			end
		}
		// for all elements contained by one of the Resource of this repository
		fullResContents.each{containedObj |
				// for all references and attribute
				var classDef : kermeta::language::structure::ClassDefinition
				classDef ?= containedObj.getMetaClass().typeDefinition
				if(not classDef.isVoid) then
     				//stdio.writeln("checking a " + classDef.name)
					classDef.allAttribute.each{prop |
						if( not prop.isDerived) then // This is weird to have a derived attribute but I don't want to crash for that
	     					//stdio.writeln("   trying property " + prop.name)
							if( prop.upper > 1 or prop.upper == -1) then
								// this is a collection
								var referencedObjs : Collection<Object> 
								referencedObjs ?= containedObj.get(prop)
								if(not referencedObjs.isVoid) then
									// check if this referenced objects are part of one of the resource of this repository
									referencedObjs.each{referencedObj |
										if(not fullResContents.contains(referencedObj)  and 
										   not (referencedObj.isKindOf(String) or
											    referencedObj.isKindOf(Integer) or
											 	referencedObj.isKindOf(Boolean))  )
										then
											var diagnostic : DanglingDiagnostic init DanglingDiagnostic.new
											diagnostic.danglingElement := referencedObj
											diagnostic.referencingElement := containedObj
											diagnostic.referencingProperty := prop
											result.add(diagnostic)								
										end	
									}
								end
							else
								var referencedObj : Object 
								referencedObj := containedObj.get(prop)
								if(not referencedObj.isVoid) then
									// check if this referenced object is part of one of the resource of this repository
									if(not fullResContents.contains(referencedObj)  and  
									   not	(referencedObj.isKindOf(String) or
										 	 referencedObj.isKindOf(Integer) or
										     referencedObj.isKindOf(Boolean)) )
									then
										var diagnostic : DanglingDiagnostic init DanglingDiagnostic.new
										diagnostic.danglingElement := referencedObj
										diagnostic.referencingElement := containedObj
										diagnostic.referencingProperty := prop
										result.add(diagnostic)								
									end	
								end
							end
						end
					}
				//else
					// not a classDefinition, should try with primitiveType and Enumetation ?					
				end
			}
				
	end
	/**
	 * Return a normalized version of the Uri 
	 * in order to prevent several loading of the same file because they have different path that leads to them, kermeta uses normalizedURI
	 * for some of its functions (eg. repository.getResource )
	 * As EMF needs URI of the form platform:/resource or platform:/plugin, kermeta automatically
	 * normalize the uri when loading or saving. This is especially true for file:/ uri or relative uri (./ or / ) 
	 * If you wish to know what concrete uri is used by kermeta when loading and saving you can use this function
	 * to check how a given uri is normalized by kermeta 
	 */
	operation normalizeUri(uri : String) : String is do
		@compiledJavaExtern "org.kermeta.compil.runtime.helper.basetypes.RepositoryUtil.normalizeUri(uri)"
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.normalizeUri(uri)
	end
}

/**
 * class used to gather the information required to make a user friendly report about a dangling element
 * (see. findDanglingModelElements())
 */
class DanglingDiagnostic {
	/**
	 * Element that is not contained by a resource in the repository  
	 */
	reference danglingElement : Object
	/**
	 * Element that has a reference to the dangling element  
	 */
	reference referencingElement : Object
	/**
	 * Property used to reference the dangling element  
	 */
	reference referencingProperty : kermeta::language::structure::Property
	/**
	 * user friendly message build with those informations
	 */
	method toString() : String is do
		result := danglingElement.toString + " referenced by " + referencingElement.toString +"."+referencingProperty.name + " is dangling"
	end
}

/**
 * Repository that stores and manages resources that come from EMF
 */
class EMFRepository inherits Repository
{	
	
	/**
	 * Overrides Repository.createResource(String, String)
	 * Create a new resource for a model given by its uri, 
	 * which meta-model is stored in file given by mm_uri
	 * If file already exists, you'll be able to call the load method to concretly load the model
	 * otherwise, you can only call the save method
	 */
	method createResource(uri : String, mm_uri : String) : Resource is do
		
		if(not resources.collect{r | r.uri}.contains(uri)) then
			@compiledJavaExtern "org.kermeta.compil.runtime.helper.basetypes.RepositoryUtil.createResource(this, uri, mm_uri)"
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.createResource(self, uri, mm_uri)
		else
			var e : kermeta::exceptions::ResourceCreateException init kermeta::exceptions::ResourceCreateException.new
			e.message := "Trying to create a resource already existing at " + uri + ".\n"
					+ "Remove existing resource from repository first, or use \"getResource\" operation."
			raise e
		end
	end
	
	/** 
	 * If true, tells to the save of the resources that they should also integrate the resources from Kermeta interpreter itself
	 * this is useful for example to make a dependency to framework.km
	 * by default, not setting this is considered as false.
	 */
	attribute useInterpreterInternalResources : Boolean
	
	/**
	 * When loading the Resources, 
	 * if there are some errors while loading some objects, the loader can try to ignore them
	 * setting this attribute to true is equivalent to setting ignoreLoadErrorUnknownMetaclass and ignoreLoadErrorUnknownProperty to true
	 * by default, not setting this attribute is considered as false.
	 */	 
	 attribute ignoreAllLoadErrors : kermeta::standard::Boolean
	 /**
	 * When loading the Resources, 
	 * if there are some errors due to an unknown metaclass while loading some objects, the loader try to ignore them
	 * by default, not setting this attribute is considered as false.
	 */
	 attribute ignoreLoadErrorUnknownMetaclass : kermeta::standard::Boolean/**
	 * When loading the Resources, 
	 * if there are some errors due to an unknown property while loading some objects (ie. the metaclass is known but it cannot retreive
	 * the given reference or attribute in the ClassDefinition, the loader try to ignore them
	 * by default, not setting this attribute is considered as false.
	 */
	 attribute ignoreLoadErrorUnknownProperty : kermeta::standard::Boolean
}


/*
	KMRepository is not used for the moment. See KMResource.


 * Repository that stores and manages XMI files representing Kermeta models
 *
class KMRepository inherits Repository
{

	method createResource(uri : String, mm_uri : String) : Resource is do
		//TODO: implement operation createResource
		result := void
	end 
}
*/
