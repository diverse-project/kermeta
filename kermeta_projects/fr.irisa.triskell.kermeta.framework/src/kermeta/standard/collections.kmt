/**
 * Contains Collections and primitive types, i.e the base types like String, 
 * Integer, etc.
 */
package kermeta::standard;

require "primitive_types.kmt"

using kermeta::exceptions

/* *************************************************
 * $Id: collections.kmt,v 1.32 2007-04-02 15:23:42 dtouzet Exp $
 * Franck FLEUREY - 14/02/2005 
 * Triskell Research Group
 * IRISA / University of Rennes 1 (France)
 * Distributed under the terms of the EPL licence
 *
 * Implementation of Kermeta collection types.
 *************************************************** */
 alias Object : kermeta::language::structure::Object ;
 
 
/**
 * Collection is the root abstract class for all kermeta collections
 * <img src="./figures/collections_view.png">
 */
abstract class Collection<G> 
{

	operation asBag() : Bag<G> is abstract
	operation asSet() : Set<G> is abstract
	operation asOrderedSet() : OrderedSet<G> is abstract
	operation asSequence() : Sequence<G> is abstract
	
	
	/**
	 * Add an element in the collection
	 * default implementation : no check for duplicates
	 */
	operation add(element : G) : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.add(self, element)
	end
	
	/**
	 * Removes element from the collection
	 * default implementation : 
	 * if the collection contains more than one object that is equals to element, they are all removed
	 * Do nothing if the element is not in the collection
	 */
	operation remove(element : G) : Void 
		post doesntContainsElementAnymore is not contains(element)
	is do
		var elem : G
		from elem := self.detect { e | e == element }
        until elem == void
        loop
        	extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)
            elem := self.detect { e | e == element }
        end
	end
	
	/**
	 * Remove all elements from the collection
	 */
	operation clear() : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.clear(self)
	end
	
	/**
	 * Add all elements from the collection elements in the collection
	 */
	operation addAll(elements : Collection<G>) : Void is do
		elements.each { element | add(element) } 
	end
	
	/**
	 * returns true if the collection contains element
	 * note that it is based on G equals() (semantic equals), which means that it will check  
	 * mycollection.exists{ e | e.equals(myValue) }
	 * Depending on the concrete type of the collection, it may contain duplicates.
	 * If you wish to check if a physical element is contained by the collection you must use the oid()
	 * ex:  mycollection.exists{e | e.oid == myvalue.oid }
	 */
	operation contains(element : G) : Boolean is do
		result := false
		from var it : Iterator<G> init iterator
		until it.isOff or result
		loop
			result := (it.next == element) 
		end
	end
	
	/**
	* OCL API alignement
	*/
	operation includes(element :G): Boolean is do
		result := self.contains(element)
	end
	
	/**
	 * returns true if the collection contains all elements
	 */
	operation containsAll(elements : Collection<G>) : Boolean is do
		result := true
		from var it : Iterator<G> init elements.iterator
		until (it.isOff or not result)
		loop
			result := self.contains(it.next)
		end
	end
	
	/**
	* OCL API alignement
	*/
	operation includesAll(elements : Collection<G>) : Boolean is do
		result := self.containsAll(elements)
	end
	
	
	
	/**
	 * Returns true if the collection does not contain element
	 */
	operation excludes(element : G) : Boolean is do
		result := not self.contains(element)
	end
	
	/**
	 * Returns true if the collection contains none of elements
	 */
	operation excludesAll(elements : Collection<G>) : Boolean is do
		result := true
		from var it : Iterator<G> init elements.iterator
		until (it.isOff or not result)
		loop
			result := not self.contains(it.next)
		end
	end
	
	/**
	 * returns the number of elements in the collection
	 */
	operation size() : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.size(self)
	end
	
	/**
	 * returns true if the collection is empty
	 */
	operation empty() : Boolean is do
		result := size == 0
	end
	
	/**
	 * OCL alignement API
	 */
	operation isEmpty() : Boolean is do
		result := self.empty
	end
	
	/**
	 * OCL alignement API
	 */
	operation isNotEmpty() : Boolean is do
		result := not self.empty
	end
	
	/**
	 * returns an iterator on the collection
	 */
	operation iterator() : Iterator<G> is do
		result := Iterator<G>.new
		extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.iterator(self, result)
	end
	
	/**
	 * returns an element from the collection or void
	 * if the collection is empty
	 */
	operation one() : G is do
		if size == 0 then
			result := void
		else
			var it : Iterator<G> init iterator
			result := it.next
		end
	end

	operation any() : G is do
		if size == 0 then raise EmptyCollection.new end
		var it : Iterator<G> init iterator
		result := it.next
	end

	
	/**
	 * runs func on each element of the collection
	 */
	operation each(func : <G -> Object>) : Void is do
		from var it : Iterator<G> init iterator
		until it.isOff
		loop
			func(it.next)
		end
	end
	
	/**
	 * checks that the condition is true on all the element of the collection
	 * returns true if the collection is empty
	 */
	operation forAll(func : <G -> Boolean>) : Boolean is do
    	var test : Boolean init true
        from var it : Iterator<G> init iterator
        until it.isOff
        loop
        	test := test and func(it.next)
        end
        result := test
        
    end
     
    /**
	 * checks that the condition is true for at least one element of the collection
	 * returns false if the collection is empty
	 */
	operation exists(func : <G -> Boolean>) : Boolean is do
    	var test : Boolean init false
        from var it : Iterator<G> init iterator
        until it.isOff or (test != false)
        loop
        	test := test or func(it.next)
        end
        result := test
    end
	
	/**
	 * returns a new Collection with the results of running collector function 
	 * once for every element in self.
	 * 
	 */
	operation collect<T> (collector : <G -> T>) : Sequence<T> is do
		result := Sequence<T>.new
		from var it : Iterator<G> init iterator
		until it.isOff
		loop
			result.add( collector(it.next) )
		end
	end
	
	/**
	 * Results in true if body evaluates to a different value for each element in the source collection; otherwise, result is false.	 * 
	 */
	operation isUnique<T> (collector : <G -> T>) : Boolean is do
		result := true
		var s : Sequence<T> init Sequence<T>.new
		from var it : Iterator<G> init iterator
		until it.isOff or not result
		loop
			var t : T init collector(it.next)
			if (s.contains(t)) then
				result := false
			else
				s.add(t)
			end
		end
	end
	
	/**
	 * Passes each element of the collection to detector function. 
	 * Returns the first element for which detector is not false. 
	 * Returns void if no object matches.
	 */
	operation detect(detector : <G -> Boolean>) : G is do
		var elem : G
		result := void
		from var it : Iterator<G> init iterator
		until it.isOff or result != void
		loop
			elem := it.next
			if detector(elem) then result := elem end
		end
	end
		
	/**
	 * Passes each element of the collection to selector function. 
	 * returns a Collection for all elements for which selector is true
	 */
	operation select(selector : <G -> Boolean>) : Sequence<G>  is do
		var elem : G
		result := Sequence<G>.new
		from var it : Iterator<G> init iterator
		until it.isOff
		loop
			elem := it.next
			if selector(elem) then result.add(elem) end
		end
	end
	
	/**
	 * Passes each element of the collection to rejector function. 
	 * returns a Collection for all elements for which rejector is false
	 */
	operation reject(rejector : <G -> Boolean>) : Sequence<G>  is do
		result := self.select { elem | not rejector(elem) } 
	end
	
	/**
	 * Returns the nb of instances of 'element' in the collection
	 */
	operation count(element : G) : Integer is do
		result := self.select{e | e == element}.size()
	end
	
	/**
	* sum the element if they are summable
	*/
	operation sum(): G is do
		var res : G 
		var tmp : Summable<G>
		var o : Object
		o:= self.one
		tmp ?= o
		result := void
		if (tmp != void) then
		
		self.each{ elem  | 
		o := elem
		tmp ?= o
		if (tmp != void) then
			res := tmp + res 
			end
			}
			end
	result := res		
			
	end
	
//	operation product(c2: Collection<T2>)) : Set( Tuple( first: T, second: T2) ) is do
//end
}



/**
 * A Set is a collection that contains distinct elements
 * The notion of "distinct" element is based on the equals operation. Be careful if your overwrite it for your type G.
 * A set is not ordered
 */
class Set<G> inherits Collection<G>
{
	/**
	 * The method 'add' adds the element in the Set
	 * only if it is not yet in the set
	 * if the element is already in the set it simply does nothing
	 */
	method add(element : G) : Void is do
		if not self.contains(element) then
			super(element)
		end
	end
	/**
	 * remove the element
	 * 
	 * This method redefines the operation from Collection in order to improve performances since there is no duplicates in Set
	 */
	method remove(element : G) : Void is do
		var elem : G init self.detect { e | e == element }
		if (elem != void) then
			extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)
		end
	end

	// DVK: weird implementation of equals !?
	method equals(element : Object) : Boolean is do
		var isEqual : Boolean init false
		if(not element.isVoid) then
			if(Collection<G>.isInstance(element)) then
				var collection : Collection<G>
				collection ?= element
				if(self.size() == collection.size()) then
					var elem : G
					var ok : Boolean init true
					from var it : Iterator<G> init self.iterator
					until (it.isOff or not ok) loop
						elem := it.next
						if(not collection.contains(elem)) then
							ok := false
						end
					end
					isEqual := ok
				end
			end
		end
		result := isEqual
	end
	
	/** returns the union of a set of elements  and the Set */
	operation union(elements : Set<G>) : Set<G> is do
		result := Set<G>.new
		result.addAll(self)
		result.addAll(elements)
	end
	
	/** returns the union of a bag of elements and the Set */
	operation unionWithBag(elements : Bag<G>) : Bag<G> is do
		result := Bag<G>.new				
		result := addAll(self)
		result := addAll(elements)
	end
	
	/** returns the intersection of elements and the Set */
	operation intersection(elements : Collection<G>) : Set<G> is do
		result := Set<G>.new
		var elem : G
		from var it : Iterator<G> init self.iterator
		until it.isOff
		loop
			elem := it.next
			if elements.contains(elem) then
				result.add(elem)
			end
		end
	end
	
	/** returns the difference of elements and the Set: the elements of the Set 
	 *  that are not in elements
	 */
	operation minus(elements : Set<G>) : Set<G> is do
		result := Set<G>.new
		var elem : G
		from var it : Iterator<G> init self.iterator
		until it.isOff
		loop
			elem := it.next
			if not elements.contains(elem) then
				result.add(elem)
			end
		end
	end
	
	/**
	* 
	*/
	method asSet() : Set<G> is do
		var s : Set<G> init Set<G>.new
		s.addAll(self)
		result := s
	end
	
	/**
	* 
	*/
	method asOrderedSet() : OrderedSet<G> is do
		var s : OrderedSet<G> init OrderedSet<G>.new
		s.addAll(self)
		result := s
	end
	/**
	* 
	*/
	method asBag() : Bag<G> is do
		var s : Bag<G> init Bag<G>.new
		s.addAll(self)
		result := s
	end
	/**
	* 
	*/
	method asSequence() : Sequence<G> is do
		var s : Sequence<G> init Sequence<G>.new
		s.addAll(self)
		result := s
	end
	
	operation symmetricDifference(s : Set<G>) : Set<G> is do
		var res : Set<G> init s.minus(self)
		result := self.minus(s).addAll(res)
		
	
	end
	
	operation flatten() : Set<Object> is do
		
		var res: Set<Object> init Set<Object>.new
		
		if (G.isKindOf(Collection<Object>)) then
			var col : Collection<Object>
			var o : Object 
			self.each{e| o:= e
			col ?= o
			res.addAll(col)}
		end
		result :=  res
		
		
	end
	
	operation sortedBy(comparator : <[G, G] -> Integer>) : OrderedSet<G>  is do
		 
		result := quickSort(self.asOrderedSet, comparator) 
	end
	
	operation quickSort(q :OrderedSet<G>, comparator : <[G, G] -> Integer>) : OrderedSet<G> is do
		 var less : OrderedSet<G> init OrderedSet<G>.new
		 var pivotList : OrderedSet<G> init OrderedSet<G>.new
		 var greater : OrderedSet<G> init OrderedSet<G>.new
		   
		 
     if (q.size <= 1) then   
     	result := q
     else
     	var pivot : G init q.one
     	q.each{x| 
     		if (comparator(x,pivot) == 1) then
     	 		less.add(x)
     	 	end
     	 	if (comparator(x,pivot) == 0) then
     	 		pivotList.add(x)
     	 	end
     	 	if (comparator(x,pivot) == -1) then
     	 		greater.add(x)
     	 	end
     	 	}
     
       result := concatenate(quickSort(less, comparator), pivotList, quickSort(greater, comparator))
		
	end	
	end
	
	operation concatenate(less : OrderedSet<G>, pivot : OrderedSet<G>, greater : OrderedSet<G>): OrderedSet<G> is do
	result := OrderedSet<G>.new
	result.addAll(less)
	result.addAll(pivot)
	result.addAll(greater)
	
	end
	
	
	
}

/**
 * A Bag is a concrete implementation of a Collection
 * A bag can contains duplicates.
 * A bag is not ordered
 */
class Bag<G> inherits Collection<G>
{

	method equals(element : Object) : Boolean is do
		var isEqual : Boolean init false
		if(not element.isVoid) then
			if(Collection<G>.isInstance(element)) then
				var collection : Bag<G>
				collection ?= element
				var selfAsSet : Set<G> init self.asSet()
				result := selfAsSet.equals(collection.asSet())
			end
		end
		result := isEqual
	end

	/** returns the union of elements and the Bag */
	operation union(elements : Collection<G>) : Bag<G> is do
		result := Bag<G>.new
		result := addAll(self)
		result := addAll(elements)
	end
	
	/** returns the intersection of elements and the Bag */
	operation intersection(elements : Bag<G>) : Bag<G> is do
		result := Bag<G>.new
		var elem : G
		var it : Iterator<G> init self.iterator
		from it	until it.isOff
		loop
			elem := it.next
			if elements.contains(elem) then
				if(self.count(elem) <= elements.count(elem)) then
					result.add(elem)
				end
			end
		end
		it := elements.iterator
		from it until it.isOff
		loop
			elem := it.next
			if self.contains(elem) then
				if(elements.count(elem) < self.count(elem)) then
					result.add(elem)
				end
			end
		end
	end
	
	/** returns the intersection of a set of elements and the Bag */
	operation intersectionWithSet(elements : Set<G>) : Set<G> is do
		result := Set<G>.new
		var elem : G
		from var it : Iterator<G> init elements.iterator
		until it.isOff
		loop
			elem := it.next
			if self.contains(elem) then
				result.add(elem)
			end
		end
	end
	
	/**
	 * Removes an element from the collection using the oid
	 * This method is provided because the standard remove operation is based on the equals operation 
	 * and removes all occurences equal to the parameter
	 */
	operation removeFromOid(elementOid : Integer) : Void 
		post doesntContainsElementAnymore is not exists{e | e.oid == elementOid}
	is do
		var elem : G init self.detect { e | e.oid == elementOid }
		if (elem != void) then
			extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)
		end
	end
	
	/**
	 * Removes one element from the bag
	 * This method is provided because the standard remove operation is based on the equals operation 
	 * and removes all occurences equal to the parameter. This one, will remove only the one of them.
	 */
	operation removeOne(element : G) : Void 
	is do
		var elem : G init self.detect { e | e == element }
		if (elem != void) then
			extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)
		end
	end
	
		/**
	* 
	*/
	method asSet() : Set<G> is do
		var s : Set<G> init Set<G>.new
		s.addAll(self)
		result := s
	end
	
	/**
	* 
	*/
	method asOrderedSet() : OrderedSet<G> is do
		var s : OrderedSet<G> init OrderedSet<G>.new
		s.addAll(self)
		result := s
	end
	/**
	* 
	*/
	method asBag() : Bag<G> is do
		var s : Bag<G> init Bag<G>.new
		s.addAll(self)
		result := s
	end
	/**
	* 
	*/
	method asSequence() : Sequence<G> is do
		var s : Sequence<G> init Sequence<G>.new
		s.addAll(self)
		result := s
	end
	
	
	operation including(object :G) : Bag<G> is do
		var s : Bag<G> init Bag<G>.new
		s.addAll(self)
		s.add(object)
		result := s	
		
	end

	operation excluding(object :G) : Bag<G> is do
		var s : Bag<G> init Bag<G>.new
		s.addAll(self)
		s.remove(object)
		result := s	
		
	end
	
	operation flatten() : Bag<Object> is do
		
		var res: Bag<Object> init Bag<Object>.new
		
		if (G.isKindOf(Collection<Object>)) then
			var col : Collection<Object>
			var o : Object 
			self.each{e| o:= e
			col ?= o
			res.addAll(col)}
		end
		result :=  res
		
		
	end
	
	
	operation sortedBy(comparator : <[G, G] -> Integer>) : Sequence<G>  is do
		 
		result := quickSort(self.asSequence, comparator) 
	end
	
	operation quickSort(q :Sequence<G>, comparator : <[G, G] -> Integer>) : Sequence<G> is do
		 var less : Sequence<G> init Sequence<G>.new
		 var pivotList : Sequence<G> init Sequence<G>.new
		 var greater : Sequence<G> init Sequence<G>.new
		   
		 
     if (q.size <= 1) then   
     	result := q
     else
     	var pivot : G init q.one
     	q.each{x| 
     		if (comparator(x,pivot) == 1) then
     	 		less.add(x)
     	 	end
     	 	if (comparator(x,pivot) == 0) then
     	 		pivotList.add(x)
     	 	end
     	 	if (comparator(x,pivot) == -1) then
     	 		greater.add(x)
     	 	end
     	 	}
     
       result := concatenate(quickSort(less, comparator), pivotList, quickSort(greater, comparator))
		
	end	
	end
	
	operation concatenate(less : Sequence<G>, pivot : Sequence<G>, greater : Sequence<G>): Sequence<G> is do
	result := Sequence<G>.new
	result.addAll(less)
	result.addAll(pivot)
	result.addAll(greater)
	
	end
	
	
	
}

/**
 * An OrderedCollection is the root abstract class for all ordered Collections.
 */
abstract class OrderedCollection<G> inherits Collection<G> {
	
	/**
	 * adds element in the OrderedCollection at index
	 */
	operation addAt(index : Integer, element : G) : Void is do
		if index < 0 or index > size then
			raise IndexOutOfBound.new
		end
		extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.addAt(self, index, element)
	end
	
	/**
	 * removes the element at index of the OrderedCollection
	 */
	operation removeAt(index : Integer) : Void is do
		if index < 0 or index > size-1 then
			raise IndexOutOfBound.new
		end
		extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.removeAt(self, index)
	end
	
	/**
	 * returns the element at index in the OrderedCollection
	 */
	operation elementAt(index : Integer) : G is do
		if index < 0 or index > size-1 then
			raise IndexOutOfBound.new
		end
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.elementAt(self, index)
	end
	
	/** returns the first element in the OrderedCollection */
	operation first() : G is do
		if size == 0 then
			raise EmptyCollection.new
		end
		result := elementAt(0)
	end
	
	/** returns the last element in the OrderedCollection */
	operation last() : G is do
		if size == 0 then
			raise EmptyCollection.new
		end
		result := elementAt(size - 1)
	end

	method equals(element : Object) : Boolean is do
		var isEqual : Boolean init false
		if (not element.isVoid) then
			if (OrderedCollection<G>.isInstance(element) ) then
				var collection : Collection<G>
				collection ?= element
				if(self.size() == collection.size()) then
					var selfIterator : Iterator<G> init self.iterator()
					var collectionIterator : Iterator<G> init collection.iterator()
					var difference : Boolean init false
					from void
					until (selfIterator.isOff() or collectionIterator.isOff() or difference)
					loop
						if(not (selfIterator.next == collectionIterator.next)) then
							difference := true
						end
					end
					isEqual := not difference
				end
			end
		end
		result := isEqual
	end
	
	/** returns the index of the first element instance in the OrderedCollection */
	operation indexOf(element : G) : Integer is do
		if size == 0 then
			raise EmptyCollection.new
		end
		if not self.contains(element) then
			result := -1
		else
			var i : Integer init 0
			from var found : Boolean init false
			until found
			loop
				if(element == elementAt(i)) then
					found := true
				else
					i := i + 1
				end
			end
			result := i
		end
	end
}

/**
 * an OrderedSet is a Set that contained ordered distinct elements
 * As it is ordered it is accessible by their index. (see AddAt method)
 */
class OrderedSet<G> inherits Set<G>, OrderedCollection<G>
{
	/**
	 * Select the method add from Set
	 */
	method add(element : G) from Set is do super(element) end

	/**
	 * Overrides addAt to ensure element uniqueness
	 */
	method addAt(index : Integer, element : G) : Void is do
		if not self.contains(element) then
			super(index, element)
		end
		// TODO : should it raise an exception otherwise ?
	end
	
	method equals(element : Object) : Boolean from OrderedCollection is do
		result := super(element)
	end
	
	operation subSet(min : Integer, max : Integer) : OrderedSet<G> is do
		result := OrderedSet<G>.new
		if(min >= 0 and max <= self.size) then
			self.each{e |
				var i : Integer init self.indexOf(e)
				if(i >= min and i <= max) then
					result.add(e)
				end
			}
		end
	end
	operation append(subject : G ) : OrderedSet<G> is do
		result := OrderedSet<G>.new
		result.addAll(self)
		result.add(subject)
	end
	
	operation preppend(subject : G ) : OrderedSet<G> is do
		result := OrderedSet<G>.new
		result.add(subject)
		result.addAll(self)
		
	end
	
	operation insertAt(index : Integer, subject : G ) : OrderedSet<G> is do
		result := OrderedSet<G>.new
		result.addAll(self)
		result.addAt(index, subject)
	end
	
	operation subOrderedSet(lower : Integer, upper : Integer ) : OrderedSet<G> is do
		result := OrderedSet<G>.new
		
		from var i : Integer init lower until i<= upper
		loop
			result.add(self.at(i))
		end

	end

	operation at(index : Integer) : G is do
	
		if(index >= 0 and index <= self.size) then
			self.each{e |
				var i : Integer init self.indexOf(e)
				if (i == index) then 
					result := e
				end				
			}
		end
	end	
	
}

/**
 * A Sequence is an ordered collection of elements
 * It allows duplicates
 */
class Sequence<G> inherits Bag<G>, OrderedCollection<G>
{
	method equals(element : Object) : Boolean from OrderedCollection is do
		result := super(element)
	end
	
	operation subSequence(min : Integer, max : Integer) : Sequence<G> is do
		result := Sequence<G>.new
		if(min >= 0 and max <= self.size) then
			self.each{e |
				var i : Integer init self.indexOf(e)
				if(i >= min and i <= max) then
					result.add(e)
				end
			}
		end
	end
	
	operation append(subject : G ) : Sequence<G> is do
		result := Sequence<G>.new
		result.addAll(self)
		result.add(subject)
	end
	
	operation preppend(subject : G ) : Sequence<G> is do
		result := Sequence<G>.new
		result.add(subject)
		result.addAll(self)
		
	end
	
	operation insertAt(index : Integer, subject : G ) : Sequence<G> is do
		result := Sequence<G>.new
		result.addAll(self)
		result.addAt(index, subject)
	end
	
	
	operation at(index : Integer) : G is do
	
		if(index >= 0 and index <= self.size) then
			self.each{e |
				var i : Integer init self.indexOf(e)
				if (i == index) then 
					result := e
				end				
			}
		end
	end	
	
	

	
}

/**
 * Iterator to be used with Collection
 * see also getIterator() on Collection
 */
class Iterator<G>
{
	/**
	 * Returns true if the iterator is on the last element
	 * i.e. returns not self.hasNext()
	 */
	operation isOff() : Boolean is do
		result := not hasNext
	end
	
	/**
	 * returns true if the iterator has a next element
	 */
	operation hasNext() : Boolean is do
	 	result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Iterator.hasNext(self)
	end
	
	/**
	 * returns the next element of the iterator
	 */
	operation next() : G is do
		if not hasNext then
			raise IteratorIsOff.new
		end
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Iterator.next(self)
	end
}