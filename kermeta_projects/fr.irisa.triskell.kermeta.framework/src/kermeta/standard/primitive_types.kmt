// $Id: primitive_types.kmt,v 1.19 2005-06-09 17:48:19 ffleurey Exp $
package kermeta::standard; 

require "../Standard.kmt"

using kermeta::language::structure
using kermeta::exceptions

/* *************************************************
 * Franck FLEUREY - 11/02/2005
 * Triskell Research Group
 * IRISA / University of Rennes 1 (France)
 * Distributed under the terms of the GPL licence
 *
 * Implementation of Metacore base types.
 *************************************************** */

/**
 * The class Void 
 * By convention it is a sub-type of everything
 */
class ~Void {

	method isVoid() : Boolean is do
		result := true
	end

	method toString() : String is do
		result := "<void>"
	end
}


/**
 * The abstract class ValueType does not contain any feature
 * but any instance of a sub-class of ValueType will be passed by value 
 * instead of by reference for any other objects.
 */
abstract class  ValueType {}

/**
 * The abstract class Comparable defines a set of operation
 * to compare instances of a class.
 * Sub-classes only has to implement abstract operation compareTo.
 * All other methods are defined w.r.t. the compareTo operation
 */
abstract class Comparable {
	
	/**
	 * This method should be implemented by any class that inherits
	 * from Comparable.
	 * returns 0 if self = other
	 * returns > 0 if  self > other
	 * returns < 0 if  self < other
	 */
	operation compareTo(other : Object) : Integer is abstract
	
	/**
	 * return true if self > other
	 */
	operation isGreater(other : Object) : Boolean is do
		self.compareTo(other) > 0
	end
	
	/**
	 * return true if self < other
	 */
	operation isLower(other : Object) : Boolean is do
		self.compareTo(other) < 0
	end
	
	/**
	 * return true if self <= other
	 */
	operation isLowerOrEqual(other : Object) : Boolean is do
		self.compareTo(other) <= 0
	end
	
	/**
	 * return true if self >= other
	 */
	operation isGreaterOrEqual(other : Object) : Boolean is do
		self.compareTo(other) >= 0
	end
} // Comparable

class NotComparableException inherits kermeta::exceptions::Exception {
	// raized when two objects are not comparable  
}

/**
 * The Boolean type
 */
class Boolean
{

	method equals(other : Object) : Boolean is do
		if other.getMetaClass != Boolean then  
			result := false 
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Boolean.equals(self, other)
		end
	end

	/**
	 * return self and other
	 */ 
	operation ~and(other : Boolean) : Boolean is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Boolean.~and(self, other)
	end
	
	/**
	 * return not self
	 */ 
	operation ~not() : Boolean is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Boolean.~not(self)
	end
	
	/**
	 * return self or other
	 */ 
	operation ~or(other : Boolean) : Boolean is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Boolean.~or(self, other)
	end
	
	method toString() : String is do
		result := if self then "true" else "false" end
	end
	
} // Boolean

/**
 * The abstract class Numeric is the root class for all
 * numeric types
 */
abstract class Numeric inherits Comparable, ValueType
{ 
	
	
}

/**
 * The class Integer
 */
class Integer inherits Numeric
{

	/**
	 * Iteration
	 */ 
	 operation times(body : <Integer->Object>) : Void is do
	 	from var i : Integer init 0
	 	until i == self
	 	loop
	 		body(i)
	 		i := i + 1
	 	end
	 end 

	/**
	 * Comparison
	 */
	method compareTo(other : Object) : Integer is do
		if other.getMetaClass != Integer then
			raise NotComparableException.new
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.compareTo(self,other)
		end
	end
	
	method equals(other : Object) : Boolean is do
		if other.getMetaClass != Integer then
			result := false
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.equals(self, other)
		end
	end

	/**
	 * returns self + other
	 */
	operation plus(other : Integer) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.plus(self,other)
	end
	
	/**
	 * returns self - other
	 */
	operation minus(other : Integer) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.minus(self,other)
	end
	
	/**
	 * returns self * other
	 */
	operation mult(other : Integer) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.times(self,other)
	end
	
	/**
	 * returns self / other
	 */
	operation div(other : Integer) : Integer is do
		if other == 0 then raise DivisionByZero.new end
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.div(self,other)
	end
	
	/**
	 * returns self modulo other
	 */
	operation mod(other : Integer) : Integer is do
		if other == 0 then raise DivisionByZero.new end
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.mod(self,other)
	end
	
	/**
	 * returns -self
	 */
	operation uminus() : Integer is do
		result := 0 - self
	end
	
	/**
	 * Convert self as a Real
	 */
	operation toReal() : Real is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.toReal()
	end
	
	/**
	 * return true if self > other
	 */
	method isGreater(other : Object) : Boolean is do
		if other.getMetaClass != Integer then
			result := false
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.isGreater(self, other)
		end
	end
	
	/**
	 * return true if self < other
	 */
	method isLower(other : Object) : Boolean is do
		if other.getMetaClass != Integer then
			result := false
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.isLower(self, other)
		end
	end
	
	/**
	 * return true if self <= other
	 */
	method isLowerOrEqual(other : Object) : Boolean is do
		if other.getMetaClass != Integer then
			result := false
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.isLowerOrEqual(self, other)
		end
	end
	
	/**
	 * return true if self >= other
	 */
	method isGreaterOrEqual(other : Object) : Boolean is do
		if other.getMetaClass != Integer then
			result := false
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.isGreaterOrEqual(self, other)
		end
	end
	
	method toString() : String is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.toString(self)
	end
	
}

/**
 * class Real
 */
class Real inherits Numeric
{
	/**
	 * returns self + other
	 */
	operation plus(other : Numeric) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.plus(other)
	end
	
	/**
	 * returns self - other
	 */
	operation minus(other : Numeric) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.minus(other)
	end
	
	/**
	 * returns self * other
	 */
	operation mult(other : Numeric) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.times(other)
	end
	
	/**
	 * returns self / other
	 */
	operation div(other : Numeric) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.div(other)
	end
	
	/**
	 * Convert self as a Real
	 */
	operation toInteger() : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.toInteger()
	end
	
	/**
	 * returns -self
	 */
	operation uminus() : Numeric is do
		result := 0.toReal - self
	end
	
	method toString() : String is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.toString(self)
	end
}

/**
 * The class Character
 */
class Character inherits ValueType, Comparable
{
	/**
	 * Comparaison
	 */
	method compareTo(other : Object) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Character.compareTo(self,other)
	end

	method equals(other : Object) : Boolean is do
		if other.getMetaClass != Character then
			result := false
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Character.equals(self, other)
		end
	end
	
	method toString() : String is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Character.toString(self)
	end
	
	}
/**
 * The class String
 */
class String inherits ValueType, Comparable 
{

	/**
	 * Comparaison
	 */
	method compareTo(other : Object) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.compareTo(self,other)
	end
	
	method equals(other : Object) : Boolean is do
		if other.getMetaClass != String then
			result := false
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.equals(self, other)
		end
	end
	
	/**
	 * returns a new string self + other
	 */
	operation plus(other : String) : String is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.plus(self,other)
	end
	
	/**
	 * Appends other at the end of self
	 */
	operation append(other : String) : Void is do
		extern fr::irisa::triskell::kermeta::runtime::basetypes::String.append(self,other)
	end
	
	/**
	 * returns the character at index in the String
	 */
	operation elementAt(index : Integer) : Character is do
		if index < 0 or index > size-1 then
			raise StringIndexOutOfBound.new
		else
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.elementAt(self,index)
		end
	end
	
	/**
	 * returns the index within this string of the first 
	 * occurrence of the specified substring
	 */
	operation indexOf(str : String) : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.indexOf(self,str)
	end
	
	
	/**
	 * returns a new string that is a substring of this string
	 */
	operation substring(startIndex : Integer, endIndex : Integer) : String is do
		if startIndex >= 0 and startIndex < size and endIndex < size and endIndex >= startIndex then
			result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.substring(self,startIndex, endIndex)
		else
			raise StringIndexOutOfBound.new
		end
	end
	
	operation size() : Integer is do
		result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.size(self)
	end
	
	method toString() : String is do
		result := self
	end
}

/**
 * Unlimited natural is used for reflection.
 * It is mapped to integer.equals().
 * Any negative number is interpreted as '*'
 */
alias UnlimitedNatural : Integer ;

/***************************************************
 *                  END OF FILE
 *************************************************** */ 
