<?xml version="1.0" encoding="ASCII"?>
<trek:UseKaseModel xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:trek="http://www.kermeta.org/trek">
  <kuseCases name="Assignment" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&lt;para/>&#xD;&#xA;&lt;para>If the left and right expressions have the same type and &quot;attr&quot; is a property from a Class Definition &quot;myCD&quot; and the multiplicity is [0..1] or [1..1]&lt;/para>&#xD;&#xA;&lt;para>In kmt: attr := theValueOfAttr&lt;/para>&#xD;&#xA;&lt;para>In Java: myCD.setAttr(theValueOfAttr);&lt;/para>&#xD;&#xA;&lt;para/>&#xD;&#xA;&lt;para>If the left and right expressions have the same type and &quot;attr&quot; is a property from a Class Definition &quot;myCD&quot; and the multiplicity is [0..*] or [1..*]&lt;/para>&#xD;&#xA;&lt;para>In kmt: attr := theValueOfAttr&lt;/para>&#xD;&#xA;&lt;para>In Java: myCD.getAttr.add(theValueOfAttr);&lt;/para>" id="comp_assignment">
    <verifiedBy href="comp_assignment/comp_assignment.trek#//@ktestCases.0"/>
    <verifiedBy href="comp_assignment/comp_assignment.trek#//@ktestCases.1"/>
    <verifiedBy href="comp_assignment/comp_assignment.trek#//@ktestCases.2"/>
    <verifiedBy href="comp_assignment/comp_assignment.trek#//@ktestCases.3"/>
    <status progress="100" key="Design"/>
    <status progress="80" key="Impl_Java"/>
    <status progress="80" key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Attribute" summary="&lt;para>&lt;/para>" id="comp_attribute">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Body" summary="&lt;para>In kmt the body of an operation begins by &quot;do&quot; and is closed by &quot;end&quot;.&lt;/para>&#xD;&#xA;&lt;para>In Java: &quot;{&quot; to begin and &quot;}&quot; to close an operation body.&lt;/para>" id="comp_body">
    <verifiedBy href="comp_body/comp_body.trek#//@ktestCases.0"/>
    <verifiedBy href="comp_body/comp_body.trek#//@ktestCases.1"/>
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status progress="100" key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="CallResult" summary="&lt;para>In Kermeta syntax the type of the CallResult variable: &quot;result&quot; can be used anywhere, in Java the &quot;return&quot; statement must be used as a root expression in the operation body. Also, we have to add systematically a first declaration of a variable which has the type of the return type with an initialization: String result=null; and as well as the &quot;return&quot; statement at the end of the operation: return result;.&lt;/para>" id="comp_callResult">
    <verifiedBy href="comp_callResult/comp_callResult.trek#//@ktestCases.0"/>
    <verifiedBy href="comp_callResult/comp_callResult.trek#//@ktestCases.1"/>
    <verifiedBy href="comp_callResult/comp_callResult.trek#//@ktestCases.2"/>
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status progress="100" key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="CallSuperOperation" summary="&lt;para>&lt;/para>" id="comp_callSuperOperation">
    <status key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="ClassDefinition" summary="&lt;para>&lt;/para>" id="comp_classDefinition">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Collection" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&lt;para/>&#xD;&#xA;&lt;para>Helper:&lt;/para>&#xD;&#xA;&lt;para>In order to access to the specific Kermeta&#x92;s methods on the Collections, we could use Java static methods. These methods will be generated from the framework in external Java classes, but not integrated into the Ecore model, because the EMF generation does not support static methods.&lt;/para>" id="comp_collection">
    <status progress="50" key="Design"/>
    <status progress="50" key="Impl_Java"/>
    <status progress="50" key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Conditional" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&lt;para/>&#xD;&#xA;&lt;programlisting>&#xD;&#xA;In kmt:&#xD;&#xA;&#x9;if(...) then&#xD;&#xA;&#x9;&#x85;&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;&#x85;&#xD;&#xA;&#x9;end&#xD;&#xA;&#xD;&#xA;In Java:&#xD;&#xA;&#x9;if(...) {&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;}&#xD;&#xA;&lt;/programlisting>" id="comp_conditional">
    <verifiedBy href="comp_conditional/comp_conditional.trek#//@ktestCases.0"/>
    <verifiedBy href="comp_conditional/comp_conditional.trek#//@ktestCases.1"/>
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Containment" summary="&lt;para>&lt;/para>" id="comp_containment">
    <verifiedBy href="comp_containment/comp_containment.trek#//@ktestCases.0"/>
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Exception" summary="&lt;para>&lt;/para>" id="comp_exception">
    <status progress="80" key="Design"/>
    <status progress="80" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="FunctionType" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&lt;para>A Function Type is called inside another method.&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>The function type is prettyprinted in a specific static method and called by the method that uses it.&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>In the context of a lambda expression:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>The two methods are generated in a same new Java Class in a &quot;helper&quot; package.&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;programlisting>&#xD;&#xA;/** Kermeta source code **/&#xD;&#xA;a.ref.each{ r |&#xD;&#xA;&#x9;stdio.writeln(r.toString)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;/** Java source code **/&#xD;&#xA;// Method that uses the function type&#xD;&#xA;  public static void each(EList String list) {&#xD;&#xA;    for(String it : list) {&#xD;&#xA;      func(it);&#xD;&#xA;    }&#xD;&#xA;  }&#xD;&#xA;  &#xD;&#xA;// The FunctionType prettyprinted in the same Java class&#xD;&#xA;  private static void func(String r) {&#xD;&#xA;    System.out.println(r.toString());&#xD;&#xA;  }&#xD;&#xA;&lt;/programlisting>&#xD;&#xA;&#xD;&#xA;&lt;para>The call of the method from the original method:&lt;/para>&#xD;&#xA;&lt;programlisting>Main_3_Helper.each(a.getRef());&lt;/programlisting>" id="comp_functionType">
    <status progress="100" key="Design"/>
    <status progress="80" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
    <status progress="100" key="Impl_Jet"/>
    <status progress="100" key="Impl_Simk"/>
  </kuseCases>
  <kuseCases name="Generics" summary="&lt;para>&lt;/para>" id="comp_generics">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Initialization" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>- Initialization of a variable:&lt;/para>&#xD;&#xA;&lt;para>In kmt: var aPrinter : Printer init Printer.new&lt;/para>&#xD;&#xA;&lt;para>In Java: comptest2.Printer aPrinter = comptest2.Comptest2Factory.eINSTANCE.createPrinter();&lt;/para>&#xD;&#xA;&lt;para/>&#xD;&#xA;&#xD;&#xA;&lt;para>- Initialization of a String:&lt;/para>&#xD;&#xA;&lt;para>In kmt: var text1 : String init &quot;Hello&quot;&lt;/para>&#xD;&#xA;&lt;para>In Java: String text1 = &quot;Hello &quot;;&lt;/para>&#xD;&#xA;&lt;para/>&#xD;&#xA;&#xD;&#xA;&lt;para>In kmt:&lt;/para>&#xD;&#xA;&lt;programlisting>&#xD;&#xA;&#x9;var text2 : String&#xD;&#xA;&#x9;text2 := &quot;World&quot;&#xD;&#xA;&lt;/programlisting>&#xD;&#xA;&lt;para>In Java:&lt;/para>&#xD;&#xA;&lt;programlisting>&#xD;&#xA;&#x9;String text2 = null;&#xD;&#xA;&#x9;text2 = &quot;World&quot;;&#xD;&#xA;&lt;/programlisting>" id="comp_initialization">
    <verifiedBy href="comp_initialization/comp_initialization.trek#//@ktestCases.0"/>
    <verifiedBy href="comp_initialization/comp_initialization.trek#//@ktestCases.1"/>
    <verifiedBy href="comp_initialization/comp_initialization.trek#//@ktestCases.2"/>
    <verifiedBy href="comp_initialization/comp_initialization.trek#//@ktestCases.3"/>
    <verifiedBy href="comp_initialization/comp_initialization.trek#//@ktestCases.4"/>
    <verifiedBy href="comp_initialization/comp_initialization.trek#//@ktestCases.5"/>
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="InstanceOf" summary="&lt;para>TODO&lt;/para>" id="comp_instanceOf">
    <verifiedBy href="comp_instanceOf/comp_instanceOf.trek#//@ktestCases.0"/>
    <status key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Invariant" summary="&lt;para>&lt;/para>" id="comp_invariant">
    <status key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="JavaStaticCall" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;programlisting>&#xD;&#xA;//In kmt:&#xD;&#xA;extern fr::irisa::triskell::kermeta::runtime::io::SimpleFileIO.writeTextFile(filename, text)&#xD;&#xA;&#xD;&#xA;//In Java:&#xD;&#xA;fr.irisa.triskell.kermeta.runtime.io.SimpleFileIO.writeTextFile(filename, text);&#xD;&#xA;&lt;/programlisting>" id="comp_javaStaticCall">
    <verifiedBy href="comp_javaStaticCall/comp_javaStaticCall.trek#//@ktestCases.0"/>
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="LambdaExpression" summary="&lt;para>A Function Type is called inside another method.&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>The function type is prettyprinted in a specific static method and called by the method that uses it.&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>In the context of a lambda expression:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>The two methods are generated in a same new Java Class in a &quot;helper&quot; package.&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;programlisting>&#xD;&#xA;/** Kermeta source code **/&#xD;&#xA;a.ref.each{ r |&#xD;&#xA;  stdio.writeln(r.toString)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;/** Java source code **/&#xD;&#xA;// Method that uses the function type&#xD;&#xA;public static void each(EList String list) {&#xD;&#xA;  for(String it : list) {&#xD;&#xA;    func(it);&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;  &#xD;&#xA;// The FunctionType prettyprinted in the same Java class&#xD;&#xA;private static void func(String r) {&#xD;&#xA;  System.out.println(r.toString());&#xD;&#xA;}&#xD;&#xA;&lt;/programlisting>&#xD;&#xA;&#xD;&#xA;&lt;programlisting>&#xD;&#xA;// The call of the method from the original method:&#xD;&#xA;Main_3_Helper.each(a.getRef());&#xD;&#xA;&lt;/programlisting>" id="comp_lambdaExpression">
    <verifiedBy href="comp_lambdaExpression/comp_lambdaExpression.trek#//@ktestCases.0"/>
    <status progress="100" key="Design"/>
    <status progress="80" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
    <status progress="100" key="Impl_Jet"/>
    <status progress="100" key="Impl_Simk"/>
  </kuseCases>
  <kuseCases name="Loop" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;programlisting>&#xD;&#xA;// In kmt:&#xD;&#xA;var j : Integer init 5&#xD;&#xA;from var i : Integer init 0&#xD;&#xA;until i == self&#xD;&#xA;loop&#xD;&#xA;&#x9;i := i + 1&#xD;&#xA;end&#xD;&#xA;&#xD;&#xA;// In Java:&#xD;&#xA;int j = 5;&#xD;&#xA;int i = 0;&#xD;&#xA;while( i != j ) {&#xD;&#xA;&#x9;i = i + 1;&#xD;&#xA;}&#xD;&#xA;&lt;/programlisting>" id="comp_loop">
    <verifiedBy href="comp_loop/comp_loop.trek#//@ktestCases.0"/>
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="ModelElementReflexivity" summary="&lt;para>The ModelElement reflexivity is provided by EMF on models and metamodels. When a km model is translated into in XMI, all the full reflexivity is able. The limit of the reflexivity is given by the input metamodel.&lt;/para>" id="comp_modelElementReflexivity">
    <status key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="ModelingUnit" summary="&lt;para>&lt;/para>" id="comp_modelingUnit">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="MultipleInheritance" summary="&lt;para>&lt;/para>" id="comp_multipleInheritance">
    <status key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="MultiplePackagesRoot" summary="&lt;para>&lt;/para>" id="comp_multiplePackagesRoot">
    <status key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Multiplicity" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>Implemented by the structural part (&#x93;model&#x94; plugin) of the EMF generated source code.&lt;/para>&#xD;&#xA;&lt;para>Some issues for multiplicity have taken into account during the assignment translation.&lt;/para>" id="comp_multiplicity">
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="New" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>The creation of Object is performed by the new method, in EMF-Java: a factory is used and it can be called like:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>For MyClassDefinition owns by the package: comp_new_test001&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;programlisting>&#xD;&#xA;// In Kermeta:&#xD;&#xA;A.new&#xD;&#xA;&#xD;&#xA;// In EMF-Java:&#xD;&#xA;Comp_new_test001Factory.eINSTANCE.createA();&#xD;&#xA;&lt;/programlisting>&#xD;&#xA;" id="comp_new">
    <verifiedBy href="comp_new/comp_new.trek#//@ktestCases.0"/>
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status progress="100" key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="OperationStructure" summary="&lt;para>&lt;/para>" id="comp_operationStructure">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Opposite" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>Implemented by the structural part (&#x93;model&#x94; plugin) of the EMF generated source code.&lt;/para>" id="comp_opposite">
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Package" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>The granularity of the EMF regeneration is the EPackage. If we want to generate incrementally the Java source code, also we regenerate the whole of the EPackage.&lt;/para>" id="comp_package">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Postcondition" summary="&lt;para>&lt;/para>" id="comp_postcondition">
    <status progress="10" key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Precondition" summary="&lt;para>&lt;/para>" id="comp_precondition">
    <status progress="10" key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="PrimitiveType" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>Helper:&lt;/para>&#xD;&#xA;&lt;para>In order to access to the specific Kermeta&#x92;s methods on the Primitive Types, we could use Java static methods. These methods will be generated from the framework in external Java classes, but not integrated into the Ecore model, because the EMF generation does not support static methods.&lt;/para>" id="comp_primitiveType">
    <verifiedBy href="comp_primitiveType/comp_primitiveType.trek#//@ktestCases.0"/>
    <status progress="50" key="Design"/>
    <status progress="20" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="PropertyBehavior" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>Behavior of a derived property: getter/ setter.&lt;/para>&#xD;&#xA;&lt;para>This ability is not supported by the EMF mechanism based on the use of EAnnotations containing the Java source code corresponding the expected behavior.&lt;/para>" id="comp_propertyBehavior">
    <status progress="50" key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
    <status key="Impl_Jet"/>
  </kuseCases>
  <kuseCases name="PropertyStructure" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>Derived property signature.&lt;/para>" id="comp_propertyStructure">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Reference" summary="&lt;para>&lt;/para>" id="comp_reference">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Runner" summary="&lt;para>Design:&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;para>In order to facilitate the accessibility for the users of the generated source code, some runners are generated. A Runner is a Java Class containing a main method which is able to launch the execution of a method. Not all the methods should infer a runner, only the methods which have none parameter or some parameters having String as type. The parameterized Method and method owning by a parameterized Class should not infer a Runner too. The runners are generated in a specific Java Package for each source code package.&#xD;&#xA;Another file is generated that is a &#x93;Eclipse Java Application Launch&#x94; file: *.launch (generated in the root of the project). This one is able to configure automatically the &quot;Run &#x85;&quot; assist of Eclipse to launch quickly an execution. The parameters of this file are provided by the tags: mainClass and mainOperation given by the ModelingUnit.&lt;/para>&#xD;&#xA;&#xD;&#xA;&lt;warning>&lt;para>The simk model should be populated by the pass written in Kermeta and not in Java.&lt;/para>&lt;/warning>" id="comp_runner">
    <verifiedBy href="comp_runner/comp_runner.trek#//@ktestCases.0"/>
    <status progress="100" key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
    <status progress="100" key="Impl_Jet"/>
    <status progress="100" key="Impl_Simk"/>
  </kuseCases>
  <kuseCases name="SubPackage" summary="&lt;para>&lt;/para>" id="comp_subPackage">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Tag" summary="&lt;para>&lt;/para>" id="comp_tag">
    <status key="Design"/>
    <status progress="100" key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="Traceability" summary="&lt;para>A traceability mechanism could be added between the merged Kermeta model file (*.km) and the generated Java.&lt;/para>" id="comp_traceability">
    <status progress="10" key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
  <kuseCases name="UriManagement" summary="&lt;para>&lt;/para>" id="comp_uriManagement">
    <status progress="10" key="Design"/>
    <status key="Impl_Java"/>
    <status key="Impl_Kermeta"/>
  </kuseCases>
</trek:UseKaseModel>
