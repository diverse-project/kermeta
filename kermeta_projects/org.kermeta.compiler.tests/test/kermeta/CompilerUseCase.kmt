package org::kermeta::compiler::trek2junit::kermeta;
require kermeta
require "http://www.kermeta.org/trek"
using kermeta::standard
using kermeta::utils
using trek
class JUnitUseCaseTemplate{
operation generate(uc:KUseCase, mode:String):String is do
var _res: StringBuffer init StringBuffer.new
_res.append("\r\n/*$Id: CompilerUseCase.kmt,v 1.9 2008-06-16 13:34:09 cfaucher Exp $\r\n* Project : org.kermeta.compiler.tests\r\n* License : EPL\r\n* Copyright : IRISA / INRIA / Universite de Rennes 1\r\n* ----------------------------------------------------------------------------\r\n* This is generated thanks to the KET template: CompilerUseCase.ket\r\n*/\r\n\r\npackage org.kermeta.compiler.tests.")
_res.append(mode)
_res.append(";\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\nimport org.junit.AfterClass;\r\nimport org.junit.Assert;\r\nimport org.junit.Before;\r\nimport org.junit.BeforeClass;\r\nimport org.junit.Test;\r\nimport org.kermeta.compiler.common.KCompilerConstants;\r\nimport org.kermeta.compiler.tests.helper.Constants;\r\nimport org.kermeta.compiler.tests.helper.DiffHelper;\r\nimport org.kermeta.interpreter.api.InitializationError;\r\nimport org.kermeta.interpreter.api.Interpreter;\r\nimport org.kermeta.interpreter.api.InterpreterMode;\r\nimport org.kermeta.interpreter.api.InterpreterOptions;\r\nimport org.kermeta.io.loader.plugin.LoaderPlugin;\r\nimport org.kermeta.io.plugin.IOPlugin;\r\nimport org.kermeta.simk.impl.SimkPackageImpl;\r\n\r\nimport fr.irisa.triskell.eclipse.console.LocalIOConsole;\r\nimport fr.irisa.triskell.kermeta.exceptions.NotRegisteredURIException;\r\nimport fr.irisa.triskell.kermeta.exceptions.URIMalformedException;\r\nimport fr.irisa.triskell.kermeta.tests.comparison.EMFCompareModelHelper;\r\n\r\npublic class ")
_res.append(uc.id.substring(0,1).toUpperCase)
_res.append(uc.id.substring(1,uc.id.size))
_res.append("UseCase {\r\n\r\n\t/*\r\n     * \r\n     * Beginning dynamic code for the current use case\r\n     * \r\n     */\r\n\tprivate String use_case = \"")
_res.append( uc.id )
_res.append("\";\r\n\t/*\r\n     * \r\n     * Ending dynamic code for the current use case\r\n     * \r\n     */\r\n\t\r\n\t/*\r\n\t * \r\n\t * Beginning static code\r\n\t *  \r\n\t */\r\n\tstatic private Interpreter _interpreter;\r\n\t\r\n\t/*\r\n\t * \r\n\t * We only load one time the program when the current class is loading.\r\n\t * \r\n\t */\r\n\t@BeforeClass\r\n\tstatic public void setInterpreter() {\r\n\t\tIOPlugin.LOCAL_USE = true;\r\n\t\tLoaderPlugin.getDefault();\r\n\t\t\r\n\t\tSimkPackageImpl.init();\r\n\r\n\t\tif ( _interpreter == null )\r\n\t\t\ttry {\r\n\t\t\t\t//KermetaUnit kermetaUnit = RunnerHelper.getKermetaUnitToExecute(Constants.TEST_COMP_BEHAVIOR_LAUNCHER);\r\n\t\t\t\tMap<String, Object> options = new HashMap<String, Object>();\r\n\t\t\t\t//options.put( InterpreterOptions.MERGE, false );\r\n\t\t\t\toptions.put( InterpreterOptions.CLEAN_AT_END, false);\r\n\t\t\t\t_interpreter = new Interpreter(Constants.TEST_COMP_BEHAVIOR_LAUNCHER, InterpreterMode.RUN, options);\r\n\t\t\t\t_interpreter.setEntryPoint(\"kermeta::compiler::Main\", \"main\");\r\n\t\t\t} catch (NotRegisteredURIException e) {\r\n\t\t\t} catch (URIMalformedException e) {\r\n\t\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * Once all the tests have been run, unload the program.\r\n\t * \r\n\t */\r\n\t@AfterClass\r\n\tstatic public void unsetInterpreter() {\r\n\t\tLoaderPlugin.getDefault().unload( Constants.TEST_COMP_BEHAVIOR_LAUNCHER );\r\n\t}\r\n    /*\r\n\t * \r\n\t * Ending static code\r\n\t *  \r\n\t */\r\n\t\r\n    /*\r\n     * \r\n     * Beginning dynamic code for each test case\r\n     * \r\n     */\r\n")
 uc.verifiedBy.each{ tc | 
				do
				var pre_suffix : String init tc.uri.replace("http://gforge.inria.fr/plugins/scmcvs/cvsweb.php/kermeta_projects/org.kermeta.compiler.tests/unit_test/", "").replace("/input/kermeta/?cvsroot=kermeta", "")
	
				var suffix : String init pre_suffix.replace("/", "_") 
_res.append("\r\n\tprivate String test_case_")
_res.append( suffix )
_res.append(" = \"")
_res.append( tc.name )
_res.append("\";\r\n\t\r\n\tprivate String input_")
_res.append( suffix )
_res.append(" = \"\";\r\n\t\r\n\tprivate String output_")
_res.append( suffix )
_res.append(" = \"\";\r\n\t\r\n\tprivate String expected_output_")
_res.append( suffix )
_res.append(" = \"\";\r\n\t\r\n\t@Before public void setParams_")
_res.append( suffix )
_res.append("() {\r\n\t\tString prefix = \"")
_res.append( pre_suffix )
_res.append("\";\r\n\t\tinput_")
_res.append( suffix )
_res.append(" = Constants.SOURCE_PATH + prefix + \"/\" + KCompilerConstants.INPUT_FOLDER + \"/kermeta/\" + use_case + \"_\" + test_case_")
_res.append( suffix )
_res.append(" + \".km\";\r\n\t\toutput_")
_res.append( suffix )
_res.append(" = Constants.SOURCE_PATH + prefix + \"/\" + KCompilerConstants.OUTPUT_FOLDER + \"/\" + use_case + \"_\" + test_case_")
_res.append( suffix )
_res.append(" + \".ecore\";\r\n\t\texpected_output_")
_res.append( suffix )
_res.append(" = Constants.SOURCE_PATH + prefix + \"/\" + KCompilerConstants.EXPECTED_OUTPUT_FOLDER +\"/ecore/\" + use_case + \"_\" + test_case_")
_res.append( suffix )
_res.append(" + \".ecore\";\r\n\t}\r\n\t\r\n\t@Test public void comp_package_test_")
_res.append( suffix )
_res.append("() {\r\n\t\trun(input_")
_res.append( suffix )
_res.append(", output_")
_res.append( suffix )
_res.append(", expected_output_")
_res.append( suffix )
_res.append(");\r\n\t}\r\n")
 end
	} 
_res.append("\t/*\r\n\t * \r\n\t * Ending dynamic code for each test case\r\n\t * \r\n\t */\r\n\t\r\n\t\r\n\t/*\r\n\t * \r\n\t * Beginning static code\r\n\t *  \r\n\t */\r\n\tprivate void run(String input, String output, String expected_output) {\r\n\t\ttry {\r\n\t\t\t/*\r\n\t\t\t * Setting the parameters.\r\n\t\t\t */\r\n\t\t\tString[] args = new String[3];\r\n\t\t\targs[0] = input;\r\n\t\t\targs[1] = \"\";//trace; path for the generated traceability file.\r\n\t\t\targs[2] = output;\r\n\t\t\t_interpreter.setParameters(args);\r\n\t\t\t\t\r\n\t\t\t/*\r\n\t\t\t * Start the interpreter.\r\n\t\t\t */\r\n\t   \t\t_interpreter.setStreams( new LocalIOConsole() );\r\n\t\t\t_interpreter.launch();\r\n\t\t\t\t\r\n\t\t\t/*\r\n\t\t\t * Assertion\r\n\t\t\t */\r\n\t\t\tAssert.assertTrue( compare(output, expected_output) );\r\n\t\t} catch (InitializationError e) {\r\n\t\t\tAssert.assertTrue(e.getErrorsAsString(), false);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean compare(String output, String expected_output) {\r\n\t\tboolean result = ! EMFCompareModelHelper.isDifferentAndSaveDiff(expected_output, output,  output + \"_diff.xmi\");\r\n\t\tif ( ! result )\r\n\t\t\tresult = DiffHelper.interpreteDiff( output + \"_diff.xmi\" );\r\n\t\treturn result;\r\n\t}\r\n    /*\r\n\t * \r\n\t * Ending static code\r\n\t *  \r\n\t */\r\n}")
result := _res.toString
end
}
