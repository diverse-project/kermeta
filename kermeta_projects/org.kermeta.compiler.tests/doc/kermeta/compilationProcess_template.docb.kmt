package org::kermeta::compiler::trek2docbook::template;
require kermeta
require "http://www.kermeta.org/trek"
using kermeta::standard
using kermeta::utils
using trek
class DOCBCompilationProcessTemplate{
operation generate():String is do
var _res: StringBuffer init StringBuffer.new
_res.append("<chapter>\r\n\t<title>Compilation Process</title>\r\n\t<section>\r\n\t\t<title id=\"kermeta2ecore.title.link\">Step 1: Kermeta to Ecore</title>\r\n\t\t<para>\r\n\t\t\tThe compilation process is divided in 2 steps: the first one consists in the translation of a Kermeta model into a Ecore model, the second one consists in the generation of the Java source code from the previous Ecore model.\r\n\t\t</para>\r\n\t</section>\r\n\t<section>\r\n\t\t<title id=\"kermeta2ecore.title.link\">Step 1: Kermeta to Ecore</title>\r\n\t\t<para>\r\n\t\t\tCurrently this implementation is divided in 2 steps: Km 2 Ecore structure (written in Java), Km 2 Ecore behavior (written in Kermeta and Java).\r\n\t\t</para>\r\n\t\t<para>\r\n\t\t\t\"Km 2 Ecore structure\" implements a visitor desing pattern and consists in the translation of each Kermeta concept to Ecore concept.\r\n\t\t\tThis step is implemented in \"fr.irisa.triskell.kermeta.io\" plugin, EcoreExporter.\r\n\t\t</para>\r\n\t\t<para>\r\n\t\t\t\"Km 2 Ecore behavior\" is written in Kermeta. This implementation is Aspect-Oriented, i.e.: we are using the aspect-oriented techniques in order to define how a concept is compiled.\r\n\t\t</para>\r\n\t\t<para>\r\n\t\t\tSome examples:</para>\r\n\t\t<para>\r\n\t\t\t<programlisting>aspect class ClassDefinition {\r\n\t\tmethod compile(context : Integer) : String is do\r\n\t\t\tresult := \"\"\r\n\t\t\t// Set the traceability\r\n\t\t\tself.ecoreProxy := CompileHelper.new.findEClassProxy(self)\r\n\t\t\t// Compile the owned elements\r\n\t\t\tself.eachOwnedElement{ o | o.compile(context) }\r\n\t\tend\r\n\t}</programlisting>\r\n\t\t\t\r\n\t\t\t<programlisting>aspect class ClassDefinition {\r\n\toperation eachOwnedElement(func : MultiplicityElement -> Object) : Void is do\r\n        self.ownedAttribute.each{ o |\r\n\t\t\tfunc(o.asType(Property))\r\n\t\t}\r\n\t\tself.ownedOperation.each{ o |\r\n\t\t\tfunc(o.asType(Operation))\r\n\t\t}\r\n\tend\t\r\n}</programlisting>\r\n\r\n\t\t<programlisting>aspect class Package {\r\n\treference ecoreProxy : EPackage\r\n\t}\r\n\t\r\n\taspect class ClassDefinition {\r\n\t\treference ecoreProxy : EClass\r\n\t}\r\n\t\r\n\taspect class Operation {\r\n\t\treference ecoreProxy : EOperation\r\n\t}</programlisting>\r\n\r\n\t\t</para>\r\n\t\t<para>\r\n\t\t\tThis technique has further advantages: the separation of concerns and the reutilisability of several aspects, i.e.: some aspects are grouped by usage like: \"containment discovering\", \"compile\" or \"traceability\".\r\n\t\t</para>\r\n\t</section>\r\n\t<section>\r\n\t\t<title id=\"ecore2java.title.link\">Step 2: Ecore to Java</title>\r\n\t\t<para>\r\n\t\t\tGeneration of a genmodel file from the Ecore file.\r\n\t\t\tThis generation is automatic and the genmodel is modified to customize and fix some parameters for the source code generation. This step is implemented in ?org.kermeta.compiler\" plugin.\r\n\t\t</para>\r\n\t\t<para>\r\n\t\t\tGeneration of the source code from the genmodel file thanks to the EMF generator abilities:\r\n\t\t\tEmf-model interfaces + implementation. This step is implemented in \"org.kermeta.compiler\" plugin.\r\n\t\t\tDuring this step, a Simk is used too, this model contains informations about the generation of Runners, Launchers and other static methods. A Java source code generation step is made to take in account this model, and also to generate the corresponding Java classes.\r\n\t\t</para>\r\n\t</section>\r\n</chapter>")
result := _res.toString
end
}
