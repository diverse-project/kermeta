@namespace(uri="http://metacore/metacore.ecore", prefix="metacore")
package metacore;

@namespace(uri="http://metacore_behavior/metacore.ecore", prefix="metacore_behavior")
package behavior {
  class Assignement extends Expression {
    val CallExpression[1] target;
    val Expression[1] value;
    attr structure.Boolean isCast;
  }

  abstract class Expression extends structure.Object {
  }

  abstract class CallExpression extends Expression {
    val Expression[*] parameters;
    attr structure.String name;
  }

  class SelfExpression extends Expression {
  }

  class Block extends Expression {
    val Expression[+] statement;
    val Rescue[*] rescueBlock;
  }

  class VariableDecl extends Expression {
    val Expression[1] initialization;
    attr structure.String identifier;
    val TypeReference type;
  }

  class TypeReference extends structure.MultiplicityElement {
  }

  class Loop extends Expression {
    val Expression initiatization;
    val Expression body;
    val Expression stopCondition;
  }

  class Conditionnal extends Expression {
    val Expression thenBody;
    val Expression elseBody;
    val Expression condition;
  }

  class CallVariable extends CallExpression {
  }

  class CallFeature extends CallExpression {
    val Expression target;
  }

  class CallSuperOperation extends CallExpression {
  }

  abstract class Literal extends Expression {
  }

  class IntegerLiteral extends Literal {
    attr structure.Integer value;
  }

  class StringLiteral extends Literal {
    attr structure.String value;
  }

  class BooleanLiteral extends Literal {
    attr structure.Boolean value;
  }

  class TypeLiteral extends Literal {
    val TypeReference[1] typeref;
  }

  class VoidLiteral extends Literal {
  }

  class EmptyExpression extends Expression {
  }

  class JavaStaticCall extends Expression {
    val Expression[*] parameters;
    attr structure.String jclass;
    attr structure.String jmethod;
  }

  class Raise extends Expression {
    val Expression[1] expression;
  }

  class Rescue extends structure.Object {
    val Expression[+] body;
    val TypeReference[1] exceptionType;
    attr structure.String exceptionName;
  }

  class LambdaExpression extends Expression {
    val LambdaParameter[*] parameters;
    val Expression body;
  }

  class LambdaParameter extends structure.Object {
    attr structure.String name;
    val TypeReference type;
  }

}

@namespace(uri="http://metacore_structure/metacore.ecore", prefix="metacore_structure")
package structure {
  datatype String : Element;

  datatype Boolean : Element;

  datatype Integer : Element;

  class Object extends Element {
    op Class getMetaClass();
    op Object container();
    op Boolean equals(Element element);
    op Element get(Property property);
    op void set(Property property, Element element);
    op Boolean isSet(Property property);
    op void unset(Property property);
    ref Tag[*]#object tag;
  }

  class Class extends Type {
    op Object create();
    derived ref Property[*] ownedAttribute;
    derived ref Operation[*] ownedOperation;
    derived ref Class[*] superClass;
    derived attr Boolean isAbstract = "false";
    ref ClassDefinition[1] classDefinition;
    val TypeVariableBinding[*] typeParamBinding;
  }

  class MultiplicityElement extends TypedElement {
    attr Boolean isOrdered = "false";
    attr Boolean isUnique = "true";
    attr Integer lower;
    attr UnlimitedNatural upper;
  }

  class Operation extends MultiplicityElement {
    val behavior.Expression body;
    ref Operation superOperation;
    attr Boolean isAbstract;
    ref Type[*] raisedException;
    val Parameter[*]#operation ownedParameter;
    ref ClassDefinition#ownedOperation owningClass;
    ref TypeVariable[*] typeParameter;
  }

  class Property extends MultiplicityElement {
    val behavior.Expression getterbody;
    val behavior.Expression setterbody;
    ref Property opposite;
    attr Boolean isReadOnly = "false";
    attr String default;
    attr Boolean isComposite = "false";
    attr Boolean isDerived = "false";
    attr Boolean isID;
    ref ClassDefinition#ownedAttributes owningClass;
  }

  abstract class DataType extends Type, TypeDefinition {
  }

  class Enumeration extends DataType {
    val EnumerationLiteral[*]#enumeration ownedLiteral;
  }

  class EnumerationLiteral extends NamedElement {
    transient ref Enumeration#ownedLiteral enumeration;
  }

  abstract class NamedElement extends Object {
    attr String name;
  }

  class Package extends NamedElement {
    val Package[*]#nestingPackage nestedPackage;
    transient ref Package#nestedPackage nestingPackage;
    attr String uri;
    val TypeDefinition[*] ownedTypeDefinition;
  }

  class Parameter extends MultiplicityElement {
    transient ref Operation#ownedParameter operation;
  }

  class PrimitiveType extends DataType, TypeContainer {
    ref Type instanceType;
  }

  abstract class TypedElement extends NamedElement, TypeContainer {
    ref Type type;
  }

  class Element {
  }

  datatype UnlimitedNatural : Element;

  class Factory extends Object {
    op Element createFromString(DataType dataType, String string);
    op String convertToString(DataType dataType, Element element);
    op Object create(Class metaClass);
    ref Package[1] ~package;
  }

  class Extent extends Element {
    op Boolean useContainment();
    op ReflectiveSequence objects();
  }

  class URIExtent extends Extent {
    op String contextURI();
    op String uri(Object object);
    op Object object(String uri);
  }

  abstract class Type extends NamedElement {
    op Boolean isInstance(Element element);
  }

  class Tag extends Object {
    ref Element[*] element;
    attr String name;
    attr String value;
    ref Object[+]#tag object;
  }

  class ReflectiveSequence extends ReflectiveCollection {
  }

  class ReflectiveCollection extends Element {
    ref Object object;
    ref Property property;
  }

  class TypeVariable extends Type, TypeContainer {
    ref Type supertype;
  }

  class SelfType extends Type {
  }

  class ClassDefinition extends TypeDefinition, TypeContainer {
    attr Boolean isAbstract;
    val Property[*]#owningClass ownedAttributes;
    val Operation[*]#owningClass ownedOperation;
    ref Type[*] superType;
    val TypeVariable[*] typeParameter;
  }

  class TypeVariableBinding extends Object, TypeContainer {
    ref TypeVariable[1] variable;
    ref Type[1] type;
  }

  class FunctionType extends Type, TypeContainer {
    ref Type left;
    ref Type right;
  }

  class ProductType extends Type, TypeContainer {
    ref Type[+] type;
  }

  class TypeDefinition extends NamedElement {
  }

  class VoidType extends Type {
  }

  abstract class TypeContainer extends Object {
    val Type[*] containedType;
  }

}

