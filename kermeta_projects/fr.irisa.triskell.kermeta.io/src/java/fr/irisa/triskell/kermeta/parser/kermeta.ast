// $Id: $

language Kermeta;
	
options { 
k=3; 
defaultErrorHandler=false;
}

//abstract abstractCompUnit : (annotations) compUnit (annotations) ;

// not ok : (annotations) added at the end of just below sequence - conflicts
sequence scompUnit : packageDecl importStmts usingStmts topLevelDecls  ;

abstract compUnit [entry] : scompUnit (postUnitAnnotations=annotations);

sequence packageDecl : preAnnotations=annotations "package" name=qualifiedID SEMI postAnnotations=annotations;

list qualifiedID : id1=ID (qidSeparator idn=ID)* ;
token qidSeparator : COL_COL ;

abstract stringLiteralOrQualifiedID : stringLiteralContainer | qualifiedID ;
sequence stringLiteralContainer : STRING_LITERAL ;

list annotations : annotation* ;
abstract annotation : tag | singleLineComment | multiLineComment; 

sequence tag : AT name=qualifiedID val=STRING_LITERAL ;
sequence singleLineComment : SINGLE_LINE_COMMENT ;
sequence multiLineComment : MULTI_LINE_COMMENT ;

//sequence annotation : AT source=stringLiteralOrQualifiedID LPAREN keyEqualsValueList RPAREN ;
//list keyEqualsValueList : kv1=keyEqualsValue (COMMA kvn=keyEqualsValue)* ;
//sequence keyEqualsValue : key=stringLiteralOrQualifiedID EQUALS value=stringLiteralOrQualifiedID ;

list importStmts : importStmt* ;
sequence importStmt : "require" uri=stringLiteralOrQualifiedID ;

list usingStmts : usingStmt* ;
sequence usingStmt : "using" name=qualifiedID ;

list topLevelDecls : topLevelDecl* ;

sequence topLevelDecl : preAnnotations=annotations annotableElement ;

abstract annotableElement : subPackageDecl | classDecl | enumDecl | dataTypeDecl; //| enumDecl | mapEntryDecl ;

sequence subPackageDecl : "package" name=ID LCURLY topLevelDecls RCURLY;

sequence classDecl :  (abstractModifier)? classKind name=ID (LT typeVarDecllst GT)? ("inherits" superTypes=typelst)? LCURLY classMemberDecls RCURLY postAnnotations=annotations; 
//(COLON instClassName=stringLiteralOrQualifiedID)? LCURLY classMemberDecls RCURLY ;
token classKind : "class" ; //| "interface" ;
token abstractModifier : "abstract" ;
list typelst : t1=type (COMMA tn=type)* ;
list typeVarDecllst : tv1=typeVarDecl (COMMA tvn=typeVarDecl)*;

sequence typeVarDecl : name=ID (COLON supertype=type)? ;
abstract type : basictype | functype | prodtype | voidType; // | selftype

sequence basictype :  name=qualifiedID (LT params=typelst GT)? ;
sequence prodtype : LSQUARE typelst RSQUARE ;
sequence functype : LT left=type MINUS_GT right=type GT;
//sequence selftype : "Self" ;
sequence voidType : "Void" ;

list classMemberDecls : classMemberDecl * ;
abstract classMemberDecl : annotation | operation | property; //attribute | reference | operation ;

//sequence attribute : MINUS modifiers typeRef name=ID (EQUALS defaultValueExpr)? SEMI ;

sequence property : propertyKind  (readOnlyModifier)? name=ID COLON typeRef (HASH oppositeName=ID)? (propertyBody)?;
//token referenceKind : MINUS_GT | LT_GT | GT_LT ;
token propertyKind : "attribute" | "reference" | "property" ;
token readOnlyModifier : "readonly" ;

sequence propertyBody : getterBody (setterBody)? ;

sequence getterBody : (annotations)? "getter" "is" getterbody = fExpression ;
sequence setterBody : (annotations)? "setter" "is" setterbody = fExpression ;

sequence operation : operationKind name=ID (LT typeVarDecllst GT)? LPAREN (params)? RPAREN (COLON typeRef)?  ("from" superSelection=qualifiedID)? ("raises" exceptions=typelst)? "is" operationBody;
token operationKind : "operation" | "method" ;

abstract operationBody : operationEmptyBody | operationExpressionBody ;
sequence operationExpressionBody : fExpression ;
sequence  operationEmptyBody : "abstract" ;

list params : p1=param (COMMA pn=param)*;
//sequence param : leadingAnnotations=annotations modifiers typeRef name=ID trailingAnnotations=annotations ;
sequence param : preAnnotations=annotations  name=ID COLON typeRef  postAnnotations=annotations ;

sequence typeRef : (collectionType)? reftype=type (multiplicity)? ;
token collectionType : "bag" | "set"| "seq" | "oset";

sequence multiplicity : LSQUARE (multiplicityExpr)? RSQUARE ;

sequence multiplicityExpr : lowerBound=simpleMultiplicityExpr (DOT_DOT upperBound=simpleMultiplicityExpr)? ;
token simpleMultiplicityExpr : STAR | PLUS | QMARK | INT_LITERAL ;

// "transient" means !serializable
sequence dataTypeDecl : "alias" name=ID COLON instanceClass=type SEMI ;

sequence enumDecl : "enumeration" name=ID LCURLY enumLiterals RCURLY ;
list enumLiterals : enumLiteral* ;
sequence enumLiteral : preAnnotations=annotations name=ID SEMI ; // (EQUALS val=INT_LITERAL)? postAnnotations=annotations 

//sequence mapEntryDecl : "mapentry" name=ID COLON key=typeRef MINUS_GT value=typeRef SEMI ;


//abstract fStatement : fBlock | fExpression | fLoop | fConditional | fRaiseException | fVariableDecl | fAssignement;

list fExpressionLst : fExpression* ;

sequence asingleExpression : fExpression ;
// an annotation is considered as an fExpression. In 
abstract fExpression : fAssignement ;
			
sequence fAssignement : preAnnotations=annotations expression=logicalExpression (assignementOp EQUALS newvalue=logicalExpression)? postAnnotations=annotations;
token assignementOp : COLON | QMARK ;

list logicalExpression : exp1=relationalExpression (logicalOp expn=relationalExpression )* ;
token logicalOp : "and" | "or" ;

sequence relationalExpression : left=additiveExpression (relationalOp right=additiveExpression )? ;
token relationalOp : EQEQ | NEQ | GT | LT | GTE | LTE ;

list additiveExpression : exp1=multiplicativeExpression ( additiveOp expn=multiplicativeExpression )* ;
token additiveOp : PLUS | MINUS ;

list multiplicativeExpression : exp1=unaryExpression (multiplicativeOp expn=unaryExpression )* ;
token multiplicativeOp : STAR | DIV ;

sequence unaryExpression : (unaryOp)? postfixExp ;
token unaryOp : "not" | MINUS ;

sequence postfixExp : target=primitiveExpression postfixlst ;

list postfixlst : postfix* ;
abstract postfix : callPostfix | lambdaPostfix | paramPostfix;

sequence callPostfix : DOT name=ID ;
sequence paramPostfix : LPAREN (parameters=actualParameterList)? RPAREN ;
list actualParameterList : p1=actualParameter (COMMA pn=actualParameter)* ;
sequence actualParameter : expression=fExpression ;
sequence lambdaPostfix : LCURLY params=lambdaPostfixParamLst PIPE expression=fExpressionLst RCURLY ;
list lambdaPostfixParamLst : p1=lambdaPostfixParam (COMMA pn=lambdaPostfixParam)* ;
sequence lambdaPostfixParam : name=ID;

// the indexer postfix should be added here


abstract primitiveExpression : fLiteral | parentExp | fSelfCall | fSuperCall | resultCall |
			fJavaStaticCall | fBlock | fConditional | fRaiseException | 
			fVariableDecl | fLambdaExpression | fLoop ;


sequence parentExp : LPAREN fExpression RPAREN ;

sequence fSelfCall : "self" ;
sequence fSuperCall : "super" ;
sequence resultCall : "result" ;

sequence fBlock : "do" annotations fExpressionLst fRescueLst "end" ;

sequence fLambdaExpression : "function" LCURLY params=fLambdaparamlst PIPE expression=fExpressionLst RCURLY ;
list fLambdaparamlst : p1=fLambdaparam (COMMA pn=fLambdaparam)* ;
sequence fLambdaparam : name=ID COLON typeRef ;

list fRescueLst : fRescue* ;
sequence fRescue : "rescue"  (LPAREN varName=ID COLON exTypeRef=typeRef RPAREN)?  rescstmts=fExpressionLst ;

sequence fLoop : "from" init=fExpression "until" condition=fExpression "loop" body=fExpressionLst "end" ;

sequence fConditional : "if" condition=fExpression "then" ifblock=fExpressionLst ("else" elseblock=fExpressionLst)? "end" ;

sequence fRaiseException : "raise" fExpression ;

sequence fVariableDecl : "var" name=ID COLON typeRef=typeRef ("init" init=fExpression)? ; 

sequence fJavaStaticCall : "extern" cname=qualifiedID DOT mname=ID LPAREN (parameters=actualParameterList)? RPAREN ;

abstract fLiteral : fStringLiteral | fBooleanLiteral | fIntegerLiteral | fVoidLiteral | fTypeOrVarLiteral;

sequence fBooleanLiteral : trueOrFalse ;
token trueOrFalse : "true" | "false" ;
sequence fIntegerLiteral : INT_LITERAL ;
sequence fStringLiteral : STRING_LITERAL ;
sequence fVoidLiteral : "void" ;

sequence fTypeOrVarLiteral : literal=type ; // this can be a variable a method or an attribute !!!!!!

