<?xml version="1.0" encoding="ASCII"?>
<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore">
  <ecore:EAnnotation source="ModellingUnit">
    <details key="require" value="primitive_types.kmt|"/>
    <details key="using" value="kermeta::exceptions|kermeta::standard|"/>
  </ecore:EAnnotation>
  <ecore:EPackage name="kermeta" nsURI="file:/C:/eclipse3.3/eclipse/workspace/fr.irisa.triskell.kermeta.framework/dist/standard/collections.ecore#/" nsPrefix="kermeta">
    <eSubpackages name="standard" nsURI="http://www.kermeta.org/kermeta/standard" nsPrefix="standard">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/**&#xD;&#xA; * Defines Collection types &#xD;&#xA; * &lt;img src=&quot;./figures/collections_view.png&quot;>&#xD;&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EDataType" name="kermeta::language::structure::Object" instanceClassName="java.lang.Object">
        <eAnnotations source="kermeta">
          <details key="alias" value="kermeta::language::structure::Object"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Collection" abstract="true">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xD;&#xA; * Collection is the root abstract class for all kermeta collections&#xD;&#xA; */"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eSuperTypes href="../language/structure.ecore#/1/language/structure/Object"/>
        <eOperations name="asBag">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Bag built from the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eTypeParameter="/1/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asSet">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Set built from the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eTypeParameter="/1/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asOrderedSet">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new OrderedSet built from the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asSequence">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Sequence built from the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="forAllCpl">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.forAll{x | do&#xA;&#x9;&#x9;&#x9;self.forAll{y | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;f(x, y)&#xA;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * To be written #####################################&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="f">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="G"/>
              <details key="2" value="kermeta::standard::Boolean"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="existsCpl">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.exists{x | do&#xA;&#x9;&#x9;&#x9;self.exists{y | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;f(x, y)&#xA;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * To be written #####################################&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="f">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="G"/>
              <details key="2" value="kermeta::standard::Boolean"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="add">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.add(self, element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Adds an element in the Collection (default implementation)&#xD;&#xA;  */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="remove">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G&#xA;&#x9;from elem := self.detect{e | do&#xA;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;end}&#xA;&#x9;until elem.equals(void)&#xA;&#x9;loop&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)&#xA;&#x9;&#x9;elem := self.detect{e | do&#xA;&#x9;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Removes all instances of element from the Collection, based on&#xD;&#xA;  * G.equals(Object) definition&#xD;&#xA;  */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.post">
            <details key="doesntContainsElementAnymore" value="not (contains(element))"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="clear">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.clear(self)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Removes all elements from the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="addAll">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;elements.each{element | do&#xA;&#x9;&#x9;&#x9;add(element)&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Adds all elements from the Collection elements in the current Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eParameters name="elements" eType="/1/standard/Collection"/>
        </eOperations>
        <eOperations name="contains">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := false&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until (it.isOff) or (result)&#xA;&#x9;loop&#xA;&#x9;&#x9;result := it.next.equals(element)&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a Boolean stating whether the Collection contains at least one&#xD;&#xA;  * instance of element, based on G.equals(elt : Object) definition&#xD;&#xA;  * Note: for checking whethera physical element is contained by the collection,&#xD;&#xA;  * make use of G.oid()&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="includes">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.contains(element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * OCL API alignement&#xD;&#xA;  * See Collection&lt;G>.contains(Object)&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="containsAll">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := true&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init elements.iterator&#xA;&#x9;until (it.isOff) or (not (result))&#xA;&#x9;loop&#xA;&#x9;&#x9;result := self.contains(it.next)&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns true if current Collection contains all elements of Collection elements&#xD;&#xA;  * See Collection&lt;G>.contains(Object)&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="elements" eType="/1/standard/Collection"/>
        </eOperations>
        <eOperations name="includesAll">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.containsAll(elements)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * OCL API alignement&#xD;&#xA;  * See Collection&lt;G>.containsAll(Collection&lt;G>)&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="elements" eType="/1/standard/Collection"/>
        </eOperations>
        <eOperations name="excludes">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := not (self.contains(element))&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns true if the Collection does not contain element&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="excludesAll">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := true&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init elements.iterator&#xA;&#x9;until (it.isOff) or (not (result))&#xA;&#x9;loop&#xA;&#x9;&#x9;result := not (self.contains(it.next))&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns true if the Collection contains no element of Collection elements&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="elements" eType="/1/standard/Collection"/>
        </eOperations>
        <eOperations name="size">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.size(self)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns the number of elements in the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
        </eOperations>
        <eOperations name="empty">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := (size) == (0)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a Boolean stating whether the Collection is empty&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
        </eOperations>
        <eOperations name="isEmpty">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.empty&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * OCL alignement API&#xD;&#xA;  * See Collection&lt;G>.empty()&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
        </eOperations>
        <eOperations name="isNotEmpty">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := not (self.empty)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * OCL alignement API&#xD;&#xA;  * Returns a Boolean stating whether the Collection contains at least&#xD;&#xA;  * one element &#xD;&#xA;  * See also Collection&lt;G>.contains(Object)&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
        </eOperations>
        <eOperations name="iterator">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Iterator&lt;G>.new&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.iterator(self, result)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns an Iterator on the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Iterator">
            <eTypeArguments eTypeParameter="/1/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="one">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if (size) == (0) then&#xA;&#x9;&#x9;result := void&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;result := it.next&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns an element from the Collection or void if the Collection is empty&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/Collection/G"/>
        </eOperations>
        <eOperations name="any">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if (size) == (0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::EmptyCollection.new&#xA;&#xA;&#x9;end&#xA;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;result := it.next&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns an element from the Collection&#xD;&#xA;  * Raises an EmptyCollection exception if the Collection is empty&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/Collection/G"/>
        </eOperations>
        <eOperations name="each">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;func(it.next)&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Runs function func on each element of the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eParameters name="func">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="alias Object : kermeta::language::structure::Object;"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="forAll">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var test : kermeta::standard::Boolean init true&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;test := (test) and (func(it.next))&#xA;&#x9;end&#xA;&#x9;result := test&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a Boolean stating whether no element of the Collection invalidates&#xD;&#xA;  * the condition specified by function func&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="func">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="exists">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var test : kermeta::standard::Boolean init false&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until (it.isOff) or ((test) != (false))&#xA;&#x9;loop&#xA;&#x9;&#x9;test := (test) or (func(it.next))&#xA;&#x9;end&#xA;&#x9;result := test&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a Boolean stating whether at least one element of the Collection&#xD;&#xA;  * validates the condition specified by function func&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="func">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="collect">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;T>.new&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;result.add(collector(it.next))&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Sequence which content corresponds to the result&#xD;&#xA;  * of running the collector function for each element of the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments/>
          </eGenericType>
          <eTypeParameters name="T"/>
          <eParameters name="collector">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="T"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="isUnique">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := true&#xA;&#x9;var s : kermeta::standard::Sequence&lt;T> init kermeta::standard::Sequence&lt;T>.new&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until (it.isOff) or (not (result))&#xA;&#x9;loop&#xA;&#x9;&#x9;var t : T init collector(it.next)&#xA;&#x9;&#x9;if s.contains(t) then&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;s.add(t)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a Boolean stating whether the the collector function evaluates to a&#xD;&#xA;  * different value for each element of the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eTypeParameters name="T"/>
          <eParameters name="collector">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="T"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="detect">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G&#xA;&#x9;result := void&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until (it.isOff) or (result.isNotEqual(void))&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if detector(elem) then&#xA;&#x9;&#x9;&#x9;result := elem&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns the first element of the Collection for which the detector function&#xD;&#xA;  * is not false&#xD;&#xA;  * Returns void if no elements is validated by the detector function&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/Collection/G"/>
          <eParameters name="detector">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="select">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if selector(elem) then&#xA;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Sequence composed of elements of the Collection that&#xD;&#xA;  * validate the selector function&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Collection/G"/>
          </eGenericType>
          <eParameters name="selector">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="reject">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.~select{elem | do&#xA;&#x9;&#x9;&#x9;not (rejector(elem))&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Sequence composed of elements of the Collection that&#xD;&#xA;  * do not validate the rejector function&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Collection/G"/>
          </eGenericType>
          <eParameters name="rejector">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="count">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.~select{e | do&#xA;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;end}.size&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns the number of instances of element in the Collection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="sum">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var res : G&#xA;&#x9;var tmp : kermeta::standard::Summable&lt;G>&#xA;&#x9;var o : kermeta::standard::Object&#xA;&#x9;o := self.one&#xA;&#x9;tmp ?= o&#xA;&#x9;result := void&#xA;&#x9;if tmp.isNotEqual(void) then&#xA;&#x9;&#x9;self.each{elem | do&#xA;&#x9;&#x9;&#x9;&#x9;o := elem&#xA;&#x9;&#x9;&#x9;&#x9;tmp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if tmp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;res := tmp.plus(res)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;result := res&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Sum the element if they are summable (ie implement '+' operator)&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/Collection/G"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Set" eSuperTypes="/1/standard/Collection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xD;&#xA; * A Set is a non-ordered collection that contains distinct elements&#xD;&#xA; * (with regards to the G.equals(Object) operation)&#xD;&#xA; */"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="add">
          <eAnnotations source="kermeta" references="/1/standard/Collection/add">
            <details key="body" value="do&#xA;&#x9;if not (self.contains(element)) then&#xA;&#x9;&#x9;super(element)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.add(G)&#xD;&#xA;  * Adds elt to the Set if it is not already contained by the&#xD;&#xA;  * Set, does nothing otherwise&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Set/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="remove">
          <eAnnotations source="kermeta" references="/1/standard/Collection/remove">
            <details key="body" value="do&#xA;&#x9;var elem : G init self.detect{e | do&#xA;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;end}&#xA;&#x9;if elem.isNotEqual(void) then&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.remove(G)&#xD;&#xA;  * Removes the element from the Set if it is contained by the Set&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Set/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="equals">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var isEqual : kermeta::standard::Boolean init false&#xA;&#x9;if not (element.isVoid) then&#xA;&#x9;&#x9;if kermeta::standard::Collection&lt;G>.isInstance(element) then&#xA;&#x9;&#x9;&#x9;var collection : kermeta::standard::Collection&lt;G>&#xA;&#x9;&#x9;&#x9;collection ?= element&#xA;&#x9;&#x9;&#x9;if (self.size) == (collection.size) then&#xA;&#x9;&#x9;&#x9;&#x9;var elem : G&#xA;&#x9;&#x9;&#x9;&#x9;var ok : kermeta::standard::Boolean init true&#xA;&#x9;&#x9;&#x9;&#x9;from var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;&#x9;&#x9;&#x9;until (it.isOff) or (not (ok))&#xA;&#x9;&#x9;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if not (collection.contains(elem)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ok := false&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;isEqual := ok&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;result := isEqual&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Object.equals(Object)&#xD;&#xA;  * Returns a Boolean stating whether the provided element is equal to&#xD;&#xA;  * current Set&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
            <references href="../language/structure.ecore#/1/language/structure/Object/equals"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="element">
            <eType xsi:type="ecore:EClass" href="../reflection/reflection.ecore#/1/reflection/Object"/>
          </eParameters>
        </eOperations>
        <eOperations name="union">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.addAll(elements)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Set corresponding to the union of the Set elements&#xD;&#xA;  * with the current Set&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
          <eParameters name="elements" eType="/1/standard/Set"/>
        </eOperations>
        <eOperations name="unionWithBag">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Bag&lt;G>.new&#xA;&#x9;result := addAll(self)&#xA;&#x9;result := addAll(elements)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Bag corresponding to the union of the Bag elements&#xD;&#xA;  * with the current Set&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
          <eParameters name="elements" eType="/1/standard/Bag"/>
        </eOperations>
        <eOperations name="intersection">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;G>.new&#xA;&#x9;var elem : G&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if elements.contains(elem) then&#xA;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Set corresponding to the intersection of the Set elements&#xD;&#xA;  * with the current Set&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
          <eParameters name="elements" eType="/1/standard/Collection"/>
        </eOperations>
        <eOperations name="minus">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;G>.new&#xA;&#x9;var elem : G&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if not (elements.contains(elem)) then&#xA;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Set corresponding to the difference between the&#xD;&#xA;  * current Set and the Set elements, ie all elements contained by &#xD;&#xA;  * the current Set that do not appear in the elements Set &#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
          <eParameters name="elements" eType="/1/standard/Set"/>
        </eOperations>
        <eOperations name="asSet">
          <eAnnotations source="kermeta" references="/1/standard/Collection/asSet">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Set&lt;G> init kermeta::standard::Set&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.asSet()&#xD;&#xA;  * Returns a new Set composed of all elements of current Set&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asOrderedSet">
          <eAnnotations source="kermeta" references="/1/standard/Collection/asOrderedSet">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::OrderedSet&lt;G> init kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.asOrderedSet()&#xD;&#xA;  * Returns a new OrderedSet that contains all elements of current Set&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asBag">
          <eAnnotations source="kermeta" references="/1/standard/Collection/asBag">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Bag&lt;G> init kermeta::standard::Bag&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.asBag()&#xD;&#xA;  * Returns a new Bag composed of all elements of current Set&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asSequence">
          <eAnnotations source="kermeta" references="/1/standard/Collection/asSequence">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Sequence&lt;G> init kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.asSequence()&#xD;&#xA;  * Returns a new Sequence composed of all elements of current Set&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="symmetricDifference">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var res : kermeta::standard::Set&lt;G> init s.minus(self)&#xA;&#x9;result := self.minus(s).addAll(res)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Set which contents corresponds to the symmetric&#xD;&#xA;  * difference between current Set and Set s, ie all elements of&#xD;&#xA;  * each Set that do not appear in the other one&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
          <eParameters name="s" eType="/1/standard/Set"/>
        </eOperations>
        <eOperations name="flatten">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var res : kermeta::standard::Set&lt;kermeta::standard::Object> init kermeta::standard::Set&lt;kermeta::standard::Object>.new&#xA;&#x9;if G.isKindOf(kermeta::standard::Collection&lt;kermeta::standard::Object>) then&#xA;&#x9;&#x9;var col : kermeta::standard::Collection&lt;kermeta::standard::Object>&#xA;&#x9;&#x9;var o : kermeta::standard::Object&#xA;&#x9;&#x9;self.each{e | do&#xA;&#x9;&#x9;&#x9;&#x9;o := e&#xA;&#x9;&#x9;&#x9;&#x9;col ?= o&#xA;&#x9;&#x9;&#x9;&#x9;res.addAll(col)&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;result := res&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Set which content includes all non-Collection elements&#xD;&#xA;  * of the current Set, and, for each Collection element of the current&#xD;&#xA;  * Set, as many elements as the Collection contains&#xD;&#xA;  * Duplicates are removed&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eClassifier="/1/standard/kermeta%3A%3Alanguage%3A%3Astructure%3A%3AObject"/>
          </eGenericType>
        </eOperations>
        <eOperations name="sortedBy">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := quickSort(self.asOrderedSet, comparator)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a ordered set of the bag elements sorted using the given comparator.&#xD;&#xA;  * The comparator must return :&lt;ul>&#xD;&#xA;  *   &lt;li>+1 if the second &lt;G> element is greater than the first&lt;/li> &#xD;&#xA;  *   &lt;li>0 if the second &lt;G> element equals the first&lt;/li> &#xD;&#xA;  *   &lt;li>-1 if the second &lt;G> element is lower than the first&lt;/li> &#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
          <eParameters name="comparator">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="G"/>
              <details key="2" value="kermeta::standard::Integer"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="quickSort">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var less : kermeta::standard::OrderedSet&lt;G> init kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;var pivotList : kermeta::standard::OrderedSet&lt;G> init kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;var greater : kermeta::standard::OrderedSet&lt;G> init kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;if (q.size) &lt;= (1) then&#xA;&#x9;&#x9;result := q&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var pivot : G init q.one&#xA;&#x9;&#x9;q.each{x | do&#xA;&#x9;&#x9;&#x9;&#x9;if (comparator(x, pivot)) == (1) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;less.add(x)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;if (comparator(x, pivot)) == (0) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;pivotList.add(x)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;if (comparator(x, pivot)) == (1.uminus) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;greater.add(x)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;result := concatenate(quickSort(less, comparator), pivotList, quickSort(greater, comparator))&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Recursive sort of the given (ordered) set using the given comparator.&#xD;&#xA;  * The comparator must return :&lt;ul>&#xD;&#xA;  *   &lt;li>+1 if the second &lt;G> element is greater than the first&lt;/li> &#xD;&#xA;  *   &lt;li>0 if the second &lt;G> element equals the first&lt;/li> &#xD;&#xA;  *   &lt;li>-1 if the second &lt;G> element is lower than the first&lt;/li> &#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
          <eParameters name="q" eType="/1/standard/OrderedSet"/>
          <eParameters name="comparator">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="G"/>
              <details key="2" value="kermeta::standard::Integer"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="concatenate">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;result.addAll(less)&#xA;&#x9;result.addAll(pivot)&#xA;&#x9;result.addAll(greater)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Internal concatenation tool for recursive 'quickSort()' method&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/Set/G"/>
          </eGenericType>
          <eParameters name="less" eType="/1/standard/OrderedSet"/>
          <eParameters name="pivot" eType="/1/standard/OrderedSet"/>
          <eParameters name="greater" eType="/1/standard/OrderedSet"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Bag" eSuperTypes="/1/standard/Collection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xD;&#xA; * Bag is a concrete non-ordered Collection allowing duplicates&#xD;&#xA; */"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="equals">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var isEqual : kermeta::standard::Boolean init false&#xA;&#x9;if not (element.isVoid) then&#xA;&#x9;&#x9;if kermeta::standard::Collection&lt;G>.isInstance(element) then&#xA;&#x9;&#x9;&#x9;var collection : kermeta::standard::Bag&lt;G>&#xA;&#x9;&#x9;&#x9;collection ?= element&#xA;&#x9;&#x9;&#x9;var selfAsSet : kermeta::standard::Set&lt;G> init self.asSet&#xA;&#x9;&#x9;&#x9;isEqual := selfAsSet.equals(collection.asSet)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;result := isEqual&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Object.equals(elt : Object)&#xD;&#xA;  * Returns a Boolean stating whether the provided element is equal to&#xD;&#xA;  * current Bag&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
            <references href="../language/structure.ecore#/1/language/structure/Object/equals"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="element">
            <eType xsi:type="ecore:EClass" href="../reflection/reflection.ecore#/1/reflection/Object"/>
          </eParameters>
        </eOperations>
        <eOperations name="union">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Bag&lt;G>.new&#xA;&#x9;result := addAll(self)&#xA;&#x9;result := addAll(elements)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Bag corresponding to the union of elements and&#xD;&#xA;  * current Bag&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="elements" eType="/1/standard/Collection"/>
        </eOperations>
        <eOperations name="intersection">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Bag&lt;G>.new&#xA;&#x9;var elem : G&#xA;&#x9;var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;from it&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if elements.contains(elem) then&#xA;&#x9;&#x9;&#x9;if (self.count(elem)) &lt;= (elements.count(elem)) then&#xA;&#x9;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;&#x9;it := elements.iterator&#xA;&#x9;from it&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if self.contains(elem) then&#xA;&#x9;&#x9;&#x9;if (elements.count(elem)) &lt; (self.count(elem)) then&#xA;&#x9;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Bag corresponding to the intersection of elements&#xD;&#xA;  * and the Bag&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="elements" eType="/1/standard/Bag"/>
        </eOperations>
        <eOperations name="intersectionWithSet">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;G>.new&#xA;&#x9;var elem : G&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init elements.iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if self.contains(elem) then&#xA;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Set corresponding to the intersection of a Set of&#xD;&#xA;  * elements and the Bag&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="elements" eType="/1/standard/Set"/>
        </eOperations>
        <eOperations name="removeFromOid">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G init self.detect{e | do&#xA;&#x9;&#x9;&#x9;(e.oid) == (elementOid)&#xA;&#x9;&#x9;end}&#xA;&#x9;if elem.isNotEqual(void) then&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Removes the element identified by the provided Oid from the Bag&#xD;&#xA;  */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.post">
            <details key="doesntContainsElementAnymore" value="not (exists{e | do&#xA;&#x9;&#x9;(e.oid) == (elementOid)&#xA;&#x9;end})"/>
          </eAnnotations>
          <eParameters name="elementOid">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
        </eOperations>
        <eOperations name="removeOne">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G init self.detect{e | do&#xA;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;end}&#xA;&#x9;if elem.isNotEqual(void) then&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Removes one instance of element from the Bag&#xD;&#xA;  */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Bag/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="asSet">
          <eAnnotations source="kermeta" references="/1/standard/Collection/asSet">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Set&lt;G> init kermeta::standard::Set&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.asSet()&#xD;&#xA;  * Returns a new Set containing elements of the Bag without duplicates&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Set">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asOrderedSet">
          <eAnnotations source="kermeta" references="/1/standard/Collection/asOrderedSet">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::OrderedSet&lt;G> init kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.asOrderedSet()&#xD;&#xA;  * Returns a new OrderedSet containing elements of the Bag without duplicates&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asBag">
          <eAnnotations source="kermeta" references="/1/standard/Collection/asBag">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Bag&lt;G> init kermeta::standard::Bag&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.asBag()&#xD;&#xA;  * Returns a new Bag containing all elements of current Bag &#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asSequence">
          <eAnnotations source="kermeta" references="/1/standard/Collection/asSequence">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Sequence&lt;G> init kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Collection&lt;G>.asSequence()&#xD;&#xA;  * Returns a new Sequence containing all elements of current Bag&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="including">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Bag&lt;G> init kermeta::standard::Bag&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;s.add(object)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Bag which content includes the content of the&#xD;&#xA;  * current Bag and the element object&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="object">
            <eGenericType eTypeParameter="/1/standard/Bag/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="excluding">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Bag&lt;G> init kermeta::standard::Bag&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;s.remove(object)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Bag which content includes the content of the&#xD;&#xA;  * current Bag from which all instances of object have been&#xD;&#xA;  * removed&#xD;&#xA;   */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="object">
            <eGenericType eTypeParameter="/1/standard/Bag/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="flatten">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var res : kermeta::standard::Bag&lt;kermeta::standard::Object> init kermeta::standard::Bag&lt;kermeta::standard::Object>.new&#xA;&#x9;if G.isKindOf(kermeta::standard::Collection&lt;kermeta::standard::Object>) then&#xA;&#x9;&#x9;var col : kermeta::standard::Collection&lt;kermeta::standard::Object>&#xA;&#x9;&#x9;var o : kermeta::standard::Object&#xA;&#x9;&#x9;self.each{e | do&#xA;&#x9;&#x9;&#x9;&#x9;o := e&#xA;&#x9;&#x9;&#x9;&#x9;col ?= o&#xA;&#x9;&#x9;&#x9;&#x9;res.addAll(col)&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;result := res&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a new Bag which content includes all non-Collection elements&#xD;&#xA;  * of the current Set, and, for each Collection element of the current&#xD;&#xA;  * Bag, as many elements as the Collection contains&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Bag">
            <eTypeArguments eClassifier="/1/standard/kermeta%3A%3Alanguage%3A%3Astructure%3A%3AObject"/>
          </eGenericType>
        </eOperations>
        <eOperations name="sortedBy">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := quickSort(self.asSequence, comparator)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns a sequence of the bag elements sorted using the given comparator.&#xD;&#xA;  * The comparator must return :&lt;ul>&#xD;&#xA;  *   &lt;li>+1 if the second &lt;G> element is greater than the first&lt;/li> &#xD;&#xA;  *   &lt;li>0 if the second &lt;G> element equals the first&lt;/li> &#xD;&#xA;  *   &lt;li>-1 if the second &lt;G> element is lower than the first&lt;/li> &#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="comparator">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="G"/>
              <details key="2" value="kermeta::standard::Integer"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="quickSort">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var less : kermeta::standard::Sequence&lt;G> init kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;var pivotList : kermeta::standard::Sequence&lt;G> init kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;var greater : kermeta::standard::Sequence&lt;G> init kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;if (q.size) &lt;= (1) then&#xA;&#x9;&#x9;result := q&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var pivot : G init q.one&#xA;&#x9;&#x9;q.each{x | do&#xA;&#x9;&#x9;&#x9;&#x9;if (comparator(x, pivot)) == (1) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;less.add(x)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;if (comparator(x, pivot)) == (0) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;pivotList.add(x)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;if (comparator(x, pivot)) == (1.uminus) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;greater.add(x)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;result := concatenate(quickSort(less, comparator), pivotList, quickSort(greater, comparator))&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Recursive sort of the given sequence using the given comparator.&#xD;&#xA;  * The comparator must return :&lt;ul>&#xD;&#xA;  *   &lt;li>+1 if the second &lt;G> element is greater than the first&lt;/li> &#xD;&#xA;  *   &lt;li>0 if the second &lt;G> element equals the first&lt;/li> &#xD;&#xA;  *   &lt;li>-1 if the second &lt;G> element is lower than the first&lt;/li> &#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="q" eType="/1/standard/Sequence"/>
          <eParameters name="comparator">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="G"/>
              <details key="2" value="kermeta::standard::Integer"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../Standard.ecore#/1/_KermetaSpecialTypesAlias_"/>
          </eParameters>
        </eOperations>
        <eOperations name="concatenate">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;result.addAll(less)&#xA;&#x9;result.addAll(pivot)&#xA;&#x9;result.addAll(greater)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Internal concatenation tool for recursive 'quickSort()' method&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="less" eType="/1/standard/Sequence"/>
          <eParameters name="pivot" eType="/1/standard/Sequence"/>
          <eParameters name="greater" eType="/1/standard/Sequence"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="OrderedCollection" abstract="true" eSuperTypes="/1/standard/Collection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xD;&#xA; * An OrderedCollection is the root abstract class for all ordered Collections.&#xD;&#xA; */"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="addAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((index) &lt; (0)) or ((index) > (size)) then&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.addAt(self, index, element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Adds element in the OrderedCollection at rank index&#xD;&#xA;  * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xD;&#xA;  * larger than the size of the OrderedCollection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eParameters name="index">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/OrderedCollection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="removeAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((index) &lt; (0)) or ((index) > ((size) - (1))) then&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.removeAt(self, index)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Removes the element at rank index from the OrderedCollection&#xD;&#xA;  * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xD;&#xA;  * larger than the size of the OrderedCollection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eParameters name="index">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
        </eOperations>
        <eOperations name="elementAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((index) &lt; (0)) or ((index) > ((size) - (1))) then&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.elementAt(self, index)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns the element at rank index in the OrderedCollection&#xD;&#xA;  * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xD;&#xA;  * larger than the size of the OrderedCollection&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/OrderedCollection/G"/>
          <eParameters name="index">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
        </eOperations>
        <eOperations name="first">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if (size) == (0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::EmptyCollection.new&#xA;&#xA;&#x9;end&#xA;&#x9;result := elementAt(0)&#xA;end"/>
            <details key="documentation" value="/** &#xD;&#xA;  * Returns the first element in the OrderedCollection&#xD;&#xA;  * Raises an EmptyCollection exception if the OrderedCollection is empty&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/OrderedCollection/G"/>
        </eOperations>
        <eOperations name="last">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if (size) == (0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::EmptyCollection.new&#xA;&#xA;&#x9;end&#xA;&#x9;result := elementAt((size) - (1))&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns the last element in the OrderedCollection&#xD;&#xA;  * Raises an EmptyCollection exception if the OrderedCollection is empty&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/OrderedCollection/G"/>
        </eOperations>
        <eOperations name="equals">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var isEqual : kermeta::standard::Boolean init false&#xA;&#x9;if not (element.isVoid) then&#xA;&#x9;&#x9;if kermeta::standard::OrderedCollection&lt;G>.isInstance(element) then&#xA;&#x9;&#x9;&#x9;var collection : kermeta::standard::Collection&lt;G>&#xA;&#x9;&#x9;&#x9;collection ?= element&#xA;&#x9;&#x9;&#x9;if (self.size) == (collection.size) then&#xA;&#x9;&#x9;&#x9;&#x9;var selfIterator : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;&#x9;&#x9;&#x9;var collectionIterator : kermeta::standard::Iterator&lt;G> init collection.iterator&#xA;&#x9;&#x9;&#x9;&#x9;var difference : kermeta::standard::Boolean init false&#xA;&#x9;&#x9;&#x9;&#x9;from void&#xA;&#x9;&#x9;&#x9;&#x9;until ((selfIterator.isOff) or (collectionIterator.isOff)) or (difference)&#xA;&#x9;&#x9;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if not (selfIterator.next.equals(collectionIterator.next)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;difference := true&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;isEqual := not (difference)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;result := isEqual&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides Object.equals(Object)&#xD;&#xA;  * Returns a Boolean stating whether the provided element is equal to&#xD;&#xA;  * current OrderedCollection&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
            <references href="../language/structure.ecore#/1/language/structure/Object/equals"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="element">
            <eType xsi:type="ecore:EClass" href="../reflection/reflection.ecore#/1/reflection/Object"/>
          </eParameters>
        </eOperations>
        <eOperations name="indexOf">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if (size) == (0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::EmptyCollection.new&#xA;&#xA;&#x9;end&#xA;&#x9;var i : kermeta::standard::Integer init 0&#xA;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;var found : kermeta::standard::Boolean init false&#xA;&#x9;from found&#xA;&#x9;until (found) or (it.isOff)&#xA;&#x9;loop&#xA;&#x9;&#x9;if element.equals(it.next) then&#xA;&#x9;&#x9;&#x9;found := true&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;i := (i) + (1)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;&#x9;if found then&#xA;&#x9;&#x9;result := i&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result := 1.uminus&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** &#xD;&#xA;  * Returns the index of the first instance of element in the OrderedCollection&#xD;&#xA;  * or -1 if the element is not contained by the OrderedCollection&#xD;&#xA;  * Raises an EmptyCollection exception if the OrderedCollection is empty&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/OrderedCollection/G"/>
          </eParameters>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="OrderedSet" eSuperTypes="/1/standard/Set /1/standard/OrderedCollection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xD;&#xA; * An OrderedSet is a Set that contained ordered distinct elements&#xD;&#xA; */"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="add" ordered="false">
          <eAnnotations source="kermeta" references="/1/standard/Set/add">
            <details key="body" value="do&#xA;&#x9;super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * See Set&lt;G>.add(G)&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::Set"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="addAt">
          <eAnnotations source="kermeta" references="/1/standard/OrderedCollection/addAt">
            <details key="body" value="do&#xA;&#x9;if not (self.contains(element)) then&#xA;&#x9;&#x9;super(index, element)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides OrderedCollection&lt;G>.addAt(Integer, G)&#xD;&#xA;  * Adds element in the OrderedSet at rank index if the ordered set does&#xD;&#xA;  * not already contain the element, does nothing otherwise&#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::OrderedCollection"/>
          </eAnnotations>
          <eParameters name="index">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="equals">
          <eAnnotations source="kermeta" references="/1/standard/OrderedCollection/equals">
            <details key="body" value="do&#xA;&#x9;result := super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * See OrderedCollection&lt;G>.equals(Object) &#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::OrderedCollection"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="element">
            <eType xsi:type="ecore:EClass" href="../reflection/reflection.ecore#/1/reflection/Object"/>
          </eParameters>
        </eOperations>
        <eOperations name="subSet">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;if (((min) >= (0)) and ((max) &lt;= (self.size))) and ((min) &lt;= (max)) then&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;var i : kermeta::standard::Integer init 0&#xA;&#x9;&#x9;from i&#xA;&#x9;&#x9;until (i) == (min)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;it.next&#xA;&#x9;&#x9;&#x9;i := (i) + (1)&#xA;&#x9;&#x9;end&#xA;&#x9;&#x9;from i&#xA;&#x9;&#x9;until (i) == ((max) + (1))&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result.add(it.next)&#xA;&#x9;&#x9;&#x9;i := (i) + (1)&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Builds and returns a new OrderedSet composed of elements of current ordered&#xD;&#xA;  * set from rank min to rank max (order is respected)&#xD;&#xA;  * Raises IndexOutOfBound exception if min is negative, max is larger than &#xD;&#xA;  * the size of the ordered set or min is larger than max&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/OrderedSet/G"/>
          </eGenericType>
          <eParameters name="min">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
          <eParameters name="max">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
        </eOperations>
        <eOperations name="append">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.add(element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Builds and returns a new OrderedSet from current one with element&#xD;&#xA;  * inserted in head&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/OrderedSet/G"/>
          </eGenericType>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="preppend">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;result.add(element)&#xA;&#x9;result.addAll(self)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Builds and returns a new OrderedSet from current one with element&#xD;&#xA;  * inserted in tail&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/OrderedSet/G"/>
          </eGenericType>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="insertAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.addAt(index, subject)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Builds and returns a new OrderedSet from current one with element&#xD;&#xA;  * inserted at rank index&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/1/standard/OrderedSet/G"/>
          </eGenericType>
          <eParameters name="index">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
          <eParameters name="subject">
            <eGenericType eTypeParameter="/1/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="at">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((index) >= (0)) and ((index) &lt;= (self.size)) then&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;from var i : kermeta::standard::Integer init 1.uminus&#xA;&#x9;&#x9;until (i) == (index)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result := it.next&#xA;&#x9;&#x9;&#x9;i := (i) + (1)&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns element at rank index in the sequence&#xD;&#xA;  * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xD;&#xA;  * larger than the size of the OrderedSet&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/OrderedSet/G"/>
          <eParameters name="index">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Sequence" eSuperTypes="/1/standard/Bag /1/standard/OrderedCollection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xD;&#xA; * A Sequence is an OrderedCollection of elements allowing duplicates&#xD;&#xA; */"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="equals">
          <eAnnotations source="kermeta" references="/1/standard/OrderedCollection/equals">
            <details key="body" value="do&#xA;&#x9;result := super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Overrides OrderedCollection&lt;G>.equals(Object)&#xD;&#xA;  * Returns a Boolean stating whether the provided element is equal to&#xD;&#xA;  * current Sequence &#xD;&#xA;  */"/>
            <details key="superOperation" value="kermeta::standard::OrderedCollection"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
          <eParameters name="element">
            <eType xsi:type="ecore:EClass" href="../reflection/reflection.ecore#/1/reflection/Object"/>
          </eParameters>
        </eOperations>
        <eOperations name="subSequence">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;if (((min) >= (0)) and ((max) &lt;= (self.size))) and ((min) &lt;= (max)) then&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;var i : kermeta::standard::Integer init 0&#xA;&#x9;&#x9;from i&#xA;&#x9;&#x9;until (i) == (min)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;it.next&#xA;&#x9;&#x9;&#x9;i := (i) + (1)&#xA;&#x9;&#x9;end&#xA;&#x9;&#x9;from i&#xA;&#x9;&#x9;until (i) == ((max) + (1))&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result.add(it.next)&#xA;&#x9;&#x9;&#x9;i := (i) + (1)&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Builds and returns a new Sequence composed of elements of current sequence&#xD;&#xA;  * from rank min to rank max (order is respected)&#xD;&#xA;  * Raises IndexOutOfBound exception if min is negative, max is larger than &#xD;&#xA;  * the size of the sequence or min is larger than max&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Sequence/G"/>
          </eGenericType>
          <eParameters name="min">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
          <eParameters name="max">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
        </eOperations>
        <eOperations name="append">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.add(element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Builds and returns a new Sequence from current one with element&#xD;&#xA;  * inserted in head&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Sequence/G"/>
          </eGenericType>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Sequence/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="preppend">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;result.add(element)&#xA;&#x9;result.addAll(self)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Builds and returns a new Sequence from current one with element&#xD;&#xA;  * inserted in tail&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Sequence/G"/>
          </eGenericType>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Sequence/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="insertAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.addAt(index, element)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Builds and returns a new Sequence from current one with element&#xD;&#xA;  * inserted at rank index&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eClassifier="/1/standard/Sequence">
            <eTypeArguments eTypeParameter="/1/standard/Sequence/G"/>
          </eGenericType>
          <eParameters name="index">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
          <eParameters name="element">
            <eGenericType eTypeParameter="/1/standard/Sequence/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="at">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((index) >= (0)) and ((index) &lt;= (self.size)) then&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;from var i : kermeta::standard::Integer init 1.uminus&#xA;&#x9;&#x9;until (i) == (index)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result := it.next&#xA;&#x9;&#x9;&#x9;i := (i) + (1)&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns element at rank index in the sequence&#xD;&#xA;  * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xD;&#xA;  * larger than the size of the Sequence&#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/Sequence/G"/>
          <eParameters name="index">
            <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Integer"/>
          </eParameters>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Iterator">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xD;&#xA; * Iterator to be used with Collection&#xD;&#xA; * See also Collection&lt;G>.getIterator()&#xD;&#xA; */"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eSuperTypes href="../language/structure.ecore#/1/language/structure/Object"/>
        <eOperations name="isOff">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := not (hasNext)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns true if the iterator is on the last element&#xD;&#xA;  * i.e. returns not self.hasNext()&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
        </eOperations>
        <eOperations name="hasNext">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Iterator.hasNext(self)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns true if the iterator has a next element&#xD;&#xA;  */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="primitive_types.ecore#/1/standard/Boolean"/>
        </eOperations>
        <eOperations name="next">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if not (hasNext) then&#xA;&#x9;&#x9;raise kermeta::exceptions::IteratorIsOff.new&#xA;&#xA;&#x9;end&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Iterator.next(self)&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;  * Returns the next element of the iterator&#xD;&#xA;  * Raises IteratorIsOff exception in case the iterator is on the last element &#xD;&#xA;  */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/1/standard/Iterator/G"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
  </ecore:EPackage>
  <ecore:EAnnotation source="dependentResource">
    <references href="primitive_types.ecore#/0"/>
    <references href="primitive_types.ecore#/1"/>
    <references href="../Standard.ecore#/0"/>
    <references href="../Standard.ecore#/1"/>
    <references href="../language/behavior.ecore#/0"/>
    <references href="../language/behavior.ecore#/1"/>
    <references href="../language/structure.ecore#/0"/>
    <references href="../language/structure.ecore#/1"/>
    <references href="../reflection/reflection.ecore#/0"/>
    <references href="../reflection/reflection.ecore#/1"/>
    <references href="../reflection/reflection.ecore#/2"/>
    <references href="../persistence/resource.ecore#/0"/>
    <references href="../persistence/resource.ecore#/1"/>
    <references href="../persistence/resource.ecore#/2"/>
    <references href="../language/reflective_collections.ecore#/0"/>
    <references href="../language/reflective_collections.ecore#/1"/>
    <references href="../language/reflective_collections.ecore#/2"/>
    <references href="../kunit/kunit.ecore#/0"/>
    <references href="../kunit/kunit.ecore#/1"/>
    <references href="../kunit/kunit.ecore#/2"/>
    <references href="../kunit/assert.ecore#/0"/>
    <references href="../kunit/assert.ecore#/1"/>
    <references href="../utils/utils.ecore#/0"/>
    <references href="../utils/utils.ecore#/1"/>
    <references href="../utils/StringBuffer.ecore#/0"/>
    <references href="../utils/StringBuffer.ecore#/1"/>
    <references href="../utils/hashtable.ecore#/0"/>
    <references href="../utils/hashtable.ecore#/1"/>
    <references href="../utils/stack.ecore#/0"/>
    <references href="../utils/stack.ecore#/1"/>
    <references href="../io/std_io.ecore#/0"/>
    <references href="../io/std_io.ecore#/1"/>
    <references href="../io/std_io.ecore#/2"/>
    <references href="../io/file_io.ecore#/0"/>
    <references href="../io/file_io.ecore#/1"/>
    <references href="../exceptions/exceptions.ecore#/0"/>
    <references href="../exceptions/exceptions.ecore#/1"/>
    <references href="../exceptions/exceptions.ecore#/2"/>
    <references href="../language/dynamic_expression.ecore#/0"/>
    <references href="../language/dynamic_expression.ecore#/1"/>
    <references href="../language/dynamic_expression.ecore#/2"/>
    <references href="java.ecore#/0"/>
    <references href="java.ecore#/1"/>
    <references href="java.ecore#/2"/>
    <references href="../ecore/ecore_compatibility.ecore#/0"/>
    <references href="../ecore/ecore_compatibility.ecore#/1"/>
    <references href="../ecore/ecore_compatibility.ecore#/2"/>
  </ecore:EAnnotation>
</xmi:XMI>
