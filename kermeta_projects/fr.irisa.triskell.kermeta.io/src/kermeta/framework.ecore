<?xml version="1.0" encoding="ASCII"?>
<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore">
  <ecore:EAnnotation source="ModelingUnit">
    <details key="using" value="kermeta::kunit|kermeta::standard|kermeta::utils|kermeta|kermeta::language::structure|kermeta::language::behavior|kermeta::exceptions|kermeta::persistence|kermeta::xmltype|kermeta::io|kermeta::interpreter|kermeta::language|kermeta::ecore|"/>
  </ecore:EAnnotation>
  <ecore:EAnnotation source="kermeta">
    <details key="executable" value="true"/>
  </ecore:EAnnotation>
  <ecore:EPackage name="kermeta" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta" nsPrefix="kermeta">
    <eAnnotations source="kermeta">
      <details key="ecore" value="true"/>
      <details key="documentation" value="/**&#xA; * The root package. See the other packages if you want to browse the classes of Kermeta api.&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/kermeta_packages.png&quot;/>&#xA; */"/>
    </eAnnotations>
    <eClassifiers xsi:type="ecore:EClass" name="DummyClass" abstract="true" eSuperTypes="/2/language/structure/Object">
      <eAnnotations source="kermeta">
        <details key="ecore" value="true"/>
        <details key="documentation" value="This class is used to workaround an EMF bug, it doesn't really belong to Kermeta metamodel"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EDataType" name="_KermetaSpecialTypesAlias_" instanceClassName="java.lang.Object"/>
    <eSubpackages name="kunit" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/kunit" nsPrefix="kunit">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/**&#xA; * main features of the famous Unit test tool for Kermeta language&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/kunit_package.png&quot;/>&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="InvalidTestCaseNameException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * This exception is rose if there is a problem on the name of the test method&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="InvalidParameterException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * This is for when we try to build a suite from a class that isn't a TestCase&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Fallible" abstract="true" eSuperTypes="/2/kunit/AbstractFallible">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * This is represents the aspect of tests that they may go wrong.&#xA; * it defines the ability to define the conditions for success&#xA; * (assertions) and the mechanism for recording that those &#xA; * conditions have not been met.&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="assertTrue">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertTrue">
            <details key="body" value="do&#xA;&#x9;assert(condition)&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure if condition is false&#xA;   */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="getLog" eType="/2/kunit/Log">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;   * where failures will be put &#xA;   */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.post">
            <details key="logDefined" value="result.isNotEqual(void)"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="assertFalseWithMsg">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertFalseWithMsg">
            <details key="body" value="do&#xA;&#x9;assertWithMsg(condition.~not, message)&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure if condition is true&#xA;   */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="message" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="fail">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/fail">
            <details key="body" value="do&#xA;&#x9;if mustStop then&#xA;&#x9;&#x9;var exception : kermeta::kunit::AssertionFailedError init kermeta::kunit::AssertionFailedError.new&#xA;&#x9;&#x9;exception.message := ((&quot;explicit failure: &quot;) + (msg))&#xA;&#x9;&#x9;raise exception&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;getLog.addFailure(self, ((&quot;explicit failure: &quot;) + (msg)))&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure &#xA;   */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assertEqual">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertEqual">
            <details key="body" value="do&#xA;&#x9;assertWithMsg(expected.equals(actual), ((((((((&quot;\nexpected\t:[&quot;) + (expected))) + (&quot;] != \nactual\t:[&quot;))) + (actual))) + (&quot;]&quot;)))&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure if the two strings are not identical&#xA;   */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="expected" eType="/2/standard/String"/>
          <eParameters name="actual" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assertFalse">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertFalse">
            <details key="body" value="do&#xA;&#x9;assert(condition.~not)&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure if condition is true&#xA;   */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="assertTrueWithMsg">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertTrueWithMsg">
            <details key="body" value="do&#xA;&#x9;assertWithMsg(condition, message)&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure if condition is false&#xA;   */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="message" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assert">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assert">
            <details key="body" value="do&#xA;&#x9;var number : kermeta::standard::Integer init self.number&#xA;&#x9;if condition.~not then&#xA;&#x9;&#x9;var msg : kermeta::standard::String init ((((&quot;assertion number &quot;) + (number.toString))) + (&quot; failed&quot;))&#xA;&#x9;&#x9;if mustStop then&#xA;&#x9;&#x9;&#x9;var exception : kermeta::kunit::AssertionFailedError init kermeta::kunit::AssertionFailedError.new&#xA;&#x9;&#x9;&#x9;exception.message := msg&#xA;&#x9;&#x9;&#x9;raise exception&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;getLog.addFailure(self, msg)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure if condition is false&#xA;   */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="number" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if rank.isVoid then&#xA;&#x9;&#x9;rank := 0&#xA;&#xA;&#x9;end&#xA;&#x9;rank := ((rank) + (1))&#xA;&#x9;result := rank&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * current order position of counter of assertions&#xA;   */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="assertWithMsg">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertWithMsg">
            <details key="body" value="do&#xA;&#x9;var number : kermeta::standard::Integer init self.number&#xA;&#x9;if condition.~not then&#xA;&#x9;&#x9;var realMsg : kermeta::standard::String init ((((((&quot;assertion number &quot;) + (number.toString))) + (&quot; failed: &quot;))) + (msg))&#xA;&#x9;&#x9;if mustStop then&#xA;&#x9;&#x9;&#x9;var exception : kermeta::kunit::AssertionFailedError init kermeta::kunit::AssertionFailedError.new&#xA;&#x9;&#x9;&#x9;exception.message := realMsg&#xA;&#x9;&#x9;&#x9;raise exception&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;getLog.addFailure(self, realMsg)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure if condition is false&#xA;   */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="mustStop" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if stopOnFailure.isVoid then&#xA;&#x9;&#x9;stopOnFailure := true&#xA;&#xA;&#x9;end&#xA;&#x9;result := stopOnFailure&#xA;end"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="stopOnFailure" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;   * Set this attribute to false if you wish your test to not stop if the assert fails.&#xA;   * note : if set to false, the count of failures/errors may be bigger that the number of executed test operations&#xA;   */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="rank" eType="/2/standard/Integer" containment="true">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;   * counter of assertions in the test method&#xA;   */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Log" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Log is a log of failures and errors that happened to fallibles since start was called&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="addSetUpError">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;harnessErrors.add(kermeta::kunit::Error.new.initFrom(test, e).makeSetUp)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Adds errors which occur during the SetUp phase&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="test" eType="/2/kunit/Fallible"/>
          <eParameters name="e" eType="/2/exceptions/Exception"/>
        </eOperations>
        <eOperations name="addTestError">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;errors.add(kermeta::kunit::Error.new.initFrom(test, e))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Adds an error to the list of errors&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="test" eType="/2/kunit/Fallible"/>
          <eParameters name="e" eType="/2/exceptions/Exception"/>
        </eOperations>
        <eOperations name="addFailure">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;failures.add(kermeta::kunit::Failure.new.initFrom(test, msg))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Adds a failed test to the list of failed tests&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="test" eType="/2/kunit/Fallible"/>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="addTearDownError">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;harnessErrors.add(kermeta::kunit::Error.new.initFrom(test, e).makeTearDown)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Adds errors which occur during the TearDown phase&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="test" eType="/2/kunit/Fallible"/>
          <eParameters name="e" eType="/2/exceptions/Exception"/>
        </eOperations>
        <eOperations name="newAttempt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if runtests.equals(void) then&#xA;&#x9;&#x9;runtests := 0&#xA;&#xA;&#x9;end&#xA;&#x9;runtests := ((1) + (runtests))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Increments the runtests counter&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="failures" upperBound="-1" eType="/2/kunit/Failure">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/** &#xA;&#x9; * list of detected assertion failures&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="errors" upperBound="-1" eType="/2/kunit/Error">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * list of detected test errors&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="runtests" eType="/2/standard/Integer" containment="true">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * number of test that were run&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="harnessErrors" upperBound="-1" eType="/2/kunit/Error">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9;* list of detected errors with the test harness&#xA;&#x9;*/"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Failure" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Failure represents an assertion failure stored in a failure log&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result := ((((failure.toString) + (&quot; &quot;))) + (message))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * overwrite the default method, in order to add the message&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initFrom" eType="/2/kunit/Failure">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;failure := fallible&#xA;&#x9;message := msg&#xA;&#x9;result := self&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * initialization of the failure&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="fallible" eType="/2/kunit/Fallible"/>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="message" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="false"/>
            <details key="documentation" value="/**&#xA;&#x9; * the stored message (given or generated one)&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="failure" eType="/2/kunit/Fallible">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * the stored failure&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EEnum" name="ErrorKind">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * all kinds of error we can meet&#xA; */"/>
        </eAnnotations>
        <eLiterals name="setUpError" literal="setUpError"/>
        <eLiterals name="testError" value="1" literal="testError"/>
        <eLiterals name="tearDownError" value="2" literal="tearDownError"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Error" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Error represents an occurrence of an exception in setUp, tearDown or a test&#xA; * and is stored in a failure log&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="makeTearDown" eType="/2/kunit/Error">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;kind := kermeta::kunit::ErrorKind.tearDownError&#xA;&#x9;result := self&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Changes the type of an error to makeTearDownError, the best way to use&#xA;&#x9; * this method is to call it after the init from line:&#xA;&#x9; * var e : Error init Error.new.initFrom(f, e).makeTearDown&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="makeSetUp" eType="/2/kunit/Error">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;kind := kermeta::kunit::ErrorKind.setUpError&#xA;&#x9;result := self&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Changes the type of an error to SetUpError, the best way to use&#xA;&#x9; * this method is to call it after the init from line:&#xA;&#x9; * var e : Error init Error.new.initFrom(f, e).makeSetUp&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;if kind.equals(kermeta::kunit::ErrorKind.testError) then&#xA;&#x9;&#x9;result := error.toString&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result := ((error.getMetaClass.name) + (&quot;.&quot;))&#xA;&#x9;&#x9;if kind.equals(kermeta::kunit::ErrorKind.setUpError) then&#xA;&#x9;&#x9;&#x9;result := ((result) + (&quot;setUp()&quot;))&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := ((result) + (&quot;tearDown()&quot;))&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;result := ((((result) + (&quot; raised &quot;))) + (exception.getMetaClass.name))&#xA;&#x9;if exception.message.isNotEqual(void) then&#xA;&#x9;&#x9;result := ((((result) + (&quot;\n    Caused by: &quot;))) + (exception.message))&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result := ((result) + (&quot;\n    (no message)&quot;))&#xA;&#xA;&#x9;end&#xA;&#x9;if exception.stackTrace.isNotEqual(void) then&#xA;&#x9;&#x9;result := ((((result) + (&quot;\n    Stack Trace:\n&quot;))) + (exception.stackTrace))&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result := ((result) + (&quot;\n    (no stack trace)&quot;))&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * overwrite the default method, in order to add :&#xA;&#x9; *   - the type&#xA;&#x9; *   - the message&#xA;&#x9; *   - the stack trace&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initFrom" eType="/2/kunit/Error">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;self.error := error&#xA;&#x9;exception := e&#xA;&#x9;kind := kermeta::kunit::ErrorKind.testError&#xA;&#x9;result := self&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Sets up a new error with failable object and the exception that occurred&#xA;&#x9; * by default it will be a test error. Use makeSetUp or makeTearDown to&#xA;&#x9; * change its type&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="error" eType="/2/kunit/Fallible"/>
          <eParameters name="e" eType="/2/exceptions/Exception"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="error" eType="/2/kunit/Fallible">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * the stored error&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="exception" eType="/2/exceptions/Exception">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * the Kermeta exception corresponding to the error&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="kind" eType="/2/kunit/ErrorKind">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * the nature of the stored error&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Test" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The abstact notion of a test which is runnable and which has a log&#xA; * in which it can keep note of failures&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="setLog">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;self.log := log&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Initializes the log where failures and errors will be put&#xA;&#x9; */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.pre">
            <details key="paramNotVoid" value="log.isNotEqual(void)"/>
          </eAnnotations>
          <eAnnotations source="kermeta.post">
            <details key="logNotVoid" value="self.log.isNotEqual(void)"/>
          </eAnnotations>
          <eParameters name="log" eType="/2/kunit/Log"/>
        </eOperations>
        <eOperations name="run">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Execute the test and verify its assertions&#xA;&#x9; */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.pre">
            <details key="logNotVoid" value="self.log.isNotEqual(void)"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initLog" eType="/2/kunit/Log">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;self.log := kermeta::kunit::Log.new&#xA;&#x9;result := self.log&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * called when run by the java testrunner&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="log" eType="/2/kunit/Log">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;     * where failures and errors will be put &#xA;     */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TestSuite" eSuperTypes="/2/kunit/Test">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * A TestSuite is a structured collection of tests, using the&#xA; * composite pattern, all tests are runnable and have a log&#xA; * In addition a suite can be populated automatically from a&#xA; * test case class with one test case object for each test&#xA; * method in the class.&#xA; *  You can make a suite and populate it manually like this:&#xA; *&#xA; *  var suite : TestSuite init TestSuite.new.&#xA; *  suite.tests.add(t1)&#xA; *&#xA; *  Alternatively you can populate a suite automatically from&#xA; *  a class that inherits TestCase and which has several methods&#xA; *  called test:&#xA; *&#xA; *  var suite : TestSuite init TestSuite.new.addAllTestCasesFrom(InterestingTestCaseSet)&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="addAllTestCasesFrom" eType="/2/kunit/TestSuite">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if testCaseClass.superClass.exists{sc | do&#xA;&#x9;&#x9;&#x9;sc.equals(kermeta::kunit::TestCase)&#xA;&#x9;&#x9;end}.~not then&#xA;&#x9;&#x9;var e : kermeta::exceptions::Exception init kermeta::kunit::InvalidParameterException.new&#xA;&#x9;&#x9;e.message := ((&quot;Cannot build a suite from class: &quot;) + (testCaseClass.name))&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;&#x9;testCaseClass.ownedOperation.~select{o | do&#xA;&#x9;&#x9;&#x9;if ((o.name.size) >= (4)) then&#xA;&#x9;&#x9;&#x9;&#x9;o.name.substring(0, 4).equals(&quot;test&quot;)&#xA;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;false&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}.each{o | do&#xA;&#x9;&#x9;&#x9;var testCase : kermeta::kunit::TestCase&#xA;&#x9;&#x9;&#x9;testCase ?= testCaseClass.new&#xA;&#x9;&#x9;&#x9;testCase.setTestMethodName(o.name)&#xA;&#x9;&#x9;&#x9;self.tests.add(testCase)&#xA;&#x9;&#x9;end}&#xA;&#x9;result := self&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9;  * Add to this suite, a set of test cases of type c, one for each&#xA;&#x9;  * test method in class c. C must be a descendent of TestCase&#xA;&#x9;  */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.pre">
            <details key="testCaseClassIsATestCase" value="testCaseClass.superClass.contains(kermeta::kunit::TestCase)"/>
          </eAnnotations>
          <eParameters name="testCaseClass" eType="/2/language/structure/Class"/>
        </eOperations>
        <eOperations name="run" ordered="false" eType="/2/standard/Void">
          <eAnnotations source="kermeta" references="/2/kunit/Test/run">
            <details key="body" value="do&#xA;&#x9;tests.each{t | do&#xA;&#x9;&#x9;&#x9;t.setLog(log)&#xA;&#x9;&#x9;&#x9;t.run&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/** &#xA;&#x9; * Run all the tests in the test suite&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::kunit::Test"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="addAllTestCasesFromAspects">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;anAspect.ownedOperation.~select{o | do&#xA;&#x9;&#x9;&#x9;if ((o.name.size) >= (4)) then&#xA;&#x9;&#x9;&#x9;&#x9;o.name.substring(0, 4).equals(&quot;test&quot;)&#xA;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;false&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}.each{o | do&#xA;&#x9;&#x9;&#x9;var testCase : kermeta::kunit::TestCase&#xA;&#x9;&#x9;&#x9;testCase ?= testCaseClass.new&#xA;&#x9;&#x9;&#x9;testCase.setTestMethodName(o.name)&#xA;&#x9;&#x9;&#x9;self.tests.add(testCase)&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9;  * to be written #####################################################&#xA;&#x9;  */"/>
          </eAnnotations>
          <eParameters name="testCaseClass" eType="/2/language/structure/Class"/>
          <eParameters name="anAspect" eType="/2/language/structure/ClassDefinition"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="tests" upperBound="-1" eType="/2/kunit/Test">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * The collection of tests which will be ran as the suite&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TestCase" abstract="true" eSuperTypes="/2/kunit/Test /2/kunit/Fallible">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * A test case comprises one or more test methods plus&#xA; * setUp and tearDown that build and destroy their test harness.&#xA; * An instance of a subclass of TestCase should have its&#xA; * testMethodName set to the name of one of its operations&#xA; * which should be called whe the test is run. You can do this&#xA; * yourself:&#xA; *&#xA; * var testCase : TestCase init MyTestCaseClass.new.setTestMethodName(&quot;testSomething&quot;)&#xA; *&#xA; * Alternatively if your TestCase Class has many methods whose&#xA; * name begins with 'test' you can create a set of instaces already&#xA; * set up with their testMethodName using the addAllTestCasesFrom&#xA; * operation on TestSuite&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="setUp">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * the things to be done before execution of the test method&#xA;&#x9; * (designed to be overwritten in real TestCase classes) &#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="raiseIfHasFailures">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var msg : kermeta::standard::String init &quot;&quot;&#xA;&#x9;if log.failures.empty.~not then&#xA;&#x9;&#x9;msg := &quot;Failures: &quot;&#xA;&#x9;&#x9;log.failures.each{f | do&#xA;&#x9;&#x9;&#x9;&#x9;msg := ((((msg) + (&quot;\n   &quot;))) + (f.toString))&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;var exception : kermeta::kunit::AssertionFailedError init kermeta::kunit::AssertionFailedError.new&#xA;&#x9;&#x9;exception.message := msg&#xA;&#x9;&#x9;raise exception&#xA;&#xA;&#x9;end&#xA;&#x9;if log.errors.empty.~not then&#xA;&#x9;&#x9;log.errors.each{f | do&#xA;&#x9;&#x9;&#x9;&#x9;msg := &quot;Errors: &quot;&#xA;&#x9;&#x9;&#x9;&#x9;msg := ((((msg) + (&quot;\n   &quot;))) + (f.toString))&#xA;&#x9;&#x9;&#x9;&#x9;var exception : kermeta::exceptions::Exception init kermeta::exceptions::Exception.new&#xA;&#x9;&#x9;&#x9;&#x9;exception.message := msg&#xA;&#x9;&#x9;&#x9;&#x9;raise exception&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * operation used when the TestCase is run from a java test runner, encapsulates the failures results&#xA;&#x9; * into an AssertionFailedError so the TestRunner can detect it&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getLog" eType="/2/kunit/Log">
          <eAnnotations source="kermeta" references="/2/kunit/Fallible/getLog">
            <details key="body" value="do&#xA;&#x9;result := self.log&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * accessor on the log&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::kunit::Fallible"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="setTestMethodName" eType="/2/kunit/TestCase">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;__testMethodName := name&#xA;&#x9;result := self&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Sets the name of the method from the concrete subclass of&#xA;&#x9; *  TestCase that should be executed when this TestCase instance&#xA;&#x9; * is run as a test.&#xA;&#x9; * Throws invalidTestCaseNameException if the given string is not&#xA;&#x9; * the name of a method in the test case&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="name" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="getTestMethodName" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := __testMethodName&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * accessor on the method name&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result := ((((((self.getMetaClass.name) + (&quot;.&quot;))) + (getTestMethodName))) + (&quot;()&quot;))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * overwrites the default method for more informative output&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="run" ordered="false" eType="/2/standard/Void">
          <eAnnotations source="kermeta" references="/2/kunit/Test/run">
            <details key="body" value="do&#xA;&#x9;getLog.newAttempt&#xA;&#x9;do&#xA;&#x9;&#x9;setUp&#xA;&#x9;&#x9;do&#xA;&#x9;&#x9;&#x9;var de : kermeta::interpreter::DynamicExpression init kermeta::interpreter::DynamicExpression.new&#xA;&#x9;&#x9;&#x9;de.initializeDefaults&#xA;&#x9;&#x9;&#x9;de.selfClass ?= self.getMetaClass.typeDefinition&#xA;&#x9;&#x9;&#x9;de.parse(((&quot;self.&quot;) + (self.getTestMethodName)))&#xA;&#x9;&#x9;&#x9;de.execute(self, kermeta::utils::Hashtable&lt;kermeta::standard::String, kermeta::standard::Object>.new)&#xA;&#x9;&#x9;&#x9;do&#xA;&#x9;&#x9;&#x9;&#x9;tearDown&#xA;&#x9;&#x9;&#x9;rescue(e : kermeta::exceptions::Exception)&#xA;&#x9;&#x9;&#x9;&#x9;getLog.addTearDownError(self, e)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;rescue(afe : kermeta::kunit::AssertionFailedError)&#xA;&#x9;&#x9;&#x9;getLog.addFailure(self, ((((afe.message) + (&quot;\nstack trace:\n&quot;))) + (afe.stackTrace)))&#xA;&#xA;&#x9;&#x9;rescue(e1 : kermeta::exceptions::Exception)&#xA;&#x9;&#x9;&#x9;getLog.addTestError(self, e1)&#xA;&#x9;&#x9;&#x9;do&#xA;&#x9;&#x9;&#x9;&#x9;tearDown&#xA;&#x9;&#x9;&#x9;rescue(e : kermeta::exceptions::Exception)&#xA;&#x9;&#x9;&#x9;&#x9;getLog.addTearDownError(self, e)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;rescue(e : kermeta::exceptions::Exception)&#xA;&#x9;&#x9;getLog.addSetUpError(self, e)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Execute the whole test case : SetUp, test method, TearDown&#xA;&#x9; * The assertions of the test method are computed&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::kunit::Test"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="tearDown">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * the things to be done after execution of the test method&#xA;&#x9; * (designed to be overwritten in real TestCase classes) &#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="__testMethodName" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * the name of the method which corresponds to the test case in the test class&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TestRunner" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Create and use a test runner to run one or more tests and print the failure log. E.g.:&#xA; * do&#xA; *&#x9;     var suite : TestSuite init TestSuite.new.addAllTestCasesFrom(InterestingTestCaseSet)&#xA; *&#x9;     var runner : TestRunner init TestRunner.new&#xA; *&#x9;     runner.run(suite)&#xA; *&#x9;     runner.printLogs&#xA; * end&#xA; *&#xA; * Where InterestingTestCaseSet is a subclass of TestCase and contains several test... methods&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="runTest">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;log := kermeta::kunit::Log.new&#xA;&#x9;test.setLog(log)&#xA;&#x9;test.run&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Use this to run a test case or a test suite.&#xA;&#x9; * If you want to run all the test.... methods in a TestCase class,&#xA;&#x9; *  you can populate a suite with TestSuite.addAllTestCasesFrom&#xA;&#x9; */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.pre">
            <details key="testNotVoid" value="test.isNotEqual(void)"/>
          </eAnnotations>
          <eAnnotations source="kermeta.post">
            <details key="logNotVoid" value="log.isNotEqual(void)"/>
          </eAnnotations>
          <eParameters name="test" eType="/2/kunit/Test"/>
        </eOperations>
        <eOperations name="printTestResult" ordered="false" eType="/2/standard/Void">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;stdio.writeln(&quot;\n---------------------------------------------  TEST RESULTS-----------------------------------------------\n&quot;)&#xA;&#x9;if log.failures.empty.~not then&#xA;&#x9;&#x9;stdio.writeln(&quot;\nFailures: &quot;)&#xA;&#x9;&#x9;log.failures.each{f | do&#xA;&#x9;&#x9;&#x9;&#x9;stdio.writeln(((&quot;\n   &quot;) + (f.toString)))&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;if log.errors.empty.~not then&#xA;&#x9;&#x9;stdio.writeln(&quot;\nErrors: &quot;)&#xA;&#x9;&#x9;log.errors.each{e | do&#xA;&#x9;&#x9;&#x9;&#x9;stdio.writeln(((&quot;\n   &quot;) + (e.toString)))&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;if log.harnessErrors.empty.~not then&#xA;&#x9;&#x9;stdio.writeln(&quot;\nErrors from setUp or tearDown : &quot;)&#xA;&#x9;&#x9;log.harnessErrors.each{e | do&#xA;&#x9;&#x9;&#x9;&#x9;stdio.writeln(((&quot;\n   &quot;) + (e.toString)))&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;stdio.writeln(&quot;\n Summary: &quot;)&#xA;&#x9;stdio.writeln(((&quot;   Number of launched tests : &quot;) + (log.runtests.toString)))&#xA;&#x9;stdio.writeln(((&quot;   Number of failures : &quot;) + (log.failures.size.toString)))&#xA;&#x9;stdio.writeln(((&quot;   Number of errors : &quot;) + (log.errors.size.toString)))&#xA;&#x9;stdio.writeln(((&quot;   Number of errors in setUp or tearDown: &quot;) + (log.harnessErrors.size.toString)))&#xA;&#x9;stdio.writeln(&quot;\n-------------------------------------------------------------------------------------------------------------------------------\n&quot;)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Prints the log or errors and failures from a test run.&#xA;&#x9; * Run some tests first.&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="run">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;runTest(kermeta::kunit::TestSuite.new.addAllTestCasesFrom(testCaseClass))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9;  * For backwards compatibility with old kunit, this takes a test case class&#xA;&#x9;  * and creates the necessary suite, and runs it. DEPRECATED&#xA;&#x9;  */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.pre">
            <details key="cIsATestCase" value="testCaseClass.superClass.contains(kermeta::kunit::TestCase)"/>
          </eAnnotations>
          <eParameters name="testCaseClass" eType="/2/language/structure/Class"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="log" eType="/2/kunit/Log" containment="true">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * Where to register the failures and errors&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="AbstractFallible" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * to be written ############################&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="assertTrue">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/** process the given condition and react if it is not satisfied */"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="distil" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := &quot;&quot;&#xA;&#x9;var white : kermeta::standard::Boolean init false&#xA;&#x9;from var i : kermeta::standard::Integer init 0&#xA;&#x9;until i.equals(s.size)&#xA;&#x9;loop&#xA;&#x9;&#x9;var c : kermeta::standard::String init s.elementAt(i).toString&#xA;&#x9;&#x9;if ((&quot; \n\t&quot;.indexOf(c)) >= (0)) then&#xA;&#x9;&#x9;&#x9;if white.~not then&#xA;&#x9;&#x9;&#x9;&#x9;white := true&#xA;&#x9;&#x9;&#x9;&#x9;result := ((result) + (&quot; &quot;))&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := ((result) + (c))&#xA;&#x9;&#x9;&#x9;if white then&#xA;&#x9;&#x9;&#x9;&#x9;white := false&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;&#x9;i := ((i) + (1))&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** &#xA;&#x9; ** reduces all runs of white-space to a single space character&#xA;&#x9; **/"/>
          </eAnnotations>
          <eParameters name="s" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assertFalseWithMsg">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;     * process the given condition and react with the given message&#xA;     * if it is satisfied&#xA;     */"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="message" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="fail">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/** to be used if a failure reaction is needed */"/>
          </eAnnotations>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assertEqual">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/** process the two given string and react if they are not equal */"/>
          </eAnnotations>
          <eParameters name="expected" eType="/2/standard/String"/>
          <eParameters name="actual" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assertFalse">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/** process the given condition and react if it is satisfied */"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="assertTrueWithMsg">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;     * process the given condition and react with the given message&#xA;     * if it is not satisfied&#xA;     */"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="message" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assert">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/** process the given condition and react if it is not satisfied */"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="assertSimilar">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;expected := distil(expected)&#xA;&#x9;actual := distil(actual)&#xA;&#x9;assertWithMsg(expected.equals(actual), ((((((((&quot;\nexpected\t:[&quot;) + (expected))) + (&quot;] != \nactual  \t:[&quot;))) + (actual))) + (&quot;]&quot;)))&#xA;end"/>
            <details key="documentation" value="/**&#xA;   * Log a failure if the two strings are not identical modulo-white-space&#xA;   */"/>
          </eAnnotations>
          <eParameters name="expected" eType="/2/standard/String"/>
          <eParameters name="actual" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assertWithMsg">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;     * process the given condition and react with the given message&#xA;     * if it is not satisfied&#xA;     */"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="AssertionFailedError" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** AssertionViolatedException are raised when assertions are violated */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Assert" eSuperTypes="/2/kunit/AbstractFallible">
        <eAnnotations source="kermeta">
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="assertTrue">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertTrue">
            <details key="body" value="do&#xA;&#x9;if condition.~not then&#xA;&#x9;&#x9;fail(&quot;assertTrue failed&quot;)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** will fail if condition is false */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="assertFalseWithMsg">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertFalseWithMsg">
            <details key="body" value="do&#xA;&#x9;if condition then&#xA;&#x9;&#x9;fail(((&quot;assertTrueWithMsg failed : &quot;) + (msg)))&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** will fail if condition is true */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="fail">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/fail">
            <details key="body" value="do&#xA;&#x9;var exception : kermeta::kunit::AssertionFailedError init kermeta::kunit::AssertionFailedError.new&#xA;&#x9;exception.message := msg&#xA;&#x9;raise exception&#xA;end"/>
            <details key="documentation" value="/** raise a AssertionViolatedException with the provided message */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assertEqual">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertEqual">
            <details key="body" value="do&#xA;&#x9;if expected.equals(actual).~not then&#xA;&#x9;&#x9;fail(((((((((&quot;assertEqual failed\nexpected\t:[&quot;) + (expected))) + (&quot;] != \nactual\t:[&quot;))) + (actual))) + (&quot;]&quot;)))&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** Will fail if the two strings are not identical */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="expected" eType="/2/standard/String"/>
          <eParameters name="actual" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assertFalse">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertFalse">
            <details key="body" value="do&#xA;&#x9;if condition then&#xA;&#x9;&#x9;fail(&quot;assertTrue number failed&quot;)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** will fail if condition is true */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="assertTrueWithMsg">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertTrueWithMsg">
            <details key="body" value="do&#xA;&#x9;if condition.~not then&#xA;&#x9;&#x9;fail(((&quot;assertTrueWithMsg failed : &quot;) + (msg)))&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** will fail if condition is false */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="assert">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assert">
            <details key="body" value="do&#xA;&#x9;if condition.~not then&#xA;&#x9;&#x9;fail(&quot;assert failed&quot;)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** Fails if condition is false */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="assertWithMsg">
          <eAnnotations source="kermeta" references="/2/kunit/AbstractFallible/assertWithMsg">
            <details key="body" value="do&#xA;&#x9;if condition.~not then&#xA;&#x9;&#x9;fail(((&quot;assertTrueWithMsg failed : &quot;) + (msg)))&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** will fail if condition is false */"/>
            <details key="superOperation" value="kermeta::kunit::AbstractFallible"/>
          </eAnnotations>
          <eParameters name="condition" eType="/2/standard/Boolean"/>
          <eParameters name="msg" eType="/2/standard/String"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="language" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/language" nsPrefix="language">
      <eAnnotations source="kermeta">
        <details key="ecore" value="true"/>
        <details key="documentation" value="/**&#xA; * Contains the implementation of Kermeta reflective collections.&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/language_package.png&quot;/>&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="DummyClass" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="ecore" value="true"/>
          <details key="documentation" value="This class is used to workaround an EMF bug, it doesn't really belong to Kermeta metamodel"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ReflectiveCollection" eSuperTypes="/2/standard/Set">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * ReflectiveCollection is a special collection that is used to define the type &#xA; * of attributes that have an upper multiplicity > 1 in a class. It indeed handles&#xA; * the update of opposite property if such an attribute has got one.&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="clear">
          <eAnnotations source="kermeta" references="/2/standard/Collection/clear">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::ReflectiveCollection.clear(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::standard::Collection&lt;G>.clear(G)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="remove">
          <eAnnotations source="kermeta" references="/2/standard/Set/remove">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::ReflectiveCollection.remove(self, element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::standard::Set&lt;G>.remove(G)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Set"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/language/ReflectiveCollection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="add">
          <eAnnotations source="kermeta" references="/2/standard/Set/add">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::ReflectiveCollection.add(self, element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::standard::Set&lt;G>.add(G)&#xA;&#x9; * Add an element to this collection and update its opposite property if it exists.&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Set"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/language/ReflectiveCollection/G"/>
          </eParameters>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ReflectiveSequence" eSuperTypes="/2/standard/OrderedSet /2/language/ReflectiveCollection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * ReflectiveSequence is an ordered ReflectiveCollection.&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="clear">
          <eAnnotations source="kermeta" references="/2/language/ReflectiveCollection/clear">
            <details key="body" value="do&#xA;&#x9;super()&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::language::ReflectiveCollection&lt;G>.clear()&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::ReflectiveCollection"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="addAt">
          <eAnnotations source="kermeta" references="/2/standard/OrderedSet/addAt">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::ReflectiveSequence.addAt(self, index, element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::standard::OrderedSet.addAt(Integer)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::OrderedSet"/>
          </eAnnotations>
          <eParameters name="index" eType="/2/standard/Integer"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/language/ReflectiveSequence/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="removeAt">
          <eAnnotations source="kermeta" references="/2/standard/OrderedCollection/removeAt">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::ReflectiveSequence.removeAt(self, index)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::standard::OrderedSet.removeAt(Integer)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::OrderedCollection"/>
          </eAnnotations>
          <eParameters name="index" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="remove">
          <eAnnotations source="kermeta" references="/2/language/ReflectiveCollection/remove">
            <details key="body" value="do&#xA;&#x9;super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::language::ReflectiveCollection&lt;G>.remove(G)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::ReflectiveCollection"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/language/ReflectiveSequence/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/standard/OrderedSet/equals">
            <details key="body" value="do&#xA;&#x9;result := super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::standard::OrderedSet.equals(Object)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::OrderedSet"/>
          </eAnnotations>
          <eParameters name="element" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="add">
          <eAnnotations source="kermeta" references="/2/language/ReflectiveCollection/add">
            <details key="body" value="do&#xA;&#x9;super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides kermeta::language::ReflectiveCollection&lt;G>.add(G)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::ReflectiveCollection"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/language/ReflectiveSequence/G"/>
          </eParameters>
        </eOperations>
      </eClassifiers>
      <eSubpackages name="structure" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/language/structure" nsPrefix="structure">
        <eAnnotations source="kermeta">
          <details key="ecore" value="true"/>
          <details key="documentation" value="/**&#xA; * Contains the concrete implementation (including the operation bodies) &#xA; * of the classes of the &lt;code>kermeta::reflection&lt;/code> package.&#xA; * If you need more documentation, please take a look at the&#xA; * &lt;code>kermeta::reflection&lt;/code> package which is more complete.&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/language_structure_package.png&quot;/>&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/language_structure_visitor_view.png&quot;/>&#xA; */"/>
        </eAnnotations>
        <eClassifiers xsi:type="ecore:EClass" name="PropertyConstraint" eSuperTypes="/2/language/structure/Constraint">
          <eStructuralFeatures xsi:type="ecore:EReference" name="property" eType="/2/language/structure/Property" eOpposite="/2/language/structure/Property/propertyConstraint">
            <eAnnotations source="kermeta">
              <details key="documentation" value="/**&#xA;&#x9; * The property that is checked by this constraint&#xA;&#x9; * Typically, it will check the lower and upper bounds&#xA;&#x9; */"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Property" eSuperTypes="/2/language/structure/MultiplicityElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Class representing the property definition. Kermeta&lt;->Ecore equivalence:&#xA; - Property with isComposite == true or with type is a base type (String, Integer, Boolean)  : EAttribute&#xA; - Property with isComposite == false : EReference"/>
          </eAnnotations>
          <eOperations name="getViolatedConstraintsMustDrillDown" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if getViolatedConstraintsMustDrillDownCache.isVoid then&#xA;&#x9;&#x9;getViolatedConstraintsMustDrillDownCache := kermeta::standard::ValueType.isSuperTypeOf(self.type).~not&#xA;&#xA;&#x9;end&#xA;&#x9;result := getViolatedConstraintsMustDrillDownCache&#xA;end"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="getViolatedConstraintsMustDrillDownCache" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isDerived" eType="/2/language/structure/Boolean" defaultValueLiteral="false">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="If True, the value of the property is not stored but computed from other properties"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="opposite" eType="/2/language/structure/Property">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Opposite Property of the Property, void if the Property has no opposite"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="getterBody" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="setterBody" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isSetterAbstract" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating wether the setter is abstract."/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="owningClass" eType="/2/language/structure/ClassDefinition" eOpposite="/2/language/structure/ClassDefinition/ownedAttribute">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="ClassDefinition that owns the Property"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isGetterAbstract" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating wether the getter is abstract."/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isComposite" eType="/2/language/structure/Boolean" defaultValueLiteral="false">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating whether the Property has a containment role"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="default" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isReadOnly" eType="/2/language/structure/Boolean" defaultValueLiteral="false">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating whether the Property is read-only"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="propertyConstraint" eType="/2/language/structure/PropertyConstraint" containment="true" eOpposite="/2/language/structure/PropertyConstraint/property">
            <eAnnotations source="kermeta">
              <details key="documentation" value="/** special constraint that apply to this Property&#xA;     * Used by the getViolatedConstraints&#xA;     */"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isID" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating whether the property allows to identify its containing Object"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="ClassDefinition" eSuperTypes="/2/language/structure/GenericTypeDefinition /2/language/structure/TypeContainer">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="The definition of a class definition :)&#xA; &lt;pre>class A&#xA;{ &#xA;  attribute s : String&#xA;}&#xA;  &lt;/pre> is a class definition; in :&#xA;&lt;pre>&#xA;main() : A is do end&#xA;&lt;/pre>&#xA;A is a &lt;b>Class&lt;/b> : it corresponds to the &lt;b>use&lt;/b> of the class definition of A"/>
          </eAnnotations>
          <eOperations name="getCachedAllAttribute">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if _allAttributeCache.isVoid then&#xA;&#x9;&#x9;_allAttributeCache := allAttribute&#xA;&#xA;&#x9;end&#xA;&#x9;result := _allAttributeCache&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * returns a cached version of the derived property allAttribute&#xA;&#x9; * It is intended to be used to optimize access on the reflexivity, &#xA;&#x9; * do not use this cache if you are modifying the ClassDefinition&#xA;&#x9; */"/>
            </eAnnotations>
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eClassifier="/2/language/structure/Property"/>
            </eGenericType>
          </eOperations>
          <eOperations name="getCachedAllSuperTypes">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if _allSuperTypesCache.isVoid then&#xA;&#x9;&#x9;_allSuperTypesCache := allSuperTypes&#xA;&#xA;&#x9;end&#xA;&#x9;result := _allSuperTypesCache&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * returns a cached version of the derived property allSuperTypes&#xA;&#x9; * It is intended to be used to optimize access on the reflexivity, &#xA;&#x9; * do not use this cache if you are modifying the ClassDefinition&#xA;&#x9; */"/>
            </eAnnotations>
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eClassifier="/2/language/structure/Type"/>
            </eGenericType>
          </eOperations>
          <eOperations name="allSuperTypes">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var allSuperClasses : kermeta::standard::Set&lt;kermeta::language::structure::Type> init kermeta::standard::Set&lt;kermeta::language::structure::Type>.new&#xA;&#x9;var superClasses : kermeta::standard::Set&lt;kermeta::language::structure::Type> init kermeta::standard::Set&lt;kermeta::language::structure::Type>.new&#xA;&#x9;superClasses.addAll(self.superType)&#xA;&#x9;from superClasses.isEmpty.~not&#xA;&#x9;until superClasses.isEmpty&#xA;&#x9;loop&#xA;&#x9;&#x9;allSuperClasses.addAll(superClasses)&#xA;&#x9;&#x9;var temp : kermeta::standard::Set&lt;kermeta::language::structure::Type> init kermeta::standard::Set&lt;kermeta::language::structure::Type>.new&#xA;&#x9;&#x9;superClasses.each{s | do&#xA;&#x9;&#x9;&#x9;&#x9;if s.isInstanceOf(kermeta::language::structure::ParameterizedType) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if s.asType(kermeta::language::structure::ParameterizedType).typeDefinition.isInstanceOf(kermeta::language::structure::ClassDefinition) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;temp.addAll(s.asType(kermeta::language::structure::ParameterizedType).typeDefinition.asType(kermeta::language::structure::ClassDefinition).superType)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;superClasses.clear&#xA;&#x9;&#x9;superClasses.addAll(temp)&#xA;&#x9;end&#xA;&#x9;result := allSuperClasses&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns all the types directly and indirectly inherited by this ClasDefinition &#xA;&#x9; */"/>
            </eAnnotations>
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eClassifier="/2/language/structure/Type"/>
            </eGenericType>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ownedOperation" upperBound="-1" eType="/2/language/structure/Operation" containment="true" eOpposite="/2/language/structure/Operation/owningClass">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Operations owned by this ClassDefinition."/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isAbstract" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating whether the ClassDefinition is abstract (which means that&#xA;no instance can be allocated)"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="_allAttributeCache">
            <eAnnotations source="kermeta">
              <details key="documentation" value="/**&#xA;&#x9; * Data structure for getCachedAllAttribute&#xA;&#x9; */"/>
            </eAnnotations>
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eClassifier="/2/language/structure/Property"/>
            </eGenericType>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="_allSuperTypesCache">
            <eAnnotations source="kermeta">
              <details key="documentation" value="/**&#xA;&#x9; * Data structure for getCachedAllSuperTypes&#xA;&#x9; */"/>
            </eAnnotations>
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eClassifier="/2/language/structure/Type"/>
            </eGenericType>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="superType" upperBound="-1" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Classes from which this ClassDefinition inherits."/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="inv" upperBound="-1" eType="/2/language/structure/Constraint" containment="true" eOpposite="/2/language/structure/Constraint/invOwner">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Invariants defined for this ClassDefinition"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="allOperation" ordered="false" upperBound="-1" eType="/2/language/structure/Operation" changeable="false" volatile="true" transient="true" derived="true">
            <eAnnotations source="kermeta">
              <details key="documentation" value="/**&#xA;&#x9; * Returns all the Operations of this ClassDefinition&#xA;&#x9; * including the inherited ones&#xA;&#x9; */"/>
              <details key="isReadOnly" value="true"/>
            </eAnnotations>
            <eAnnotations source="kermetaderivedProp.getter">
              <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;kermeta::language::structure::Operation>.new&#xA;&#x9;result.addAll(self.ownedOperation)&#xA;&#x9;self.superType.each{t | do&#xA;&#x9;&#x9;&#x9;if kermeta::language::structure::Class.isInstance(t) then&#xA;&#x9;&#x9;&#x9;&#x9;var c : kermeta::language::structure::Class&#xA;&#x9;&#x9;&#x9;&#x9;c ?= t&#xA;&#x9;&#x9;&#x9;&#x9;var cDef : kermeta::language::structure::ClassDefinition&#xA;&#x9;&#x9;&#x9;&#x9;cDef ?= c.typeDefinition&#xA;&#x9;&#x9;&#x9;&#x9;cDef.allOperation.each{p | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.add(p)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}&#xA;end"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="allAttribute" ordered="false" upperBound="-1" eType="/2/language/structure/Property" changeable="false" volatile="true" transient="true" derived="true">
            <eAnnotations source="kermeta">
              <details key="documentation" value="/**&#xA;&#x9; * Returns all the Attributes, References, derived Properties of this &#xA;&#x9; * ClassDefinition including the inherited ones&#xA;&#x9; */"/>
              <details key="isReadOnly" value="true"/>
            </eAnnotations>
            <eAnnotations source="kermetaderivedProp.getter">
              <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;kermeta::language::structure::Property>.new&#xA;&#x9;result.addAll(self.ownedAttribute)&#xA;&#x9;self.superType.each{t | do&#xA;&#x9;&#x9;&#x9;if kermeta::language::structure::Class.isInstance(t) then&#xA;&#x9;&#x9;&#x9;&#x9;var c : kermeta::language::structure::Class&#xA;&#x9;&#x9;&#x9;&#x9;c ?= t&#xA;&#x9;&#x9;&#x9;&#x9;var cDef : kermeta::language::structure::ClassDefinition&#xA;&#x9;&#x9;&#x9;&#x9;cDef ?= c.typeDefinition&#xA;&#x9;&#x9;&#x9;&#x9;cDef.allAttribute.each{p | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.add(p)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}&#xA;end"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ownedAttribute" upperBound="-1" eType="/2/language/structure/Property" containment="true" eOpposite="/2/language/structure/Property/owningClass">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Attributes, References, and derived Properties owned by this ClassDefinition."/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Object definition: all entities of Kermeta metamodel explicitly inherit from Object"/>
          </eAnnotations>
          <eOperations name="checkInvariant">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var minusOne : kermeta::language::structure::Integer init 1.uminus&#xA;&#x9;var cd : kermeta::language::structure::ClassDefinition init self.getMetaClass.classDefinition&#xA;&#x9;if invariant.isKindOf(kermeta::language::structure::PropertyConstraint) then&#xA;&#x9;&#x9;var prop : kermeta::language::structure::Property init invariant.asType(kermeta::language::structure::PropertyConstraint).~property&#xA;&#x9;&#x9;var v : kermeta::language::structure::Object init self.get(prop)&#xA;&#x9;&#x9;if v.isVoid then&#xA;&#x9;&#x9;&#x9;if prop.lower.equals(1) then&#xA;&#x9;&#x9;&#x9;&#x9;var e : kermeta::exceptions::ConstraintViolatedInv init kermeta::exceptions::ConstraintViolatedInv.new&#xA;&#x9;&#x9;&#x9;&#x9;e.constraintAppliedTo := self&#xA;&#x9;&#x9;&#x9;&#x9;e.message := ((((((((((((((&quot;Invariant lower bound of &quot;) + (cd.name))) + (&quot;_&quot;))) + (prop.name))) + (&quot;_&quot;))) + (prop.type.toString))) + (&quot; violated on &quot;))) + (self.toString))&#xA;&#x9;&#x9;&#x9;&#x9;e.failedConstraint := invariant&#xA;&#x9;&#x9;&#x9;&#x9;raise e&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;if v.isInstanceOf(kermeta::standard::Collection&lt;kermeta::language::structure::Object>) then&#xA;&#x9;&#x9;&#x9;&#x9;var coll : kermeta::standard::Collection&lt;kermeta::language::structure::Object> init v.asType(kermeta::standard::Collection&lt;kermeta::language::structure::Object>)&#xA;&#x9;&#x9;&#x9;&#x9;if ((prop.upper.isNotEqual(minusOne)) and (((coll.size) > (prop.upper)))) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var e : kermeta::exceptions::ConstraintViolatedInv init kermeta::exceptions::ConstraintViolatedInv.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;e.constraintAppliedTo := self&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;e.message := ((((((((((((((&quot;Invariant upper bound of &quot;) + (cd.name))) + (&quot;_&quot;))) + (prop.name))) + (&quot;_&quot;))) + (prop.type.toString))) + (&quot; violated on &quot;))) + (self.toString))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;e.failedConstraint := invariant&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;raise e&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;if ((coll.size) &lt; (prop.lower)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var e : kermeta::exceptions::ConstraintViolatedInv init kermeta::exceptions::ConstraintViolatedInv.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;e.constraintAppliedTo := self&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;e.message := ((((((((((((((&quot;Invariant lower bound of &quot;) + (cd.name))) + (&quot;_&quot;))) + (prop.name))) + (&quot;_&quot;))) + (prop.type.toString))) + (&quot; violated on &quot;))) + (self.toString))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;e.failedConstraint := invariant&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;raise e&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;do&#xA;&#x9;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Object.checkInvariant(self, invariant)&#xA;&#x9;&#x9;rescue(error : kermeta::exceptions::RuntimeError)&#xA;&#x9;&#x9;&#x9;var e : kermeta::exceptions::ConstraintViolatedInv init kermeta::exceptions::ConstraintViolatedInv.new&#xA;&#x9;&#x9;&#x9;e.constraintAppliedTo := self&#xA;&#x9;&#x9;&#x9;e.message := ((((&quot;Invariant violated on &quot;) + (self.toString))) + (&quot;runtime error (probably due to another failed constraint or an error in the code of the constraint)&quot;))&#xA;&#x9;&#x9;&#x9;e.failedConstraint := invariant&#xA;&#x9;&#x9;&#x9;e.nestedException := error&#xA;&#x9;&#x9;&#x9;raise e&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Checks a constraint invariant defined for the metaclass of the Object&#xA;&#x9; * You can use PropertyConstraint for checking structural constraints associated to a property&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="invariant" eType="/2/language/structure/Constraint"/>
          </eOperations>
          <eOperations name="isSet" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.isSet(self, ~property)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * True if the &lt;code>~property&lt;/code> of the object has been set&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="property" eType="/2/language/structure/Property"/>
          </eOperations>
          <eOperations name="get" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := extern fr::irisa::triskell::kermeta::runtime::language::Object.get(self, ~property)&#xA;end"/>
              <details key="documentation" value="/** &#xA;&#x9; * Returns the instances of the given property for this Object.&#xA;&#x9; *&#xA;&#x9; * Example : &#xA;&#x9; * &lt;pre>&#xA;&#x9; * class A { reference attr : String }&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * Using A :&#xA;&#x9; * &lt;pre>&#xA;&#x9; * operation getAProp() is do&#xA;&#x9; *    var a : A&#xA;&#x9; *    var s : String&#xA;&#x9; *    var the_attr : Property init self.getMetaClass.ownedAttribute.one&#xA;&#x9; *    s ?= a.get(the_attr)&#xA;&#x9; * end&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * The user has to cast&#xA;&#x9; * the result of this method according to the type and the upper multiplicity&#xA;&#x9; * of this property. If upper multiplicity > 1, than the effective type of the &#xA;&#x9; * result is a Sequence&lt;ThePropertyName>. Otherwise, the type corresponds to &#xA;&#x9; * the name of the given Property (i.e the type of the property instance).&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="property" eType="/2/language/structure/Property"/>
          </eOperations>
          <eOperations name="isKindOf" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := self.getMetaClass.equals(cl)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether the current Object is an instance of the given Class&#xA;&#x9; */"/>
            </eAnnotations>
            <eParameters name="cl" eType="/2/language/structure/Class"/>
          </eOperations>
          <eOperations name="equals" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.equals(self, element)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * semantic equality,&#xA;&#x9; * if you wish to test for object identity you need to use the method oid&#xA;&#x9; * ex: x.oid == y.oid&#xA;&#x9; * by default, (ie. if not overloaded), the equals method for class Object implements &#xA;&#x9; * the most discriminating possible equivalence relation on objects; that is, for any non-null &#xA;&#x9; * reference values x and y, this method returns true if and only if x and y refer to the same &#xA;&#x9; * object (x.oid == y.oid has the value true). &#xA;&#x9; *&#xA;&#x9; * note1: the operator == is mapped to this &#xA;&#x9; * note2: overloading this operation have some impact on the behavior on collection and hashtable that rely on it&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="element" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="getMetaClass" eType="/2/language/structure/Class">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.getMetaClass(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns the Class object that is the metaclass of current Object&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="set">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if element.isInstanceOf(~property.type) then&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Object.~set(self, ~property, element)&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var v : kermeta::language::structure::EnumerationLiteral&#xA;&#x9;&#x9;v ?= element&#xA;&#x9;&#x9;if v.isNotEqual(void).andThen{e | do&#xA;&#x9;&#x9;&#x9;&#x9;~property.type.equals(v.~enumeration)&#xA;&#x9;&#x9;&#x9;end} then&#xA;&#x9;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Object.~set(self, ~property, v)&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;var e : kermeta::exceptions::IncompatibleTypeError init kermeta::exceptions::IncompatibleTypeError.new&#xA;&#x9;&#x9;&#x9;e.message := ((((((((((((&quot;IncompatibleTypeError : Cannot set property &quot;) + (~property.name))) + (&quot; of object &quot;))) + (self.toString))) + (&quot; to &quot;))) + (element.toString))) + (&quot;.&quot;))&#xA;&#x9;&#x9;&#x9;raise e&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Sets the &lt;code>element&lt;/code> to the &lt;code>~property&lt;/code> of the object &#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="property" eType="/2/language/structure/Property"/>
            <eParameters name="element" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="isFrozen" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.isFrozen(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether the Object is currently in a&#xA;&#x9; * frozen state&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="hashcode" eType="/2/language/structure/Integer">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.hashcode(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * code used in hashtable in order to identify an object in the hashtable keys&#xA;&#x9; * This system is similar to the hashcode used in java. Please refer to java documentation&#xA;&#x9; * for more information about hashcode&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="checkInvariants">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var cd : kermeta::language::structure::ClassDefinition init self.getMetaClass.classDefinition&#xA;&#x9;if cd.isVoid.~not then&#xA;&#x9;&#x9;cd.allAttribute.each{p | do&#xA;&#x9;&#x9;&#x9;&#x9;if ((p.tag.exists{t | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;t.name.equals(&quot;ecore.isTransient&quot;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end}.~not) and (p.isDerived.~not)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var v : kermeta::language::structure::Object init self.get(p)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if v.isVoid.~not.andThen{f | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;v.isInstanceOf(kermeta::standard::Collection&lt;kermeta::language::structure::Object>)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end} then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var c : kermeta::standard::Collection&lt;kermeta::language::structure::Object> init v.asType(kermeta::standard::Collection&lt;kermeta::language::structure::Object>)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((p.upper.isNotEqual(1.uminus)) and (((c.size) > (p.upper)))) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var e : kermeta::exceptions::ConstraintViolatedInv init kermeta::exceptions::ConstraintViolatedInv.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.constraintAppliedTo := self.asType(kermeta::language::structure::Object)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.message := ((((((((((&quot;Inv upper bound of &quot;) + (cd.name))) + (&quot;.&quot;))) + (p.name))) + (&quot; violated on &quot;))) + (self.toString))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;raise e&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((c.size) &lt; (p.lower)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var e : kermeta::exceptions::ConstraintViolatedInv init kermeta::exceptions::ConstraintViolatedInv.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.constraintAppliedTo := self.asType(kermeta::language::structure::Object)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.message := ((((((((((&quot;Inv lower bound of &quot;) + (cd.name))) + (&quot;.&quot;))) + (p.name))) + (&quot; violated on &quot;))) + (self.toString))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;raise e&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((p.lower.equals(1)) and (v.isVoid)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var e : kermeta::exceptions::ConstraintViolatedInv init kermeta::exceptions::ConstraintViolatedInv.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.constraintAppliedTo := self.asType(kermeta::language::structure::Object)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.message := ((((((((((&quot;Inv lower bound of &quot;) + (cd.name))) + (&quot;.&quot;))) + (p.name))) + (&quot; violated on &quot;))) + (self.toString))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;raise e&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Object.checkInvariants(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Runs checking of invariants defined for the metaclass of the Object&#xA;&#x9; * Also check the multiplicity of attributes (except derived and transient attributes)&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="getViolatedConstraints" eType="/2/exceptions/ConstraintsDiagnostic">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var contraintes : kermeta::exceptions::ConstraintsDiagnostic init kermeta::exceptions::ConstraintsDiagnostic.new.initialize&#xA;&#x9;var cd : kermeta::language::structure::ClassDefinition&#xA;&#x9;cd := self.getMetaClass.classDefinition&#xA;&#x9;if cd.isVoid.~not then&#xA;&#x9;&#x9;cd.~inv.each{invariant | do&#xA;&#x9;&#x9;&#x9;&#x9;checkInvariant(invariant)&#xA;&#x9;&#x9;&#x9;rescue(e : kermeta::exceptions::ConstraintViolatedInv)&#xA;&#x9;&#x9;&#x9;&#x9;stdio.writeln(((&quot;    &quot;) + (e.message)))&#xA;&#x9;&#x9;&#x9;&#x9;contraintes.add(e)&#xA;&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;cd.getCachedAllAttribute.each{prop | do&#xA;&#x9;&#x9;&#x9;&#x9;if ((prop.tag.exists{t | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;t.name.equals(&quot;ecore.isTransient&quot;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end}.~not) and (prop.isDerived.~not)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var constraint : kermeta::language::structure::PropertyConstraint init prop.propertyConstraint&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if constraint.isVoid then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;constraint := kermeta::language::structure::PropertyConstraint.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if prop.type.isInstanceOf(kermeta::language::structure::ParameterizedType) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;constraint.name := ((((((((cd.name) + (&quot;_&quot;))) + (prop.name))) + (&quot;_&quot;))) + (prop.type.asType(kermeta::language::structure::ParameterizedType).typeDefinition.name))&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;constraint.name := ((((((((cd.name) + (&quot;_&quot;))) + (prop.name))) + (&quot;_&quot;))) + (prop.type.toString))&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;constraint.~property := prop&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;checkInvariant(constraint)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rescue(e : kermeta::exceptions::ConstraintViolatedInv)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;contraintes.add(e)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if ((prop.isComposite) and (prop.getViolatedConstraintsMustDrillDown)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var propValue : kermeta::language::structure::Object init self.get(prop)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if propValue.isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if prop.upper.equals(1) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if propValue.isInstanceOf(kermeta::language::structure::EnumerationLiteral).~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;propValue.getViolatedConstraints.setConstraints.each{v | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;stdio.writeln(((&quot;    &quot;) + (v.message)))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;contraintes.add(v)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var subObjInstances : kermeta::standard::Collection&lt;kermeta::language::structure::Object>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;subObjInstances ?= propValue&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;subObjInstances.each{aSubObjInstance | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if aSubObjInstance.isInstanceOf(kermeta::language::structure::EnumerationLiteral).~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;aSubObjInstance.getViolatedConstraints.setConstraints.each{v | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;stdio.writeln(((&quot;    &quot;) + (v.message)))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;contraintes.add(v)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;result := contraintes&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Checks all the invariants for this object and return a complete diagnostic.&#xA;&#x9; * This also includes the structural constraints associated to the properties.&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="isVoid" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := false&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether the Object is Void&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="isNotEqual" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := equals(element).~not&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * See kermeta::language::structure::Object.equals(Object)&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="element" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="container" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := extern fr::irisa::triskell::kermeta::runtime::language::Object.container(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns the Object that contains current Object, void if the Object has&#xA;&#x9; * no container&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="unset">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Object.unSet(self, ~property)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Remove the element set as the &lt;code>~property&lt;/code> of the object.&#xA;&#x9; * The &lt;code>isSet(~property)&lt;/code> method will then return False&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="property" eType="/2/language/structure/Property"/>
          </eOperations>
          <eOperations name="oid" eType="/2/language/structure/Integer">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.oid(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns the unique Oid of the Object&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="freeze">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Object.freeze(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Freeze the Object&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="isInstanceOf" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.isInstanceOf(self, type)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether the current Object conforms to given Type&#xA;&#x9; * This means: is this object an instance of this type, or is it an instance of its subtype &#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="type" eType="/2/language/structure/Type"/>
          </eOperations>
          <eOperations name="containingResource" eType="/2/persistence/Resource">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.getContainingResource(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns the Resource currently containing (directly or indirectly) the Object &#xA;&#x9; * or void if the object belongs to no Resource&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="asType" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if isInstanceOf(type) then&#xA;&#x9;&#x9;result := self&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::TypeCastError.new&#xA;&#xA;&#x9;end&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Implementation of OCL like cast. It returns self if the object object conforms to the type given as parameter.&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="type" eType="/2/language/structure/Class"/>
          </eOperations>
          <eOperations name="checkAllInvariants">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if self.isNotEqual(void) then&#xA;&#x9;&#x9;self.checkInvariants&#xA;&#x9;&#x9;var cd : kermeta::language::structure::ClassDefinition&#xA;&#x9;&#x9;cd ?= self.getMetaClass.typeDefinition&#xA;&#x9;&#x9;cd.allAttribute.each{prop | do&#xA;&#x9;&#x9;&#x9;&#x9;if ((prop.isComposite) and (prop.isDerived.~not)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if self.get(prop).isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if self.get(prop).getMetaClass.typeDefinition.asType(kermeta::language::structure::ClassDefinition).allSuperTypes.exists{t | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if t.isInstanceOf(kermeta::language::structure::ParameterizedType) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;t.asType(kermeta::language::structure::ParameterizedType).typeDefinition.qualifiedName.equals(&quot;kermeta::standard::Collection&quot;)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;false&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end} then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var subObjInstances : kermeta::standard::Collection&lt;kermeta::language::structure::Object>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;subObjInstances ?= self.get(prop)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;subObjInstances.each{aSubObjInstances | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;aSubObjInstances.checkAllInvariants&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;self.get(prop).checkAllInvariants&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Recursively runs checking of invariants defined for the metaclass of the Object&#xA;&#x9; * and its supertypes&#xA;&#x9; * Ignores derived attributes. &#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="toString" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := ((((((((&quot;[&quot;) + (self.getMetaClass.typeDefinition.qualifiedName))) + (&quot;:&quot;))) + (oid.toString))) + (&quot;]&quot;))&#xA;end"/>
              <details key="documentation" value="/**&#xA; &#x9; * Implements Object.toString()&#xA; &#x9; * Returns a String of form [qn:oid] where 'qn' is the qualified name of&#xA; &#x9; * the object type, and oid the unique ID of the object&#xA; &#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="tag" upperBound="-1" eType="/2/language/structure/Tag" eOpposite="/2/language/structure/Tag/object">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="An Object can be tagged by a Tag. &#xA;They are typically used to put comments/documentation on the object"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ownedTags" upperBound="-1" eType="/2/language/structure/Tag" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="An object can contains a Tag.  &#xA;Be careful, owning a tag doesn't means that the tag applies to the Object&#xA;To know which Tags apply to the object use the &quot;tag&quot; reference"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EDataType" name="String" instanceClassName="java.lang.String">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EDataType" name="Boolean" instanceClassName="java.lang.Boolean">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Operation" eSuperTypes="/2/language/structure/MultiplicityElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Every one knows what an operation is."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="typeParameter" upperBound="-1" eType="/2/language/structure/TypeVariable">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="TypeParameters of the Operation"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="body" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Body of the Operation, expressed as a KerMeta expression"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ownedParameter" upperBound="-1" eType="/2/language/structure/Parameter" containment="true" eOpposite="/2/language/structure/Parameter/operation">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Parameters of the Operation"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isAbstract" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating whether the Operation is abstract"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="post" upperBound="-1" eType="/2/language/structure/Constraint" containment="true" eOpposite="/2/language/structure/Constraint/postOwner">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Post-conditions of the Operation"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="raisedException" upperBound="-1" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Exceptions raised by the Operation"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="pre" upperBound="-1" eType="/2/language/structure/Constraint" containment="true" eOpposite="/2/language/structure/Constraint/preOwner">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Pre-conditions of the Operation"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="superOperation" eType="/2/language/structure/Operation">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Super-operation of the Operation, if any"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="owningClass" eType="/2/language/structure/ClassDefinition" eOpposite="/2/language/structure/ClassDefinition/ownedOperation">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="ClassDefinition owning the Operation"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Type" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Base class definition for the &lt;b>use&lt;/b> of a type."/>
          </eAnnotations>
          <eOperations name="clone" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta">
              <details key="isAbstract" value="true"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns a copy of passed Object built by recursively copying attribute&#xA;&#x9; * properties, and referencing original reference properties values&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="objectToClone" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="isInstance" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := element.isInstanceOf(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Implements Type.isInstance(Object)&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="element" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="deepClone" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta">
              <details key="isAbstract" value="true"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns a copy of passed Object built by recursively copying values of&#xA;&#x9; * all properties, no matter the property kind&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="objectToClone" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="isSuperTypeOf" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Type.hasSubType(self, object)&#xA;end"/>
              <details key="documentation" value="/**&#xA; &#x9; * Implements Type.isSuperTypeOf(Type)&#xA; &#x9; * For technical reason, the current implementation works only with Type that comes from a kermeta declaration (ie. in a require)&#xA; &#x9; * it won't work with Type created programmaticaly by the user. If you need that, please ask to the kermeta developpers&#xA; &#x9; * to extend it.&#xA; &#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="object" eType="/2/language/structure/Type"/>
          </eOperations>
          <eOperations name="isSubTypeOf" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := object.isSuperTypeOf(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA; &#x9; * Implements Type.isSubTypeOf(Type)&#xA; &#x9; * For technical reason, the current implementation works only with Type that comes from a kermeta declaration (ie. in a require)&#xA; &#x9; * it won't work with Type created programmaticaly by the user. If you need that, please ask to the kermeta developpers&#xA; &#x9; * to extend it.&#xA; &#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="object" eType="/2/language/structure/Type"/>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="typeContainer" eType="/2/language/structure/TypeContainer" eOpposite="/2/language/structure/TypeContainer/containedType">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Owning TypeContainer, if any"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="TypeContainer" abstract="true" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Phantom class : EMF reflexive editors need that any element of a metamodel &#xA;has a direct or indirect containment relationship with the root model element of&#xA;the metamodel. This class resolves this technical requirement."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="containedType" upperBound="-1" eType="/2/language/structure/Type" containment="true" eOpposite="/2/language/structure/Type/typeContainer">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Contained types"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="EnumerationLiteral" eSuperTypes="/2/language/structure/NamedElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Item definition for enumeration"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="enumeration" eType="/2/language/structure/Enumeration" eOpposite="/2/language/structure/Enumeration/ownedLiteral">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="ecore.isTransient" value="true"/>
              <details key="documentation" value="Owning Enumeration"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="TypeVariableBinding" eSuperTypes="/2/language/structure/TypeContainer">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Definition of a binding between a TypeVariable and a Type"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="type" lowerBound="1" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Assigned Type"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="variable" lowerBound="1" eType="/2/language/structure/TypeVariable">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="TypeVariable"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EDataType" name="Integer" instanceClassName="java.lang.Integer">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="MultiplicityElement" eSuperTypes="/2/language/structure/TypedElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value=" Model elements with a multiplicity [lower..upper] inherit this class"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isOrdered" eType="/2/language/structure/Boolean" defaultValueLiteral="false">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating whether the element is ordered"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="upper" eType="/2/language/structure/UnlimitedNatural">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Max cardinality of the element, '-1' for '*'"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="lower" eType="/2/language/structure/Integer">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Min cardinality of the element"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="/2/language/structure/Boolean" defaultValueLiteral="true">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating whether duplicated elements are allowed"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EDataType" name="UnlimitedNatural" instanceClassName="java.lang.Integer">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="TypedElement" abstract="true" eSuperTypes="/2/language/structure/TypeContainer /2/language/structure/NamedElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Abstraction of the notion of typed element : each element &#xA;that is typed inherits this class."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="type" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Type of the model element"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="TypeDefinition" eSuperTypes="/2/language/structure/NamedElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Abstraction for type definitions (ClassDefinition, ModelTypeDefinition, DataType inherit&#xA;this class)"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isAspect" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="NamedElement" abstract="true" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Any element that contain a  name (example : Operation, Property) inherit this&#xA;class."/>
          </eAnnotations>
          <eOperations name="qualifiedName" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var elem : kermeta::language::structure::NamedElement init self&#xA;&#x9;result := self.name&#xA;&#x9;if elem.container.isInstanceOf(kermeta::language::structure::NamedElement) then&#xA;&#x9;&#x9;from elem ?= elem.container&#xA;&#x9;&#x9;until elem.equals(void)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result := ((((elem.name) + (&quot;::&quot;))) + (result))&#xA;&#x9;&#x9;&#x9;if elem.container.isInstanceOf(kermeta::language::structure::NamedElement) then&#xA;&#x9;&#x9;&#x9;&#x9;elem ?= elem.container&#xA;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;elem := void&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns the qualified name of this named element. Qualified name is &#xA;&#x9; * the list of the names of the packages hierarchically ordered, delimited by&#xA;&#x9; * a &quot;::&quot;, followed by the name of this named element.&#xA;&#x9; */"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="name" lowerBound="1" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Name of this named element"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Class" eSuperTypes="/2/language/structure/ParameterizedType">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Returns the Attributes, References, and derived Properties owned by&#xA;the ClassDefinition of this Class."/>
          </eAnnotations>
          <eOperations name="clone" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta" references="/2/language/structure/Type/clone">
              <details key="body" value="do&#xA;&#x9;result := extern fr::irisa::triskell::kermeta::runtime::language::Class.cloneObject(self, objectToClone)&#xA;end"/>
              <details key="CompilerIgnore" value="true"/>
              <details key="superOperation" value="kermeta::language::structure::Type"/>
            </eAnnotations>
            <eParameters name="objectToClone" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="deepClone" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta" references="/2/language/structure/Type/deepClone">
              <details key="body" value="do&#xA;&#x9;result := extern fr::irisa::triskell::kermeta::runtime::language::Class.deepCloneObject(self, objectToClone)&#xA;end"/>
              <details key="CompilerIgnore" value="true"/>
              <details key="superOperation" value="kermeta::language::structure::Type"/>
            </eAnnotations>
            <eParameters name="objectToClone" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="new" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := extern fr::irisa::triskell::kermeta::runtime::language::Class.newObject(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Instantiates a new occurence for this Class&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="equals" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::Class.equals(self, other)&#xA;end"/>
              <details key="CompilerIgnore" value="true"/>
              <details key="superOperation" value="kermeta::language::structure::Object"/>
            </eAnnotations>
            <eParameters name="other" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="toString" eType="/2/language/structure/String">
            <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
              <details key="body" value="do&#xA;&#x9;result := self.typeDefinition.name&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Returns the String representation of this class. &#xA;&#x9; *  Note : throws an exception if this class has no classDefinition&#xA;&#x9; *  or if the classDefinition is not well constructed.&#xA;&#x9; */"/>
              <details key="superOperation" value="kermeta::language::structure::Object"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ownedOperation" upperBound="-1" eType="/2/language/structure/Operation" changeable="false" volatile="true" transient="true" derived="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Returns the Operations owned by the ClassDefinition of this Class."/>
              <details key="isReadOnly" value="true"/>
            </eAnnotations>
            <eAnnotations source="kermetaderivedProp.getter">
              <details key="body" value="do&#xA;&#x9;var cDef : kermeta::language::structure::ClassDefinition&#xA;&#x9;cDef ?= typeDefinition&#xA;&#x9;result := cDef.ownedOperation&#xA;end"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="superClass" ordered="false" upperBound="-1" eType="/2/language/structure/Class" changeable="false" volatile="true" transient="true" derived="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Returns the Classes of which the ClassDefinition of this Class inherits."/>
              <details key="isReadOnly" value="true"/>
            </eAnnotations>
            <eAnnotations source="kermetaderivedProp.getter">
              <details key="body" value="do&#xA;&#x9;var cDef : kermeta::language::structure::ClassDefinition&#xA;&#x9;cDef ?= typeDefinition&#xA;&#x9;var supertypes : kermeta::standard::OrderedSet&lt;kermeta::language::structure::Class> init kermeta::standard::OrderedSet&lt;kermeta::language::structure::Class>.new&#xA;&#x9;cDef.superType.each{elem | do&#xA;&#x9;&#x9;&#x9;if kermeta::language::structure::Class.isInstance(elem) then&#xA;&#x9;&#x9;&#x9;&#x9;var c : kermeta::language::structure::Class&#xA;&#x9;&#x9;&#x9;&#x9;c ?= elem&#xA;&#x9;&#x9;&#x9;&#x9;supertypes.add(c)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}&#xA;&#x9;result := supertypes&#xA;end"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isAbstract" eType="/2/language/structure/Boolean" changeable="false" volatile="true" transient="true" derived="true">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Returns a Boolean stating whether ClassDefinition of this Class is abstract."/>
              <details key="isReadOnly" value="true"/>
            </eAnnotations>
            <eAnnotations source="kermetaderivedProp.getter">
              <details key="body" value="do&#xA;&#x9;var cDef : kermeta::language::structure::ClassDefinition&#xA;&#x9;cDef ?= typeDefinition&#xA;&#x9;result := cDef.isAbstract&#xA;end"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="name" eType="/2/language/structure/String" changeable="false" volatile="true" transient="true" derived="true">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Returns the name of the ClassDefinition of this Class"/>
              <details key="isReadOnly" value="true"/>
            </eAnnotations>
            <eAnnotations source="kermetaderivedProp.getter">
              <details key="body" value="do&#xA;&#x9;result := typeDefinition.name&#xA;end"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="classDefinition" eType="/2/language/structure/ClassDefinition" changeable="false" volatile="true" transient="true" derived="true">
            <eAnnotations source="kermeta">
              <details key="documentation" value="/**&#xA;&#x9; * Returns the ClassDefinition for this class&#xA;&#x9; */"/>
              <details key="isReadOnly" value="true"/>
            </eAnnotations>
            <eAnnotations source="kermetaderivedProp.getter">
              <details key="body" value="do&#xA;&#x9;result ?= typeDefinition&#xA;end"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ownedAttribute" ordered="false" upperBound="-1" eType="/2/language/structure/Property" changeable="false" volatile="true" transient="true" derived="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Returns the Attributes, References, and derived Properties owned by&#xA;the ClassDefinition of this Class."/>
              <details key="isReadOnly" value="true"/>
            </eAnnotations>
            <eAnnotations source="kermetaderivedProp.getter">
              <details key="body" value="do&#xA;&#x9;var cDef : kermeta::language::structure::ClassDefinition&#xA;&#x9;cDef ?= typeDefinition&#xA;&#x9;result := cDef.ownedAttribute&#xA;end"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="DataType" abstract="true" eSuperTypes="/2/language/structure/Type /2/language/structure/TypeDefinition">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Special type definition for Enumeration, PrimitiveType"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Enumeration" eSuperTypes="/2/language/structure/DataType">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Definition for Enumeration"/>
          </eAnnotations>
          <eOperations name="clone" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta" references="/2/language/structure/Type/clone">
              <details key="body" value="do&#xA;&#x9;raise &quot;NOT IMPLEMENTED&quot;&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * Implements kermeta::language::structure::Type.clone(Object)&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
              <details key="superOperation" value="kermeta::language::structure::Type"/>
            </eAnnotations>
            <eParameters name="objectToClone" eType="/2/language/structure/Object"/>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ownedLiteral" upperBound="-1" eType="/2/language/structure/EnumerationLiteral" containment="true" eOpposite="/2/language/structure/EnumerationLiteral/enumeration">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Owned items in an Enumeration"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Package" eSuperTypes="/2/language/structure/NamedElement /2/language/structure/TypeDefinitionContainer">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Package in kermeta. Each kermeta model must have a root package. "/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="nestingPackage" eType="/2/language/structure/Package" eOpposite="/2/language/structure/Package/nestedPackage">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="ecore.isTransient" value="true"/>
              <details key="documentation" value="Owning Package, if any"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="nestedPackage" upperBound="-1" eType="/2/language/structure/Package" containment="true" eOpposite="/2/language/structure/Package/nestingPackage">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Nested Packages contained by the Package"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="uri" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Uri of the Package"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Parameter" eSuperTypes="/2/language/structure/MultiplicityElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Definition for operation parameter"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="operation" eType="/2/language/structure/Operation" eOpposite="/2/language/structure/Operation/ownedParameter">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="ecore.isTransient" value="true"/>
              <details key="documentation" value="Owning operation"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="PrimitiveType" eSuperTypes="/2/language/structure/DataType /2/language/structure/TypeContainer">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="The class definition for kermeta aliases. Above statement defines a primitive&#xD;&#xA;type called MyString, which instanceType is &lt;code>kermeta::standard::String&lt;/code>&#xD;&#xA;&lt;pre>alias MyString : kermeta::standard::String&lt;/pre>. Another example could be: &lt;code>root::apackage::AClass&lt;/code>&#xD;&#xA;&lt;pre>alias MyClass : root::apackage::AClass&lt;/pre>, thus a primitive type may be not a subtype of ValueType (ValueType is a concept from the Kermeta framework)."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="instanceType" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="The type the primitive type is linked with"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Tag" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Tag is intended to be used to add documentation on a  model element,&#xA;or add some textual information that cannot be expressed with any&#xA;model element definition."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="name" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Name of the Tag"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="value" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="String value of the Tag"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="object" lowerBound="1" upperBound="-1" eType="/2/language/structure/Object" eOpposite="/2/language/structure/Object/tag">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Objects to which the Tag is attached to"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Constraint" eSuperTypes="/2/language/structure/NamedElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Constraint is part of a contract implementation in a Class definition or an operation.&#xA;Three kinds of constraints are available : pre, post, and inv (invariant constraint)"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="body" ordered="false" lowerBound="1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Body of the constraint, expressed as a KerMeta expression"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="preOwner" eType="/2/language/structure/Operation" eOpposite="/2/language/structure/Operation/pre">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Owning Operation if Constraint corresponds to pre-condition"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="stereotype" eType="/2/language/structure/ConstraintType">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Type of the Constraint (precond/postcond/inv)"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="postOwner" eType="/2/language/structure/Operation" eOpposite="/2/language/structure/Operation/post">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Owning Operation if Constraint corresponds to post-condition"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="language" eType="/2/language/structure/ConstraintLanguage">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Language in which the constraint is expressed"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="invOwner" eType="/2/language/structure/ClassDefinition" eOpposite="/2/language/structure/ClassDefinition/inv">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Owning ClassDefinition if Constraint corresponds to invariant"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EEnum" name="ConstraintType">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
          </eAnnotations>
          <eLiterals name="inv" literal="inv"/>
          <eLiterals name="pre" value="1" literal="pre"/>
          <eLiterals name="post" value="2" literal="post"/>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EEnum" name="ConstraintLanguage">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
          </eAnnotations>
          <eLiterals name="kermeta" literal="kermeta"/>
          <eLiterals name="ocl" value="1" literal="ocl"/>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="GenericTypeDefinition" abstract="true" eSuperTypes="/2/language/structure/TypeDefinition">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Abstracts the definition of generic type definitions (i.e. type definitions that&#xA;can be parameterized), namely, for ClassDefinition and ModelTypeDefinition."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="typeParameter" upperBound="-1" eType="/2/language/structure/TypeVariable" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Type variables defined for the GenericTypeDefinition"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="ParameterizedType" abstract="true" eSuperTypes="/2/language/structure/Type">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Abstraction for Parameterized types, namely, Class and ModelType"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="typeParamBinding" upperBound="-1" eType="/2/language/structure/TypeVariableBinding" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Bindings between type variables and provided types "/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="typeDefinition" lowerBound="1" eType="/2/language/structure/GenericTypeDefinition">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Definition of the Type"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="virtualTypeBinding" upperBound="-1" eType="/2/language/structure/TypeVariableBinding" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="TypeVariable" abstract="true" eSuperTypes="/2/language/structure/TypeContainer /2/language/structure/Type /2/language/structure/NamedElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Definition of a type variable for generic types :  &#xA;in class definition &lt;pre>class AClass&lt;X,Y> {}&lt;/pre>, X and Y are type variables."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="supertype" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Reference to the supertype, if any"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="ObjectTypeVariable" eSuperTypes="/2/language/structure/TypeVariable">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="To be written"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="ModelType" eSuperTypes="/2/language/structure/Type /2/language/structure/TypeDefinition">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Type of a model, consisting of a set of included type definitions"/>
          </eAnnotations>
          <eOperations name="new" eType="/2/language/structure/Model">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::ModelType.newObject(self)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * To be written ##########################################&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="isModelTypeOf" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::ModelType.isModelTypeOf(self, m)&#xA;end"/>
              <details key="documentation" value="/**&#xA;&#x9; * To be written ##########################################&#xA;&#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="m" eType="/2/language/structure/Model"/>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="includedTypeDefinition" upperBound="-1" eType="/2/language/structure/TypeDefinition">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="ModelTypeVariable" eSuperTypes="/2/language/structure/TypeVariable">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="To be written"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="virtualType" upperBound="-1" eType="/2/language/structure/VirtualType" containment="true" eOpposite="/2/language/structure/VirtualType/modelType">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="VirtualType" eSuperTypes="/2/language/structure/ObjectTypeVariable">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="To be written"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="modelType" lowerBound="1" eType="/2/language/structure/ModelTypeVariable" eOpposite="/2/language/structure/ModelTypeVariable/virtualType">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="typeParamBinding" upperBound="-1" eType="/2/language/structure/TypeVariableBinding" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="classDefinition" lowerBound="1" eType="/2/language/structure/ClassDefinition">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Model" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Is the holder of a set of model elements (Object) that are compatible with the ModelType that has &#xA;instantiated this Model."/>
          </eAnnotations>
          <eOperations name="addCompatible" eType="/2/language/structure/Object">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;contents&#xA;&#x9;result := extern fr::irisa::triskell::kermeta::runtime::language::Model.addCompatible(self, objectToAdd)&#xA;end"/>
              <details key="documentation" value="/**&#xA; &#x9; * Add the Object if it is copmpatible with the ModelDefinition. Other objects are ignored.&#xA; &#x9; * Returns the object if it has been added (One can check that some element have been ignored or not)&#xA; &#x9; * return Void if not added&#xA; &#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="objectToAdd" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="remove">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::ReflectiveCollection.remove(contents, obj)&#xA;end"/>
              <details key="documentation" value="/**&#xA; &#x9; * Remove an object from the model&#xA; &#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="obj" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="addAllCompatible">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;kermeta::language::structure::Object>.new&#xA;&#x9;objectsToAdd.each{obj | do&#xA;&#x9;&#x9;&#x9;var addedObject : kermeta::language::structure::Object init addCompatible(obj)&#xA;&#x9;&#x9;&#x9;if addedObject.isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;result.add(obj)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}&#xA;end"/>
              <details key="documentation" value="/**&#xA; &#x9; * Add all the Object of the collection that are copmpatible with the ModelDefinition. Other objects are ignored.&#xA; &#x9; * Returns the list of Object that have been added (One can check that some element have been ignored or not)&#xA; &#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eGenericType eClassifier="/2/standard/Collection">
              <eTypeArguments eClassifier="/2/language/structure/Object"/>
            </eGenericType>
            <eParameters name="objectsToAdd">
              <eGenericType eClassifier="/2/standard/Collection">
                <eTypeArguments eClassifier="/2/language/structure/Object"/>
              </eGenericType>
            </eParameters>
          </eOperations>
          <eOperations name="add">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;contents&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Model.add(self, obj)&#xA;end"/>
              <details key="documentation" value="/**&#xA; &#x9; * Add an object to the model. According to the ModelType, the typechecker will statically verify if the object can be added or not&#xA; &#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eParameters name="obj" eType="/2/language/structure/Object"/>
          </eOperations>
          <eOperations name="filter">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := contents.~select{o | do&#xA;&#x9;&#x9;&#x9;typeName.isInstance(o)&#xA;&#x9;&#x9;end}.asSet&#xA;end"/>
              <details key="documentation" value="/**&#xA; &#x9; * Returns a set of all the elements of the model that are instance of the given Type&#xA; &#x9; */"/>
              <details key="CompilerIgnore" value="true"/>
            </eAnnotations>
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eClassifier="/2/language/structure/Object"/>
            </eGenericType>
            <eParameters name="typeName" eType="/2/language/structure/Type"/>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="contents" upperBound="-1" eType="/2/language/structure/Object" changeable="false">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Contents of this model..."/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="ModelingUnit" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="The modeling unit is the root of any kermeta model. It contains packages, requires and usings.&#xA;It also reference others modeling unit."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="usings" upperBound="-1" eType="/2/language/structure/Using" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Set of &quot;using&quot; statement associated with this ModelingUnit. Ie. list of &quot;syntatic shortcut&quot;&#xA;that can be used within this unit."/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="includeFilters" upperBound="-1" eType="/2/language/structure/Filter" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="list of filters that apply to this modeling unit.&#xA;This means that if the same unit was loaded without this filters, it would have loaded more content&#xA;only element whose qualified name begins with one of these filter will be loaded in the unit"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="packages" upperBound="-1" eType="/2/language/structure/Package" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="root packages contained by this ModelingUnit"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="excludeFilters" upperBound="-1" eType="/2/language/structure/Filter" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="list of filters that apply to this modeling unit.&#xA;This means that if the same unit was loaded without this filters, it would have loaded more content&#xA;element whose qualified name begins with one of these filter will NOT be loaded in the unit"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="referencedModelingUnits" upperBound="-1" eType="/2/language/structure/ModelingUnit">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="requires" upperBound="-1" eType="/2/language/structure/Require" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Set of &quot;require&quot; statements associated with this ModelingUnit. Ie. list of the other&#xA;files required to run this unit"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Require" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="To be written"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="uri" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Using" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="To be written"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="qualifiedName" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Filter" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Filter is the class that represent a filter on a ModelingUnit.&#xA;the qualifiedName represent the beginning of the matched names"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="qualifiedName" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="ProductType" eSuperTypes="/2/language/structure/TypeContainer /2/language/structure/Type">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Type corresponding to a set of Types&#xA;Only used in the context of FunctionType"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="type" unique="false" upperBound="-1" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Types "/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="FunctionType" eSuperTypes="/2/language/structure/TypeContainer /2/language/structure/Type">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Type used to define the use of lambda expressions.&#xA; Uses :&#xA; &lt;pre>operation forAll(func : &lt;G -> Boolean>) : Boolean is do&#xA;     var test : Boolean init true&#xA;     from var it : Iterator&lt;G> init iterator&#xA;     until it.isOff&#xA;     loop&#xA;        test := test and func(it.next)&#xA;     end&#xA;     result := test&#xA; end&#xA; &lt;/pre>&#xA; *&#xA; In the above example, &amp;lt;G -> Boolean&amp;gt; is a function type f(G) -&amp;gt; &#xA; Boolean, with a parameter of type G and a return type of type Boolean&#xA; The operation &lt;code>forAll&lt;/code> takes a lambda expression as parameter."/>
          </eAnnotations>
          <eAnnotations source="kermeta.inv">
            <details key="resultType_must_not_be_a_ProductType" value="right.isKindOf(kermeta::language::structure::ProductType).~not"/>
          </eAnnotations>
          <eAnnotations source="kermeta.inv.doc" references="/2/language/structure/FunctionType/%kermeta.inv%">
            <details key="documentation" value="/**&#xA;&#x9; * Right part of the FunctionType cannot be a ProductType&#xA;&#x9; */"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="left" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Parameters of the function (a ProductType for multiple parameters)"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="right" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Result type of the function"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="VoidType" eSuperTypes="/2/language/structure/Type">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Class definition for the &lt;pre>Void&lt;/pre> type"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="TypeDefinitionContainer" abstract="true" eSuperTypes="/2/language/structure/NamedElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Abstraction of the notion of containment for type definitions. Now, kermeta metamodel contains one container&#xA;element, that is Package. In a later release, ModelTypeDefinition will be the main container for type and&#xA;package definition."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ownedTypeDefinition" upperBound="-1" eType="/2/language/structure/TypeDefinition" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Contained TypeDefinitions"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
      </eSubpackages>
      <eSubpackages name="behavior" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/language/behavior" nsPrefix="behavior">
        <eAnnotations source="kermeta">
          <details key="ecore" value="true"/>
        </eAnnotations>
        <eClassifiers xsi:type="ecore:EClass" name="CallExpression" abstract="true" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Any callable expression inherits this class, e.g : &#xA;  - variable call&#xA;  - feature call ( &lt;code>a.b&lt;/code> : b is a feature call)&#xA;&#xA;&lt;img alt=&quot;&quot;  height=&quot;90%&quot; width=&quot;90%&quot;  src=&quot;http://www.kermeta.org/docs/html.single/KerMeta-Manual/KerMeta-Manual_figures/kermeta_call_expressions.png&quot; />"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="staticTypeVariableBindings" upperBound="-1" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="name" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="A call must be named"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="parameters" upperBound="-1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Kermeta calls can embedd expressions as parameters"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Expression" abstract="true" eSuperTypes="/2/language/structure/TypeContainer">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="The base class for every entity used to define a behavior in operation body."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="staticType" eType="/2/language/structure/Type">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Type of the Expression (set by type checking)"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="CallVariable" eSuperTypes="/2/language/behavior/CallExpression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="We call &quot;CallVariable&quot; the use of a variable in a statement.&#xA;in &lt;code>i := j + 1&lt;/code>, i and j are 2 CallVariables."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isAtpre" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Tells whether this CallVariable represents a call to @pre in a postcondition"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="CallFeature" eSuperTypes="/2/language/behavior/CallExpression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="CallFeature is the model element that refers to the use of a feature, i.e either &#xA;a property or an operation in a statement. In &lt;code>stdio.writeln(&quot;hello&quot;)&lt;/code>, &#xA;&lt;code>writeln&lt;/code> is a CallFeature."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="staticOperation" eType="/2/language/structure/Operation">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="The method which will be executed (operation case)&#xA;and the result value passed to the caller"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isAtpre" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Tells whether this CallFeature represents a call to @pre in a postcondition"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="target" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Target Expression (the owner of the feature)"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="staticEnumLiteral" eType="/2/language/structure/EnumerationLiteral">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="staticProperty" eType="/2/language/structure/Property">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="The object which will be returned (property case)"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="CallSuperOperation" eSuperTypes="/2/language/behavior/CallExpression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="This class represents a call to the operataion in the parent class&#xA;&#x9;In the following example, the type of super(element) is CallSuperOperation:&#xA;&#xA;class ParentClass {&#xA;  operation op(element : Integer) : Integer is do&#xA;      result := element + 1&#xA;  end&#xA;}&#xA; *&#xA;class ChildClass {&#xA;  method op(element : Integer) : Integer is do&#xA;      result := super(element)&#xA;  end&#xA;}"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="CallResult" eSuperTypes="/2/language/behavior/CallVariable">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="This class represents a call to the special internal variable &quot;result&quot; that is used to store the return value of any operation "/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="CallValue" eSuperTypes="/2/language/behavior/CallExpression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="CallValue refers to the use of the &lt;code>value&lt;/code> reserved keyword. This keyword is&#xA;only used in the body of the &lt;code>setter&lt;/code> part of derived properties."/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Assignment" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Assignment is the model-element representation of the assignment statement &lt;code>x := y&lt;/code>&#xA;&lt;img alt=&quot;&quot; src=&quot;http://www.kermeta.org/docs/html.single/KerMeta-Manual/KerMeta-Manual_figures/kermeta_assign_expressions.png&quot;/>"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="value" lowerBound="1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Value to be assigned, as a KerMeta expression"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="target" lowerBound="1" eType="/2/language/behavior/CallExpression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Target of the assignment, as a CallExpression"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isCast" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Boolean stating whether current assignment corresponds to a cast operation "/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Block" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Block is the model-element representation for the &lt;code>do...end&lt;/code> block."/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="statement" upperBound="-1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="List of statements composing the block"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="rescueBlock" upperBound="-1" eType="/2/language/behavior/Rescue" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="List of rescues defined for the block"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Conditional" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Condition is the model-element representation for the &lt;code>&lt;/code> "/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="thenBody" lowerBound="1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Then part of the conditional statement"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="condition" lowerBound="1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Condition expression of conditional statement"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="elseBody" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Optional else part of the conditional statement"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Raise" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Refers to raise exception block"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="expression" lowerBound="1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written #######################"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Rescue" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Refers to rescue exception block"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="exceptionName" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Name of the catched exception"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="body" lowerBound="1" upperBound="-1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Body of the rescue block, specified as a KerMeta expression"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="exceptionType" lowerBound="1" eType="/2/language/behavior/TypeReference" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Type of the cathed exception"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="TypeReference" eSuperTypes="/2/language/structure/MultiplicityElement">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="TypeReference refers to the type used in a variable declaration"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Literal" abstract="true" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Literal refers to String values, Integer values, etc."/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="EmptyExpression" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="As suggested by its name, this class represents an expression that do nothing. Like a &quot;nop&quot;"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="JavaStaticCall" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="This class represent a call to an extern Java operation. &#xA;This Java operation must be static and have at least one RuntimeO"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="jmethod" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Name of the Java method to be launched in the identified Java class"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="parameters" upperBound="-1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Parameters of the Java static call provided as KerMeta expressions"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="jclass" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Qualified name of the targeted Java class"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="LambdaExpression" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Refers to lambda expression definition (&lt;code>function { e | stdio.writeln(e.toString) }&lt;/code>)&#xA;&lt;img alt=&quot;&quot; src=&quot;http://www.kermeta.org/docs/html.single/KerMeta-Manual/KerMeta-Manual_figures/kermeta_lambda_expressions.png&quot;/>"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="body" lowerBound="1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Body of the lambda expression providede as a KerMeta expression"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="parameters" upperBound="-1" eType="/2/language/behavior/LambdaParameter" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Parameters of the lambda expression"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="LambdaParameter" eSuperTypes="/2/language/structure/Object">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Refers to parameter definition in lambda expression"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="name" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Name of the lambda parameter"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="type" lowerBound="1" eType="/2/language/behavior/TypeReference" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="To be written ################################"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="IntegerLiteral" eSuperTypes="/2/language/behavior/Literal">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="This expression is a literal representing an Integer value"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="value" eType="/2/language/structure/Integer">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="The concrete value represented by this literal"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="StringLiteral" eSuperTypes="/2/language/behavior/Literal">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="This expression is a literal representing a String value, typically : &quot;my string&quot;"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="value" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="The concrete value represented by this literal"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="BooleanLiteral" eSuperTypes="/2/language/behavior/Literal">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="This expression is a literal representing a Boolean value, typically : true or false keyword"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="value" eType="/2/language/structure/Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="The concrete value represented by this literal"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="TypeLiteral" eSuperTypes="/2/language/behavior/Literal">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="This expression is a literal representing a Type.&#xA;for example, in &#xA;   Integer.new&#xA;Integer is a type literal representing the type kermeta::standard::Integer"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="typeref" lowerBound="1" eType="/2/language/behavior/TypeReference" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="The type refered by this literal"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="VoidLiteral" eSuperTypes="/2/language/behavior/Literal">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="This class is used to represent the special expression void"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="Loop" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Loop refers to &lt;code>from var x : X init a until booleanCondition loop ... end&lt;/code>"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="initialization" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Initialization expression for the loop"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="body" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Body of the loop"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="stopCondition" lowerBound="1" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Stop condition of the loop, is interpreted as a Bollean value"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="SelfExpression" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="Refers to &lt;code>self&lt;/code> use"/>
          </eAnnotations>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="VariableDecl" eSuperTypes="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="ecore" value="true"/>
            <details key="documentation" value="refers to variable declaration &lt;code>var x : X init a&lt;/code>&#xA;&lt;img alt=&quot;&quot; src=&quot;http://www.kermeta.org/docs/html.single/KerMeta-Manual/KerMeta-Manual_figures/kermeta_var_expressions.png&quot;/>"/>
          </eAnnotations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="initialization" eType="/2/language/behavior/Expression" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Initialization expression for the variable&#xA;Default value is &lt;code>void&lt;/code> ????"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="type" lowerBound="1" eType="/2/language/behavior/TypeReference" containment="true">
            <eAnnotations source="kermeta">
              <details key="ecore" value="true"/>
              <details key="documentation" value="Type of the declared variable"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="identifier" eType="/2/language/structure/String">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
              <details key="ecore" value="true"/>
              <details key="documentation" value="Initialization expression for the variable&#xA;Default value is &lt;code>void&lt;/code> ????"/>
            </eAnnotations>
          </eStructuralFeatures>
        </eClassifiers>
      </eSubpackages>
    </eSubpackages>
    <eSubpackages name="standard" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/standard" nsPrefix="standard">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/**&#xA; * Contains types dedicated to dealing with java objects&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/java_package.png&quot;/>&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="Void" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The class Void &#xA; * By convention it is a sub-type of everything&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="isVoid" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/isVoid">
            <details key="body" value="do&#xA;&#x9;result := true&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Return true&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isInstanceOf" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/isInstanceOf">
            <details key="body" value="do&#xA;&#x9;result := true&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="type" eType="/2/language/structure/Type"/>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result := &quot;&lt;void>&quot;&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the String identifier '&lt;void>'&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ValueType" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The abstract class ValueType does not contain any feature.&#xA; * However, any instance of a sub-class of ValueType will be passed by value &#xA; * instead of by reference for any other objects.&#xA; * that means that each time you := such object it will call the clone function associated to it (Not implemented yet except for Integer, String and boolean!!!)&#xA; * &#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Comparable" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The abstract class Comparable defines a set of operation&#xA; * to compare instances of a class.&#xA; * Sub-classes only has to implement abstract operation compareTo.&#xA; * All other methods are defined w.r.t. the compareTo operation&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="isLower" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((self.compareTo(other)) &lt; (0))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return true if self &lt; other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="isGreaterOrEqual" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((self.compareTo(other)) >= (0))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return true if self >= other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="compareTo" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * This method should be implemented by any class that inherits&#xA;&#x9; * from Comparable.&#xA;&#x9; * returns 0 if self = other&#xA;&#x9; * returns > 0 if  self > other&#xA;&#x9; * returns &lt; 0 if  self &lt; other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="isLowerOrEqual" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((self.compareTo(other)) &lt;= (0))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return true if self &lt;= other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="isGreater" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((self.compareTo(other)) > (0))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return true if self > other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Summable" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The abstract class Summable defines a set of operation&#xA; * to sum instances of a class.&#xA; * Sub-classes only has to implement abstract operation plus.&#xA;  */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="plus">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Summarization method to be implemented by any summable class.&#xA;&#x9; * The parameter must have the same type (or one of its subtypes)&#xA;&#x9; *  than the current object .&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/Summable/G"/>
          <eParameters name="other">
            <eGenericType eTypeParameter="/2/standard/Summable/G"/>
          </eParameters>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="NotComparableException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * raised when two objects are not comparable&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Boolean" eSuperTypes="/2/standard/ValueType">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The Boolean type&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="not" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Boolean.~not(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return not self&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="xor" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((((self) and (other.~not))) or (((self.~not) and (other))))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return self xor other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Boolean) then&#xA;&#x9;&#x9;result := false&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Boolean.equals(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if &lt;code>other&lt;/code> type is Boolean&#xA;&#x9; * and has the same boolean value than current object.&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="or" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Boolean.~or(self, other)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return self or other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="implies" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((self.~not) or (other))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return self implies other&#xA;&#x9; * http://en.wikipedia.org/wiki/Material_implication&#xA;&#x9; * meaning : (not self) or other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="nand" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((self) and (other)).~not&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return self nand other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Boolean"/>
        </eOperations>
        <eOperations name="orElse" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if self then&#xA;&#x9;&#x9;result := true&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result := right(void)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Short-circuit version of OR. This means that the function passed in parameter will be evaluated only if self is false&#xA;&#x9; * Note: we don't have a dedicated operator in the syntax for it yet so here is an example of use :&#xA;&#x9; *   self.orElse{v | functionThatReturnABoolean() }&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="right" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="Void"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result := if self then&#xA;&#x9;&#x9;&quot;true&quot;&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;&quot;false&quot;&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns 'true' or 'false', depending on self  value&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="andThen" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if self then&#xA;&#x9;&#x9;result := right(void)&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result := false&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Short-circuit version of AND. This means that the function passed in parameter will be evaluated only if self is true&#xA;&#x9; * Note: we don't have a dedicated operator in the syntax for it yet so here is an example of use :&#xA;&#x9; *   self.andThen{v | functionThatReturnABoolean() }&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="right" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="Void"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="and" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Boolean.~and(self, other)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return self and other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Boolean"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Numeric" abstract="true" eSuperTypes="/2/standard/Comparable /2/standard/ValueType">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The abstract class Numeric is the root class for all&#xA; * numeric types&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Integer" eSuperTypes="/2/standard/Numeric /2/standard/Summable">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The class Integer&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="plus" eType="/2/standard/Integer">
          <eAnnotations source="kermeta" references="/2/standard/Summable/plus">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.plus(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self + other&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Summable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="isLower" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/standard/Comparable/isLower">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Integer) then&#xA;&#x9;&#x9;if other.getMetaClass.equals(kermeta::standard::Real) then&#xA;&#x9;&#x9;&#x9;result := ((self.toReal) &lt; (other))&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.isLower(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return true if self &lt; other&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Comparable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="mult" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.times(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self * other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="minus" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.minus(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self - other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Integer) then&#xA;&#x9;&#x9;if other.getMetaClass.equals(kermeta::standard::Real) then&#xA;&#x9;&#x9;&#x9;result := self.toReal.equals(other)&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.equals(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if &lt;code>other&lt;/code> type is Integer or Real&#xA;&#x9; * and has the same numeric value than current object.&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="mod" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if other.equals(0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::DivisionByZero.new&#xA;&#xA;&#x9;end&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.mod(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self modulo other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="toReal" eType="/2/standard/Real">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.toReal(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Convert self as a Real&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="div" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if other.equals(0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::DivisionByZero.new&#xA;&#xA;&#x9;end&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.div(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self / other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="compareTo" eType="/2/standard/Integer">
          <eAnnotations source="kermeta" references="/2/standard/Comparable/compareTo">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Integer) then&#xA;&#x9;&#x9;if other.getMetaClass.equals(kermeta::standard::Real) then&#xA;&#x9;&#x9;&#x9;result := self.toReal.compareTo(other)&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;raise kermeta::standard::NotComparableException.new&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.compareTo(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Comparison&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Comparable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="isGreater" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/standard/Comparable/isGreater">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Integer) then&#xA;&#x9;&#x9;if other.getMetaClass.equals(kermeta::standard::Real) then&#xA;&#x9;&#x9;&#x9;result := ((self.toReal) > (other))&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.isGreater(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return true if self > other&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Comparable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="isGreaterOrEqual" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/standard/Comparable/isGreaterOrEqual">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Integer) then&#xA;&#x9;&#x9;if other.getMetaClass.equals(kermeta::standard::Real) then&#xA;&#x9;&#x9;&#x9;result := ((self.toReal) >= (other))&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.isGreaterOrEqual(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return true if self >= other&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Comparable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="uminus" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((0) - (self))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns -self&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="times">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;from var i : kermeta::standard::Integer init 0&#xA;&#x9;until ((i) >= (self))&#xA;&#x9;loop&#xA;&#x9;&#x9;body(i)&#xA;&#x9;&#x9;i := ((i) + (1))&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Iteration&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="body" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="kermeta::standard::Integer"/>
              <details key="1" value="alias Object : kermeta::language::structure::Object;"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.toString(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Numeric value in string format&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isLowerOrEqual" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/standard/Comparable/isLowerOrEqual">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Integer) then&#xA;&#x9;&#x9;if other.getMetaClass.equals(kermeta::standard::Real) then&#xA;&#x9;&#x9;&#x9;result := ((self.toReal) &lt;= (other))&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Integer.isLowerOrEqual(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * return true if self &lt;= other&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Comparable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Real" eSuperTypes="/2/standard/Numeric /2/standard/Summable">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * class Real&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="plus" eType="/2/standard/Real">
          <eAnnotations source="kermeta" references="/2/standard/Summable/plus">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.plus(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self + other&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Summable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Real"/>
        </eOperations>
        <eOperations name="mult" eType="/2/standard/Real">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.times(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self * other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Real"/>
        </eOperations>
        <eOperations name="minus" eType="/2/standard/Real">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.minus(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self - other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Real"/>
        </eOperations>
        <eOperations name="uminus" eType="/2/standard/Real">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := ((0.toReal) - (self))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns -self&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="toInteger" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.toInteger(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Convert self as an Integer&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Real) then&#xA;&#x9;&#x9;if other.getMetaClass.equals(kermeta::standard::Integer) then&#xA;&#x9;&#x9;&#x9;result := self.equals(other.asType(kermeta::standard::Integer).toReal)&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.equals(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if &lt;code>other&lt;/code> type is Integer or Real&#xA;&#x9; * and has the same numeric value than current object.&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="div" eType="/2/standard/Real">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if other.equals(0.toReal) then&#xA;&#x9;&#x9;raise kermeta::exceptions::DivisionByZero.new&#xA;&#xA;&#x9;end&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::VoidOperandError.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.div(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns self / other&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Real"/>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.toString(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns numeric value in string format&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="compareTo" eType="/2/standard/Integer">
          <eAnnotations source="kermeta" references="/2/standard/Comparable/compareTo">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Real) then&#xA;&#x9;&#x9;if other.getMetaClass.equals(kermeta::standard::Integer) then&#xA;&#x9;&#x9;&#x9;result := self.compareTo(other.asType(kermeta::standard::Integer).toReal)&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;raise kermeta::standard::NotComparableException.new&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Real.compareTo(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Comparison&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Comparable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Character" eSuperTypes="/2/standard/ValueType /2/standard/Comparable">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The class Character&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::Character) then&#xA;&#x9;&#x9;result := false&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Character.equals(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if &lt;code>other&lt;/code> type is Character&#xA;&#x9; * and has the same letter value than current object.&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Character.toString(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Conversion from Character to String&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="compareTo" eType="/2/standard/Integer">
          <eAnnotations source="kermeta" references="/2/standard/Comparable/compareTo">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::CallOnVoidTarget.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Character.compareTo(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Comparaison&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Comparable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="String" eSuperTypes="/2/standard/ValueType /2/standard/Comparable /2/standard/Summable">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The class String&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="plus" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/standard/Summable/plus">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.plus(self, other.toString)&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.plus(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns a new string self + other&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Summable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="append">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::CallOnVoidTarget.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::String.append(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Appends other at the end of self&#xA;&#x9; * A more efficient method is kermeta::utils::StringBuffer::append(other)&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
            <details key="body" value="do&#xA;&#x9;if other.getMetaClass.isNotEqual(kermeta::standard::String) then&#xA;&#x9;&#x9;result := false&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.equals(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if &lt;code>other&lt;/code> type is String&#xA;&#x9; * and has the same string value than current object.&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="toReal" eType="/2/standard/Real">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.toReal(self)&#xA;&#x9;if result.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::StringFormatException.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Parses the current string into a real.&#xA;&#x9; * if no real value is recognized then a StringFormatException is raised.&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="toBoolean" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.toBoolean(self)&#xA;&#x9;if result.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::StringFormatException.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Parses the current string and returns true if the string is &quot;true&quot; and false if the string is &quot;false&quot;&#xA;&#x9; * The parsing is not case sensitive and if no boolean value is recognized then a StringFormatException is raised.&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="contains" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.contains(self, str1)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Return if a string is contained by another string&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="str1" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="compareTo" eType="/2/standard/Integer">
          <eAnnotations source="kermeta" references="/2/standard/Comparable/compareTo">
            <details key="body" value="do&#xA;&#x9;if other.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::CallOnVoidTarget.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.compareTo(self, other)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Comparaison&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Comparable"/>
          </eAnnotations>
          <eParameters name="other" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="indexOf" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.indexOf(self, str)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns the index within this string of the first &#xA;&#x9; * occurrence of the specified substring&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="str" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="elementAt" eType="/2/standard/Character">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((((index) &lt; (0))) or (((index) > (((size) - (1)))))) then&#xA;&#x9;&#x9;raise kermeta::exceptions::StringIndexOutOfBound.new&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.elementAt(self, index)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns the character at index in the String&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="index" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="size" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.size(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns the number of characters in the current String&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="replace" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.replace(self, str1, str2)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Replaces all occurences of str1 in the current string by the string str2&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="str1" eType="/2/standard/String"/>
          <eParameters name="str2" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="toUpperCase" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.toUpperCase(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Return the current string in upper case&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="toInteger" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.toInteger(self)&#xA;&#x9;if result.isVoid then&#xA;&#x9;&#x9;raise kermeta::exceptions::StringFormatException.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Parses the current string into an integer.&#xA;&#x9; * if no integer value is recognized then a StringFormatException is raised.&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="toLowerCase" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.toLowerCase(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Return the current string in lower case&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="substring" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((((((((startIndex) >= (0))) and (((startIndex) &lt;= (size))))) and (((endIndex) &lt;= (size))))) and (((endIndex) >= (startIndex)))) then&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.substring(self, startIndex, endIndex)&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::StringIndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns a new string that is a substring of this string&#xA;&#x9; * takes as parameters : the startIndex and endIndex&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="startIndex" eType="/2/standard/Integer"/>
          <eParameters name="endIndex" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="split">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::String.split(self, delimiter)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Return of an ordered set of the splitted string&#xA;&#x9; * Note that the delimiter is a regular expression (as the split operation in java) &#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eClassifier="/2/standard/String"/>
          </eGenericType>
          <eParameters name="delimiter" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result := self&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * returns the string itself&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EDataType" name="UnlimitedNatural" instanceClassName="java.lang.Object">
        <eAnnotations source="kermeta">
          <details key="alias" value="kermeta::standard::Integer"/>
          <details key="documentation" value="/**&#xA; * Unlimited natural is used for reflection.&#xA; * It is mapped to integer.equals().&#xA; * Any negative number is interpreted as '*'&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EDataType" name="Object" instanceClassName="java.lang.Object">
        <eAnnotations source="kermeta">
          <details key="deprecated" value="please use directly kermeta::language::structure::Object"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Collection" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Collection is the root abstract class for all kermeta collections&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="reject">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.~select{elem | do&#xA;&#x9;&#x9;&#x9;rejector(elem).~not&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Sequence composed of elements of the Collection that&#xA;&#x9; * do not validate the rejector function&#xA;&#x9; * example :&#xA;&#x9; * aCollection2 := aCollection.reject { e | &#xA;     *     \/* put here a condition that returns true for elements that must  be exclude in the resulting Collection *\/&#xA;     * }&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
          </eGenericType>
          <eParameters name="rejector" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="count" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.~select{e | do&#xA;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;end}.size&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the number of instances of element in the Collection&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="remove">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G&#xA;&#x9;from elem := self.detect{e | do&#xA;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;end}&#xA;&#x9;until elem.equals(void)&#xA;&#x9;loop&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)&#xA;&#x9;&#x9;elem := self.detect{e | do&#xA;&#x9;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Removes all instances of element from the Collection, based on&#xA;&#x9; * G.equals(Object) definition&#xA;&#x9; */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.post">
            <details key="doesntContainsElementAnymore" value="contains(element).~not"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="excludes" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.contains(element).~not&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if the Collection does not contain element&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="indexedEach">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var index : kermeta::standard::Integer init 0&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;var context : kermeta::standard::EachContext init kermeta::standard::EachContext.new.initialize(index, index.equals(0), index.equals(((size) - (1))))&#xA;&#x9;&#x9;func(it.next, context)&#xA;&#x9;&#x9;index := ((index) + (1))&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Runs function func on each element of the Collection&#xA;&#x9; * the eachContext contains some information about the each process that can be used in the function, &#xA;&#x9; *  for example the index represents the rank in the collection, start on 0&#xA;&#x9; *  or boolean to indicates weither we are processing the first and/or the last element of the collection&#xA;&#x9; *  note that this rank is relative to the processing order. this processing order is ensured only for sequence and ordered set&#xA;&#x9; *&#xA;&#x9; * example : &#xA;&#x9; * aCollection.indexedEach { e, eachContext | \/* do something with each element e of this collection *\/ }&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="func" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::EachContext"/>
              <details key="2" value="alias Object : kermeta::language::structure::Object;"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="one">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if size.equals(0) then&#xA;&#x9;&#x9;result := void&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;result := it.next&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns an element from the Collection or void if the Collection is empty&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/Collection/G"/>
        </eOperations>
        <eOperations name="containsAll" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := true&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init elements.iterator&#xA;&#x9;until ((it.isOff) or (result.~not))&#xA;&#x9;loop&#xA;&#x9;&#x9;result := self.contains(it.next)&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if current Collection contains all elements of Collection elements&#xA;&#x9; * See Collection&lt;G>.contains(Object)&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Collection">
              <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="sum">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var res : G&#xA;&#x9;var tmp : kermeta::standard::Summable&lt;G>&#xA;&#x9;var o : G&#xA;&#x9;o := self.one&#xA;&#x9;tmp ?= o&#xA;&#x9;result := void&#xA;&#x9;if tmp.isNotEqual(void) then&#xA;&#x9;&#x9;self.each{elem | do&#xA;&#x9;&#x9;&#x9;&#x9;o := elem&#xA;&#x9;&#x9;&#x9;&#x9;tmp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if tmp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;res := tmp.plus(res)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;result := res&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Sum the element if they are summable (ie implement '+' operator by inheriting of the class Summable)&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/Collection/G"/>
        </eOperations>
        <eOperations name="contains" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := false&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until ((it.isOff) or (result))&#xA;&#x9;loop&#xA;&#x9;&#x9;result := it.next.equals(element)&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether the Collection contains at least one&#xA;&#x9; * instance of element, based on G.equals(elt : Object) definition&#xA;&#x9; * Note: for checking whether a physical element is contained by the collection,&#xA;&#x9; * make use of G.oid()&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="asSequence">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Sequence built from the Collection&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="add">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.add(self, element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Adds an element in the Collection (default implementation)&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="excludesAll" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := true&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init elements.iterator&#xA;&#x9;until ((it.isOff) or (result.~not))&#xA;&#x9;loop&#xA;&#x9;&#x9;result := self.contains(it.next).~not&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if the Collection contains no element of Collection elements&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Collection">
              <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="includes" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.contains(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * OCL API alignment, doeas the same as contains&#xA;&#x9; * See Collection&lt;G>.contains(Object)&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Collection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="clear">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.clear(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Removes all elements from the Collection&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isEmpty" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.empty&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * OCL alignment API, does the same as empty&#xA;&#x9; * See Collection&lt;G>.empty()&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="asBag">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Bag built from the Collection&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="isUnique" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := true&#xA;&#x9;var s : kermeta::standard::Sequence&lt;T> init kermeta::standard::Sequence&lt;T>.new&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until ((it.isOff) or (result.~not))&#xA;&#x9;loop&#xA;&#x9;&#x9;var t : T init collector(it.next)&#xA;&#x9;&#x9;if s.contains(t) then&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;s.add(t)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether the the collector function evaluates to a&#xA;&#x9; * different value for each element of the Collection&#xA;&#x9; * example :&#xA;&#x9; * aCollection2 := aCollection.isUnique { e | \/* put here an expression that must be unique for all elements, for example e.name *\/ }&#xA;&#x9; */"/>
          </eAnnotations>
          <eTypeParameters name="T"/>
          <eParameters name="collector" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="T"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="any">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if size.equals(0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::EmptyCollection.new&#xA;&#xA;&#x9;end&#xA;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;result := it.next&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns an element from the Collection&#xA;&#x9; * Raises an EmptyCollection exception if the Collection is empty&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/Collection/G"/>
        </eOperations>
        <eOperations name="empty" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := size.equals(0)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether the Collection is empty&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="forAllCpl" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.forAll{x | do&#xA;&#x9;&#x9;&#x9;self.forAll{y | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;f(x, y)&#xA;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Combinaison of ForAll on two elements in the collection &#xA;&#x9; * result := self.forAll{x | self.forAll {y | f(x,y)}}&#xA;&#x9; * (where x and y are 2 elements of the Collection)&#xA;&#x9; * typical use sample : ownedState.forAll{s1,s2| (s1.name==s2.name)implies(s1==s2)}&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="f" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="G"/>
              <details key="2" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="existsCpl" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.exists{x | do&#xA;&#x9;&#x9;&#x9;self.exists{y | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;f(x, y)&#xA;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Combinaison of exists on two elements in the collection&#xA;&#x9; * => result := self.exists{x | self.exists {y | f(x,y)}}&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="f" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="G"/>
              <details key="2" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="isNotEmpty" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.empty.~not&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * OCL alignment API&#xA;&#x9; * Returns a Boolean stating whether the Collection contains at least&#xA;&#x9; * one element &#xA;&#x9; * See also Collection&lt;G>.contains(Object)&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="detect">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G&#xA;&#x9;result := void&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until ((it.isOff) or (result.isNotEqual(void)))&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if detector(elem) then&#xA;&#x9;&#x9;&#x9;result := elem&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns an element of the Collection (usually the first) for which the detector function&#xA;&#x9; * is not false&#xA;&#x9; * Returns void if no elements is validated by the detector function&#xA;&#x9; * example : &#xA;&#x9; * anObject := aCollection.detect { e | \/* a condition *\/} // returns an element that fulfill the condition.&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/Collection/G"/>
          <eParameters name="detector" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="iterator">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Iterator&lt;G>.new&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.iterator(self, result)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns an Iterator on the Collection&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Iterator">
            <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="addAll">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;elements.each{element | do&#xA;&#x9;&#x9;&#x9;add(element)&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Adds all elements from the Collection elements in the current Collection&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Collection">
              <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="includesAll" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.containsAll(elements)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * OCL API alignment, does the same as containsAll&#xA;&#x9; * See Collection&lt;G>.containsAll(Collection&lt;G>)&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Collection">
              <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="select">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if selector(elem) then&#xA;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Sequence composed of elements of the Collection that&#xA;&#x9; * validate the selector function&#xA;&#x9; * example :&#xA;&#x9; * aCollection2 := aCollection.select { e | &#xA;     *    \/* put here a condition that returns true for elements that must  be included in the resulting Collection *\/&#xA;&#x9; * }&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
          </eGenericType>
          <eParameters name="selector" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="size" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.size(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the number of elements in the Collection&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="asOrderedSet">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new OrderedSet built from the Collection&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="forAll" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var test : kermeta::standard::Boolean init true&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;test := ((test) and (func(it.next)))&#xA;&#x9;end&#xA;&#x9;result := test&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether no element of the Collection invalidates&#xA;&#x9; * the condition specified by function func&#xA;&#x9; * example : &#xA;&#x9; * aBoolean := aCollection.forAll { e | \/* put here a condition *\/ } // return true if the condition is true for all elements in the collection.&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="func" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="exists" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var test : kermeta::standard::Boolean init false&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until ((it.isOff) or (test.isNotEqual(false)))&#xA;&#x9;loop&#xA;&#x9;&#x9;test := ((test) or (func(it.next)))&#xA;&#x9;end&#xA;&#x9;result := test&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a Boolean stating whether at least one element of the Collection&#xA;&#x9; * validates the condition specified by function func&#xA;&#x9; * example :&#xA;&#x9; * aBoolean := aCollection.exists { e | \/* a condition *\/} // returns true if at least one element fulfill the condition.&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="func" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="kermeta::standard::Boolean"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="each">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;func(it.next)&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Runs function func on each element of the Collection&#xA;&#x9; * example : &#xA;&#x9; * aCollection.each { e | \/* do something with each element e of this collection *\/ }&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="func" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="alias Object : kermeta::language::structure::Object;"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
        <eOperations name="asSet">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Set built from the Collection&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/standard/Collection/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="collect">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;T>.new&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;result.add(collector(it.next))&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Sequence which content corresponds to the result&#xA;&#x9; * of running the collector function for each element of the Collection&#xA;&#x9; * The new collection size is the same as in the original collection, and which element types is the type of the result of the expression.&#xA;&#x9; * example :&#xA;&#x9; * aCollection2 := aCollection.collect { e | \/* put here an expression, for example e.name *\/ } &#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments/>
          </eGenericType>
          <eTypeParameters name="T"/>
          <eParameters name="collector" eType="/2/_KermetaSpecialTypesAlias_">
            <eAnnotations source="kermeta.functionType">
              <details key="0" value="G"/>
              <details key="1" value="T"/>
            </eAnnotations>
          </eParameters>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EachContext" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * context used in the indexedEach of Collection&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="initialize" eType="/2/standard/EachContext">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;index := i&#xA;&#x9;isFirst := first&#xA;&#x9;isLast := last&#xA;&#x9;result := self&#xA;end"/>
          </eAnnotations>
          <eParameters name="i" eType="/2/standard/Integer"/>
          <eParameters name="first" eType="/2/standard/Boolean"/>
          <eParameters name="last" eType="/2/standard/Boolean"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isLast" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="index" eType="/2/standard/Integer" containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isFirst" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Set" eSuperTypes="/2/standard/Collection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * A Set is a non-ordered collection that contains distinct elements&#xA; * (with regards to the G.equals(Object) operation)&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="intersection">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;G>.new&#xA;&#x9;var elem : G&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if elements.contains(elem) then&#xA;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Set corresponding to the intersection of the Set elements&#xA;&#x9; * with the current Set&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Collection">
              <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="minus">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;G>.new&#xA;&#x9;var elem : G&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if elements.contains(elem).~not then&#xA;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Set corresponding to the difference between the&#xA;&#x9; * current Set and the Set elements, ie all elements contained by &#xA;&#x9; * the current Set that do not appear in the elements Set &#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="remove">
          <eAnnotations source="kermeta" references="/2/standard/Collection/remove">
            <details key="body" value="do&#xA;&#x9;var elem : G init self.detect{e | do&#xA;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;end}&#xA;&#x9;if elem.isNotEqual(void) then&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.remove(G)&#xA;&#x9; * Removes the element from the Set if it is contained by the Set&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Set/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
            <details key="body" value="do&#xA;&#x9;var isEqual : kermeta::standard::Boolean init false&#xA;&#x9;if element.isVoid.~not then&#xA;&#x9;&#x9;if kermeta::standard::Collection&lt;G>.isInstance(element) then&#xA;&#x9;&#x9;&#x9;var collection : kermeta::standard::Collection&lt;G>&#xA;&#x9;&#x9;&#x9;collection ?= element&#xA;&#x9;&#x9;&#x9;if self.size.equals(collection.size) then&#xA;&#x9;&#x9;&#x9;&#x9;var elem : G&#xA;&#x9;&#x9;&#x9;&#x9;var ok : kermeta::standard::Boolean init true&#xA;&#x9;&#x9;&#x9;&#x9;from var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;&#x9;&#x9;&#x9;until ((it.isOff) or (ok.~not))&#xA;&#x9;&#x9;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if collection.contains(elem).~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ok := false&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;isEqual := ok&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;result := isEqual&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Object.equals(Object)&#xA;&#x9; * Returns a Boolean stating whether the provided element is equal to&#xA;&#x9; * current Set&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="element" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="asSequence">
          <eAnnotations source="kermeta" references="/2/standard/Collection/asSequence">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Sequence&lt;G> init kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.asSequence()&#xA;&#x9; * Returns a new Sequence composed of all elements of current Set&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="add">
          <eAnnotations source="kermeta" references="/2/standard/Collection/add">
            <details key="body" value="do&#xA;&#x9;if self.contains(element).~not then&#xA;&#x9;&#x9;super(element)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.add(G)&#xA;&#x9; * Adds elt to the Set if it is not already contained by the&#xA;&#x9; * Set, does nothing otherwise&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Set/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="symmetricDifference">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var res : kermeta::standard::Set&lt;G> init s.minus(self)&#xA;&#x9;result := self.minus(s)&#xA;&#x9;result.addAll(res)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Set which contents corresponds to the symmetric&#xA;&#x9; * difference between current Set and Set s, ie all elements of&#xA;&#x9; * each Set that do not appear in the other one&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
          <eParameters name="s">
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="concatenate">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;result.addAll(less)&#xA;&#x9;result.addAll(pivot)&#xA;&#x9;result.addAll(greater)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Internal concatenation tool for recursive 'quickSort()' method&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
          <eParameters name="less">
            <eGenericType eClassifier="/2/standard/OrderedSet">
              <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
            </eGenericType>
          </eParameters>
          <eParameters name="pivot">
            <eGenericType eClassifier="/2/standard/OrderedSet">
              <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
            </eGenericType>
          </eParameters>
          <eParameters name="greater">
            <eGenericType eClassifier="/2/standard/OrderedSet">
              <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="flatten">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var res : kermeta::standard::Set&lt;kermeta::standard::Object> init kermeta::standard::Set&lt;kermeta::standard::Object>.new&#xA;&#x9;if G.isKindOf(kermeta::standard::Collection&lt;kermeta::standard::Object>) then&#xA;&#x9;&#x9;var col : kermeta::standard::Collection&lt;kermeta::standard::Object>&#xA;&#x9;&#x9;var o : kermeta::standard::Object&#xA;&#x9;&#x9;self.each{e | do&#xA;&#x9;&#x9;&#x9;&#x9;col ?= e&#xA;&#x9;&#x9;&#x9;&#x9;res.addAll(col)&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;result := res&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Set which content includes all non-Collection elements&#xA;&#x9; * of the current Set, and, for each Collection element of the current&#xA;&#x9; * Set, as many elements as the Collection contains&#xA;&#x9; * Duplicates are removed&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eClassifier="/2/standard/Object"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asOrderedSet">
          <eAnnotations source="kermeta" references="/2/standard/Collection/asOrderedSet">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::OrderedSet&lt;G> init kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.asOrderedSet()&#xA;&#x9; * Returns a new OrderedSet that contains all elements of current Set&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="asBag">
          <eAnnotations source="kermeta" references="/2/standard/Collection/asBag">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Bag&lt;G> init kermeta::standard::Bag&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.asBag()&#xA;&#x9; * Returns a new Bag composed of all elements of current Set&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="union">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.addAll(elements)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Set corresponding to the union of the Set elements&#xA;&#x9; * with the current Set&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="unionWithBag">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Bag&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.addAll(elements)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Bag corresponding to the union of the Bag elements&#xA;&#x9; * with the current Set&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Bag">
              <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="asSet">
          <eAnnotations source="kermeta" references="/2/standard/Collection/asSet">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Set&lt;G> init kermeta::standard::Set&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.asSet()&#xA;&#x9; * Returns a new Set composed of all elements of current Set&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/standard/Set/G"/>
          </eGenericType>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Bag" eSuperTypes="/2/standard/Collection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Bag is a concrete non-ordered Collection allowing duplicates&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="intersection">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Bag&lt;G>.new&#xA;&#x9;var elem : G&#xA;&#x9;var it : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;from it&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if elements.contains(elem) then&#xA;&#x9;&#x9;&#x9;if ((self.count(elem)) &lt;= (elements.count(elem))) then&#xA;&#x9;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;&#x9;it := elements.iterator&#xA;&#x9;from it&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if self.contains(elem) then&#xA;&#x9;&#x9;&#x9;if ((elements.count(elem)) &lt; (self.count(elem))) then&#xA;&#x9;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Bag corresponding to the intersection of elements&#xA;&#x9; * and the Bag&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Bag">
              <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
            <details key="body" value="do&#xA;&#x9;var isEqual : kermeta::standard::Boolean init false&#xA;&#x9;if element.isVoid.~not then&#xA;&#x9;&#x9;if kermeta::standard::Collection&lt;G>.isInstance(element) then&#xA;&#x9;&#x9;&#x9;var collection : kermeta::standard::Bag&lt;G>&#xA;&#x9;&#x9;&#x9;collection ?= element&#xA;&#x9;&#x9;&#x9;var selfAsSet : kermeta::standard::Set&lt;G> init self.asSet&#xA;&#x9;&#x9;&#x9;isEqual := selfAsSet.equals(collection.asSet)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;result := isEqual&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Object.equals(elt : Object)&#xA;&#x9; * Returns a Boolean stating whether the provided element is equal to&#xA;&#x9; * current Bag&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="element" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="asSequence">
          <eAnnotations source="kermeta" references="/2/standard/Collection/asSequence">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Sequence&lt;G> init kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.asSequence()&#xA;&#x9; * Returns a new Sequence containing all elements of current Bag&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="concatenate">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;result.addAll(less)&#xA;&#x9;result.addAll(pivot)&#xA;&#x9;result.addAll(greater)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Internal concatenation tool for recursive 'quickSort()' method&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="less">
            <eGenericType eClassifier="/2/standard/Sequence">
              <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
            </eGenericType>
          </eParameters>
          <eParameters name="pivot">
            <eGenericType eClassifier="/2/standard/Sequence">
              <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
            </eGenericType>
          </eParameters>
          <eParameters name="greater">
            <eGenericType eClassifier="/2/standard/Sequence">
              <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="excluding">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Bag&lt;G> init kermeta::standard::Bag&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;s.remove(object)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Bag which content includes the content of the&#xA;&#x9; * current Bag from which all instances of object have been&#xA;&#x9; * removed&#xA; &#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="object">
            <eGenericType eTypeParameter="/2/standard/Bag/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="flatten">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var res : kermeta::standard::Bag&lt;kermeta::standard::Object> init kermeta::standard::Bag&lt;kermeta::standard::Object>.new&#xA;&#x9;if G.isKindOf(kermeta::standard::Collection&lt;kermeta::standard::Object>) then&#xA;&#x9;&#x9;var col : kermeta::standard::Collection&lt;kermeta::standard::Object>&#xA;&#x9;&#x9;var o : kermeta::standard::Object&#xA;&#x9;&#x9;self.each{e | do&#xA;&#x9;&#x9;&#x9;&#x9;col ?= e&#xA;&#x9;&#x9;&#x9;&#x9;res.addAll(col)&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;result := res&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Bag which content includes all non-Collection elements&#xA;&#x9; * of the current Set, and, for each Collection element of the current&#xA;&#x9; * Bag, as many elements as the Collection contains&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eClassifier="/2/standard/Object"/>
          </eGenericType>
        </eOperations>
        <eOperations name="intersectionWithSet">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;G>.new&#xA;&#x9;var elem : G&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;G> init elements.iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;elem := it.next&#xA;&#x9;&#x9;if self.contains(elem) then&#xA;&#x9;&#x9;&#x9;result.add(elem)&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Set corresponding to the intersection of a Set of&#xA;&#x9; * elements and the Bag&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Set">
              <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="asOrderedSet">
          <eAnnotations source="kermeta" references="/2/standard/Collection/asOrderedSet">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::OrderedSet&lt;G> init kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.asOrderedSet()&#xA;&#x9; * Returns a new OrderedSet containing elements of the Bag without duplicates&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="including">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Bag&lt;G> init kermeta::standard::Bag&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;s.add(object)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Bag which content includes the content of the&#xA;&#x9; * current Bag and the element object&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="object">
            <eGenericType eTypeParameter="/2/standard/Bag/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="asBag">
          <eAnnotations source="kermeta" references="/2/standard/Collection/asBag">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Bag&lt;G> init kermeta::standard::Bag&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.asBag()&#xA;&#x9; * Returns a new Bag containing all elements of current Bag&#x9;&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
        </eOperations>
        <eOperations name="union">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Bag&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.addAll(elements)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a new Bag corresponding to the union of elements and&#xA;&#x9; * current Bag&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
          <eParameters name="elements">
            <eGenericType eClassifier="/2/standard/Collection">
              <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="removeOne">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G init self.detect{e | do&#xA;&#x9;&#x9;&#x9;e.equals(element)&#xA;&#x9;&#x9;end}&#xA;&#x9;if elem.isNotEqual(void) then&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Removes one instance of element from the Bag&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Bag/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="removeFromOid">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var elem : G init self.detect{e | do&#xA;&#x9;&#x9;&#x9;e.oid.equals(elementOid)&#xA;&#x9;&#x9;end}&#xA;&#x9;if elem.isNotEqual(void) then&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Collection.remove(self, elem)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Removes the element identified by the provided Oid from the Bag&#xA;&#x9; */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.post">
            <details key="doesntContainsElementAnymore" value="exists{e | do&#xA;&#x9;&#x9;e.oid.equals(elementOid)&#xA;&#x9;end}.~not"/>
          </eAnnotations>
          <eParameters name="elementOid" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="asSet">
          <eAnnotations source="kermeta" references="/2/standard/Collection/asSet">
            <details key="body" value="do&#xA;&#x9;var s : kermeta::standard::Set&lt;G> init kermeta::standard::Set&lt;G>.new&#xA;&#x9;s.addAll(self)&#xA;&#x9;result := s&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Collection&lt;G>.asSet()&#xA;&#x9; * Returns a new Set containing elements of the Bag without duplicates&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Collection"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/standard/Bag/G"/>
          </eGenericType>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="OrderedCollection" abstract="true" eSuperTypes="/2/standard/Collection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * An OrderedCollection is the root abstract class for all ordered Collections.&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="removeAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((((index) &lt; (0))) or (((index) > (((size) - (1)))))) then&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.removeAt(self, index)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Removes the element at rank index from the OrderedCollection&#xA;&#x9; * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xA;&#x9; * larger than the size of the OrderedCollection&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="index" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="addAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((((index) &lt; (0))) or (((index) > (size)))) then&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.addAt(self, index, element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Adds element in the OrderedCollection at rank index&#xA;&#x9; * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xA;&#x9; * larger than the size of the OrderedCollection&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="index" eType="/2/standard/Integer"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/OrderedCollection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="last">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if size.equals(0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::EmptyCollection.new&#xA;&#xA;&#x9;end&#xA;&#x9;result := elementAt(((size) - (1)))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the last element in the OrderedCollection&#xA;&#x9; * Raises an EmptyCollection exception if the OrderedCollection is empty&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/OrderedCollection/G"/>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/equals">
            <details key="body" value="do&#xA;&#x9;var isEqual : kermeta::standard::Boolean init false&#xA;&#x9;if element.isVoid.~not then&#xA;&#x9;&#x9;if kermeta::standard::OrderedCollection&lt;G>.isInstance(element) then&#xA;&#x9;&#x9;&#x9;var collection : kermeta::standard::Collection&lt;G>&#xA;&#x9;&#x9;&#x9;collection ?= element&#xA;&#x9;&#x9;&#x9;if self.size.equals(collection.size) then&#xA;&#x9;&#x9;&#x9;&#x9;var selfIterator : kermeta::standard::Iterator&lt;G> init self.iterator&#xA;&#x9;&#x9;&#x9;&#x9;var collectionIterator : kermeta::standard::Iterator&lt;G> init collection.iterator&#xA;&#x9;&#x9;&#x9;&#x9;var difference : kermeta::standard::Boolean init false&#xA;&#x9;&#x9;&#x9;&#x9;from 1.equals(1)&#xA;&#x9;&#x9;&#x9;&#x9;until ((((selfIterator.isOff) or (collectionIterator.isOff))) or (difference))&#xA;&#x9;&#x9;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if selfIterator.next.equals(collectionIterator.next).~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;difference := true&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;isEqual := difference.~not&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;result := isEqual&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Object.equals(Object)&#xA;&#x9; * Returns a Boolean stating whether the provided element is equal to&#xA;&#x9; * current OrderedCollection&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
          <eParameters name="element" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="indexOf" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if size.equals(0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::EmptyCollection.new&#xA;&#xA;&#x9;end&#xA;&#x9;var i : kermeta::standard::Integer init 0&#xA;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;var found : kermeta::standard::Boolean init false&#xA;&#x9;from found&#xA;&#x9;until ((found) or (it.isOff))&#xA;&#x9;loop&#xA;&#x9;&#x9;if element.equals(it.next) then&#xA;&#x9;&#x9;&#x9;found := true&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;i := ((i) + (1))&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;&#x9;if found then&#xA;&#x9;&#x9;result := i&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;result := 1.uminus&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/** &#xA;&#x9; * Returns the index of the first instance of element in the OrderedCollection&#xA;&#x9; * or -1 if the element is not contained by the OrderedCollection&#xA;&#x9; * Raises an EmptyCollection exception if the OrderedCollection is empty&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/OrderedCollection/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="elementAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((((index) &lt; (0))) or (((index) > (((size) - (1)))))) then&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::OrderedCollection.elementAt(self, index)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the element at rank index in the OrderedCollection&#xA;&#x9; * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xA;&#x9; * larger than the size of the OrderedCollection&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/OrderedCollection/G"/>
          <eParameters name="index" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="first">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if size.equals(0) then&#xA;&#x9;&#x9;raise kermeta::exceptions::EmptyCollection.new&#xA;&#xA;&#x9;end&#xA;&#x9;result := elementAt(0)&#xA;end"/>
            <details key="documentation" value="/** &#xA;&#x9; * Returns the first element in the OrderedCollection&#xA;&#x9; * Raises an EmptyCollection exception if the OrderedCollection is empty&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/OrderedCollection/G"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="OrderedSet" eSuperTypes="/2/standard/Set /2/standard/OrderedCollection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * An OrderedSet is a Set that contained ordered distinct elements&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="append">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.add(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Builds and returns a new OrderedSet from current one with element&#xA;&#x9; * inserted in head&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/2/standard/OrderedSet/G"/>
          </eGenericType>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="insertAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.addAt(index, subject)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Builds and returns a new OrderedSet from current one with element&#xA;&#x9; * inserted at rank index&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/2/standard/OrderedSet/G"/>
          </eGenericType>
          <eParameters name="index" eType="/2/standard/Integer"/>
          <eParameters name="subject">
            <eGenericType eTypeParameter="/2/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="addAt">
          <eAnnotations source="kermeta" references="/2/standard/OrderedCollection/addAt">
            <details key="body" value="do&#xA;&#x9;if self.contains(element).~not then&#xA;&#x9;&#x9;super(index, element)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides OrderedCollection&lt;G>.addAt(Integer, G)&#xA;&#x9; * Adds element in the OrderedSet at rank index if the ordered set does&#xA;&#x9; * not already contain the element, does nothing otherwise&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::OrderedCollection"/>
          </eAnnotations>
          <eParameters name="index" eType="/2/standard/Integer"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="preppend">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;result.add(element)&#xA;&#x9;result.addAll(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Builds and returns a new OrderedSet from current one with element&#xA;&#x9; * inserted in tail&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/2/standard/OrderedSet/G"/>
          </eGenericType>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/standard/OrderedCollection/equals">
            <details key="body" value="do&#xA;&#x9;result := super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * See OrderedCollection&lt;G>.equals(Object) &#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::OrderedCollection"/>
          </eAnnotations>
          <eParameters name="element" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="at">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((((index) >= (0))) and (((index) &lt;= (self.size)))) then&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;from var i : kermeta::standard::Integer init 1.uminus&#xA;&#x9;&#x9;until i.equals(index)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result := it.next&#xA;&#x9;&#x9;&#x9;i := ((i) + (1))&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns element at rank index in the sequence&#xA;&#x9; * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xA;&#x9; * larger than the size of the OrderedSet&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/OrderedSet/G"/>
          <eParameters name="index" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="add" ordered="false" eType="/2/standard/Void">
          <eAnnotations source="kermeta" references="/2/standard/Set/add">
            <details key="body" value="do&#xA;&#x9;super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * See Set&lt;G>.add(G)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Set"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/OrderedSet/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="subSet">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::OrderedSet&lt;G>.new&#xA;&#x9;if ((((((min) >= (0))) and (((max) &lt;= (self.size))))) and (((min) &lt;= (max)))) then&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;var i : kermeta::standard::Integer init 0&#xA;&#x9;&#x9;from i&#xA;&#x9;&#x9;until i.equals(min)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;it.next&#xA;&#x9;&#x9;&#x9;i := ((i) + (1))&#xA;&#x9;&#x9;end&#xA;&#x9;&#x9;from i&#xA;&#x9;&#x9;until i.equals(((max) + (1)))&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result.add(it.next)&#xA;&#x9;&#x9;&#x9;i := ((i) + (1))&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Builds and returns a new OrderedSet composed of elements of current ordered&#xA;&#x9; * set from rank min to rank max (order is respected)&#xA;&#x9; * Raises IndexOutOfBound exception if min is negative, max is larger than &#xA;&#x9; * the size of the ordered set or min is larger than max&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/OrderedSet">
            <eTypeArguments eTypeParameter="/2/standard/OrderedSet/G"/>
          </eGenericType>
          <eParameters name="min" eType="/2/standard/Integer"/>
          <eParameters name="max" eType="/2/standard/Integer"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Sequence" eSuperTypes="/2/standard/Bag /2/standard/OrderedCollection">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * A Sequence is an OrderedCollection of elements allowing duplicates&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="subSequence">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;if ((((((min) >= (0))) and (((max) &lt;= (self.size))))) and (((min) &lt;= (max)))) then&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;var i : kermeta::standard::Integer init 0&#xA;&#x9;&#x9;from i&#xA;&#x9;&#x9;until i.equals(min)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;it.next&#xA;&#x9;&#x9;&#x9;i := ((i) + (1))&#xA;&#x9;&#x9;end&#xA;&#x9;&#x9;from i&#xA;&#x9;&#x9;until i.equals(((max) + (1)))&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result.add(it.next)&#xA;&#x9;&#x9;&#x9;i := ((i) + (1))&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Builds and returns a new Sequence composed of elements of current sequence&#xA;&#x9; * from rank min to rank max (order is respected)&#xA;&#x9; * Raises IndexOutOfBound exception if min is negative, max is larger than &#xA;&#x9; * the size of the sequence or min is larger than max&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Sequence/G"/>
          </eGenericType>
          <eParameters name="min" eType="/2/standard/Integer"/>
          <eParameters name="max" eType="/2/standard/Integer"/>
        </eOperations>
        <eOperations name="append">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.add(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Builds and returns a new Sequence from current one with element&#xA;&#x9; * inserted in head&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Sequence/G"/>
          </eGenericType>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Sequence/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="insertAt">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;result.addAll(self)&#xA;&#x9;result.addAt(index, element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Builds and returns a new Sequence from current one with element&#xA;&#x9; * inserted at rank index&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Sequence/G"/>
          </eGenericType>
          <eParameters name="index" eType="/2/standard/Integer"/>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Sequence/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="preppend">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Sequence&lt;G>.new&#xA;&#x9;result.add(element)&#xA;&#x9;result.addAll(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Builds and returns a new Sequence from current one with element&#xA;&#x9; * inserted in tail&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Sequence">
            <eTypeArguments eTypeParameter="/2/standard/Sequence/G"/>
          </eGenericType>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/standard/Sequence/G"/>
          </eParameters>
        </eOperations>
        <eOperations name="equals" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta" references="/2/standard/OrderedCollection/equals">
            <details key="body" value="do&#xA;&#x9;result := super(element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides OrderedCollection&lt;G>.equals(Object)&#xA;&#x9; * Returns a Boolean stating whether the provided element is equal to&#xA;&#x9; * current Sequence&#x9;&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::OrderedCollection"/>
          </eAnnotations>
          <eParameters name="element" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="at">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if ((((index) >= (0))) and (((index) &lt;= (self.size)))) then&#xA;&#x9;&#x9;var it : kermeta::standard::Iterator&lt;G> init iterator&#xA;&#x9;&#x9;from var i : kermeta::standard::Integer init 1.uminus&#xA;&#x9;&#x9;until i.equals(index)&#xA;&#x9;&#x9;loop&#xA;&#x9;&#x9;&#x9;result := it.next&#xA;&#x9;&#x9;&#x9;i := ((i) + (1))&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;raise kermeta::exceptions::IndexOutOfBound.new&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns element at rank index in the sequence&#xA;&#x9; * Raises IndexOutOfBound exception if provided index is lower than 0 or&#xA;&#x9; * larger than the size of the Sequence&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/Sequence/G"/>
          <eParameters name="index" eType="/2/standard/Integer"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Iterator" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Iterator to be used with Collection&#xA; * See also Collection&lt;G>.getIterator()&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="hasNext" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Iterator.hasNext(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if the iterator has a next element&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="next">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if hasNext.~not then&#xA;&#x9;&#x9;raise kermeta::exceptions::IteratorIsOff.new&#xA;&#xA;&#x9;end&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Iterator.next(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the next element of the iterator&#xA;&#x9; * Raises IteratorIsOff exception in case the iterator is on the last element &#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/standard/Iterator/G"/>
        </eOperations>
        <eOperations name="isOff" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := hasNext.~not&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns true if the iterator is on the last element&#xA;&#x9; * i.e. returns not self.hasNext()&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="UnknownJavaObject" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** &#xA;  * This special object is used to represent java objects that cannot be concretely used with kermeta&#xA;  * &lt;b>the only actions possible on these objects are : assignment and passing them as parameter&lt;/b>&#xA;  * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/java_package.png&quot;/>&#xA;  */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result := &quot;toString of  UnknownJavaObject not implemented yet&quot;&#xA;end"/>
            <details key="documentation" value="/**&#xA; &#x9; * NOT IMPLEMENTED&#xA; &#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="utils" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/utils" nsPrefix="utils">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/** &#xA; * Contains special classes (Hashtable, Stack) that are not contained in Kermeta&#xA; * metamodel&#xA; * &#xA; * &lt;img src=&quot;./figures/utils_package.png&quot;/>&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="StringBuffer" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * This class mimic the behavior of the java's StringBuffer class. This enables better performance in long&#xA; * string concatenation.&lt;br>&#xA; * &lt;b>Only work on Strings&lt;/b>&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/utils_package.png&quot;/>&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="append" eType="/2/utils/StringBuffer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::StringBuffer.append(self, arg0)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Append a given string at the end of this StringBuffer&#xA;&#x9; * @param arg0 A string to append at the end of this StringBuffer&#xA;&#x9; * @return A reference to this object&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="arg0" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="length" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::StringBuffer.length(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Return the length of the StringBuffer&#xA;&#x9; * @return length of the StringBuffer&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;var stringValue : kermeta::standard::String&#xA;&#x9;stringValue ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::StringBuffer.toString(self)&#xA;&#x9;result := stringValue&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; *Convert this StringBuffer to String and return its value&#xA;&#x9; *@return The string value of this StringBuffer&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Stack" eSuperTypes="/2/standard/Sequence">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * An implementation of stack&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/utils_package.png&quot;/>&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="G"/>
        <eOperations name="peek">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self.first&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Gets the element at the top of the stack&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/utils/Stack/G"/>
        </eOperations>
        <eOperations name="pop">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := peek&#xA;&#x9;self.removeAt(0)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Get and remove the element at the top of the stack&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/utils/Stack/G"/>
        </eOperations>
        <eOperations name="push">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;self.addAt(0, element)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Pushes an element into the stack&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="element">
            <eGenericType eTypeParameter="/2/utils/Stack/G"/>
          </eParameters>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Hashtable" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * An implementation of hashtable&#xA; * This implementation is for speed optimisation it cannot be serialized. &#xA; * If your wish to serialize its content you need to copy its content into a classical ecore structure (attribute or references)&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/utils_package.png&quot;/>&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eTypeParameters name="K"/>
        <eTypeParameters name="V"/>
        <eOperations name="getValue">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Map.get(self, key)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the value for key 'key' if it exists, otherwise returns Void&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eTypeParameter="/2/utils/Hashtable/V"/>
          <eParameters name="key">
            <eGenericType eTypeParameter="/2/utils/Hashtable/K"/>
          </eParameters>
        </eOperations>
        <eOperations name="clear">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Map.clear(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Removes all elements from the Hashtable&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="containsKey" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := getValue(key).isNotEqual(void)&#xA;end"/>
            <details key="documentation" value="/**&#x9;&#xA;&#x9; * Returns a Boolean stating whether a key is present or not in this Hashtable&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="key">
            <eGenericType eTypeParameter="/2/utils/Hashtable/K"/>
          </eParameters>
        </eOperations>
        <eOperations name="put">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Map.put(self, key, ~value)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Adds a entry into the Hashtable&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="key">
            <eGenericType eTypeParameter="/2/utils/Hashtable/K"/>
          </eParameters>
          <eParameters name="value">
            <eGenericType eTypeParameter="/2/utils/Hashtable/V"/>
          </eParameters>
        </eOperations>
        <eOperations name="values">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Bag&lt;V>.new&#xA;&#x9;keys.each{k | do&#xA;&#x9;&#x9;&#x9;result.add(self.getValue(k))&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a collection containing the elements of this Hashtable&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Collection">
            <eTypeArguments eTypeParameter="/2/utils/Hashtable/V"/>
          </eGenericType>
        </eOperations>
        <eOperations name="remove">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Map.remove(self, key)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Removes the entry with key equals to 'key'&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="key">
            <eGenericType eTypeParameter="/2/utils/Hashtable/K"/>
          </eParameters>
        </eOperations>
        <eOperations name="keys">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;K>.new&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;K> init keyIterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;result.add(it.next)&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns a set containing the hash keys of this Hashtable&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eTypeParameter="/2/utils/Hashtable/K"/>
          </eGenericType>
        </eOperations>
        <eOperations name="keyIterator">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Map.keysIterator(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns an iterator over the Keys of this Hashtable&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Iterator">
            <eTypeArguments eTypeParameter="/2/utils/Hashtable/K"/>
          </eGenericType>
        </eOperations>
        <eOperations name="valueIterator">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Map.valueIterator(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns an iterator over the values of this Hashtable&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Iterator">
            <eTypeArguments eTypeParameter="/2/utils/Hashtable/V"/>
          </eGenericType>
        </eOperations>
        <eOperations name="size" eType="/2/standard/Integer">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Map.size(self)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the size of this Hashtable&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="xmltype" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/xmltype" nsPrefix="xmltype">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/** &#xA; * Contains the definition of a Kermeta classes used for compatibility with XMLType.ecore &#xA; * &#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="QName" eSuperTypes="/2/standard/String">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Kermeta representation of EMF type::QName from XMLType.ecore&#xA; * &#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="persistence" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/persistence" nsPrefix="persistence">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/**&#xA; * Contains the classes that handle the serialization of models, in particular&#xA; * EMF models.&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/persistence_package.png&quot;/>&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="EMFResource" eSuperTypes="/2/persistence/Resource">
        <eAnnotations source="kermeta">
          <details key="CompilerIgnore" value="true"/>
          <details key="documentation" value="/**&#xA; * Extension of the Resource class definition that is specific to EMF Repository.&#xA; * User is not supposed to directly create it. Otherwise it will not be correctly initialized&#xA; * You must To create one &#xA; */"/>
        </eAnnotations>
        <eOperations name="save">
          <eAnnotations source="kermeta" references="/2/persistence/Resource/save">
            <details key="body" value="do&#xA;&#x9;if isReadOnly then&#xA;&#x9;&#x9;var e : kermeta::exceptions::ResourceSaveException init kermeta::exceptions::ResourceSaveException.new&#xA;&#x9;&#x9;e.message := ((((&quot;Cannot save a readonly resource. Probably this resource was indirectly loaded when loading another resource. \n&quot;) + (&quot;If you really intend to save this resource, you can set isReadOnly to false, but you must ensure to do so before any resource save.\n&quot;))) + (&quot;Note : setting isReadOnly to false on the metamodel may lead to unpredictable results&quot;))&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(self, self.uri, metaModelURI, &quot;EMF&quot;, self, false)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Resource.save()&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::persistence::Resource"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="clean" ordered="false" eType="/2/standard/Void">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;do&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::MarkerHelper.cleanFile(self.uri)&#xA;&#x9;end&#xA;end"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="remove">
          <eAnnotations source="kermeta" references="/2/standard/Set/remove">
            <details key="body" value="do&#xA;&#x9;if self.contains(instance) then&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Object.unSetContainingResource(instance)&#xA;&#x9;&#x9;super(instance)&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Set&lt;Object>.remove(Object)&#xA;&#x9; * Remove the instance from the Resource&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Set"/>
          </eAnnotations>
          <eParameters name="instance" eType="/2/standard/Object"/>
        </eOperations>
        <eOperations name="saveWithNewURI">
          <eAnnotations source="kermeta" references="/2/persistence/Resource/saveWithNewURI">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(self, new_uri, metaModelURI, &quot;EMF&quot;, self, false)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Resource.saveWithNewURI(String)&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::persistence::Resource"/>
          </eAnnotations>
          <eParameters name="new_uri" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="saveAndValidateWithEMF" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.save(self, self.uri, metaModelURI, &quot;EMF&quot;, self, true)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Checks the Resource using the EMF validation function, and saves it if&#xA;&#x9; * validation succeeds&#xA;&#x9; * Applies validation to all root objects of the Resource&#xA;&#x9; * Returns true if the validation reports no error, raises exceptions otherwise&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="mark" ordered="false" eType="/2/standard/Void">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;do&#xA;&#x9;&#x9;extern fr::irisa::triskell::kermeta::runtime::MarkerHelper.markFile(self.uri, message)&#xA;&#x9;end&#xA;end"/>
          </eAnnotations>
          <eParameters name="message" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="load">
          <eAnnotations source="kermeta" references="/2/persistence/Resource/load">
            <details key="body" value="do&#xA;&#x9;self.clear&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.load(self, uri, metaModelURI, &quot;EMF&quot;)&#xA;&#x9;if self.size.equals(0) then&#xA;&#x9;&#x9;stdio.writeln(&quot;Resource load failed!&quot;)&#xA;&#x9;&#x9;var e : kermeta::exceptions::ResourceLoadException init kermeta::exceptions::ResourceLoadException.new&#xA;&#x9;&#x9;e.message := ((&quot;Resource load failed, no object was created in this resource from &quot;) + (uri))&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Resource.load()&#xA;&#x9; * In case the metamodelURI was not previously set, metamodelURI is filled with&#xA;&#x9; * the nsuri of the root package of the metamodel used to load the Resource after&#xA;&#x9; * a successful load&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::persistence::Resource"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="add">
          <eAnnotations source="kermeta" references="/2/standard/Set/add">
            <details key="body" value="do&#xA;&#x9;repository.resources.~select{r | do&#xA;&#x9;&#x9;&#x9;(r.isNotEqual(self)) and (r.contains(instance))&#xA;&#x9;&#x9;end}.each{r | do&#xA;&#x9;&#x9;&#x9;stdio.writeln(&quot;DVK ! another resource of the same repository was containing this element&quot;)&#xA;&#x9;&#x9;&#x9;r.remove(instance)&#xA;&#x9;&#x9;end}&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::language::Object.setContainingResource(instance, self)&#xA;&#x9;super(instance)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Set&lt;Object>.add(Object)&#xA;&#x9; * Add an instance to the Resource &#xA;&#x9; * Ensures that the instance is referenced by a one and only one Resource of the same Repository&#xA;&#x9; * Ensures that the instance does not appear more than once in the Resource&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::standard::Set"/>
          </eAnnotations>
          <eParameters name="instance" eType="/2/standard/Object"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Resource" abstract="true" eSuperTypes="/2/standard/Set">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * The main class that handle a loaded/saved model.&#xA; * There are a few important things to note for the developer :&#xA; * &#xA; * - load a Resource : this loads a Collection of instances corresponding to the&#xA; *   objects in the loaded model. If the Collection of instances is empty, than &#xA; *&#x9; a ResourceLoadException is raised&#xA; *&#xA; * - save a Resource : this saves the collection of instances in a new file. This can&#xA; *   be correctly done if and only if the instances saved are conform to the metamodel&#xA; *   linked to this resource (this link does not need to be explicit. It is normally retrieved&#xA; *   through the EMF model -- see Java wrapping &quot;Resource.java&quot;).&#xA; * &#xA; * - add/remove an instance to the Resource : this adds an element in the resource. It cannot&#xA; *   be &quot;simply&quot; added because of the following potential errors :&#xA; *&#xA; *   - The object added is not conform to the metamodel -> Error&#xA; *   - The object was already added in the resource -> Not a real error : we do nothing&#xA; *   - The object to remove does not exist -> redirect to a collection-specific error&#xA; *   - The object to remove is attached to an object in the collection -> &quot;dependency-violation&quot; exception?&#xA;&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="save">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Save a Resource in the file specified by the current value of uri &#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="saveWithNewURI">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Save a Resource in a file referenced by the new uri.&#xA;&#x9; * note: this doesn't change the URI of the resource, it is only saved in another place &#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="new_uri" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="findDanglingModelElements">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;kermeta::persistence::DanglingDiagnostic>.new&#xA;&#x9;self.contents.each{containedObj | do&#xA;&#x9;&#x9;&#x9;var classDef : kermeta::language::structure::ClassDefinition&#xA;&#x9;&#x9;&#x9;classDef ?= containedObj.getMetaClass.typeDefinition&#xA;&#x9;&#x9;&#x9;if classDef.isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;classDef.allAttribute.each{prop | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if prop.isDerived.~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((((prop.upper) > (1))) or (prop.upper.equals(1.uminus))) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var referencedObjs : kermeta::standard::Collection&lt;kermeta::standard::Object>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;referencedObjs ?= containedObj.get(prop)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if referencedObjs.isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;referencedObjs.each{referencedObj | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((self.repository.resources.exists{res2 | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;res2.contents.contains(referencedObj)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end}.~not) and (((((referencedObj.isKindOf(kermeta::standard::String)) or (referencedObj.isKindOf(kermeta::standard::Integer)))) or (referencedObj.isKindOf(kermeta::standard::Boolean))).~not)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var diagnostic : kermeta::persistence::DanglingDiagnostic init kermeta::persistence::DanglingDiagnostic.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.danglingElement := referencedObj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.referencingElement := containedObj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.referencingProperty := prop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.add(diagnostic)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var referencedObj : kermeta::standard::Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;referencedObj := containedObj.get(prop)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if referencedObj.isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((self.repository.resources.exists{res2 | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;res2.contents.contains(referencedObj)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end}.~not) and (((((referencedObj.isKindOf(kermeta::standard::String)) or (referencedObj.isKindOf(kermeta::standard::Integer)))) or (referencedObj.isKindOf(kermeta::standard::Boolean))).~not)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var diagnostic : kermeta::persistence::DanglingDiagnostic init kermeta::persistence::DanglingDiagnostic.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.danglingElement := referencedObj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.referencingElement := containedObj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.referencingProperty := prop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.add(diagnostic)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Search for elements referenced by one element contained by this resource that are not contained by this repository&#xA;&#x9; * ie. element that EMF would claim as &quot;not contained in a resource&quot;&#xA;&#x9; * checks only objects directly referenced by the element in this resource, ignores indirectly referenced objects&#xA;&#x9; * example of use :&#xA;&#x9; *  var report : Set&amp;lt;DanglingDiagnostic&amp;gt;&#xA;&#x9; *&#x9;report := resource.findDanglingModelElements()&#xA;&#x9; *&#x9;report.each{ diag | stdio.writeln(diag.toString ) }&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eClassifier="/2/persistence/DanglingDiagnostic"/>
          </eGenericType>
        </eOperations>
        <eOperations name="load">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Loads the Resource, thus making content of the Resource browsable.&#xA;&#x9; * Raises a ResourceLoadException in case loaded Resource is empty&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="instances" eType="/2/persistence/Resource">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := self&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * The entities contained in the model-instance, that are provided when user loads a resource &#xA;&#x9; * instances == rootContents&#xA;&#x9; * this is a loop on Resource itself in order to get backward compatibility&#xA;&#x9; */"/>
            <details key="deprecated" value="user should use the resource directly since this is a collection"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="normalizedUri" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.normalizeUri(uri)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Return a normalized version of the Uri of this resource&#xA;&#x9; * in order to prevent several loading of the same file because they have different path that leads to them, kermeta uses normalizedURI&#xA;&#x9; * for some of its functions (eg. repository.getResource )&#xA;&#x9; * As EMF needs URI of the form platform:/resource or platform:/plugin, kermeta automatically&#xA;&#x9; * normalize the uri when loading or saving. This is especially true for file:/ uri or relative uri (./ or / ) &#xA;&#x9; * If you wish to know what concrete uri is used by kermeta when loading and saving you can use this function&#xA;&#x9; * to check how a given uri is normalized by kermeta&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="dependentResources" ordered="false" upperBound="-1" eType="/2/persistence/Resource" changeable="false" volatile="true" transient="true" derived="true">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#x9;&#xA;&#x9; * Returns the set of Resources the current Resource, which must have been loaded,&#xA;&#x9; * depends on, an empty set if current Resource has no dependency&#xA;&#x9; */"/>
            <details key="isReadOnly" value="true"/>
          </eAnnotations>
          <eAnnotations source="kermetaderivedProp.getter">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Resource.getDependentResources(self, uri, metaModelURI, &quot;EMF&quot;)&#xA;end"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="repository" eType="/2/persistence/Repository" eOpposite="/2/persistence/Repository/resources">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * Repository used to create the Resource&#xA;&#x9; * This feature is supposed read only, otherwise it cannot garantee that an element is contained by only &#xA;&#x9; * one Resource of a given Repository&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="contents" ordered="false" upperBound="-1" eType="/2/standard/Object" changeable="false" volatile="true" transient="true" derived="true">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="false"/>
            <details key="documentation" value="/** &#xA;&#x9; * Returns the set of all Objects directly or indirectly contained by the Resource,&#xA;&#x9; * or an empty set if the Resource is empty&#xA;&#x9; * implementation note: since this derived property  build a set, it guarantees the unicity, as a drawback,&#xA;&#x9; *  calling this property on large resources will be really slow due to this verification. some user may prefer&#xA;&#x9; * to reimplement it using a bag.&#xA;&#x9; */"/>
            <details key="isReadOnly" value="true"/>
          </eAnnotations>
          <eAnnotations source="kermetaderivedProp.getter">
            <details key="body" value="do&#xA;&#x9;var res : kermeta::standard::Set&lt;kermeta::language::structure::Object> init kermeta::standard::Set&lt;kermeta::language::structure::Object>.new&#xA;&#x9;res.addAll(self)&#xA;&#x9;var coll : kermeta::standard::Set&lt;kermeta::language::structure::Object>&#xA;&#x9;self.each{e | do&#xA;&#x9;&#x9;&#x9;coll ?= extern fr::irisa::triskell::kermeta::runtime::language::Object.getAllContainedObjects(e)&#xA;&#x9;&#x9;&#x9;res.addAll(coll)&#xA;&#x9;&#x9;end}&#xA;&#x9;result := res&#xA;end"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isReadOnly" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Indicates weither this resource will be updated when saving the repository&#xA;&#x9; * This is useful if the repository contains some metamodels that should not be saved.&#xA;&#x9; *&#xA;&#x9; * Note that in the current version, it doesn't ensure that you have not modified its content (using the freeze)&#xA;&#x9; * If you modify the elements of such resource, other resource that depend on it will be incorrectly saved &#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="metaModelURI" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Uri of the meta-model of the Resource to load&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="uri" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Uri of the Resource to load&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Repository" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Abstract resource container, that contains a list of available loaded resources, &#xA; * and methods to create or get a resource given an URI.&#xA; * A repository cannot contain 2 resources which points to the same file (ie. that have the same normalizedURI)&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="createResource" eType="/2/persistence/Resource">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Creates a new Resource with given uri, and an optional mm_uri&#xA;&#x9; * mm_uri is required when creating a new model from scratch.&#xA;&#x9; * Raises a ResourceCreate exception in case the Repository already&#xA;&#x9; * contains a Resource with the given uri&#xA;&#x9; * If uri does not points to an existing model file (in the case of&#xA;&#x9; * a model creation), calls to load() operation will fail as long as&#xA;&#x9; * the model has not been saved once&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="uri" eType="/2/standard/String"/>
          <eParameters name="mm_uri" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="normalizeUri" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.normalizeUri(uri)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Return a normalized version of the Uri &#xA;&#x9; * in order to prevent several loading of the same file because they have different path that leads to them, kermeta uses normalizedURI&#xA;&#x9; * for some of its functions (eg. repository.getResource )&#xA;&#x9; * As EMF needs URI of the form platform:/resource or platform:/plugin, kermeta automatically&#xA;&#x9; * normalize the uri when loading or saving. This is especially true for file:/ uri or relative uri (./ or / ) &#xA;&#x9; * If you wish to know what concrete uri is used by kermeta when loading and saving you can use this function&#xA;&#x9; * to check how a given uri is normalized by kermeta &#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="uri" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="findDanglingModelElements">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := kermeta::standard::Set&lt;kermeta::persistence::DanglingDiagnostic>.new&#xA;&#x9;var fullResContents : kermeta::standard::Set&lt;kermeta::standard::Object>&#xA;&#x9;self.resources.each{res | do&#xA;&#x9;&#x9;&#x9;if fullResContents.isVoid then&#xA;&#x9;&#x9;&#x9;&#x9;fullResContents := res.contents&#xA;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;fullResContents.addAll(res.contents)&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}&#xA;&#x9;fullResContents.each{containedObj | do&#xA;&#x9;&#x9;&#x9;var classDef : kermeta::language::structure::ClassDefinition&#xA;&#x9;&#x9;&#x9;classDef ?= containedObj.getMetaClass.typeDefinition&#xA;&#x9;&#x9;&#x9;if classDef.isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;classDef.allAttribute.each{prop | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if prop.isDerived.~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((((prop.upper) > (1))) or (prop.upper.equals(1.uminus))) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var referencedObjs : kermeta::standard::Collection&lt;kermeta::standard::Object>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;referencedObjs ?= containedObj.get(prop)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if referencedObjs.isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;referencedObjs.each{referencedObj | do&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((fullResContents.contains(referencedObj).~not) and (((((referencedObj.isKindOf(kermeta::standard::String)) or (referencedObj.isKindOf(kermeta::standard::Integer)))) or (referencedObj.isKindOf(kermeta::standard::Boolean))).~not)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var diagnostic : kermeta::persistence::DanglingDiagnostic init kermeta::persistence::DanglingDiagnostic.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.danglingElement := referencedObj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.referencingElement := containedObj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.referencingProperty := prop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.add(diagnostic)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var referencedObj : kermeta::standard::Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;referencedObj := containedObj.get(prop)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if referencedObj.isVoid.~not then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((fullResContents.contains(referencedObj).~not) and (((((referencedObj.isKindOf(kermeta::standard::String)) or (referencedObj.isKindOf(kermeta::standard::Integer)))) or (referencedObj.isKindOf(kermeta::standard::Boolean))).~not)) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var diagnostic : kermeta::persistence::DanglingDiagnostic init kermeta::persistence::DanglingDiagnostic.new&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.danglingElement := referencedObj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.referencingElement := containedObj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;diagnostic.referencingProperty := prop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.add(diagnostic)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;end}&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Search for elements referenced by one element contained by this repository  that are not contained by this repository&#xA;&#x9; * ie. element that EMF would claim as &quot;not contained in a resource&quot;&#xA;&#x9; * example of use :&#xA;&#x9; *  var report : Set&amp;lt;DanglingDiagnostic&amp;gt;&#xA;     *&#x9;report := repository.findDanglingModelElements()&#xA;     *&#x9;report.each{ diag | stdio.writeln(diag.toString ) }&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/standard/Set">
            <eTypeArguments eClassifier="/2/persistence/DanglingDiagnostic"/>
          </eGenericType>
        </eOperations>
        <eOperations name="getResource" eType="/2/persistence/Resource">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.initRepository(self)&#xA;&#x9;var normalisedUri : kermeta::standard::String init normalizeUri(uri)&#xA;&#x9;from var it : kermeta::standard::Iterator&lt;kermeta::persistence::Resource> init resources.iterator&#xA;&#x9;until it.isOff&#xA;&#x9;loop&#xA;&#x9;&#x9;var next : kermeta::persistence::Resource init it.next&#xA;&#x9;&#x9;if normalisedUri.equals(next.normalizedUri) then&#xA;&#x9;&#x9;&#x9;result := next&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;end&#xA;&#x9;if result.equals(void) then&#xA;&#x9;&#x9;result := self.createResource(uri, &quot;&quot;)&#xA;&#x9;&#x9;result.load&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Returns the Resource associated with the given uri if this uri is associated with&#xA;&#x9; * an already created Resource of the Repository.&#xA;&#x9; * If the Repository contains no Resource associated with the given uri, creates&#xA;&#x9; * a new Resource and loads it.&#xA;&#x9; * In order to prevent multiple load of the same file by using variant path to the same file, all URI used by this function are normalized&#xA;&#x9; * Raises a ResourceCreate exception if the given uri does not point to an existing&#xA;&#x9; * model file &#xA;&#x9; * May also raises loading exceptions if this is the first retrieval of the resource&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="uri" eType="/2/standard/String"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="resources" ordered="false" upperBound="-1" eType="/2/persistence/Resource" containment="true" eOpposite="/2/persistence/Resource/repository">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * Resources created by this Repository &#xA;&#x9; * This feature is supposed read only, otherwise it cannot garantee that an element is contained by only &#xA;&#x9; * one Resource of a given Repository&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DanglingDiagnostic" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * class used to gather the information required to make a user friendly report about a dangling element&#xA; * (see. findDanglingModelElements())&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="toString" eType="/2/standard/String">
          <eAnnotations source="kermeta" references="/2/language/structure/Object/toString">
            <details key="body" value="do&#xA;&#x9;result := ((((((((((danglingElement.toString) + (&quot; referenced by &quot;))) + (referencingElement.toString))) + (&quot;.&quot;))) + (referencingProperty.name))) + (&quot; is dangling&quot;))&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * user friendly message build with those informations&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::language::structure::Object"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="referencingElement" eType="/2/standard/Object">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="false"/>
            <details key="documentation" value="/**&#xA;&#x9; * Element that has a reference to the dangling element  &#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="danglingElement" eType="/2/standard/Object">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="false"/>
            <details key="documentation" value="/**&#xA;&#x9; * Element that is not contained by a resource in the repository  &#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="referencingProperty" eType="/2/language/structure/Property">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * Property used to reference the dangling element  &#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EMFRepository" eSuperTypes="/2/persistence/Repository">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Repository that stores and manages resources that come from EMF&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="createResource" eType="/2/persistence/Resource">
          <eAnnotations source="kermeta" references="/2/persistence/Repository/createResource">
            <details key="body" value="do&#xA;&#x9;if resources.collect{r | do&#xA;&#x9;&#x9;&#x9;r.uri&#xA;&#x9;&#x9;end}.contains(uri).~not then&#xA;&#x9;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.createResource(self, uri, mm_uri)&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var e : kermeta::exceptions::ResourceCreateException init kermeta::exceptions::ResourceCreateException.new&#xA;&#x9;&#x9;e.message := ((((((&quot;Trying to create a resource already existing at &quot;) + (uri))) + (&quot;.\n&quot;))) + (&quot;Remove existing resource from repository first, or use \&quot;getResource\&quot; operation.&quot;))&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Overrides Repository.createResource(String, String)&#xA;&#x9; * Create a new resource for a model given by its uri, &#xA;&#x9; * which meta-model is stored in file given by mm_uri&#xA;&#x9; * If file already exists, you'll be able to call the load method to concretly load the model&#xA;&#x9; * otherwise, you can only call the save method&#xA;&#x9; */"/>
            <details key="superOperation" value="kermeta::persistence::Repository"/>
          </eAnnotations>
          <eParameters name="uri" eType="/2/standard/String"/>
          <eParameters name="mm_uri" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="registerEcoreFile">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::Repository.registerEcoreFile(mm_uri)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9;  * Register the content of the given ecore file into EMF registry&#xA;&#x9;  * Once registered, EMF will be able to load and save models conformant to this ecore file&#xA;&#x9;  * Warning: if the NSURI you wish to register is already, registered (either statically or due to a previous call)&#xA;&#x9;  *  it will do nothing. Ie. modification in the ecore file will not be taken into account unless you manually unregister it.&#x9;    &#xA;&#x9;  */"/>
          </eAnnotations>
          <eParameters name="mm_uri" eType="/2/standard/String"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="useInterpreterInternalResources" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/** &#xA;&#x9; * If true, tells to the save of the resources that they should also integrate the resources from Kermeta interpreter itself&#xA;&#x9; * this is useful for example to make a dependency to framework.km&#xA;&#x9; * by default, not setting this is considered as false.&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="ignoreLoadErrorUnknownMetaclass" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * When loading the Resources, &#xA;&#x9; * if there are some errors due to an unknown metaclass while loading some objects, the loader try to ignore them&#xA;&#x9; * by default, not setting this attribute is considered as false.&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="ignoreAllLoadErrors" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * When loading the Resources, &#xA;&#x9; * if there are some errors while loading some objects, the loader can try to ignore them&#xA;&#x9; * setting this attribute to true is equivalent to setting ignoreLoadErrorUnknownMetaclass and ignoreLoadErrorUnknownProperty to true&#xA;&#x9; * by default, not setting this attribute is considered as false.&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="ignoreLoadErrorUnknownProperty" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * When loading the Resources, &#xA;&#x9; * if there are some errors due to an unknown property while loading some objects (ie. the metaclass is known but it cannot retreive&#xA;&#x9; * the given reference or attribute in the ClassDefinition, the loader try to ignore them&#xA;&#x9; * by default, not setting this attribute is considered as false.&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="exceptions" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/exceptions" nsPrefix="exceptions">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/** &#xA; * Contains the definition of a Kermeta exception and a few basic exceptions.&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/exceptions_package.png&quot;/>&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="ConstraintsDiagnostic" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="prettyPrint">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;setConstraints.collect{constraint | do&#xA;&#x9;&#x9;&#x9;constraint.constraintAppliedTo.containingResource.asType(kermeta::persistence::EMFResource)&#xA;&#x9;&#x9;end}.asSet.each{resource | do&#xA;&#x9;&#x9;&#x9;resource.clean&#xA;&#x9;&#x9;end}&#xA;&#x9;setConstraints.each{c | do&#xA;&#x9;&#x9;&#x9;var resource : kermeta::persistence::EMFResource init c.constraintAppliedTo.containingResource.asType(kermeta::persistence::EMFResource)&#xA;&#x9;&#x9;&#x9;stdio.writeln(((((c.message) + (&quot; in file &quot;))) + (resource.uri)))&#xA;&#x9;&#x9;&#x9;resource.mark(c.message)&#xA;&#x9;&#x9;end}&#xA;end"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="add" ordered="false" eType="/2/standard/Void">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;setConstraints.add(cons)&#xA;end"/>
          </eAnnotations>
          <eParameters name="cons" eType="/2/exceptions/ConstraintViolatedInv"/>
        </eOperations>
        <eOperations name="initialize" eType="/2/exceptions/ConstraintsDiagnostic">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;setConstraints := kermeta::standard::Bag&lt;kermeta::exceptions::ConstraintViolatedInv>.new&#xA;&#x9;result := self&#xA;end"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="setConstraints" containment="true">
          <eGenericType eClassifier="/2/standard/Bag">
            <eTypeArguments eClassifier="/2/exceptions/ConstraintViolatedInv"/>
          </eGenericType>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Exception" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Generic exceptions&#xA; * The main class from which all the exception inherit&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="message" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/** The message attached to the exception     */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="nestedException" eType="/2/exceptions/Exception" containment="true">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/** Any nested exception     */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="stackTrace" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;     * The stack trace as a String&#xA;     * Filled by the interpreted when the exception is raised&#xA;     */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="RuntimeError" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Exception for interpreter exceptions */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="expression" eType="/2/language/behavior/Expression" containment="true">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/** The code that raised the exception */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CallOnVoidTarget" eSuperTypes="/2/exceptions/RuntimeError">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Occurs when a feature is called on void */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TypeCastError" eSuperTypes="/2/exceptions/RuntimeError">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Occurs when a cast (Object::asType operation) fails&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="NotImplementedException" eSuperTypes="/2/exceptions/RuntimeError">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Use this exception when you want to forbid the access to an unimplemented operation &#xA; * and invite to implement it&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="UpperBoundReachedError" eSuperTypes="/2/exceptions/RuntimeError">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** &#xA; * Use this exception when user tries to add an element to a property which type is collection&#xA; * which has an upper bound != -1 ( ie *)&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="AbstractClassInstantiationError" eSuperTypes="/2/exceptions/RuntimeError">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Creation on an abstract class. Usually this is detected by the type-checker. The only&#xA; * case where this happens is when instantiating a type variable, whose bound type turns&#xA; * out to be abstract.&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="IncompatibleTypeError" eSuperTypes="/2/exceptions/RuntimeError">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Raised by the Object::set operation if the type of the &#xA; * Object to set has an incompatible type.&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DivisionByZero" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** well-known attempt to divide with a zero valued divider */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="OverflowError" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** the figure oversteps the capacity of the numeric variable */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="VoidOperandError" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** one of the required operands is void */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StringIndexOutOfBound" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** the data overstep the size of the string variable */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StringFormatException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * to be written #########################################&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="IndexOutOfBound" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Occurs when trying to access out of bounds elements */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EmptyCollection" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Occurs when trying to access element on an empty collection */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="IteratorIsOff" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Occurs when calling next() operation while iterator is already&#xA; * positioned on the last element of a collection&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="IOException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** an interaction with the underlying system failed */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="FileNotFoundException" eSuperTypes="/2/exceptions/IOException">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** the file has not be found on the underlying system */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ConstraintViolatedException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Common super class for all ConstraintVioloated exceptions */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="constraintAppliedTo" eType="/2/standard/Object">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="false"/>
            <details key="documentation" value="/** Object on which the constraint was applied to&#xA;&#x9; * On Invariant, we can generally consider this object as the faulty Object&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="failedConstraint" eType="/2/language/structure/Constraint">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/** constraint that has failed&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ConstraintViolatedPre" eSuperTypes="/2/exceptions/ConstraintViolatedException">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** The pre-condition is not satisfied */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ConstraintViolatedPost" eSuperTypes="/2/exceptions/ConstraintViolatedException">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** The post-condition is not satisfied */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ConstraintViolatedInv" eSuperTypes="/2/exceptions/ConstraintViolatedException">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** An invariant isn't satisfied on a given Object */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ResourceLoadException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Occurs when Resource loading fails for some reasons */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ResourceSaveException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Occurs when Resource saving fails for some reasons */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="failedWhileSaving" eType="/2/standard/Object">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="false"/>
            <details key="documentation" value="/** Object on which the the saved failed&#xA;&#x9; * One can rescue the exception and analyse the structure next to this object, &#xA;&#x9; * this can give some clue about the faulty structure&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ResourceMixedLevelsException" eSuperTypes="/2/exceptions/ResourceSaveException">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Occurs when Resource saving fails because an object refers to an element which &#xA; * belongs to the Definition of the currently running program */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ResourceCreateException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Occurs when trying to crate a Resource already existing in the Repository */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ResourceUnconformityException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Raised when user tries to add an object that is not conform to the metamodel */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="UnregisteredMetamodelException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/** Raised when a resource cannot be loaded or saved because the URI used for &#xA; * the  metamodel is not registered&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DynamicExpressionException" eSuperTypes="/2/exceptions/Exception">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * to be written #########################################&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="io" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/io" nsPrefix="io">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/**&#xA; * Contains standard input/output related classes. &#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="FileIO" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Implementation of simple helpers to read ans write text files&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/io_package.png&quot;/>&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="writeTextFileWithEncoding">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if filename.equals(void) then&#xA;&#x9;&#x9;raise kermeta::exceptions::FileNotFoundException.new&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::io::SimpleFileIO.writeTextFileWithEncoding(filename, text, encoding)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Writes a String in a text file by using a specific encoding&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="filename" eType="/2/standard/String"/>
          <eParameters name="text" eType="/2/standard/String"/>
          <eParameters name="encoding" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="writeTextFile">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if filename.equals(void) then&#xA;&#x9;&#x9;raise kermeta::exceptions::FileNotFoundException.new&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::io::SimpleFileIO.writeTextFile(filename, text)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Writes a String in a text file&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="filename" eType="/2/standard/String"/>
          <eParameters name="text" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="readTextFile" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if filename.equals(void) then&#xA;&#x9;&#x9;raise kermeta::exceptions::FileNotFoundException.new&#xA;&#xA;&#x9;end&#xA;&#x9;var exists : kermeta::standard::Boolean&#xA;&#x9;var isdirectory : kermeta::standard::Boolean&#xA;&#x9;exists ?= extern fr::irisa::triskell::kermeta::runtime::io::SimpleFileIO.fileExists(filename)&#xA;&#x9;isdirectory ?= extern fr::irisa::triskell::kermeta::runtime::io::SimpleFileIO.fileIsDirectory(filename)&#xA;&#x9;if exists.~not then&#xA;&#x9;&#x9;var e : kermeta::exceptions::FileNotFoundException init kermeta::exceptions::FileNotFoundException.new&#xA;&#x9;&#x9;e.message := filename&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;&#x9;if isdirectory then&#xA;&#x9;&#x9;var e : kermeta::exceptions::FileNotFoundException init kermeta::exceptions::FileNotFoundException.new&#xA;&#x9;&#x9;e.message := ((filename) + (&quot; is not a file&quot;))&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::io::SimpleFileIO.readTextFile(filename)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Reads a text file&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="filename" eType="/2/standard/String"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StdIO" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * An implementation of StdIO : standard input/output&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/io_package.png&quot;/>&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="writeln">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if object.equals(void) then&#xA;&#x9;&#x9;object := &quot;&lt;void>&quot;&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.writeln(object)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Writeln the object to standard output&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="object" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="errorln">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if object.equals(void) then&#xA;&#x9;&#x9;object := &quot;&lt;void>&quot;&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.errorln(object)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Writeln the object to error output&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="object" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="error">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if object.equals(void) then&#xA;&#x9;&#x9;object := &quot;&lt;void>&quot;&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.error(object)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Writes the object to error output&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="object" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="write">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if object.equals(void) then&#xA;&#x9;&#x9;object := &quot;&lt;void>&quot;&#xA;&#xA;&#x9;end&#xA;&#x9;extern fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.write(object)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Writes the object to standard output&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="object" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="read" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if prompt.equals(void) then&#xA;&#x9;&#x9;prompt := &quot;&quot;&#xA;&#xA;&#x9;end&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.read(prompt)&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Reads a String from standard input&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="prompt" eType="/2/standard/String"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="interpreter" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/interpreter" nsPrefix="interpreter">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/**&#xA; * Contains a set of classes whose function is to evaluate a kermeta &#xA; * expression written as a string.&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/interpreter_package.png&quot;/>&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="DynamicExpression" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * DynamicExpression is a class used to make dynamic calls, i.e dynamic evaluation&#xA; * of Kermeta statements represented in a string.&#xA; * &#xA; * An example :&#xA; *   var de : DynamicExpression init DynamicExpression.new&#xA; *   de.initializeDefaults&#xA; *   de.formalParameters.put(&quot;a&quot;, String)&#xA; *   de.parse(&quot;stdio.writeln(a)&quot;) // note: to execute a list of statements, you have to surround them with do..end&#xA; *   var params : Hashtable&lt;String, Object> init Hashtable&lt;String, Object>.new&#xA; *   params.put(&quot;a&quot;, &quot;hello world!&quot;)&#xA; *   de.execute(void, params)&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/dynamic_expression_view.png&quot;/>&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eOperations name="execute" eType="/2/standard/Object">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if expression.equals(void) then&#xA;&#x9;&#x9;var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new&#xA;&#x9;&#x9;e.message := &quot;execute precondition - expression is void&quot;&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;&#x9;if errors.size.isNotEqual(0) then&#xA;&#x9;&#x9;var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new&#xA;&#x9;&#x9;e.message := &quot;execute precondition - expression contains errors&quot;&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;&#x9;result := extern fr::irisa::triskell::kermeta::runtime::language::DynamicExpression.execute(self, selfObj, actualParams)&#xA;end"/>
            <details key="documentation" value="/**&#xA;     * Execute the expression in the given context&#xA;     */"/>
          </eAnnotations>
          <eParameters name="selfObj" eType="/2/standard/Object"/>
          <eParameters name="actualParams">
            <eGenericType eClassifier="/2/utils/Hashtable">
              <eTypeArguments eClassifier="/2/standard/String"/>
              <eTypeArguments eClassifier="/2/standard/Object"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eOperations name="initializeDefaults" ordered="false" eType="/2/standard/Void">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;formalParameters := kermeta::utils::Hashtable&lt;kermeta::standard::String, kermeta::language::structure::Type>.new&#xA;&#x9;selfClass ?= kermeta::standard::Object.typeDefinition&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Initializes the formalParameters with an empty set of parameters&#xA;&#x9; * and the self type with void&#xA;&#x9; */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="parse" eType="/2/standard/Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;errors.clear&#xA;&#x9;if ((formalParameters.equals(void)) or (selfClass.equals(void))) then&#xA;&#x9;&#x9;var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new&#xA;&#x9;&#x9;e.message := &quot;parse precondition - formalParameters or selfType is void&quot;&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;&#x9;result ?= extern fr::irisa::triskell::kermeta::runtime::language::DynamicExpression.parse(self, expression)&#xA;&#x9;if errors.size.isNotEqual(0) then&#xA;&#x9;&#x9;var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new&#xA;&#x9;&#x9;e.message := &quot;parse result - expression contains errors&quot;&#xA;&#x9;&#x9;errors.each{error | do&#xA;&#x9;&#x9;&#x9;&#x9;e.message.append(((&quot;\n&quot;) + (error.message)))&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xA;&#x9; * Parse the expression as a string&#xA;&#x9; * and updates the expression field and errors&#xA;&#x9; * Returns true if the expression was parsed sucessfuly&#xA;&#x9; */"/>
          </eAnnotations>
          <eParameters name="expression" eType="/2/standard/String"/>
        </eOperations>
        <eOperations name="evalString" eType="/2/standard/Object">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if parse(body).~not then&#xA;&#x9;&#x9;var e : kermeta::exceptions::DynamicExpressionException init kermeta::exceptions::DynamicExpressionException.new&#xA;&#x9;&#x9;e.message := &quot;evalString - expression contains errors&quot;&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;&#x9;result := execute(selfObj, actualParams)&#xA;end"/>
            <details key="documentation" value="/**&#xA;     * Execute the expression given as a string.&#xA;     * the self type and formal parameters are supposed to be set&#xA;     * before calling this operation&#xA;     */"/>
          </eAnnotations>
          <eParameters name="body" eType="/2/standard/String"/>
          <eParameters name="selfObj" eType="/2/standard/Object"/>
          <eParameters name="actualParams">
            <eGenericType eClassifier="/2/utils/Hashtable">
              <eTypeArguments eClassifier="/2/standard/String"/>
              <eTypeArguments eClassifier="/2/standard/Object"/>
            </eGenericType>
          </eParameters>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="expression" eType="/2/language/behavior/Expression">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * the expression&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="errors" upperBound="-1" eType="/2/interpreter/KermetaError">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * Parse errors and type errors&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="formalParameters">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * Formal parameters of the expression (bindings between parameters' names and types)&#xA;&#x9; */"/>
          </eAnnotations>
          <eGenericType eClassifier="/2/utils/Hashtable">
            <eTypeArguments eClassifier="/2/standard/String"/>
            <eTypeArguments eClassifier="/2/language/structure/Type"/>
          </eGenericType>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="selfClass" eType="/2/language/structure/ClassDefinition">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xA;&#x9; * The type of the self object&#xA;&#x9; * or void if the expression is not to be executed&#xA;&#x9; * in the context of an object&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="KermetaError" abstract="true" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Kermeta language error in a code written in Kermeta&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="message" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
            <details key="documentation" value="/**&#xA;&#x9; * Error message&#xA;&#x9; */"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ParseError" eSuperTypes="/2/interpreter/KermetaError">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Kermeta error for parsing problems&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TypeError" eSuperTypes="/2/interpreter/KermetaError">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Type errors in a code written in Kermeta&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="ecore" nsURI="http://www.kermeta.org/kermeta/1_2_0//kermeta/ecore" nsPrefix="ecore">
      <eAnnotations source="kermeta">
        <details key="documentation" value="/** &#xA; * Contains the definition of a Kermeta classes used for compatibility with Ecore &#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/ecore_compatibility_package.png&quot;/>&#xA; */"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="EFeatureMapEntry" eSuperTypes="/2/language/structure/Object">
        <eAnnotations source="kermeta">
          <details key="documentation" value="/**&#xA; * Kermeta representation of EMF EFeatureMapEntry&#xA; * it contains the name of the required feature and the actual value&#xA; * &lt;img src=&quot;platform:/plugin/fr.irisa.triskell.kermeta.documentation/src/figures/ecore_compatibility_package.png&quot;/>&#xA; */"/>
          <details key="CompilerIgnore" value="true"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="value" eType="/2/language/structure/Object" containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="eStructuralFeatureName" eType="/2/standard/String">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
    </eSubpackages>
  </ecore:EPackage>
  <ecore:EAnnotation source="dependentResource"/>
</xmi:XMI>
