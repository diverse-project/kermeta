-----------------------------------------------------------------
$Id : $
TODO and FIXME for fr.irisa.triskell.kermeta.io project
-----------------------------------------------------------------

************** 25/02/2005 : ********************

Dans loader
	KMT2KMExperessionBuilder
	KMT2KMExperessionListBuilder
	KMT2KMLogicalExperessionBuilder
	-> y a un "e" en trop...
Dans ast
	fAssignement : y a aussi un "e" en trop...
	
FIXME :
1/ Weird cases where errors are not detected :
example : 

	class Toto{}
	awrongtoken
	class Titi{}
	
This could be because "awrongtoken" is a valuable expression
But an assertion failure is thrown when such a weird token appears before any class definition...

2/ The method from Gymnat generated ASTNode "getTextLength" returns always the 0 value.


**************** 08/03/2005 ************************

Definition of the lambda expression :
There is a redundant syntax : 

function { parametres | appel(avec les parametres)} 
or : 
{ parametres | appel(avec les parametres) }

In the first case, function keyword is used to "define" a lambda 
expression and can then be assigned to an element of type FunctionType.

Example : 
---------
	result : FunctionType
	result := function { a | not(a) }
	
In the second case, it is used to "call" a lambda expression, 
which stands as an argument :

	some_call { a | not(a) } 

In a non functional language, we need a syntax to specify a lambda expression : 
here, we have" function" and/or the curlies...So, isn't that too sugared?

Another problem :
The arguments in an operation call (in an assignment) are defined as a postfixlst :

list postfixlst : postfix* ;
abstract postfix : callPostfix | fLambdaExpression | paramPostfix;

This allows the following examples of notations :

* f1.f2.f3(a, b, c) -> correct
* f1(a, b, f4.f5(c)) -> correct
* f1(a, b)(c, d)     -> coherent but this is a functional orientation
* f1 { a | not(a) } { b | not(b) } -> coherent as well but priority rules to define

But not this one, which is though coherent as well :

	f1 ( { a | not(a) } )
	
Nor any other call that mixes lambda expressions and "normal" expresssions (fExpressions),
like :

	f1 ( {a | not(a) } , i : Integer)

**************** 08/03/2005 (2) ************************

We have to decide, later, if the following cases will be allowed by Kermeta grammar 
or not :

* f1 ({lambda}, fExp)
* f1 ({lambda},{lambda})
* f1 {lambda}
* f1 ({lambda})
* f1 (fExp, fExp)

i.e, in a regexp formalism, something like : 
	operationCall = operationName LPAREN paramList RPAREN
	paramList = ( lambdaExpression | fExpression ) +

	
(chsais au moins faire les TODO;-P