/* $Id: Pass1.kmt,v 1.24 2008-06-26 12:49:57 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 *			Francois Tanguy <ftanguy@irisa.fr>
 */


package kermeta::language::structure;


require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "CreateEcoreModelElement.kmt"
require "../common/TraceStructure.kmt"
require "../helper/KM2EcoreHelper.kmt"
require "../common/Exception.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"

using ecore
using km2ecore
using km2ecore::helper::kermeta
using km2ecore::common::exception

aspect class Object {
	operation applyPass1(context : KM2EcoreContext) is do
	end
}

aspect class ModelingUnit {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore package
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
		// Compile the owned elements
		self.eachOwnedElement{ p | p.applyPass1(context) }
		// Getting the ecore packages
		self.packages.each{p|
			self.ecorePackages.add( p.ecoreModelElement )
		}
	end
}

aspect class Require {
	method applyPass1(context : KM2EcoreContext) is do
		self.createEcoreModelElement(context)
	end
}

aspect class Using {
	method applyPass1(context : KM2EcoreContext) is do
		self.createEcoreModelElement(context)
	end
}

aspect class Package {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore package
		var ecorePackage : EPackage init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.nestingPackage
		//p ?= self.container()
		if ( p != void ) then
			p.ecoreModelElement.eSubpackages.add(ecorePackage)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecorePackage
		// Compile the owned elements
		self.eachOwnedElement{ cd |
			if cd.getDeprecated() == "" then
					cd.applyPass1(context)
			end
		}
	end
}

aspect class PrimitiveType {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		//context.primitiveType_Type := PrimitiveType_Type.edatatype
		//var ecoreDataType : EDataType init self.createEcoreModelElement(context).asType(EDataType)		
		//context.primitiveType_Type := PrimitiveType_Type.eclass
		var eModelElement : EDataType init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(eModelElement)
		// Setting the ecore proxy
		//self.ecoreDataType := ecoreDataType
		self.ecoreModelElement := eModelElement
		// Compile the owned elements
		self.eachOwnedElement{ cd | cd.applyPass1(context) }
	end 
}

aspect class Enumeration { 
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreEnumeration : EEnum init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(ecoreEnumeration)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreEnumeration
		// Compile the owned elements
		self.eachOwnedElement{ l | l.applyPass1(context) }
	end
} 
  
aspect class EnumerationLiteral {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreEnumLiteral : EEnumLiteral init self.createEcoreModelElement(context)
		// Setting the container
		var e : Enumeration init self.~enumeration.asType(Enumeration)
		e.ecoreModelElement.eLiterals.add(ecoreEnumLiteral)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreEnumLiteral
	end
}
  
aspect class ClassDefinition {
	method applyPass1(context : KM2EcoreContext) is do
	
		//stdio.writeln("  +--+ " + self.name)
		
		// Getting the container
		var p : Package init self.container().asType(Package)
		
		// If this ClassDefinition is a subType of kermeta::standard::ValueType then
		// an EAttribute value is added to allow the use of the value of a ValueType
		//stdio.writeln("ClassDefinition applyPass1(): " + self.qualifiedName + " " + self.isValueType().toString())
		if self.isValueType() then
		
			//stdio.writeln(" ---- ClassDefinition applyPass1(): " + self.name)

			var instanceClassName : String init self.getEMFInstanceClassName()
			
			if instanceClassName != "" then
				var eDataType : EDataType init EDataType.new
				eDataType.name := self.name
				eDataType.instanceClassName := instanceClassName
				// Setting the container
				p.ecoreModelElement.eClassifiers.add(eDataType)
				// Setting the ecore proxy
				self.ecoreDataType := eDataType
			
				// Compile only the methods that are not taking directly
				// into account by the target language like times() for an Integer
				self.ownedOperation.each{ o |
					//stdio.writeln("operation: " + o.name)
					/*var static_tag : Tag init o.ownedTags.detect{ t |
						t.name == "EMF_static"
					}*/
					if o.getEMFStatic()!="" then
						stdio.writeln("An EMF_static method has been detected: " + o.name)
						//TODO Compile with Simk
					end
				}
			else
				if not self.isAbstract then
					raise UndefinedValueTypeInstanceClassNameException.new()
				end
			end
		else
					
			// Creating the associated ecore class
			var ecoreClass : EClass init self.createEcoreModelElement(context)		
			// Setting the container
			p.ecoreModelElement.eClassifiers.add(ecoreClass)
			// Setting the ecore proxy
			self.ecoreModelElement := ecoreClass
			
			// Compile the owned elements
			self.eachOwnedElement{ o |
				if not o.isInstanceOf(Operation) then
					o.applyPass1(context)
				else
					if o.asType(Operation).mustBeCompiled() then
						//stdio.writeln("opopop: " + o.asType(Operation).name + " " + self.name)
						o.applyPass1(context)
					end
				end
			}
							
		end
		
		rescue (e : UndefinedValueTypeInstanceClassNameException) do
			stdio.errorln("The class definition: " + self.qualifiedName + " is a ValueType, but the tag: @EMF_instanceClassName has not been correctly setted, please check this one in the *.km file that you try to load.")
		end
	end
	
} 
  
aspect class Property {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreStructuralFeature : EStructuralFeature init self.createEcoreModelElement(context)
		// Setting the container
		var c : ClassDefinition
		c ?= self.container()
		c.ecoreModelElement.eStructuralFeatures.add( ecoreStructuralFeature )
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreStructuralFeature
		// Compile the owned elements
		self.eachOwnedElement{ o | o.applyPass1(context) }
	end 
}

aspect class Operation {
	method applyPass1(context : KM2EcoreContext) is do
	
		//stdio.writeln("createOperation: " + self.name)
		
		// Compile only the method, if that are not taking directly
		// into account by the target language like times() for an Integer
		
		/*if getEMFStatic()!="" then
			stdio.writeln("An EMF_static method has been detected: " + self.name)
			//TODO Compile with Simk
			//o.applyPass1(context)
		
		else*/
			//stdio.writeln("Operation " + self.name + " " + self.container.asType(ClassDefinition).name)
			// Creating the associated ecore class
			var ecoreOperation : EOperation init self.createEcoreModelElement(context)
			// Setting the container
			var c : ClassDefinition
			c ?= self.container()
			c.ecoreModelElement.eOperations.add(ecoreOperation)
			// Setting the ecore proxy
			self.ecoreModelElement := ecoreOperation
			// Compile the owned elements
			self.eachOwnedElement{ o |
				o.applyPass1(context)
			}
		
		//end
		
	end
}

aspect class Parameter {
	method applyPass1(context : KM2EcoreContext) is do
	
		var ecoreParameter : EParameter
		
		// DETERMINE if the parameter should be compiled or redirect to a KermetaSpecialType
		// Case of the FunctionType
		if self.type.isInstanceOf(FunctionType) then
			ecoreParameter := EParameter.new
			ecoreParameter.name := self.name
			stdio.writeln("Pass1 - inline")
			//TODO inline of the FunctionType
		else
			// Creating the associated ecore class
			ecoreParameter := self.createEcoreModelElement(context)
		end
		
		// Setting the container
		var o : Operation init self.container().asType(Operation)
		o.ecoreModelElement.eParameters.add( ecoreParameter )
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreParameter
	end
}

aspect class Constraint {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the container
		var c : Object init self.container
		var p : Property init c.getPropertyValue("ecoreModelElement")
		if ( p!= void ) then
			var ecoreModelElement : EModelElement init c.get(p).asType(EModelElement)
			ecoreModelElement.eAnnotations.add(ecoreAnnotation)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
	end
}

aspect class ObjectTypeVariable {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreTypeParameter : ETypeParameter init self.createEcoreModelElement(context)
		// Setting the container
		var container : Object init self.container
		if container.isInstanceOf(ClassDefinition) then
			container.asType(ClassDefinition).ecoreModelElement.eTypeParameters.add(ecoreTypeParameter)
		else
			if container.isInstanceOf(Operation) then
				container.asType(Operation).ecoreModelElement.eTypeParameters.add(ecoreTypeParameter)
			end
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreTypeParameter
	end
}

aspect class Tag {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the container
		var c : Object init self.container
		
		if ( c.isInstanceOf(ModelingUnit) ) then
			c.asType(ModelingUnit).entryPoints.add(ecoreAnnotation)
		else
			var p : Property init c.getPropertyValue("ecoreModelElement")
			if ( not p.isVoid() ) then
				var ecoreModelElement_retrieved : EModelElement init c.get(p).asType(EModelElement)
				ecoreModelElement_retrieved.eAnnotations.add(ecoreAnnotation)
			end
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
	end
}