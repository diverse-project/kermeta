/* $Id: Pass1.kmt,v 1.8 2008-04-02 08:39:30 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 *			Francois Tanguy <ftanguy@irisa.fr>
 */


package kermeta::language::structure;


require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "CreateEcoreModelElement.kmt"
require "../common/trace_structure.kmt"
require "../helper/KM2EcoreHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/pass1/Pass1.kmt"


using ecore
using km2ecore
using km2ecore::helper::kermeta

aspect class Object {
	operation applyPass1(context : KM2EcoreContext) is do
	end
}

aspect class ModelingUnit {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore package
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
		// Compile the owned elements
		self.eachOwnedElement{ p | p.applyPass1(context) }
		// Getting the ecore packages
		self.packages.each{p|
			self.ecorePackages.add( p.ecoreModelElement )
		}
	end
}

aspect class Package {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore package
		var ecorePackage : EPackage init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.nestingPackage
		//p ?= self.container()
		if ( p != void ) then
			p.ecoreModelElement.eSubpackages.add(ecorePackage)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecorePackage
		// Compile the owned elements
		self.eachOwnedElement{ cd | cd.applyPass1(context) }
	end
}

aspect class PrimitiveType {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreDataType : EDataType init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(ecoreDataType)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreDataType
		// Compile the owned elements
		self.eachOwnedElement{ cd | cd.applyPass1(context) }
	end 
}

aspect class Enumeration { 
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreEnumeration : EEnum init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(ecoreEnumeration)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreEnumeration
		// Compile the owned elements
		self.eachOwnedElement{ l | l.applyPass1(context) }
	end
} 
  
aspect class EnumerationLiteral {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreEnumLiteral : EEnumLiteral init self.createEcoreModelElement(context)
		// Setting the container
		var e : Enumeration init self.~enumeration.asType(Enumeration)
		e.ecoreModelElement.eLiterals.add(ecoreEnumLiteral)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreEnumLiteral
	end
}  
  
aspect class ClassDefinition {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreClass : EClass init self.createEcoreModelElement(context)		
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(ecoreClass)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreClass
		// Compile the owned elements
		self.eachOwnedElement{ o |
			o.applyPass1(context)
		}
		
		// If this ClassDefinition is a subType of kermeta::standard::ValueType then
		// an EAttribute value is added to allow the use of the value of a ValueType
		/*if not self.superType.detect{ sp | sp.isInstanceOf(ParameterizedType) and sp.asType(ParameterizedType).typeDefinition.qualifiedName == "kermeta::standard::ValueType" }.isVoid() then
			var type_tag : Tag init self.ownedTags.detect{ t |
				t.name == "selfType"
			}
			if not type_tag.isVoid() then
				var ecoreDataType : EDataType init EDataType.new
				ecoreDataType.name := "K" + self.name + "DataType"
				ecoreDataType.instanceClassName := type_tag.~value
				p.ecoreModelElement.eClassifiers.add(ecoreDataType)
			
				var myEAttribute : EAttribute init EAttribute.new
				myEAttribute.name := "value"
				myEAttribute.ordered := true
				myEAttribute.unique := true
				myEAttribute.lowerBound := 0
				myEAttribute.upperBound := 1
				myEAttribute.derived := false
				myEAttribute.eType := ecoreDataType
				
				self.ecoreModelElement.eStructuralFeatures.add(myEAttribute)
			end
		end*/
	end
	
} 
  
aspect class Property {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreStructuralFeature : EStructuralFeature init self.createEcoreModelElement(context)
		// Setting the container
		var c : ClassDefinition
		c ?= self.container()
		c.ecoreModelElement.eStructuralFeatures.add( ecoreStructuralFeature )
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreStructuralFeature
		// Compile the owned elements
		self.eachOwnedElement{ o | o.applyPass1(context) }
	end 
}

aspect class Operation {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreOperation : EOperation init self.createEcoreModelElement(context)
		// Setting the container
		var c : ClassDefinition
		c ?= self.container()
		c.ecoreModelElement.eOperations.add(ecoreOperation)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreOperation
		// Compile the owned elements
		self.eachOwnedElement{ o | o.applyPass1(context) }
	end
}

aspect class Parameter {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreParameter : EParameter init self.createEcoreModelElement(context)
		// Setting the container
		var o : Operation init self.container().asType(Operation)
		o.ecoreModelElement.eParameters.add( ecoreParameter )
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreParameter
	end
}

aspect class Constraint {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the container
		var c : Object init self.container
		var p : Property init ObjectHelper.new.getPropertyValue(c, "ecoreModelElement")
		if ( p!= void ) then
			var ecoreModelElement : EModelElement init c.get(p).asType(EModelElement)
			ecoreModelElement.eAnnotations.add(ecoreAnnotation)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
	end
}

aspect class ObjectTypeVariable {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreTypeParameter : ETypeParameter init self.createEcoreModelElement(context)
		// Setting the container
		var container : Object init self.container
		if ( container.isInstanceOf(ClassDefinition) ) then		
			container.asType(ClassDefinition).ecoreModelElement.eTypeParameters.add(ecoreTypeParameter)
		else
			container.asType(Operation).ecoreModelElement.eTypeParameters.add(ecoreTypeParameter)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreTypeParameter
	end
}

aspect class Tag {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the container
		var c : Object init self.container
		
		if ( c.isInstanceOf(ModelingUnit) ) then
			c.asType(ModelingUnit).entryPoints.add(ecoreAnnotation)
		else
			var p : Property init ObjectHelper.new.getPropertyValue(c, "ecoreModelElement")
			if ( not p.isVoid() ) then
				var ecoreModelElement_retrieved : EModelElement init c.get(p).asType(EModelElement)
				ecoreModelElement_retrieved.eAnnotations.add(ecoreAnnotation)
			end
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
	end
}