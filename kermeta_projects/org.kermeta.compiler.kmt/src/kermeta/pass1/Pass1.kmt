/* $Id: Pass1.kmt,v 1.31 2008-09-08 19:58:26 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 *			Francois Tanguy <ftanguy@irisa.fr>
 */


package kermeta::language::structure;


require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "CreateEcoreModelElement.kmt"
require "../common/TraceStructure.kmt"
require "../helper/KM2EcoreHelper.kmt"
require "../common/Exception.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"

using ecore
using km2ecore
using km2ecore::helper::kermeta
using km2ecore::common::exception

aspect class Object {
	operation applyPass1(context : KM2EcoreContext) is do
	end
}

aspect class ModelingUnit {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore EAnnotation
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
		// Compile the owned elements
		self.eachOwnedElement{ p | p.applyPass1(context) }
		// Getting the ecore packages
		self.packages.each{p|
			self.ecorePackages.add( p.ecoreModelElement )
		}
	end
}

aspect class Require {
	method applyPass1(context : KM2EcoreContext) is do
		self.createEcoreModelElement(context)
	end
}

aspect class Using {
	method applyPass1(context : KM2EcoreContext) is do
		self.createEcoreModelElement(context)
	end
}

aspect class Package {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore package
		var ecorePackage : EPackage init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.nestingPackage
		//p ?= self.container()
		if ( p != void ) then
			p.ecoreModelElement.eSubpackages.add(ecorePackage)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecorePackage
		// Compile the owned elements
		self.eachOwnedElement{ cd |
			if cd.getDeprecated() == "" then
					cd.applyPass1(context)
			end
		}
	end
}

aspect class PrimitiveType {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore class
		//context.primitiveType_Type := PrimitiveType_Type.edatatype
		//var ecoreDataType : EDataType init self.createEcoreModelElement(context).asType(EDataType)		
		//context.primitiveType_Type := PrimitiveType_Type.eclass
		var eModelElement : EDataType init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(eModelElement)
		// Setting the ecore proxy
		//self.ecoreDataType := ecoreDataType
		self.ecoreModelElement := eModelElement
		// Compile the owned elements
		self.eachOwnedElement{ cd | cd.applyPass1(context) }
	end 
}

aspect class Enumeration { 
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore enumeration
		var ecoreEnumeration : EEnum init self.createEcoreModelElement(context)
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(ecoreEnumeration)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreEnumeration
		// Compile the owned elements
		self.eachOwnedElement{ l | l.applyPass1(context) }
	end
} 
  
aspect class EnumerationLiteral {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore EEnumLiteral
		var ecoreEnumLiteral : EEnumLiteral init self.createEcoreModelElement(context)
		// Setting the container
		var e : Enumeration init self.~enumeration.asType(Enumeration)
		e.ecoreModelElement.eLiterals.add(ecoreEnumLiteral)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreEnumLiteral
	end
}
  
aspect class ClassDefinition {
	method applyPass1(context : KM2EcoreContext) is do
	
		// Getting the container
		var p : Package init self.container().asType(Package)
		
		// If this ClassDefinition is a subType of kermeta::standard::ValueType then
		// an EAttribute value is added to allow the use of the value of a ValueType
		if self.isValueType() then
		
			var instanceClassName : String init self.getEMFInstanceClassName()
			
			if instanceClassName != "" then
				var eDataType : EDataType init EDataType.new
				// The EDataType name is prefixed by Java
				eDataType.name := "Java" + self.name
				eDataType.instanceClassName := instanceClassName
				
				context.valueTypeMapping.add(instanceClassName)
				
				// Setting the container
				p.ecoreModelElement.eClassifiers.add(eDataType)
				// Setting the ecore proxy
				self.ecoreDataType := eDataType
			else
				if not self.isAbstract then
					var except : UndefinedValueTypeInstanceClassNameException init UndefinedValueTypeInstanceClassNameException.new()
					except.message := "The class definition: " + self.qualifiedName +
						 " is a ValueType, but the tag: @EMF_instanceClassName has not been correctly setted, please check this one in the *.km file that you try to load."
					raise except
				end
			end
			
		else
					
			// Creating the associated ecore EClass
			var ecoreClass : EClass init self.createEcoreModelElement(context)		
			// Setting the container
			p.ecoreModelElement.eClassifiers.add(ecoreClass)
			// Setting the ecore traceability
			self.ecoreModelElement := ecoreClass
			
			// Compiling the owned elements
			self.eachOwnedElement{ o |
				if not o.isInstanceOf(Operation) then
					o.applyPass1(context)
				else
					var op : Operation init o.asType(Operation)
					// The function types are not compiled, but inlined directly during their usages
					if (not op.isFunctionType()) then
						op.applyPass1(context)
					end
				end
			}
							
		end

	end
	
} 
  
aspect class Property {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore EStructuralFeature
		var ecoreStructuralFeature : EStructuralFeature init self.createEcoreModelElement(context)
		// Setting the container
		var c : ClassDefinition
		c ?= self.container()
		c.ecoreModelElement.eStructuralFeatures.add( ecoreStructuralFeature )
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreStructuralFeature
		// Compile the owned elements
		self.eachOwnedElement{ o | o.applyPass1(context) }
	end 
}

aspect class Operation {
	method applyPass1(context : KM2EcoreContext) is do
		
		// Creating the associated ecore EOperation
		var ecoreOperation : EOperation init self.createEcoreModelElement(context)
		// Setting the container
		var c : ClassDefinition
		c ?= self.container()
		c.ecoreModelElement.eOperations.add(ecoreOperation)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreOperation
		// Compile the owned elements
		self.eachOwnedElement{ o |
			o.applyPass1(context)
		}
		
	end
}

aspect class Parameter {
	method applyPass1(context : KM2EcoreContext) is do
	
		var ecoreParameter : EParameter
		
		// DETERMINE if the parameter should be compiled or redirect to a KermetaSpecialType
		// Case of the FunctionType
		if self.type.isInstanceOf(FunctionType) then
			ecoreParameter := EParameter.new
			ecoreParameter.name := self.name
		else
			// Creating the associated ecore parameter
			ecoreParameter := self.createEcoreModelElement(context)
		end
		
		// Setting the container
		var o : Operation init self.container().asType(Operation)
		o.ecoreModelElement.eParameters.add( ecoreParameter )
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreParameter
	end
}

aspect class Constraint {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore EAnnotation
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the container
		var c : Object init self.container
		var p : Property init c.getPropertyValue("ecoreModelElement")
		if ( p!= void ) then
			var ecoreModelElement : EModelElement init c.get(p).asType(EModelElement)
			ecoreModelElement.eAnnotations.add(ecoreAnnotation)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
	end
}

aspect class ObjectTypeVariable {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore ETypeParameter
		var ecoreTypeParameter : ETypeParameter init self.createEcoreModelElement(context)
		// Setting the container
		var container : Object init self.container
		if container.isInstanceOf(ClassDefinition) then
			container.asType(ClassDefinition).ecoreModelElement.eTypeParameters.add(ecoreTypeParameter)
		else
			if container.isInstanceOf(Operation) then
				container.asType(Operation).ecoreModelElement.eTypeParameters.add(ecoreTypeParameter)
			end
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreTypeParameter
	end
}

aspect class Tag {
	method applyPass1(context : KM2EcoreContext) is do
		// Creating the associated ecore EAnnotation
		var ecoreAnnotation : EAnnotation init self.createEcoreModelElement(context)
		// Setting the container
		var c : Object init self.container
		
		if ( c.isInstanceOf(ModelingUnit) ) then
			c.asType(ModelingUnit).entryPoints.add(ecoreAnnotation)
		else
			var p : Property init c.getPropertyValue("ecoreModelElement")
			if ( not p.isVoid() ) then
				var ecoreModelElement_retrieved : EModelElement init c.get(p).asType(EModelElement)
				ecoreModelElement_retrieved.eAnnotations.add(ecoreAnnotation)
			end
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
	end
}