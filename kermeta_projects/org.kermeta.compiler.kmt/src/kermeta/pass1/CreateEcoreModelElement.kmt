/* $Id: CreateEcoreModelElement.kmt,v 1.21 2008-06-12 10:18:46 cfaucher Exp $
 * Creation date: February 1, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Francois Tanguy <ftanguy@irisa.fr>
 *			Cyril Faucher <cfaucher@irisa.fr>
 */

package kermeta::language::structure;


require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "../common/ContainmentTraversable.kmt"
require "../helper/KM2EcoreHelper.kmt"
require "../common/Exception.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"

using ecore
using kermeta::utils
using km2ecore
using km2ecore::helper::ecore
using km2ecore::helper::kermeta
using km2ecore::common::exception
using km2ecore::helper::java

/**
 *
 */
aspect class ModelingUnit {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		var ecoreAnnotation : EAnnotation init EAnnotation.new
		ecoreAnnotation.source := "ModelingUnit"
		
		var requireEntry : EStringToStringMapEntry init EStringToStringMapEntry.new
		requireEntry.key := "require"
		requireEntry.~value := ""
		// Setting the details
		ecoreAnnotation.details.add(requireEntry)
		
		var usingEntry : EStringToStringMapEntry init EStringToStringMapEntry.new
		usingEntry.key := "using"
		usingEntry.~value := ""
		// Setting the details
		ecoreAnnotation.details.add(usingEntry)
		
		//self.eachOwnedElement{ omu | omu.createEcoreModelElement(context) }

		result := ecoreAnnotation
	end
}

/**
 * 
 */
aspect class Require {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		
		var ecoreAnnotation : EAnnotation init self.container.asType(ModelingUnit).ecoreModelElement
		
		// Get of the require entry
		var requireEntry : EStringToStringMapEntry init ecoreAnnotation.details.detect{ d | d.key == "require" }
		
		requireEntry.~value := requireEntry.~value + self.uri + "|"
		
		result := ecoreAnnotation
	end
}

/**
 * 
 */
aspect class Using {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		
		var ecoreAnnotation : EAnnotation init self.container.asType(ModelingUnit).ecoreModelElement
		
		// Get of the using entry
		var usingEntry : EStringToStringMapEntry init ecoreAnnotation.details.detect{ d | d.key == "using" }
		
		usingEntry.~value := usingEntry.~value + self.qualifiedName + "|"
		
		// Setting the details
		ecoreAnnotation.details.add(usingEntry)
		
		result := ecoreAnnotation
	end
}

/**
 *
 */
aspect class Package {
	operation createEcoreModelElement(context : KM2EcoreContext) : EPackage is do
	
		stdio.writeln(" + Package " + self.name + " in progress")
		
		var ecorePackage : EPackage init EPackage.new
		ecorePackage.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		
		if not self.uri.isVoid() and self.uri != "" then
			ecorePackage.nsURI := self.uri
		else
			raise UndefinedUriEPackageException.new()
		end
		
		// In order complete the EMF checking, we have to set the nsPrefix to "", void is not enough
		ecorePackage.nsPrefix := ""
		result := ecorePackage
	
		rescue (e : UndefinedUriEPackageException) do
			stdio.errorln("The uri of the Package: " + self.qualifiedName + " is not correctly setted, please check this one in the *.km file that you try to load.")
		end
	end
}

/**
 *
 */
aspect class PrimitiveType {
	operation createEcoreModelElement(context : KM2EcoreContext) : EDataType is do
		
		var eModelElement : EDataType init EDataType.new
		
		eModelElement.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		//eModelElement.serializable
		//eModelElement.instanceTypeName
		//eModelElement.defaultValue
		
		
		// by default
		eModelElement.instanceClassName := "java.lang.Object"
//		if self.getClassFromPrimitiveType().isInstanceOf(Class) then

			//if self.getClassFromPrimitiveType().isValueType() then
				var instanceClassName : String init self.getEMFEDataTypeInstanceClassName()
				if instanceClassName != "" then
					eModelElement.instanceClassName := instanceClassName
				end				
			//end
			
			var qualifiedName : String init self.getClassFromPrimitiveType().asType(Class).typeDefinition.qualifiedName
			eModelElement.eAnnotations.add(EAnnotationHelper.new.createKermetaEAnnotation(KermetaEAnnotationKey.~alias.name.toString(), qualifiedName))
			
			if eModelElement.instanceClassName == "" then
				eModelElement.instanceClassName := qualifiedName.replace("::", ".")
			end
			
//		end
		
		result := eModelElement
	end
}

/**
 *
 */
aspect class Enumeration {
	operation createEcoreModelElement(context : KM2EcoreContext) : EEnum is do
		var ecoreEnumeration : EEnum init EEnum.new
		ecoreEnumeration.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		//ecoreEnumeration.serializable
		//ecoreEnumeration.instanceClass
		//ecoreEnumeration.instanceTypeName
		//ecoreEnumeration.instanceClassName
		//ecoreDataType.defaultValue
		result := ecoreEnumeration
	end
}

/**
 *
 */
aspect class EnumerationLiteral {
	operation createEcoreModelElement(context : KM2EcoreContext) : EEnumLiteral is do
		var ecoreEnumerationLiteral : EEnumLiteral init EEnumLiteral.new
		ecoreEnumerationLiteral.name := self.name
		ecoreEnumerationLiteral.literal := self.name
		ecoreEnumerationLiteral.~value := self.~enumeration.asType(Enumeration).ecoreModelElement.eLiterals.size
		//ecoreEnumerationLiteral.instance
		result := ecoreEnumerationLiteral
	end 
}

/**
 *
 */
aspect class ClassDefinition {
	operation createEcoreModelElement(context : KM2EcoreContext) : EClass is do
		var ecoreClass : EClass init EClass.new
		ecoreClass.interface := false
		ecoreClass.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		ecoreClass.~abstract := self.isAbstract
		
		/*if not (self.getEMFInstanceClassName() == "") then
			ecoreClass.instanceClassName := self.getEMFInstanceClassName()
		end*/
		result := ecoreClass
	end
}

/**
 *
 */
aspect class Operation {
	operation createEcoreModelElement(context : KM2EcoreContext) : EOperation is do
		var ecoreOperation : EOperation init EOperation.new
		ecoreOperation.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		ecoreOperation.ordered := self.isOrdered
		ecoreOperation.unique := self.isUnique
		ecoreOperation.lowerBound := self.lower
		ecoreOperation.upperBound := self.upper
		//ecoreOperation.many := 
		//ecoreOperation.required :=
		if self.isAbstract then
			var ecoreAnnotation : EAnnotation init EAnnotationHelper.new.createAbstract()
			ecoreOperation.eAnnotations.add( ecoreAnnotation )
		end 
		result := ecoreOperation 
	end
}

/**
 *
 */
aspect class Parameter {
	operation createEcoreModelElement(context : KM2EcoreContext) : EParameter is do
		var ecoreParameter : EParameter init EParameter.new
		ecoreParameter.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		//ecoreParameter.ordered
		//ecoreParameter.unique
		//ecoreParameter.lowerBound
		//ecoreParameter.upperBound
		//ecoreParameter.many
		//ecoreParameter.required
		result := ecoreParameter
	end
}

/**
 *
 */
aspect class Constraint {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		// TODO : Fill the body using the java pretty printer
		var body : String init ""
				
		if self.container.isInstanceOf(ClassDefinition) then
			result := EAnnotationHelper.new.create("kermeta.inv", self.name, body)		
		else
			if ConstraintHelper.new.isPre(self) then
				result := EAnnotationHelper.new.create("kermeta.pre", self.name, body)	
			else
				result := EAnnotationHelper.new.create("kermeta.post", self.name, body)
			end
		end
	end
}

/**
 *
 */
aspect class Property {
	operation createEcoreModelElement(context : KM2EcoreContext) : EStructuralFeature is do
		var ecoreStructuralFeature : EStructuralFeature
		var current_type : Type init self.type.asType(Type)
		//stdio.writeln("Create Property: " + self.name) + " - " + current_type.toString() + " - " + current_type.getTypeName())
		if current_type.isValueType() or current_type.isEnumeration() then
			//stdio.writeln("Create Property2: " + self.name + " " + self.type.getTypeName())
			ecoreStructuralFeature := EAttribute.new
			//ecoreStructuralFeature.iD := 
		else
			ecoreStructuralFeature := EReference.new
			ecoreStructuralFeature.asType(EReference).containment := self.isComposite
		end
		
		EcoreModelElementHelper.new.setEStructuralFeatureProperties(self, ecoreStructuralFeature, context)
		
		if self.isDerived then
			var annotation : EAnnotation init EAnnotationHelper.new.createKermetaEAnnotation(KermetaEAnnotationKey.isReadOnly.name.toString(), self.isReadOnly.toString())
			ecoreStructuralFeature.eAnnotations.add(annotation)
		end
		// management of read only
		// management of default		
		result := ecoreStructuralFeature
	end
}

/**
 *
 */
aspect class ObjectTypeVariable {
	operation createEcoreModelElement(context : KM2EcoreContext) : ETypeParameter is do
		var ecoreTypeParameter : ETypeParameter init ETypeParameter.new
		ecoreTypeParameter.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		result := ecoreTypeParameter
	end
}

/**
 *
 */
aspect class Tag {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		var ecoreAnnotation : EAnnotation init EAnnotationHelper.new.getKermetaEAnnotation(self)
		
		if ( self.name.isVoid() ) then
		
			EAnnotationHelper.new.addEntry(ecoreAnnotation, KermetaEAnnotationKey.documentation.name.toString(), self.~value)
			//ecoreAnnotation := EAnnotationHelper.new.createKermetaEAnnotation(KermetaEAnnotationKey.documentation.name.toString(), self.~value)
		else
			EAnnotationHelper.new.addEntry(ecoreAnnotation, self.name, self.~value)
			//ecoreAnnotation := EAnnotationHelper.new.createKermetaEAnnotation(self.name, self.~value)
		end
		result := ecoreAnnotation
	end
}
