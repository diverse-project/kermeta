/* $Id: CreateEcoreModelElement.kmt,v 1.47 2009-02-10 13:33:28 cfaucher Exp $
 * Creation date: February 1, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Francois Tanguy <ftanguy@irisa.fr>
 *			Cyril Faucher <cfaucher@irisa.fr>
 *
 * This file is dedicated to the creation of Ecore elements during the first pass of the Km2Ecore transformation
 * Typically, the "createEcoreModelElement" methods are builders called during the traverse in Pass1.kmt
 */

package kermeta::language::structure;


require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "../common/ContainmentTraversable.kmt"
require "../helper/KM2EcoreHelper.kmt"
require "../common/Exception.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"

using ecore
using kermeta::standard
using kermeta::utils
using km2ecore
using km2ecore::helper::ecore
using km2ecore::helper::kermeta
using km2ecore::common::exception
using km2ecore::helper::java

/**
 *
 */
aspect class ModelingUnit {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		var ecoreAnnotation : EAnnotation init EAnnotation.new
		ecoreAnnotation.source := "ModelingUnit"
		
		var requireEntry : EStringToStringMapEntry init EStringToStringMapEntry.new
		requireEntry.key := "require"
		requireEntry.~value := ""
		// Setting the details
		ecoreAnnotation.details.add(requireEntry)
		
		var usingEntry : EStringToStringMapEntry init EStringToStringMapEntry.new
		usingEntry.key := "using"
		usingEntry.~value := ""
		// Setting the details
		ecoreAnnotation.details.add(usingEntry)

		result := ecoreAnnotation
	end
}

/**
 * 
 */
aspect class Require {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		
		var ecoreAnnotation : EAnnotation init self.container.asType(ModelingUnit).ecoreModelElement
		
		// Get of the require entry
		var requireEntry : EStringToStringMapEntry init ecoreAnnotation.details.detect{ d | d.key == "require" }
		
		requireEntry.~value := requireEntry.~value + self.uri + "|"
		
		result := ecoreAnnotation
	end
}

/**
 * 
 */
aspect class Using {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		
		var ecoreAnnotation : EAnnotation init self.container.asType(ModelingUnit).ecoreModelElement
		
		// Get of the using entry
		var usingEntry : EStringToStringMapEntry init ecoreAnnotation.details.detect{ d | d.key == "using" }
		
		usingEntry.~value := usingEntry.~value + self.qualifiedName + "|"
		
		// Setting the details
		ecoreAnnotation.details.add(usingEntry)
		
		result := ecoreAnnotation
	end
}

/**
 *
 */
aspect class Package {
	operation createEcoreModelElement(context : KM2EcoreContext) : EPackage is do
	
		stdio.writeln(" + Package " + self.qualifiedName + " in progress")
		
		var ecorePackage : EPackage init EPackage.new
		ecorePackage.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		
		if not self.uri.isVoid() and self.uri != "" then
			ecorePackage.nsURI := self.uri + "/kermeta_temp_uri"
			ecorePackage.eAnnotations.add(EAnnotationHelper.new().createKermetaEAnnotation("ecoreUri", self.uri))
		else
			var default_uri : String init "http://www.kermeta.org/" + self.qualifiedName.replace("::", "/")
			ecorePackage.nsURI := default_uri + "/kermeta_temp_uri"
			ecorePackage.eAnnotations.add(EAnnotationHelper.new().createKermetaEAnnotation("ecoreUri", default_uri))
			//raise UndefinedUriEPackageException.new()
		end
		
		// In order complete the EMF checking, we have to set the nsPrefix to "", void is not enough
		ecorePackage.nsPrefix := ""
		result := ecorePackage
	
		/*rescue (e : UndefinedUriEPackageException) do
			stdio.errorln("The uri of the Package: " + self.qualifiedName + " is not correctly setted, please check this one in the *.km file that you try to load.")
		end*/
	end
}

/**
 *
 */
aspect class PrimitiveType {
	operation createEcoreModelElement(context : KM2EcoreContext) : EDataType is do
		
		var eModelElement : EDataType init EDataType.new
		
		eModelElement.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		//eModelElement.serializable
		//eModelElement.instanceTypeName
		//eModelElement.defaultValue
		
		
		// by default
		eModelElement.instanceClassName := "java.lang.Object"

		var instanceClassName : String init self.getEMFEDataTypeInstanceClassName()
		if instanceClassName != "" then //is an EDataType from an Ecore model
			eModelElement.instanceClassName := instanceClassName
			var etps : Sequence<String> init self.getUniqueTagValue("ecore.EDataType_eTypeParameters").split(" , ")
			
			if etps.size()>0 then
				etps.each{ etp |
					if etp!="" then
						var ecoreTypeParameter : ETypeParameter init ETypeParameter.new
						ecoreTypeParameter.name := IdentifierHelper.new.getMangledIdentifier(etp, context)
						eModelElement.eTypeParameters.add(ecoreTypeParameter)
					end
				}
			end
			
			eModelElement.serializable := self.getEMFEDataTypeIsSerializable
			
		end				
		
		var typeDef : TypeDefinition init self.getClassFromPrimitiveType().asType(Class).typeDefinition
		var typeDef_EMFInstanceClassName : String init typeDef.getEMFInstanceClassName()
		
		if (typeDef_EMFInstanceClassName != "") and (eModelElement.instanceClassName == "" or eModelElement.instanceClassName == "java.lang.Object") then
			eModelElement.instanceClassName := typeDef_EMFInstanceClassName
		end
		
		var qualifiedName : String init typeDef.qualifiedName
		eModelElement.eAnnotations.add(EAnnotationHelper.new.createKermetaEAnnotation(KermetaEAnnotationKey.~alias.name.toString(), qualifiedName))
			
		if eModelElement.instanceClassName == "" then
			eModelElement.instanceClassName := qualifiedName.replace(context.KERMETA_SEPARATOR, context.JAVA_SEPARATOR)
		end
		
		
		result := eModelElement
	end
}

/**
 *
 */
aspect class Enumeration {
	operation createEcoreModelElement(context : KM2EcoreContext) : EEnum is do
		var ecoreEnumeration : EEnum init EEnum.new
		ecoreEnumeration.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		//ecoreEnumeration.serializable := true
		//ecoreEnumeration.instanceClass
		//ecoreEnumeration.instanceTypeName
		//ecoreEnumeration.instanceClassName
		//ecoreDataType.defaultValue
		result := ecoreEnumeration
	end
}

/**
 *
 */
aspect class EnumerationLiteral {
	operation createEcoreModelElement(context : KM2EcoreContext) : EEnumLiteral is do
		var ecoreEnumerationLiteral : EEnumLiteral init EEnumLiteral.new
		ecoreEnumerationLiteral.name := self.name
		ecoreEnumerationLiteral.literal := self.name
		ecoreEnumerationLiteral.~value := self.~enumeration.asType(Enumeration).ecoreModelElement.eLiterals.size
		//ecoreEnumerationLiteral.instance
		result := ecoreEnumerationLiteral
	end 
}

/**
 *
 */
aspect class ClassDefinition {
	operation createEcoreModelElement(context : KM2EcoreContext) : EClass is do
		var ecoreClass : EClass init EClass.new
		ecoreClass.interface := false
		ecoreClass.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		ecoreClass.~abstract := self.isAbstract
		
		result := ecoreClass
	end
}

/**
 *
 */
aspect class Operation {
	operation createEcoreModelElement(context : KM2EcoreContext) : EOperation is do
		var ecoreOperation : EOperation init EOperation.new
		
		ecoreOperation.name := self.getFinalName(context)
		ecoreOperation.ordered := self.isOrdered
		ecoreOperation.unique := self.isUnique
		ecoreOperation.lowerBound := self.lower
		ecoreOperation.upperBound := self.upper
		
		//ecoreOperation.many := is a derived property => not setted
		//ecoreOperation.required := is a derived property => not setted
		
		if self.isAbstract then
			var ecoreAnnotation : EAnnotation init EAnnotationHelper.new.createAbstract()
			ecoreOperation.eAnnotations.add( ecoreAnnotation )
		end 
		result := ecoreOperation 
	end
}

/**
 *
 */
aspect class Parameter {
	operation createEcoreModelElement(context : KM2EcoreContext) : EParameter is do
		var ecoreParameter : EParameter init EParameter.new
		ecoreParameter.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		ecoreParameter.ordered := self.isOrdered
		ecoreParameter.unique := self.isUnique
		ecoreParameter.lowerBound := self.lower
		ecoreParameter.upperBound := self.upper
		
		//ecoreParameter.many := is a derived property
		//ecoreParameter.required := is a derived property
		result := ecoreParameter
	end
}

/**
 *
 */
aspect class Constraint {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		// TODO : Fill the body using the java pretty printer
		var body : String init ""
				
		if self.stereotype==ConstraintType.~inv then
			result := EAnnotationHelper.new.create("kermeta.inv", self.name, body)		
		else
			if self.stereotype==ConstraintType.~pre then
				result := EAnnotationHelper.new.create("kermeta.pre", self.name, body)	
			else
				if self.stereotype==ConstraintType.~post then
					result := EAnnotationHelper.new.create("kermeta.post", self.name, body)
				end
			end
		end
	end
}

/**
 *
 */
aspect class Property {
	operation createEcoreModelElement(context : KM2EcoreContext) : EStructuralFeature is do
		var ecoreStructuralFeature : EStructuralFeature
		var current_type : Type init self.type.asType(Type)
		
		if current_type.isValueType() or current_type.isEnumeration() or current_type.isEDataType() then
			ecoreStructuralFeature := EAttribute.new
			//ecoreStructuralFeature.iD := 
		else
			ecoreStructuralFeature := EReference.new
			ecoreStructuralFeature.asType(EReference).containment := self.isComposite
		end
		
		EcoreModelElementHelper.new.setEStructuralFeatureProperties(self, ecoreStructuralFeature, context)
		
		if self.isDerived then
			// FIXME: Maybe this eAnnotation could be removed, because the "changeable" attribute is setted
			// the Kermeta loader for Ecore could inspect for checking which property is taking into account
			// the "changeable" attribute or the EAnnotation
			var annotation : EAnnotation init EAnnotationHelper.new.createKermetaEAnnotation(KermetaEAnnotationKey.isReadOnly.name.toString(), self.isReadOnly.toString())
			ecoreStructuralFeature.eAnnotations.add(annotation)
		end
		
		ecoreStructuralFeature.transient := self.getEMFIsTransient()
		
		if (not ecoreStructuralFeature.transient)
				and ecoreStructuralFeature.isInstanceOf(EAttribute)
				and self.type.getMetaClass().typeDefinition.qualifiedName == "kermeta::language::structure::Enumeration" then
			ecoreStructuralFeature.asType(EAttribute).transient := true
		end
		
		// management of read only
		// management of default
		
		result := ecoreStructuralFeature
	end
}

/**
 *
 */
aspect class ObjectTypeVariable {
	operation createEcoreModelElement(context : KM2EcoreContext) : ETypeParameter is do
		var ecoreTypeParameter : ETypeParameter init ETypeParameter.new
		ecoreTypeParameter.name := IdentifierHelper.new.getMangledIdentifier(self.name, context)
		result := ecoreTypeParameter
	end
}

/**
 *
 */
aspect class Tag {
	operation createEcoreModelElement(context : KM2EcoreContext) : EAnnotation is do
		var ecoreAnnotation : EAnnotation init EAnnotationHelper.new.getKermetaEAnnotation(self)
		
		if self.name.isVoid() then
			EAnnotationHelper.new.addEntry(ecoreAnnotation, KermetaEAnnotationKey.documentation.name.toString(), self.~value)
		else
			EAnnotationHelper.new.addEntry(ecoreAnnotation, self.name, self.~value)
		end
		result := ecoreAnnotation
	end
}
