/* $Id: ExpressionHelper.kmt,v 1.24 2008-09-29 15:44:42 cfaucher Exp $
 * Creation date: Jul 25, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors:
 * 			Cyril Faucher <cfaucher@irisa.fr>
 */

package kermeta::language::behavior;

require kermeta
require "KermetaHelper.kmt"
require "../java/JavaHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"

using kermeta::language::structure
using kermeta::standard
using kermeta::utils
using km2ecore
using km2ecore::helper::kermeta
using km2ecore::helper::java

aspect class Expression {
	
	attribute beforeLambdaExpressionResult : String [0..1]
	
	method mustBeAssigned() : Boolean is do
		result := false
		
		if self.isInstanceOf(CallVariable)
			or self.isInstanceOf(Literal)
			or self.isInstanceOf(SelfExpression)
			or self.isInstanceOf(CallResult)
			or self.isInstanceOf(VoidType) then
			result := true
		end
		
		if self.isFunctionTypeVariable() then
			result := false
		end
		
	end
	
	operation isFunctionTypeVariable() : Boolean is do
		result := false
		
		if self.isInstanceOf(CallVariable) then
			if self.asType(CallVariable).isFunctionTypeVariable() then
				result := true
			end
		end
	end
	
	/**
	 * Check if the current element is at the end of an Expression, if so a ";" is added
	 */
	operation endOfExpressionFixer() : String is do
		result := ""
		
		if not self.callsFunctionType() then
		
		if self.container.isInstanceOf(Conditional) or self.container.isInstanceOf(Loop) or self.container.isInstanceOf(Block) or self.container.isInstanceOf(Rescue) or self.container.isInstanceOf(Assignment) or self.container.isInstanceOf(VariableDecl) then
			if self.container.isInstanceOf(Assignment) then
				if self.container.asType(Assignment).target == self then
					result := ""
				else
					if self.container.asType(Assignment).target.isCallFeatureAsStaticProperty() then
						result := ""
					else
						result := ";"
					end
				end
			else
				result := ";"
			end
			
		end
		
		end
	end
	
}


aspect class CallVariable {
	
	operation isParameter() : Boolean is do
		result := false
		if self.container.isInstanceOf(CallFeature) then
			var exp : Expression init self.container.asType(CallFeature).parameters.detect{ p |
				p==self
			}
			if not exp.isVoid() then
				result := true
			end
		end
	end
	
	operation isParameterSingle() : Boolean is do
		result := false
		
		if self.isParameter() then
			var cf_ : CallFeature init self.container.asType(CallFeature)
			var i : Integer init -1
			var exp : Expression init cf_.parameters.detect{ p |
				i := i+1
				p==self
			}
			if cf_.staticOperation.ownedParameter.elementAt(i).asType(Parameter).upper==1 then
				result := true
			end
		end
	end
	
	operation isParameterMany() : Boolean is do
		result := false
		
		if self.isParameter() then
			var cf_ : CallFeature init self.container.asType(CallFeature)
			var i : Integer init -1
			var exp : Expression init cf_.parameters.detect{ p |
				i := i+1
				p==self
			}
			if cf_.staticOperation.ownedParameter.elementAt(i).asType(Parameter).upper!=1 then
				result := true
			end
		end
	end
	
	operation getCallFeatureCorrespondingParameter() : Parameter is do
		result := void

		if self.isParameter() then
			var cf_ : CallFeature init self.container.asType(CallFeature)
			var i : Integer init -1
			var exp : Expression init cf_.parameters.detect{ p |
				i := i+1
				p==self
			}
			result := cf_.staticOperation.ownedParameter.elementAt(i).asType(Parameter)
		end
	end
	
	operation isParameterForOwningOperation() : Boolean is do
		result := false
		// The container could not be an Operation, but a derived property
		if self.container.isInstanceOf(CallFeature) and (not self.getContainerAsType(Operation).isVoid()) then
			result := not self.getContainerAsType(Operation).asType(Operation).ownedParameter.detect{ p |
				p.name==self.name
			}.isVoid()
		end
	end
	
	operation isParameterForOwningOperationSingle() : Boolean is do
		result := false
		if not self.retrieveCorrespondingParameter().isVoid() then
			if self.retrieveCorrespondingParameter().upper==1 then
				result := true
			end
		end
	end
	
	operation isParameterForOwningOperationMany() : Boolean is do
		result := false
		if not self.retrieveCorrespondingParameter().isVoid() then
			if self.retrieveCorrespondingParameter().upper!=1 then
				result := true
			end
		end
	end
	
	operation isParameterManyAndForOwningOperation() : Boolean is do
		result := false
		
		if self.isParameterMany() and self.isParameterForOwningOperation() then
			result := true
		end
	end
	
	method isFunctionTypeVariable() : Boolean is do
		result := false
		var ftParam : Parameter init retrieveCorrespondingParameter()
		if not ftParam.isVoid() then
			if ftParam.isFunctionType() then
				result := true
			end
		end
	end
	
	/** Retrieve in an operation signature, the parameter that is a function type */
	operation getFunctionTypeParameter() : Parameter is do
		var ftParam : Parameter init retrieveCorrespondingParameter()
		if not ftParam.isVoid() then
			if ftParam.isFunctionType() then
				result := ftParam
			end
		end
	end
	
	operation retrieveCorrespondingParameter() : Parameter is do
		result := void
		// The container could not be an Operation, but a derived property
		if not self.getContainerAsType(Operation).isVoid() then
			result := self.getContainerAsType(Operation).asType(Operation).ownedParameter.detect{ p | p.name == self.name }
		end
	end
	
	operation isDeclaredInLambdaExpression() : Boolean is do
		result := false
		
		if not self.getContainerAsType(LambdaExpression).isVoid() then
		
			var tmp_block : Block
			tmp_block ?= self.getContainerAsType(Block)
			var aStatement : Expression
			if not tmp_block.isVoid() then
				aStatement := getVariableDeclInBlock(tmp_block)
			end
			
			if not aStatement.isVoid() then
				if aStatement.isInstanceOf(VariableDecl) then
					var theVariableDecl : VariableDecl init aStatement.asType(VariableDecl)
					result := not theVariableDecl.getContainerAsType(LambdaExpression).isVoid()
				end
			end
			
			if not result then
				var tmp_loop : Loop
				tmp_loop ?= self.getContainerAsType(Loop)
				var aStatement_ : Expression
				if not tmp_loop.isVoid() then
					aStatement_ := getVariableDeclInLoop(tmp_loop)
				end
				
				if not aStatement_.isVoid() then
					if aStatement_.isInstanceOf(VariableDecl) then
						var theVariableDecl : VariableDecl init aStatement_.asType(VariableDecl)
						result := not theVariableDecl.getContainerAsType(LambdaExpression).isVoid()
					end
				end
			end
		end
		
	end
	
	operation getVariableDeclInBlock(block : Block) : Expression is do
		result := block.statement.detect{s |
			if s.isInstanceOf(VariableDecl) then
				s.asType(VariableDecl).identifier == self.name
			else
				false
			end
		}
		
		if result.isVoid() and (not block.getContainerAsType(Block).isVoid()) then
			result := getVariableDeclInBlock(block.getContainerAsType(Block).asType(Block))
		end
	end
	
	operation getVariableDeclInLoop(l : Loop) : Expression is do
		result := void

		if not l.isVoid() then
			if not l.initialization.isVoid() then
				if l.initialization.isInstanceOf(VariableDecl) then
					if l.initialization.asType(VariableDecl).identifier == self.name then
						result := l.initialization.asType(VariableDecl)
					end
				end
			end
		end
		
		if result.isVoid() and (not l.getContainerAsType(Loop).isVoid()) then
			result := getVariableDeclInLoop(l.getContainerAsType(Loop).asType(Loop))
		end
	end
	
	operation isDeclaredInAFunctionType() : Boolean is do

		result := false
		
		if not self.getContainerAsType(Operation).isVoid() then
			if self.getContainerAsType(Operation).asType(Operation).isFunctionType() then

				var tmp_block : Block
				tmp_block ?= self.getContainerAsType(Block)
				var aStatement : Expression
				if not tmp_block.isVoid() then
					aStatement := getVariableDeclInBlock(tmp_block)
				end
				
				if not aStatement.isVoid() then
					if aStatement.isInstanceOf(VariableDecl) then
						var theVariableDecl : VariableDecl init aStatement.asType(VariableDecl)
						result := theVariableDecl.getContainerAsType(Operation).asType(Operation).isFunctionType()
					end
				end

				if not result then
					var tmp_loop : Loop
					tmp_loop ? = self.getContainerAsType(Loop)
					var aStatement_ : Expression
					if not tmp_loop.isVoid() then
						aStatement_ := getVariableDeclInLoop(tmp_loop)
					end

					if not aStatement_.isVoid() then
						if aStatement_.isInstanceOf(VariableDecl) then
							var theVariableDecl : VariableDecl init aStatement_.asType(VariableDecl)
							result := theVariableDecl.getContainerAsType(Operation).asType(Operation).isFunctionType()
						end
					end
				end
			
			end
		end
		
	end
	
	operation isLambdaExpressionParameter() : Boolean is do
		result := false	
		if not self.getContainerAsType(LambdaExpression).isVoid() then
			result := not getLambdaParameter(self.getContainerAsType(LambdaExpression).asType(LambdaExpression)).isVoid()
		end
	end
	
	operation getCorrespondingLambdaExpressionParameter() : LambdaParameter is do
		result := void
		
		if not self.getContainerAsType(LambdaExpression).isVoid() then
			//result := not self.getContainerAsType(LambdaExpression).asType(LambdaExpression).parameters.detect{ p | p.name == self.name }.isVoid()
			result := getLambdaParameter(self.getContainerAsType(LambdaExpression).asType(LambdaExpression))
		end
	end
	
	operation getLambdaParameter(lambdaExpression : LambdaExpression) : LambdaParameter is do
		result := void
		
		if not lambdaExpression.isVoid() then
			result := lambdaExpression.parameters.detect{ p | p.name == self.name }
			
			if (result.isVoid()) and (not lambdaExpression.getContainerAsType(LambdaExpression).isVoid()) then
				result := getLambdaParameter(lambdaExpression.getContainerAsType(LambdaExpression).asType(LambdaExpression))
			end
		end
	end
}

aspect class CallFeature {	
	
	// This attribute is on CallFeature, because the called operation
	// may be called futher times in the same expression series
	attribute calledFtResult : String [0..1]
	
	operation isParameter() : Boolean is do
		result := false
		if self.container.isInstanceOf(CallFeature) then
			result := not self.container.asType(CallFeature).parameters.detect{ p |
				p==self
			}.isVoid()
		end
	end
	
	// Determine if the callFeature is called by a static method: Java package 'util'
	operation fromUtil(context : KM2EcoreContext) : Boolean is do
	
		var fName : String  init IdentifierHelper.new.getMangledIdentifier(self.name, context)
		
		//stdio.writeln(" -- " + self.toString + " - " + self.staticOperation.toString + " - " + self.staticOperation.container().toString)
		
		if self.staticOperation.container().asType(ClassDefinition).isValueType()
		
			or (self.staticOperation.container().asType(ClassDefinition).qualifiedName=="kermeta::language::structure::Object"
				and (
					context.frameworkOperations.contains(fName)
						or ( (not target.isInstanceOf(CallVariable)) 
								and (not target.isInstanceOf(CallResult))
								and (not target.isInstanceOf(CallFeature))
								and (not target.isInstanceOf(SelfExpression))
							)
					)
				)
			
			or (self.staticOperation.container().asType(ClassDefinition).qualifiedName=="kermeta::language::structure::Type"
				and (
					context.frameworkOperations.contains(fName)
						or ( (not target.isInstanceOf(CallVariable)) 
								and (not target.isInstanceOf(CallResult))
								and (not target.isInstanceOf(CallFeature))
								and (not target.isInstanceOf(SelfExpression))
							)
					)
				)
		then
			result := true
		else
			result := false
		end
						
	end
	
	// Determine if the callFeature refers a method owned by the class definition: "Class"
	operation isFromClass() : Boolean is do
		result := false
		if not self.staticOperation.isVoid() then
			if self.staticOperation.container.asType(ClassDefinition).qualifiedName=="kermeta::language::structure::Class" then
				result := true
			end
		end
	end
	
	operation getFunctionType() : FunctionType is do
		result ?= self.containedType.detect{ t | t.isInstanceOf(FunctionType)}
	end
	
	operation getFunctionTypeReturnType() : Type is do
		result := void
		if not self.getFunctionType().isVoid() then
			result := self.getFunctionType().right
		end
	end

	operation createStringFromFunctionType(context : KM2EcoreContext) : String is do
		
		var tgt : Expression init self.target
		
		var map_type : Hashtable<Type, Type> init Hashtable<Type, Type>.new()
		var inc_tp : Integer init 0
		self.staticTypeVariableBindings.each{ type_ |
			map_type.put(self.staticOperation.typeParameter.elementAt(inc_tp), type_)
			inc_tp := inc_tp + 1			
		}
		context.ftMapTypeStack.push(map_type)
		
		/************/
		context.pushFtSuffix()
		/************/
		
		//Lambda expression to inline
		var ftRightType : Type init Type.new()
		if not self.parameters.detect{param | param.isInstanceOf(LambdaExpression)}.isVoid() then
			
			var theLambdaExp : LambdaExpression init self.parameters.detect{param | param.isInstanceOf(LambdaExpression)}.asType(LambdaExpression)
		
			context.ftStack.push(theLambdaExp)
			
			self.staticOperation.lambdaExpression := theLambdaExp
			theLambdaExp.cuid := context.inc_ftSuffix.toString()
			self.staticOperation.cuid := context.inc_ftSuffix.toString()
			
			if theLambdaExp.staticType.isInstanceOf(FunctionType) then
			
				var current_functionType : FunctionType init theLambdaExp.staticType.asType(FunctionType)
				
				if current_functionType.left.isInstanceOf(ProductType) then
					context.ftProductTypeStack.push(current_functionType.left.asType(ProductType))
				end
				
				ftRightType := current_functionType.right
			end
		end
		
		var ft_str : String init ""
		
		//stdio.writeln("context.pushFtSuffix()")
		//context.pushFtSuffix()
		
		
		// Replacing the self
		if tgt.callsFunctionType() then
			// FIXME CF 08-09-10
			context.ftSuffixActivation := true
			
			context.ftContextualSelf := context.SELF_EXPRESSION_TO_REPLACE
		else
			/*if tgt.isInstanceOf(CallFeature) then
				var tmp_cl : CallFeature init tgt.asType(CallFeature)
				
				if tmp_cl.target.isInstanceOf(SelfExpression) then
					if not tmp_cl.target.asType(SelfExpression).getContainerAsType(Operation).isVoid() then
					
					var	tmp_op : Operation init tmp_cl.target.asType(SelfExpression).getContainerAsType(Operation).asType(Operation)
						if tmp_op.isFunctionType() and tmp_cl.target.getContainerAsType(LambdaExpression).isVoid() then
							stdio.writeln("tgt.toString(): " + tmp_cl.name + " - " + tgt.createBehaviorJava(context))
							context.ftSuffixActivation := true
							stdio.writeln("tgt.toString() with true: " + tmp_cl.name + " - " + tgt.createBehaviorJava(context))
						end
					end
				end
			end*/
			
			context.ftContextualSelf := tgt.createBehaviorJava(context)
		end
		
		// FIXME CF 08-09-10
		context.ftSuffixActivation := true

		var callElement : String init ""
		if self.container.isInstanceOf(VariableDecl) then
			callElement := IdentifierHelper.new.getMangledIdentifier(self.container.asType(VariableDecl).identifier, context)
		else
			if self.container.isInstanceOf(CallVariable) then
				stdio.writeln("Please contact the development team if you have this case !")
				callElement := IdentifierHelper.new.getMangledIdentifier(self.container.asType(CallVariable).name, context)
			end
		end
		
		if (callElement != "") then
			ft_str := ft_str + "null;\n"
		end
		
		if self.container.isInstanceOf(Assignment) then
			if self.container.asType(Assignment).target.isInstanceOf(CallResult) then
				callElement := self.container.asType(Assignment).target.createBehaviorJava(context)
			end
			if self.container.asType(Assignment).target.isInstanceOf(CallVariable) then
				callElement := self.container.asType(Assignment).target.createBehaviorJava(context)
			end
		end
		
		
		ft_str := ft_str + context.SEPARATOR_STATEMENT_FT + "//BIft:" + self.staticOperation.name + "\n"
		
		context.ftSuffixActivation := false
		var type_ftReturnType : String init self.staticType.createBehaviorJava(context) //self.getFunctionTypeReturnType().createBehaviorJava(context)
		context.ftSuffixActivation := true
		
		context.ftReturnType := type_ftReturnType
		
		/****************************/
		/****************************/
		/****************************/
		/****************************/
		/****************************/
		/****************************/
		//if self.target.staticType.getTypeQName() == self.staticOperation.container.asType(ClassDefinition).qualifiedName then
			ft_str := ft_str + self.staticOperation.createBehaviorJava(context)
		/*else
			ft_str := ft_str + self.getMoreAppropriateOperation().createBehaviorJava(context)
		end*/
		
				
		// Management of the result last statement,
		// at the end of the function type a binding between the variables of the calling operation
		// and the variables of the given function type
		if callElement != "" then
			//callElement
			ft_str := ft_str + "\n//CE\n"
			
			if context.getResultLastStatementId()!="" then
				ft_str := ft_str + context.getResultLastStatementId() + "result" + context.printFtSuffix() + ";\n"
			else
				ft_str := ft_str + callElement + " = result" + context.printFtSuffix() + ";\n"
			end
		end
		
		if (callElement == "") and self.container.isInstanceOf(Assignment) then
			if self.container.asType(Assignment).target.isInstanceOf(CallResult) then
				//callElement
				ft_str := ft_str + "\n//CER\n"
				ft_str := ft_str + context.RETURN_EXPRESSION_TO_REPLACE + "result" + context.printFtSuffix() + ";\n"
			end
		end
		
		if (callElement == "") and self.container.isInstanceOf(Conditional) then
			//if self.container.asType(Assignment).target.isInstanceOf(CallResult) then
				//callElement
				ft_str := ft_str + "\n//CEC\n"
				ft_str := ft_str + context.getResultLastStatementId() + "result" + context.printFtSuffix() + ";\n"
			//end
		end
		// End of the Management of the result last statement
		
		if (callElement == "") and (not Operation.new().isVoidType(self.staticType.getTypeName())) then
			self.calledFtResult := "result" + context.printFtSuffix()
		end
		
		ft_str := ft_str + "//EIft:" + self.staticOperation.name + "\n"
		
		//Pop all the stacks related to the compiling of function type
		context.ftSuffixActivation := false
		context.ftMapTypeStack.pop()
		context.ftProductTypeStack.pop()
		context.ftSuffix.pop()
		//context.current_param_ft.pop()
		
		result := ft_str
	end
	
	/** In progress */
	operation getMoreAppropriateOperation() : Operation is do
		result := void
		
		var op_name : String init self.staticOperation.name
		
		stdio.writeln("getMoreAppropriateOperation(): " + op_name.toString())
		
		var typeOfCallingCallFeature : Type init self.target.staticType
		
		var detectedOp : Operation init typeOfCallingCallFeature.asType(ParameterizedType).typeDefinition.asType(ClassDefinition).ownedOperation.detect{ op | op.name==op_name}
		
		if not detectedOp.isVoid() then
			result := detectedOp
		else
			var sc : OrderedSet<Class> init typeOfCallingCallFeature.asType(Class).superClass()
			
			
			/*sc.detect{ class_ |
				class_.asType(ParameterizedType).typeDefinition.asType(ClassDefinition).ownedOperation.exists{ op | op.name==op_name}
			}*/
			
	        var superClasses : OrderedSet<Class> init OrderedSet<Class>.new
	        superClasses.addAll(sc)
	        
	        from  not superClasses.isEmpty
	        until superClasses.isEmpty or (not result.isVoid())
	        loop
	            var ttttyp : Type init superClasses.detect{ class_ |
					class_.asType(ParameterizedType).typeDefinition.asType(ClassDefinition).ownedOperation.exists{ op | op.name==op_name}
				}
				if not ttttyp.isVoid() then
					result := ttttyp.asType(ParameterizedType).typeDefinition.asType(ClassDefinition).ownedOperation.detect{ op | op.name==op_name}
				else
					var tmp : OrderedSet<Class> init OrderedSet<Class>.new
					superClasses.each{ sc | tmp.addAll(sc.superClass())}
	            	superClasses.clear()
	            	superClasses.addAll(tmp)
				end
	        end
		end
	end
	
	operation printGetAccessor() : String is do
		result := self.staticProperty.printGetAccessor()
	end
	
	operation printSetAccessor() : String is do
		result := self.staticProperty.printSetAccessor()
	end

	/**
	 * Unused for the moment
	 */
	operation getParamBindings() : String is do
		result := ""
		var i : Integer init 0
		self.parameters.each{ param |
			if param.isInstanceOf(LambdaExpression) then
				if param.asType(LambdaExpression).staticType.isInstanceOf(ProductType) then
					param.asType(LambdaExpression).staticType.asType(ProductType).type.each{ t |
						if i==1 then
							result := result + ", "
						else
							i := 1
						end
						result := result + t.getTypeQName()
					}
				end
			end
		}
		if result != "" then
			result := "<" + result + ">"
		end
	end

}