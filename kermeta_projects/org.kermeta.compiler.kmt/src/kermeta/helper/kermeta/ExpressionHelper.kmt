/* $Id: ExpressionHelper.kmt,v 1.4 2008-08-07 14:59:01 cfaucher Exp $
 * Creation date: Jul 25, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors:
 * 			Cyril Faucher <cfaucher@irisa.fr>
 */

package kermeta::language::behavior;

require kermeta
require "KermetaHelper.kmt"
require "../java/JavaHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"

using kermeta::language::structure
using kermeta::standard
using kermeta::utils
using km2ecore
using km2ecore::helper::kermeta
using km2ecore::helper::java

aspect class Expression {

	method mustBeAssigned() : Boolean is do
		result := false
		
		if self.isInstanceOf(CallVariable)
			or self.isInstanceOf(Literal)
			or self.isInstanceOf(SelfExpression)
			or self.isInstanceOf(CallResult)
			or self.isInstanceOf(VoidType) then
			result := true
		end
		
		
		if self.isInstanceOf(CallVariable) then
			if self.asType(CallVariable).isFunctionTypeVariable() then
				result := false
			end
		end
		
		
	end
	
}


aspect class CallVariable {

	operation isFunctionTypeVariable() : Boolean is do
		result := false
		var ftParam : Parameter init retrieveCorrespondingParameter()
		if not ftParam.isVoid() then
			if ftParam.isFunctionType() then
				result := true
			end
		end
	end
	
	operation getFunctionTypeParameter() : Parameter is do
		var ftParam : Parameter init retrieveCorrespondingParameter()
		if not ftParam.isVoid() then
			if ftParam.isFunctionType() then
				result := ftParam
			end
		end
	end
	
	operation retrieveCorrespondingParameter() : Parameter is do
		result := self.getContainerAsType(Operation).asType(Operation).ownedParameter.detect{ p | p.name == self.name }
	end
}

aspect class CallFeature {

	/*operation retrieveTopCallFeatureFunctionType() : CallFeature is do
		
		var return : Boolean init false
		
		var test : CallFeature init self
		
		from return
        until return
        loop
        	return := true
        	if test.target.isInstanceOf(CallFeature) then
        		
            	test := test.target.asType(CallFeature)
            	
            	if test.callsFunctionType() then
            		result := test
            		return := false
            	end
            	
            end
        end
        
	end*/

	operation createStringFromFunctionType(context : KM2EcoreContext) : String is do
		
		var tgt : Expression init self.target
		
		context.tasks_stack.push("FunctionType_Compilation")
		
		//Retrieve the corresponding CallFeature for setting the name of the searched call variable
		self.staticOperation.ownedParameter.each{ p |
			if p.type.isInstanceOf(FunctionType) then
				context.current_param_ft := p.name
			end
		}
		
		var map_type : Hashtable<Type, Type> init Hashtable<Type, Type>.new()
		var inc_tp : Integer init 0
		self.staticTypeVariableBindings.each{ type_ |
			map_type.put(self.staticOperation.typeParameter.elementAt(inc_tp), type_)
			inc_tp := inc_tp + 1			
		}
		context.ftMapTypeStack.push(map_type)
		
		//Lambda expression to inline
		var ftRightType : Type init Type.new()
		if self.parameters.one().isInstanceOf(LambdaExpression) then
		
			var theLambdaExp : LambdaExpression init self.parameters.one().asType(LambdaExpression)
		
			context.ftStack.push(theLambdaExp)
			
			if theLambdaExp.staticType.isInstanceOf(FunctionType) then
				if theLambdaExp.staticType.asType(FunctionType).left.isInstanceOf(ProductType) then
				
					/*var type_ : Type init theLambdaExp.container.asType(CallFeature).containedType.detect{ ft | ft.isInstanceOf(FunctionType) }
					
					var ft_ : FunctionType init type_.asType(FunctionType)
					
					if not ft_.isVoid() then
						if ft_.left.isInstanceOf(ProductType) then
							context.ftProductTypeStack.push(ft_.left.asType(ProductType))
						end
					end*/
				
					context.ftProductTypeStack.push(theLambdaExp.staticType.asType(FunctionType).left.asType(ProductType))
				end
				
				ftRightType := theLambdaExp.staticType.asType(FunctionType).right
			end
		end
		
		
		
		var ft_str : String init ""
		
		context.pushFtSuffix()
		
		//Replacing the self
		if tgt.callsFunctionType() then
			//context.ftSuffixActivation := true
			context.ftContextualSelf := context.SELF_EXPRESSION_TO_REPLACE// + context.getFtSuffix()
			//context.ftSuffixActivation := false
		else
		//if context.ftContextualSelf=="" then
			context.ftContextualSelf := tgt.createBehaviorJava(context)
		end
		
		context.ftSuffixActivation := true
		
		var callElement : String init ""
		if self.container.isInstanceOf(VariableDecl) then
			callElement := IdentifierHelper.new.getMangledIdentifier(self.container.asType(VariableDecl).identifier, context)
		else
			if self.container.isInstanceOf(CallVariable) then
				callElement := IdentifierHelper.new.getMangledIdentifier(self.container.asType(CallVariable).name, context)
			end
		end
		
		if callElement != "" or self.container.isInstanceOf(Assignment) then
			ft_str := ft_str + "null;\n"
		end
		
		ft_str := ft_str + "//Beginning of the Inlining of the function type: " + self.staticOperation.name + "\n"
		
		///////////////
		context.ftSuffixActivation := false
		var type_ftReturnType : String init self.staticType.createBehaviorJava(context)
		//stdio.writeln("+++ type_ftReturnType +++ " + type_ftReturnType)
		context.ftSuffixActivation := true
		
		/* NOT USED IF DESACTIVATION
		if type_ftReturnType.split("<").size()>1 then
			type_ftReturnType := type_ftReturnType.split("<").one()
		end
		
		var tp_ftReturnType : String init ""
		var i_t_ : Integer init 0
		self.staticTypeVariableBindings.each{ t |
			if i_t_==1 then
				tp_ftReturnType := tp_ftReturnType + ", "
			else
				i_t_ := 1
			end
			tp_ftReturnType := tp_ftReturnType + t.createBehaviorJava(context)
		}
		if tp_ftReturnType!="" then
			tp_ftReturnType := "<" + tp_ftReturnType + ">"
		end*/
		context.ftReturnType := type_ftReturnType/* + tp_ftReturnType*/
		///////////////
		
		ft_str := ft_str + self.staticOperation.createBehaviorJava(context)
		
		if callElement != "" then
			ft_str := ft_str + "\n//callElement\n"
			ft_str := ft_str + callElement + " = result" + context.getFtSuffix() + ";\n"
		end
		
		if callElement == "" and (not Operation.new().isVoidType(self.staticType.getTypeName())) then
			//ft_str := ft_str + self.staticType.createBehaviorJava(context) + " res_res = result" + context.getFtSuffix() + ";\n"
			//context.ftContextualSelf := "result" + context.getFtSuffix()
			
			context.resultOfLastFt := "result" + context.getFtSuffix()
		end
		
		ft_str := ft_str + "//Ending of the Inlining of the function type: " + self.staticOperation.name + "\n"
		
		context.ftSuffixActivation := false
		context.ftMapTypeStack.pop()
		context.ftProductTypeStack.pop()
		context.ftSuffix.pop()
		
		result := ft_str
	end


	/**
	 * Unused for the moment
	 */
	operation getParamBindings() : String is do
		result := ""
		var i : Integer init 0
		self.parameters.each{ param |
			if param.isInstanceOf(LambdaExpression) then
				if param.asType(LambdaExpression).staticType.isInstanceOf(ProductType) then
					param.asType(LambdaExpression).staticType.asType(ProductType).type.each{ t |
						if i==1 then
							result := result + ", "
						else
							i := 1
						end
						result := result + t.getTypeQName()
					}
				end
			end
		}
		if result != "" then
			result := "<" + result + ">"
		end
	end

	/**
	 * Unused and it should be removed
	 */
	operation getPP(tgt : Expression, fName : String, context : KM2EcoreContext) : String is do
		result := ""
		
		var isBoolean : Boolean init tgt.staticType.isBooleanTypeDef(context)
		var isNumeric : Boolean init tgt.staticType.isNumericalTypeDef(context)
		
		if(fName == "not" and isBoolean) then
				result := result + "! ("
				result := result + tgt.createBehaviorJava(context)
				result := result + ")"
			
			else if (fName == "and" and isBoolean) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") && ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if (fName == "or" and isBoolean) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") || ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if (fName == "plus" and isNumeric) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") + ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "minus" and isNumeric) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") - ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "mult" and isNumeric) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") * ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "div" and isNumeric) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") / ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "isGreater" and isNumeric) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") > ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "isLower" and isNumeric) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") < ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "isGreaterOrEqual" and isNumeric) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") >= ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "isLowerOrEqual" and isNumeric) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") <= ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "equals" and (isBoolean or isNumeric)) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") == ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
			else if(fName == "isNotEqual" and (isBoolean or isNumeric)) then
				result := result + "("
				result := result + tgt.createBehaviorJava(context)
				result := result + ") != ("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			
		
			else
				var ppParam : String init ""
				if tgt.isInstanceOf(CallFeature) then
					ppParam := "(" + CompilerHelperJava.new.ppComaSeparatedNodes(tgt.asType(CallExpression).parameters, context) + ")"
				end
				result := result + tgt.createBehaviorJava(context) + ppParam + "."
			
			end
			end
			end
			end
			end
			end
			end
			end
			end
			end
			end
			end
			end
	end
}