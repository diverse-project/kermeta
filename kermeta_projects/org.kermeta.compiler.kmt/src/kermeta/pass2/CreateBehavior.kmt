/* $Id: CreateBehavior.kmt,v 1.37 2008-07-31 08:15:03 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 */

package kermeta::language;

require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/KM2EcoreHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/StringHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/PrettyPrinterHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/common/ContainmentTraversable.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/common/TraceSource.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/simk/SimkHelper.kmt"

using kermeta::language::structure
using kermeta::language::behavior
using kermeta::standard
using kermeta::utils
using ecore
using km2ecore
using km2ecore::helper::ecore
using km2ecore::helper::kermeta
using km2ecore::helper::java
using simk

package structure {

	aspect class Object {
		operation createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
		end
	}
	
	/** We have to visit property in order to print the behavior of the getter and setter */
	aspect class Property {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := void
			
			// The current property is derived
			if self.isDerived then
				// The current property could have a setter
				if not self.isReadOnly then
					// todo compile the setter in an EAnnotation
				end
				// todo compile the getter in an EAnnotation
			end
		end
	}
	
	/** We have to visit operation in order to print the result initialization and the return statement */
	aspect class Operation {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := void
			
/*			var ft_parameters : Set<Parameter> init self.ownedParameter.detect{ p |
				if p.type.isInstanceOf(FunctionType)
			}*/
			/*
			var ft : FunctionType init p.type.asType(FunctionType)
			//ft.left
			//ft.right*/
			
			//if ft_parameters.detect{ p | p.name==cv.name} then
			//stdio.writeln("context.tasks_stack.peek(): " + context.tasks_stack.peek())
			 
			var javaCode : StringBuffer init StringBuffer.new
			
			//stdio.writeln("\tCurrent operation: " + self.name + " has for type: " + self.type.toString)
			
			// The body of the operation must be filled for being compiled
			if ( not self.body.isVoid() ) then
				var type_label : String init self.type.createBehaviorJava(context)
				
				// result is initialized only if the "return type" is not Void
				if not isVoidType(type_label) then
					javaCode.append("\n" + type_label + " result" + context.getFtSuffix() + " = null;\n")
				end

				// The Java source code is provided by: self.body.createBehaviorJava(context)
				javaCode.append(self.body.createBehaviorJava(context))
				
				// result is returned only if the "return type" is not Void
				if (not isVoidType(type_label)) and (not context.ftSuffixActivation) then
					javaCode.append("\nreturn result;\n")
				end
				
			end
			
			// Finally add the EAnnotation containing the Java code in the Ecore model
			if context.tasks_stack.peek() != "FunctionType_Compilation" then
	        	EAnnotationHelper.new.addAnnotationGenModelImpl(self.ecoreModelElement, javaCode.toString)
	        	//stdio.writeln(javaCode.toString)
	        end
	        result := javaCode.toString()
		end
		
		operation isVoidType(type_label : String) : Boolean is do
			result := false
			if (type_label == "null")
				or (type_label == "void")
				or (type_label == "Void")
				or (type_label == "VoidType")
				or (type_label == "kermeta::standard::Void")
				or (type_label == "kermeta::standard::VoidType")
				or (type_label == "kermeta::language::structure::Void")
				or (type_label == "kermeta::language::structure::VoidType")
				or (type_label == "kermeta.standard.Void")
				or (type_label == "kermeta.standard.VoidType")
				or (type_label == "kermeta.language.structure.Void")
				or (type_label == "kermeta.language.structure.VoidType") then
				result := true
			end
		end
		
		
		operation getOptimizedStaticCall(context : KM2EcoreContext) : String is do
			result := ""
			if self.body.isInstanceOf(Block) then
				if self.body.asType(Block).statement.size==1 then
					if self.body.asType(Block).statement.isInstanceOf(JavaStaticCall) then
						var static_call_set_1 : OrderedSet<String> init self.body.asType(Block).statement.asType(JavaStaticCall).createBehaviorJava(context).split("(")//.getCompiledJavaExtern().split("(")
						result := static_call_set_1.one()
					else
						if self.body.asType(Block).statement.isInstanceOf(Assignment) then
							if self.body.asType(Block).statement.asType(Assignment).~value.isInstanceOf(JavaStaticCall) then
								var static_call_set_2 : OrderedSet<String> init self.body.asType(Block).statement.asType(Assignment).~value.asType(JavaStaticCall).createBehaviorJava(context).split("(")//.getCompiledJavaExtern().split("(")
								result := static_call_set_2.one()
							end
						end
					end
				end
			end
		end
		
		
		/**
		 * Compiling in Simk mode the methods from ValueType
		 */
		operation compilingInSimkMode(context : KM2EcoreContext) : Void is do
			
			var sMContext : SMContext init context.simkModel.retrieveOrCreateContext(self, context)
			
			if not sMContext.isVoid() then
			
				var staticMethod : StaticMethod init StaticMethod.new()
				
				context.simkModel.staticMethods.add(staticMethod)
				sMContext.staticMethods.add(staticMethod)
				
				staticMethod.name := self.name
				
				//By default, a self parameter has been added
				var self_param : SMParameter init SMParameter.new()
				self_param.name := "self"
				self_param.type := context.current_valueType.getEMFInstanceClassName()
				staticMethod.sMParameters.add(self_param)
				
				self.ownedParameter.each{ p |
					var param : SMParameter init SMParameter.new()
					param.name := p.name
					
					//stdio.writeln("p.type.getTypeQName(): " + self.name + " - " + p.type.getTypeQName() + " == " + self.container.asType(ClassDefinition).qualifiedName)
					
					if not p.type.isInstanceOf(FunctionType) then
						if (p.type.getTypeQName() == self.container.asType(ClassDefinition).qualifiedName) or (p.type.getTypeQName() == "kermeta::language::structure::Object") then
							param.type := context.current_valueType.getEMFInstanceClassName()//.qualifiedName().replace("::", ".")
						else
							param.type := p.type.createBehaviorJava(context)//.getTypeQName().replace("::", ".")
							if Operation.new().isVoidType(param.type) then
								param.type := "void"
							end
						end
					else
						stdio.writeln("//TODO inline the function type into the SIMK body")
					end
					
					staticMethod.sMParameters.add(param)
				}
				
				var sMReturn : SMReturn init SMReturn.new()
				staticMethod.sMReturn := sMReturn
				
				//if self.type.isVoid() then
				//	sMReturn.type := "void"
				//else
					if self.type.getTypeQName() == self.container.asType(ClassDefinition).qualifiedName then
						sMReturn.type := context.current_valueType.getEMFInstanceClassName()//.qualifiedName().replace("::", ".")
					else
						sMReturn.type := self.type.createBehaviorJava(context)//.getTypeQName().replace("::", ".")
						if Operation.new().isVoidType(sMReturn.type) then
							sMReturn.type := "void"
						end
					end
				//end
				
				staticMethod.body := self.createBehaviorJava(context)
			
			end
			
		end
	}
	
	aspect class Type {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
		end
	}
	
	/** Complete */
	aspect class VoidType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do
			result := "null" // the VoidType is "normally" mapped to the Void class
		end
	}
	
	aspect class PrimitiveType {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := self.instanceType.createBehaviorJava(context) // self.instanceType should be a ParameterizedType
		end
	}
	
	aspect class ParameterizedType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do

			if self.typeDefinition.getEMFInstanceClassName()!="" then
				result := self.typeDefinition.getEMFInstanceClassName()
			else
				result := self.getTypeQName().replace("::",".")
			end
			
			//Look the param binding
			var str_tpb : String init ""
			var i : Integer init 0
			self.typeParamBinding.each{ tpb |
				
				if i >= 1 then
					str_tpb := str_tpb + ", "
				end
				
				if not context.ftSuffixActivation then
					str_tpb := str_tpb + tpb.type.createBehaviorJava(context)
				else
					str_tpb := str_tpb + context.ftProductTypeStack.peek().type.elementAt(i).createBehaviorJava(context)
				end
				
				i := i + 1
			}
			if str_tpb!="" then
				result := result + "<" + str_tpb + ">"
			end
			result := result + ""
		end
	}
	
	aspect class ObjectTypeVariable {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := self.name
		end
	}
	
	aspect class Enumeration {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := self.name
		end
	}
	
	aspect class FunctionType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do
			super(context)
			result := ""
		end
	}

}


package behavior {
	
	/** Complete */
	aspect class Expression {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
		
			if (self.getCompiledJavaExtern()!="") and (context.compiledJavaExtern=="") then
				context.compiledJavaExtern := getCompiledJavaExtern()
				
				if not context.current_valueType.isVoid() then
					context.compiledJavaExtern := context.compiledJavaExtern.replace("this", "self")
				end
			
			end
			
			//This method must be returned nothing
			result := ""
		end
		
		/**
		 * Check if the current element is at the end of an Expression
		 */
		operation endOfExpressionFixer() : String is do
			result := ""
			if self.container.isInstanceOf(Conditional) or self.container.isInstanceOf(Block) or self.container.isInstanceOf(Rescue) or self.container.isInstanceOf(Assignment) or self.container.isInstanceOf(VariableDecl) then
				if self.container.isInstanceOf(Assignment) then
					if self.container.asType(Assignment).target == self then
						result := ""
					else
						if self.container.asType(Assignment).target.isCallFeatureAsStaticProperty() then
							result := ""
						else
							result := ";"
						end
					end
				else
					result := ";"
				end
				
			end
		end
	}
	
	/** Complete */
	aspect class Block {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)
			
			var javaCode : StringBuffer init StringBuffer.new
			
			
			/*self.eachOwnedElement{ stm |
				stm.getAllContainedElementAsType(CallFeature)
			}*/
			
			
			//EMF adds automatically the first {, thus we are checking if the container of the current block
			//is an Operation, else a { is printed
			if (not self.container.isInstanceOf(Operation)) and (not self.container.isInstanceOf(LambdaExpression)) then
				javaCode.append("{\n")
			end
						
			//At the beginning of each block, the need of "try" block is checked
			if self.containsRescue() then
				javaCode.append("try {")
			end
			
			var nbrStm : Integer init self.statement.size()
			var i_stm : Integer init 0
			self.eachOwnedElement{ stm |
				
				javaCode.append("\n\t")
				
				/*if not stm.mustBeAssigned() then
					context.pushResultLastStatementStack()
					javaCode.append(stm.asType(Expression).staticType.createBehaviorJava(context) + " " + context.getResultLastStatementId() + " = null;\n")
				end*/
				
				//if the given statement is the last one
				if i_stm == (nbrStm-1) then
					
					//FIXME The 3 following lines of code should be deprecated
					if context.lastStatementStack.size()>0 then
						javaCode.append(context.lastStatementStack.pop())
					end
					
					if stm.mustBeAssigned() then
						if self.container.isInstanceOf(Operation) then
							javaCode.append(context.NOT_EVALUATED_MESSAGE)
						else
							if Operation.new().isVoidType(stm.asType(Expression).staticType.getTypeName()) then
								javaCode.append(context.NOT_EVALUATED_MESSAGE)
							else
								if self.container.container.isInstanceOf(Block) and (context.resultLastStatementStack.size()==0) then
									javaCode.append(context.NOT_EVALUATED_MESSAGE)
								else
									
									javaCode.append(context.getResultLastStatementId())
									
								end
							end
						end
					else
						if stm.isInstanceOf(CallFeature) and (context.resultLastStatementStack.size()>0) then
							javaCode.append(context.getResultLastStatementId())
						end
					end
				else
					if stm.mustBeAssigned() then
						javaCode.append(context.NOT_EVALUATED_MESSAGE)
					end
				end
				
				javaCode.append(stm.createBehaviorJava(context))
				
				/*if stm.isInstanceOf(Assignment) then //not stm.mustBeAssigned() then
					var str_right : String init context.getResultLastStatementId()
					
					context.popResultLastStatementStack()
					
					javaCode.append(context.getResultLastStatementId() + " = " + str_right + ";\n")
				end*/
				
				javaCode.append("\n")
				
				i_stm := i_stm + 1
				
			}
			
			if self.containsRescue() then
				context.pushKRErrorStack()
				javaCode.append("} catch( " + context.JAVA_CLASS_EXCEPTION_SWITCHER + " " + context.VARIABLE_EXCEPTION_SWITCHER + "_" + context.kRErrorStack.peek() + " ) {\n")
				//result := result + "(" + self.exceptionType.createBehaviorJava(context) + " " + self.exceptionName + ")"
				
				self.rescueBlock.each{ e |
					javaCode.append(e.createBehaviorJava(context))
				}
				javaCode.append("\n}\n")
				context.kRErrorStack.pop()
			else
				//javaCode.append("} catch( Exception e ) {\ne.printStackTrace();\n}\n")
			end

			//end of a block 
			if (not self.container.isInstanceOf(Operation)) and (not self.container.isInstanceOf(LambdaExpression)) then
				javaCode.append("}")
			end		
			result := javaCode.toString()
		end
 
	}
	
	//**** Begin **** Managing of the CallExpression branch ****//
	aspect class CallExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := self.toString
		end
		
		operation isCallFeatureAsStaticProperty() : Boolean is do
			result := false
			
			if self.isInstanceOf(CallFeature) then
				if not self.asType(CallFeature).staticProperty.isVoid() then
					result := true
				end
			end
		end
		
		operation isCallFeatureAsStaticOperation() : Boolean is do
			result := false
			
			if self.isInstanceOf(CallFeature) then
				if not self.asType(CallFeature).staticOperation.isVoid() then
					result := true
				end
			end
		end
		
		operation isCallFeatureAsStaticEnumLiteral() : Boolean is do
			result := false
			
			if self.isInstanceOf(CallFeature) then
				if not self.asType(CallFeature).staticEnumLiteral.isVoid() then
					result := true
				end
			end
		end
	}
	
	aspect class CallFeature {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			super(context)
			result := ""

			//By default, the self expression is added to a call feature
			if self.target.isVoid() then
				self.target := SelfExpression.new()
			end
			var tgt : Expression init self.target
			var fName : String  init IdentifierHelper.new.getMangledIdentifier(self.name, context)
			
			
			//stdio.writeln("self.staticOperation: " + self.staticOperation.toString())
			
			var static_call : String init ""
			
			if self.isCallFeatureAsStaticOperation() then
			
				if self.staticOperation.isFunctionType() then
					
					var ft_str : String init self.createStringFromFunctionType(context)
					
					result := ft_str + result
				
				end
				
				///////Added 08-07-28 or self.staticOperation.container().asType(ClassDefinition).isMappedToJavaRawType()
				if self.staticOperation.container().asType(ClassDefinition).isValueType() then
				
					static_call := self.staticOperation.getOptimizedStaticCall(context)
					
					if static_call == "" then
						static_call := self.staticOperation.container().asType(ClassDefinition).container().asType(Package).qualifiedName.replace("::", ".") + ".helper." + self.staticOperation.container().asType(ClassDefinition).name + "Wrapper." + self.name
					end
				else
				
					if not tgt.isVoid() then
						if not tgt.staticType.isVoid() then
							if tgt.staticType.isValueType() then
								static_call := "org.kermeta.compil.runtime.helper.basetypes." + tgt.staticType.getTypeName() + "Util." + self.name
							end
						end
					
					else
					
						if self.staticOperation.container().asType(ClassDefinition).isMappedToJavaRawType() and (not self.staticOperation.body.isVoid()) then
							static_call := self.staticOperation.getOptimizedStaticCall(context)
						end
					
					end
				
				end
			
			end
			
			
			if self.name == "new" and (not tgt.isInstanceOf(CallVariable)) then
				result := result + "((" + tgt.createBehaviorJava(context) + ") " + "org.kermeta.compil.runtime.helper.language.ClassUtil.newObject(\"" + tgt.createBehaviorJava(context) + "\"))"
			else
				
				if not tgt.isVoid() then
					
					if not tgt.callsFunctionType() then
						result := result + tgt.createBehaviorJava(context)
						if static_call=="" then
							result := result + "."
						end
					else
						/*if tgt.callsFunctionType() and (not self.callsFunctionType) then
							var topCallF : CallFeature init self.retrieveTopCallFeatureFunctionType()
							stdio.writeln("topCallF: " + topCallF.name)
							
							result := result + topCallF.createBehaviorJava(context)
							
						else
							result := result + self.container.createBehaviorJava(context)
						end*/
						result := tgt.createBehaviorJava(context) + result.replace(context.SELF_EXPRESSION_TO_REPLACE, context.resultOfLastFt)
					end
				end
				
				if self.name == "writeln" then
					result := result + "println"
				else
					if static_call=="" then
						if self.isCallFeatureAsStaticEnumLiteral then
							result := result + "getByName(\"" + self.name + "\")"
						else
							if self.isCallFeatureAsStaticProperty() then
							
								var cf_prop_suffix : String
								
								if self.staticProperty.upper != 1 then
									var type_binding : String init self.staticType.asType(Class).typeParamBinding.one.type.createBehaviorJava(context)
									
									if (not self.staticProperty.isUnique) and (not self.staticProperty.isOrdered) then
										result := "CollectionUtil.<" + type_binding + ">convertAsBag(" + result
									end
									
									if (self.staticProperty.isUnique) and (not self.staticProperty.isOrdered) then
										result := "CollectionUtil.<" + type_binding + ">convertAsSet(" + result
									end
									
									if (self.staticProperty.isUnique) and (self.staticProperty.isOrdered) then
										result := "CollectionUtil.<" + type_binding + ">convertAsOrderedSet(" + result
									end
									
									if (not self.staticProperty.isUnique) and (self.staticProperty.isOrdered) then
										result := "CollectionUtil.<" + type_binding + ">convertAsSequence(" + result
									end
									
									cf_prop_suffix := ")"
								end
								
								result := result + "get" + self.name.capName() + "()" + cf_prop_suffix
							else
								result := result + IdentifierHelper.new.getMangledIdentifier(self.name, context)
							end
						end
					else
						result := static_call + "(" + result
					end
				end
			
				
				if self.isCallFeatureAsStaticOperation() then
					if static_call=="" then
						result := result + "("
					else
						static_call := ""
						if (not self.parameters.isVoid()) and (self.parameters.size()>0) then
							result := result + ", "
						end
					end
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context) + ")"
				end
			
			end
			
			result := result + self.endOfExpressionFixer()
		end
		
	}
	
	aspect class CallVariable {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			super(context)
			result := ""

			if (context.tasks_stack.peek() == "FunctionType_Compilation") and (context.current_param_ft == self.name) then
				context.tasks_stack.pop()
				
				context.ftSuffixActivation := false
				
				var theLambdaExp : LambdaExpression init context.ftStack.pop()
						
				var str_toInclude : String init ""
				
				if theLambdaExp.staticType.isInstanceOf(FunctionType) then
					var lambdaExp_returnType : String init theLambdaExp.staticType.asType(FunctionType).right.createBehaviorJava(context)
					if not Operation.new().isVoidType(lambdaExp_returnType) then
						//context.pushResultLastStatementStack()
						//str_toInclude := str_toInclude + lambdaExp_returnType + " " + context.getResultLastStatementId() + "null;\n"
					end
				end
				
				var inc_param : Integer init 0
				theLambdaExp.parameters.each{ p |
					//str_toInclude := str_toInclude + self.parameters.elementAt(inc_param).staticType.createBehaviorJava(context) + " " + p.name
					
					//Declare and initialize the function type parameters
					str_toInclude := str_toInclude + context.ftProductTypeStack.peek().type.elementAt(inc_param).createBehaviorJava(context)
					
					/*if theLambdaExp.staticType.isInstanceOf(FunctionType) then
						if theLambdaExp.staticType.asType(FunctionType).left.isInstanceOf(ProductType) then
							str_toInclude := str_toInclude + theLambdaExp.staticType.asType(FunctionType).left.asType(ProductType).type.elementAt(inc_param).createBehaviorJava(context)
						end
					end*/

					
					str_toInclude := str_toInclude + " " + p.name
					
					context.ftSuffixActivation := true
					str_toInclude := str_toInclude + " = " + self.parameters.elementAt(inc_param).createBehaviorJava(context) + ";\n"
					context.ftSuffixActivation := false
					
					inc_param := inc_param + 1
				}
				
				//Add the compiled version of the body of the current LambdaExpression
				result := result + "//Beginning of the Inlining of the function type parameter: " + self.name + "\n"
				result := result + str_toInclude + theLambdaExp.body.createBehaviorJava(context)
				result := result + "//Ending of the Inlining of the function type parameter: " + self.name + "\n"
				
				if theLambdaExp.staticType.isInstanceOf(FunctionType) then
					var lambdaExp_returnType : String init theLambdaExp.staticType.asType(FunctionType).right.createBehaviorJava(context)
					if not Operation.new().isVoidType(lambdaExp_returnType) then
						//context.popResultLastStatementStack()
					end
				end
				
				context.ftSuffixActivation := true
				
			else
				if self.name == "stdio" then
					result := result + "System.out"
				else
					result := result + IdentifierHelper.new.getMangledIdentifier(self.name, context) + context.getFtSuffix()
				end
				
				result := result + self.endOfExpressionFixer()
			
			end
		end
	}
	
	aspect class CallResult {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallVariable is do
			super(context)
			//Try to insert line number
			//result := "begin " + self.lineNumber.toString() + " " + self.fileName + "\n" + "result" + "\nend " + self.lineNumber.toString() + " " + self.fileName + "\n"
			result := "result" + context.getFtSuffix()
		end
	}
	
	aspect class CallValue {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
		
			super(context)
			
			result := self.toString
		end
	}
	
	aspect class CallSuperOperation {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
		
			super(context)
			
			result := "super." + self.getContainerAsType(Operation).asType(Operation).name + "("
			
			var i : Integer init 0
			self.parameters.each{ param |
				if i==1 then
					result := result + ", "
				else
					i := 1
				end
				result := result + param.createBehaviorJava(context)
			}
			
			result := result + ");"
		end
	}
	//**** End **** Managing of the CallExpression branch ****//
	
	aspect class VariableDecl {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)
			
			result := ""
			
			var localType : String init self.type.createBehaviorJava(context)
			var var_id : String init IdentifierHelper.new.getMangledIdentifier(self.identifier, context) + context.getFtSuffix()
			
			result := result + localType + " " + var_id
			
			if not self.initialization.isVoid() then
				if self.initialization.isInstanceOf(Conditional) then
					context.resultLastStatementStack.push(var_id + " = ")
					result := result + " = null;\n" + self.initialization.createBehaviorJava(context)
					context.resultLastStatementStack.pop()
				else
					result := result + " = " + self.initialization.createBehaviorJava(context)
				end
			else
				result := result + " = null;"
			end
			
		end
	}
	
	aspect class Assignment {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)
			
			result := ""
			
			var left : String init self.target.createBehaviorJava(context)
			
			var ppCast : String init ""
			if self.isCast() then
				ppCast := "(" + self.staticType.createBehaviorJava(context) + ") "
			end
			
			context.resultLastStatementStack.push(left + " = " + ppCast)
			
			var right : String init self.~value.createBehaviorJava(context)
		
			// Patch that adds the 'function' keyword in case the assigned value is a function
			if self.~value.isInstanceOf(LambdaExpression) then
				right := "function " + right
			end
			
			
			
			if self.target.isCallFeatureAsStaticProperty() then
					
				var tabLeft : kermeta::standard::OrderedSet<String> init left.replace(".", "%").split("%")
				
				result := ""
				from var i : Integer init 0
				until i >= tabLeft.size()
				loop
					if i < (tabLeft.size()-1) then
						result := result + tabLeft.elementAt(i) + "."
					end
					if i == (tabLeft.size()-1) then
						result := result + "set" + self.target.asType(CallFeature).name.capName() + "(" + ppCast + right + ");"
					end
					i := i+1
				end

			else
				//stdio.writeln("ttttttttt")
				//result := right.replace(context.leftAssign, left + " = " + ppCast)
				
				if self.~value.isInstanceOf(Conditional) then
					result := right
				else
					result := left + " = " + ppCast + right
				end
			end
			context.resultLastStatementStack.pop()
		end
	}
	
	aspect class LambdaExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := ""
		end
	}
	
	aspect class LambdaParameter {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			super(context)
			result := ""
		end
	}
	
	aspect class TypeReference {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			super(context)
			result := CompilerHelperJava.new().ppTypeFromMultiplicityElement(self, context)
		end
	}
	
	//**** Begin **** Managing of the exception (wrapper to java.lang.Error) ****//
	/** Complete */
	aspect class Raise {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			
			super(context)
		
			//DO NOT REMOVE the following source code, this is used for fixing throws attribute on the EOperations
			/*var newEGenericType : EGenericType init EGenericType.new()
			newEGenericType.eClassifier := context.mu.getEClassifierByQualifiedName("kermeta::exceptions::KRuntimeError")

			if (not newEGenericType.eClassifier.isVoid()) and (not self.getContainerAsType(Operation).isVoid()) then
				
				if not self.getContainerAsType(Operation).asType(Operation).ecoreModelElement.isVoid() then
					if (self.getContainerAsType(Operation).asType(Operation).ecoreModelElement.eGenericExceptions.isVoid()) or (self.getContainerAsType(Operation).asType(Operation).ecoreModelElement.eGenericExceptions.size==0) then
						self.getContainerAsType(Operation).asType(Operation).ecoreModelElement.eGenericExceptions.add(newEGenericType)
					end
				else
					//We are in the case of a Simk method
				end
				
			end*/
			
			result := "\n\tthrow new " + context.JAVA_CLASS_EXCEPTION_SWITCHER + "( " + self.expression.createBehaviorJava(context) + " );\n"
		end
	}
	
	/** Complete */
	aspect class Rescue {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
		
			super(context)
			
			result := ""
			
			if not self.exceptionType.isVoid() then
			
				var str_exceptionType : String init self.exceptionType.createBehaviorJava(context)
				
				result := result + "if( " + context.VARIABLE_EXCEPTION_SWITCHER + "_" + context.kRErrorStack.peek() + ".getRealException() instanceof " + str_exceptionType + " ) {\n"
				
				result := result + str_exceptionType + " " + self.exceptionName + " = (" + str_exceptionType + ") " + context.VARIABLE_EXCEPTION_SWITCHER + "_" + context.kRErrorStack.peek() + ".getRealException();\n"
				
				self.eachOwnedElement{e | 
					result := result + e.createBehaviorJava(context)
				}
				
				//end of the if
				result := result + "\n}"
				
			end

		end
	}
	//**** End **** Managing of the exception ****//
	
	/** Complete */
	aspect class SelfExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			
			result := "this"
			
			if not context.current_valueType.isVoid() then
				result := "self"
			end
			
			if context.ftSuffixActivation then
				result := context.ftContextualSelf
			end

			result := result + self.endOfExpressionFixer()
		end
	}
	
	/** Complete */
	aspect class Conditional {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			
			super(context)
			
			context.pushCondStack()
			
			result := "java.lang.Boolean " + context.getIfConditionId() + " = false;"
			
			var str_condition : String init ""
			
			if context.getFtSuffix()=="" then
				str_condition := str_condition + "\n\t" + context.getIfConditionId() + " = " + self.condition.createBehaviorJava(context)
			else
				if self.condition.isInstanceOf(CallVariable) then
		
					var ftParam : Parameter init self.getContainerAsType(Operation).asType(Operation).ownedParameter.detect{ p | p.name == self.condition.asType(CallVariable).name }
					if not ftParam.isVoid() then
					
						if ftParam.isBooleanFunctionType(context) then
							//context.lastStatementStack.push(context.getIfConditionId() + " = ")
							
							context.resultLastStatementStack.push(context.getIfConditionId() + " = ")
							
							str_condition := str_condition + "\n" + self.condition.createBehaviorJava(context)
							
							//var resultOfFt : String init context.resultLastStatementStack.pop().replace(" = ", "") + ";"
							
							/*str_condition := str_condition + */context.resultLastStatementStack.pop()/* + resultOfFt*/
							
						end
					end
				end				
			end
			
			result := result + str_condition
			
			/*if not Operation.new().isVoidType(self.staticType.getTypeName()) then
				context.pushResultLastStatementStack()
				result := result + "\n" + self.staticType.createBehaviorJava(context) + " " + context.getResultLastStatementId() + " = null;" 
			end*/
			
			result := result + "\n\n\tif( " + context.getIfConditionId() + " ) "
			
			if not self.thenBody.isVoid() then 
				
				/*if not Operation.new().isVoidType(self.staticType.getTypeName()) then
					context.lastStatementStack.push(context.getResultLastStatementId() + " = ")
				end*/
				
				result := result + self.thenBody.createBehaviorJava(context) + "\n"
			end
			if not self.elseBody.isVoid() then
				result := result + " else "
				
				/*if not Operation.new().isVoidType(self.staticType.getTypeName()) then
					context.lastStatementStack.push(context.getResultLastStatementId() + " = ")
				end*/
				
				result := result + self.elseBody.createBehaviorJava(context) + "\n"
			end
			
			/*if not Operation.new().isVoidType(self.staticType.getTypeName()) then
				context.resultLastStatementStack().pop()
			end*/
			
			context.condStack.pop()
			
		end
	}
	
	/** TODO */
	aspect class Loop {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := ""
			
			context.pushCondStack()
			
			if self.initialization.isInstanceOf(CallVariable) then
				//FIXME CF Maybe we should do something here
			else
				result := result + "\n\t" + self.initialization.createBehaviorJava(context)
			end
			
			result := result + "\n\tjava.lang.Boolean " + context.getLoopConditionId() + " = false;"
			result := result + "\n\twhile( !" + context.getLoopConditionId() + " ) {"
			result := result + "\n\t" + context.getLoopConditionId() + " = " + self.stopCondition.createBehaviorJava(context) + ";"
			result := result + "\n\tif ( " + context.getLoopConditionId() + " ) {"
			context.condStack.pop()
			result := result + "\n\t} else "
			result := result + self.body.createBehaviorJava(context)
			
			//close the while
			result := result + "\n\t}"
		end
	}
	
	/** Complete */
	aspect class JavaStaticCall {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			//stdio.writeln(self.jmethod)

			super(context)
			
			if context.compiledJavaExtern!="" then
				result := context.compiledJavaExtern
				context.compiledJavaExtern := ""
			else
				if self.getContainerAsType(ClassDefinition).asType(ClassDefinition).isValueType() then
					result := "org.kermeta.compil.runtime.helper.basetypes." + self.getContainerAsType(ClassDefinition).asType(ClassDefinition).name + "Util." + self.jmethod
				else
					result := self.jclass.replace("::", ".") + "." + IdentifierHelper.new.getMangledIdentifier(self.jmethod, context)
				end
				result := result + "(" + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context) + ")"
			end
			
			result := result + self.endOfExpressionFixer()
		end
	}
	
	
	//**** Begin **** Managing of the literal ****//
	aspect class Literal {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := ""
		end
	}
	
	/** Complete */
	aspect class StringLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := "\"" + self.~value.replace("\"", "\\\"") + "\""
			result := result.replace("\n", "\\n")
			result := result.replace("\t", "\\t")
			result := result + self.endOfExpressionFixer()
		end
	}
	
	/** Complete */
	aspect class IntegerLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.~value.toString
			result := result + self.endOfExpressionFixer()
		end
	}
	
	/** Complete */
	aspect class BooleanLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.~value.toString
			result := result + self.endOfExpressionFixer()
		end
	}
	
	aspect class TypeLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.typeref.createBehaviorJava(context)
		end
	}
	
	/** Complete */
	aspect class VoidLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := "null" // the VoidLiteral is "normally" mapped to the void singleton
			result := result + self.endOfExpressionFixer()
		end
	}
	//**** End **** Managing of the literal ****//
	
}