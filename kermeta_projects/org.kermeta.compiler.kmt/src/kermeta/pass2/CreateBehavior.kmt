/* $Id: CreateBehavior.kmt,v 1.78 2008-09-26 08:24:05 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 */

package kermeta::language;

require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/KM2EcoreHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/ExpressionHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/MultiplicityElementHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/OperationHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/StringHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/PrettyPrinterHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/common/ContainmentTraversable.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/common/TraceSource.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/pass2/Postprocess.kmt"
require "SetLinks.kmt"

using kermeta::language::structure
using kermeta::language::behavior
using kermeta::standard
using kermeta::utils
using ecore
using km2ecore
using km2ecore::helper::ecore
using km2ecore::helper::kermeta
using km2ecore::helper::java

package structure {

	aspect class Object {
		/** Super method */
		operation createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
		end
	}
	
	/** We have to visit property in order to print the behavior of the getter and setter */
	aspect class Property {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := void
			
			var javaCode : String init ""
			
			// The current property is derived
			if self.isDerived then
				// The current property could have a setter
				if (not self.isReadOnly) and (not self.setterBody.isVoid()) then
					// Compiling the setter in an EAnnotation
					//context.staticOperationMode := true
					javaCode := self.setterBody.createBehaviorJava(context)
					//context.staticOperationMode := false
					//EAnnotationHelper.new().addAnnotationPropSetter(self.ecoreModelElement, javaCode)
					
					var setterEOp : EOperation init EOperation.new()
					setterEOp.name := self.printSetAccessor()
					setterEOp.upperBound := self.ecoreModelElement.upperBound
					setterEOp.ordered := self.ecoreModelElement.ordered
					setterEOp.unique := self.ecoreModelElement.unique
					
					var param_setterEOp : EParameter init EParameter.new()
					param_setterEOp.name := "value"
					LinkSetterForTypedElement.new().setLinks(self, param_setterEOp, context)
					
					setterEOp.eParameters.add(param_setterEOp)
					
					EAnnotationHelper.new().addAnnotationGenModelImpl(setterEOp, javaCode)
					
					self.container.asType(ClassDefinition).ecoreModelElement.eOperations.add(setterEOp)
				end
				
				// Reinit the content
				javaCode := ""
				
				// Compiling the getter in an EAnnotation
				//context.staticOperationMode := true
				
				var type_label : String init ""
				if context.ftSuffixActivation then
					type_label := context.ftReturnType
					context.ftReturnType := ""
				else
					type_label := CompilerHelperJava.new().ppTypeFromMultiplicityElement(self, context)
				end
				
				// result is initialized only if the "return type" is not Void
				if not Operation.new().isVoidType(type_label) then
					javaCode := javaCode + "\n" + type_label + " result" + context.printFtSuffix() + " = null;\n"
				end
				
				if not self.getterBody.isVoid() then
					javaCode := javaCode + self.getterBody.createBehaviorJava(context)
				end
				
				javaCode := javaCode + self.ppReturnResult(context)
				//context.staticOperationMode := false
				//EAnnotationHelper.new().addAnnotationPropGetter(self.ecoreModelElement, javaCode)
				
				var getterEOp : EOperation init EOperation.new()
				getterEOp.name := self.printGetAccessor()
				getterEOp.upperBound := self.ecoreModelElement.upperBound
				getterEOp.ordered := self.ecoreModelElement.ordered
				getterEOp.unique := self.ecoreModelElement.unique
				//getterEOp.eGenericType := self.ecoreModelElement.eGenericType
				
				LinkSetterForTypedElement.new().setLinks(self, getterEOp, context)
				
				EAnnotationHelper.new().addAnnotationGenModelImpl(getterEOp, javaCode)
				
				self.container.asType(ClassDefinition).ecoreModelElement.asType(EClass).eOperations.add(getterEOp)
				
				// Removing the old property, only the Operations: getter and setter are remaining
				// FIXME CF - this choice could be reconsidered
				self.container.asType(ClassDefinition).ecoreModelElement.eStructuralFeatures.remove(self.ecoreModelElement)
				self.ecoreModelElement := void
			end
		end
	}
	
	/** We have to visit operation in order to print the result initialization and the return statement */
	aspect class Operation {
		
		method createBehaviorJava(context : KM2EcoreContext) : String is do

			result := void
			 
			var javaCode : StringBuffer init StringBuffer.new
			
			//stdio.writeln("\tCurrent operation: " + self.name + " has for type: " + self.type.toString)
			
			// The body of the operation must be filled for being compiled
			if not self.body.isVoid() then

				var type_label : String init ""
				if context.ftSuffixActivation then
					type_label := context.ftReturnType
					context.ftReturnType := ""
				else
					type_label := CompilerHelperJava.new().ppTypeFromMultiplicityElement(self, context)
				end
	
				// result is initialized only if the "return type" is not Void
				if not isVoidType(type_label) then
					javaCode.append("\n" + type_label + " result" + context.printFtSuffix() + " = null;\n")
				end

				// The Java source code is provided by: self.body.createBehaviorJava(context)
				javaCode.append(self.body.createBehaviorJava(context))
				
				// result is returned only if the "return type" is not Void
				if (not isVoidType(type_label)) and (not context.ftSuffixActivation) then
					javaCode.append(self.ppReturnResult(context))
				end
			else
				// The current operation has a Void return type
				if not Operation.new().isVoidType(self.type.getTypeQName()) then
					javaCode.append(CompilerHelperJava.new().ppTypeFromMultiplicityElement(self, context) + " result = null;\n")
					javaCode.append(self.ppReturnResult(context))
				end
			end

			// Finally add the EAnnotation containing the Java code in the Ecore model
			if context.tasks_stack.peek() != context.FUNCTION_TYPE_COMPILATION_TASK and context.current_valueType.isVoid() then
	        	EAnnotationHelper.new.addAnnotationGenModelImpl(self.ecoreModelElement, javaCode.toString)
	        end
	        result := javaCode.toString()
		end

	}
	
	aspect class Type {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
		end
	}
	
	/** Complete */
	aspect class VoidType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do
			result := "null" // the VoidType is "normally" mapped to the Void class
		end
	}
	
	aspect class PrimitiveType {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
			
			if (not self.isValueType()) and self.isEDataType() then
				result := self.getEMFEDataTypeInstanceClassName()
				// FIXME CF: We should add the type parameters, but currently Kermeta (perhaps the loader)
				// does not keep this information when the EDataType is mapped on kermeta::language::structure::Object
			end
			if result == "" then
				result := self.instanceType.createBehaviorJava(context) // self.instanceType should be a ParameterizedType
			end
		end
	}
	
	aspect class ParameterizedType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do
		
			result := ""

			if self.typeDefinition.getEMFInstanceClassName()!="" then
				result := self.typeDefinition.getEMFInstanceClassName()
			else
				result := self.getTypeQName().replace("::",".")
			end

			//Look the param binding
			var str_tpb : String init ""
			var i : Integer init 0
			self.typeParamBinding.each{ tpb |
				
				if not context.ftSuffixActivation then
					if i >= 1 then
						str_tpb := str_tpb + ", "
					end
				
					if not tpb.type.isVoid() then
						str_tpb := str_tpb + tpb.type.createBehaviorJava(context)
					else
						// This case occurs because of the Kermeta bug #6260
						//stdio.writeln("tpb.type.isVoid(): " + self.toString)
					end
				else
					
					var type_from_map : Type init context.ftMapTypeStack.peek().getValue(tpb.type)
					if not type_from_map.isVoid() then
						context.ftSuffixActivation := false
						str_tpb := str_tpb + type_from_map.createBehaviorJava(context)
						context.ftSuffixActivation := true
					else
						
						// If we are in the context of FunctonType binding (context.ftSuffixActivation==true) and the current Type is self
						// then we have to reset result
						if context.ftProductTypeStack.peek().getTypeByIndex(i) == self then
							result := ""
						end							
							
						context.ftSuffixActivation := false
						str_tpb := str_tpb + context.ftProductTypeStack.peek().getTypeByIndex(i).createBehaviorJava(context)
						context.ftSuffixActivation := true
							
					end
				end
				
				i := i + 1
			}
			
			if str_tpb!="" then
				if result != "" then
					result := result + "<" + str_tpb + ">"
				else
					result := str_tpb
				end
			end
			
		end
	}
	
	aspect class ObjectTypeVariable {

		method createBehaviorJava(context : KM2EcoreContext) : String is do

			result := self.name
			
			if context.ftSuffixActivation then
			
				var type_from_map : Type init context.ftMapTypeStack.peek().getValue(self)
				if not type_from_map.isVoid() then
					stdio.writeln("Please contact the Kermeta Development team, if you are in this case [ObjectTypeVariable::createBehaviorJava - not type_from_map.isVoid()] " + self.toString)
					context.ftSuffixActivation := false
					result := type_from_map.createBehaviorJava(context)
					context.ftSuffixActivation := true
				else
			
					var i : Integer init -1
					var obj : Object init self.container.asType(ClassDefinition).typeParameter.detect{ otv |
						if otv.isInstanceOf(ObjectTypeVariable) then
							i:=i+1
							self == otv
						end
					}
					if (not obj.isVoid()) and (i>=0) then
						//Prevent cycle
						if context.ftProductTypeStack.peek().getTypeByIndex(i)!=self then
							result := context.ftProductTypeStack.peek().getTypeByIndex(i).createBehaviorJava(context)
						end
					end
				end
			end
		end

	}
	
	aspect class Enumeration {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := self.qualifiedName.replace("::", ".")
		end
	}
	
	aspect class FunctionType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do
			super(context)
			result := ""
		end
	}
	
	aspect class ProductType {
	
		operation getTypeByIndex(index : Integer) : Type is do
		
			result := void
			if index < self.type.size() then
				if self.type.elementAt(index).isInstanceOf(FunctionType) then
					result := self.type.elementAt(index).asType(FunctionType).right
				else
					result := self.type.elementAt(index)
				end
			end
		end
		
	}

}


package behavior {
	
	/** Complete */
	aspect class Expression {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
		
			// Set the context.compiledJavaExtern variable
			// An extern may be defined on an Expression
			if (self.getCompiledJavaExtern()!="") and (context.compiledJavaExtern=="") then
				context.compiledJavaExtern := getCompiledJavaExtern()
				
				// The parameters are removing in order to recalculation in the sub-operation in the JavaStaticCall
				if not self.getContainerAsType(FunctionType).isVoid() or not self.getContainerAsType(LambdaExpression).isVoid() then
					context.compiledJavaExtern := context.compiledJavaExtern.replace("(", "%").split("%").first()
				end
				
				if (not context.current_valueType.isVoid()) or context.staticOperationMode then
					context.compiledJavaExtern := context.compiledJavaExtern.replace("this", "self")
				end
			end
			
			//This method must be returned nothing
			result := ""
		end

	}
	
	/** Complete */
	aspect class Block {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)
			
			var javaCode : StringBuffer init StringBuffer.new
			
			//EMF adds automatically the first {, thus we are checking if the container of the current block
			//is an Operation, else a { is printed
			if (not self.container.isInstanceOf(Operation)) and (not self.container.isInstanceOf(LambdaExpression)) then
				javaCode.append("{\n")
			end
						
			//At the beginning of each block, the need of "try" block is checked
			if self.containsRescue() then
				javaCode.append("try {")
			end
			
			var nbrStm : Integer init self.statement.size()
			var i_stm : Integer init 0
			self.eachOwnedElement{ stm |

				var str_statement : String init stm.createBehaviorJava(context).normalizeStatement()

				var str_statement_splitted : OrderedSet<String> init str_statement.split(context.SEPARATOR_STATEMENT_FT) 
				
				if str_statement_splitted.size() == 2 then
					var s1 : String init str_statement_splitted.first()
					var s2 : String init str_statement_splitted.last()
					
					if s2.contains(context.PREVIOUS_STATEMENT_FT) then
						str_statement := s2.replace(context.PREVIOUS_STATEMENT_FT, s1)
					end

				end
				
				//FIXME CF Maybe we could find a better solution
				str_statement := str_statement.replace(context.SEPARATOR_STATEMENT_FT + "//", "//")
				str_statement := str_statement.replace(context.RETURN_EXPRESSION_TO_REPLACE + "result", "result")
				
				javaCode.append(context.beforeLambdaExpressionResult)
				context.beforeLambdaExpressionResult := ""
				
				javaCode.append("\n\t")
				
				//if the given statement is the last one
				if i_stm == (nbrStm-1) then
					
					if stm.mustBeAssigned() then
						if self.container.isInstanceOf(Operation) then
							javaCode.append(context.NOT_EVALUATED_MESSAGE)
						else
							if Operation.new().isVoidType(stm.asType(Expression).staticType.getTypeName()) then
								javaCode.append(context.NOT_EVALUATED_MESSAGE)
							else
								if self.container.container.isInstanceOf(Block) and (context.resultLastStatementStack.size()==0) then
									javaCode.append(context.NOT_EVALUATED_MESSAGE)
								else
									if context.getResultLastStatementType() == stm.asType(Expression).staticType.createBehaviorJava(context) then
										javaCode.append(context.getResultLastStatementId())
									end
								end
							end
						end
					else
						if stm.isInstanceOf(CallFeature) and (context.resultLastStatementStack.size()>0) then

							if context.getResultLastStatementType() == stm.asType(Expression).staticType.createBehaviorJava(context) then
								if stm.callsFunctionType() then
									str_statement := str_statement + context.getResultLastStatementId() + stm.asType(CallFeature).resultOfLastFt + ";\n"
								else
									if str_statement.contains(context.RETURN_EXPRESSION_TO_REPLACE_SPECIAL) then
										str_statement := str_statement.replace(context.RETURN_EXPRESSION_TO_REPLACE_SPECIAL, context.getResultLastStatementId())
									else
										javaCode.append(context.getResultLastStatementId())
									end
								end
							end
						end
					end
				else
					if stm.mustBeAssigned() then
						javaCode.append(context.NOT_EVALUATED_MESSAGE)
					end
				end
				
				if str_statement.contains(context.RETURN_EXPRESSION_TO_REPLACE_SPECIAL) then
					// We have to remove the context.RETURN_EXPRESSION_TO_REPLACE_SPECIAL, but not its setter in the operation KM2EcoreContext::initializeConstants
					if not str_statement.contains( "(\"" + context.RETURN_EXPRESSION_TO_REPLACE_SPECIAL + "\")") then
						str_statement := str_statement.replace(context.RETURN_EXPRESSION_TO_REPLACE_SPECIAL, "")
					end
				end
				
				javaCode.append(str_statement)
				
				javaCode.append("\n")
				
				i_stm := i_stm + 1
				
			}
			
			if self.containsRescue() then
				context.pushKRErrorStack()
				javaCode.append("} catch( " + context.JAVA_CLASS_EXCEPTION_SWITCHER + " " + context.VARIABLE_EXCEPTION_SWITCHER + "_" + context.kRErrorStack.peek() + " ) {\n")
				
				self.rescueBlock.each{ e |
					javaCode.append(e.createBehaviorJava(context))
				}
				javaCode.append("\n}\n")
				context.kRErrorStack.pop()
			end

			//end of a block 
			if (not self.container.isInstanceOf(Operation)) and (not self.container.isInstanceOf(LambdaExpression)) then
				javaCode.append("}")
			end		
			result := javaCode.toString()
		end
 
	}
	
	//**** Begin **** Managing of the CallExpression branch ****//
	aspect class CallExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := self.toString
		end
		
		operation isCallFeatureAsStaticProperty() : Boolean is do
			result := false
			
			if self.isInstanceOf(CallFeature) then
				if not self.asType(CallFeature).staticProperty.isVoid() then
					result := true
				end
			end
		end
		
		operation isCallFeatureAsStaticOperation() : Boolean is do
			result := false
			
			if self.isInstanceOf(CallFeature) then
				if not self.asType(CallFeature).staticOperation.isVoid() then
					result := true
				end
			end
		end
		
		operation isCallFeatureAsStaticEnumLiteral() : Boolean is do
			result := false
			
			if self.isInstanceOf(CallFeature) then
				if not self.asType(CallFeature).staticEnumLiteral.isVoid() then
					result := true
				end
			end
		end
	}
	
	aspect class CallFeature {
	
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			super(context)
			result := ""
			
			var ppCast : Boolean init false
			
			var cf_prop_suffix : String init ""

			//By default, the self expression is added to a call feature
			if self.target.isVoid() then
				self.target := SelfExpression.new()
			end
			var tgt : Expression init self.target
			var fName : String  init IdentifierHelper.new.getMangledIdentifier(self.name, context)
			
			
			var static_call : String init ""
			
			if self.isCallFeatureAsStaticOperation() then
				
				if self.callsFunctionType() then
					
					context.tasks_stack.push(context.FUNCTION_TYPE_COMPILATION_TASK)
					context.afterLbdExpActivation := false
					
					// A switch should be printed: subClassDefinitions
					self.target.staticType.asType(ParameterizedType).getClassDefinitionAsTyped().subClassDefinitions.each{ cd |
						if cd.ownedOperation.exists{ op | op.name == self.staticOperation.name } then
							stdio.writeln("//if( instanceof " + cd.name + " ) - " + self.staticOperation.name)
						end
					}
					
					var ft_str : String init self.createStringFromFunctionType(context)
					
					context.tasks_stack.pop()
					
					result := ft_str
				
				else
				
					if fromUtil(context) then
					
						if self.staticOperation.container().asType(ClassDefinition).isValueType() then
							static_call := self.staticOperation.getOptimizedStaticCall(context)
							
							if static_call == "" then
								static_call := self.staticOperation.container().asType(ClassDefinition).container().asType(Package).qualifiedName.replace("::", ".") + ".helper." + self.staticOperation.container().asType(ClassDefinition).name + "Wrapper." + fName
							end
						else
							
							static_call := "org.kermeta.compil.runtime.helper.language." + self.staticOperation.container().asType(ClassDefinition).name + "Util." + fName
							
							if fName == "asType" then
								ppCast := true
								static_call := "(" + self.parameters.first().createBehaviorJava(context) + ") " + static_call
							end
						end
					else
					
						if not tgt.isVoid() then
							if not tgt.staticType.isVoid() then
								if tgt.staticType.isValueType() then
									static_call := "org.kermeta.compil.runtime.helper.basetypes." + tgt.staticType.getTypeName() + "Util." + fName
								end
							end
						else
							if self.staticOperation.container().asType(ClassDefinition).isMappedToJavaRawType() and (not self.staticOperation.body.isVoid()) then
								static_call := self.staticOperation.getOptimizedStaticCall(context)
							end
						end
						
					end
				
				end
			
			end
			
			if (fName == "_new")
					and isFromClass()
					and (not tgt.isInstanceOf(CallVariable))
					and (not tgt.isInstanceOf(CallFeature))
					and (not tgt.isInstanceOf(SelfExpression))
					and (not tgt.isInstanceOf(CallResult)) then
				if not tgt.createBehaviorJava(context).isValueType(context) then
					result := result + "((" + tgt.createBehaviorJava(context) + ") " + "org.kermeta.compil.runtime.helper.language.ClassUtil.newObject(\"" + tgt.createBehaviorJava(context) + "\"))"
				else
					result := "null"
				end
			else
				
				if not tgt.isVoid() then
					
					if not tgt.callsFunctionType() then
						
						if not self.callsFunctionType() then
						
							if tgt.isInstanceOf(TypeLiteral) and (tgt.staticType.toString!="Enumeration") then
								result := result + "org.kermeta.compil.runtime.ExecutionContext.getInstance().getMetaClass(\"" + tgt.createBehaviorJava(context) + "\")"
							else
								result := result + tgt.createBehaviorJava(context)
							end
							
							if static_call=="" then
								result := result + "."
							end
						else
							//The result identifier of the function type is printing for calling the following methods
							//eg: self.select{...}.size() => compiling of the FT + result_ft1.size();
							if self.container.isInstanceOf(CallExpression) and (not self.container.callsFunctionType()) then
								var resultPrefix : String init ""
								if self.getContainerAsTypeIn(Assignment, Block).isVoid() then
									resultPrefix := context.RETURN_EXPRESSION_TO_REPLACE_SPECIAL
								end
								result := result + resultPrefix + context.PREVIOUS_STATEMENT_FT + context.RETURN_EXPRESSION_TO_REPLACE + self.resultOfLastFt
							end
						end
					else
						result := tgt.createBehaviorJava(context) + result.replace(context.SELF_EXPRESSION_TO_REPLACE, tgt.asType(CallFeature).resultOfLastFt)
					end
				end
				
				if static_call=="" then
					if self.isCallFeatureAsStaticEnumLiteral then
						result := result + "getByName(\"" + fName + "\")"
					else
					
						if self.isCallFeatureAsStaticProperty() then
						
							if self.staticProperty.upper != 1 then
								var type_binding : String init self.staticType.asType(Class).typeParamBinding.first().type.createBehaviorJava(context)
								
								if (not self.staticProperty.isUnique) and (not self.staticProperty.isOrdered) then
									result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsBag(" + result
								end
								
								if (self.staticProperty.isUnique) and (not self.staticProperty.isOrdered) then
									result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsSet(" + result
								end
								
								if (self.staticProperty.isUnique) and (self.staticProperty.isOrdered) then
									result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsOrderedSet(" + result
								end
								
								if (not self.staticProperty.isUnique) and (self.staticProperty.isOrdered) then
									result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsSequence(" + result
								end
								
								cf_prop_suffix := ")"
							end
							
							result := result + self.printGetAccessor() + "()" + cf_prop_suffix
							cf_prop_suffix := ""
							
						else
						
							if not self.callsFunctionType() then
							
								if self.staticOperation.upper != 1 then
									var type_binding : String init self.staticType.asType(Class).typeParamBinding.first().type.createBehaviorJava(context)
									
									if (not self.staticOperation.isUnique) and (not self.staticOperation.isOrdered) then
										result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsBag(" + result
									end
									
									if (self.staticOperation.isUnique) and (not self.staticOperation.isOrdered) then
										result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsSet(" + result
									end
									
									if (self.staticOperation.isUnique) and (self.staticOperation.isOrdered) then
										result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsOrderedSet(" + result
									end
									
									if (not self.staticOperation.isUnique) and (self.staticOperation.isOrdered) then
										result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsSequence(" + result
									end
									
									cf_prop_suffix := ")"
								end
							
							
								result := result + IdentifierHelper.new.getMangledIdentifier(self.staticOperation.getFinalName(), context)
								
							else
								//Fix the dot after the result of an FunctionType
								if self.container.isInstanceOf(CallExpression) and (not self.container.callsFunctionType()) then
									if self.container.isInstanceOf(CallFeature) then
										var cf_ : CallFeature init self.container.asType(CallFeature)
										
										if not cf_.staticOperation.isVoid() then
											if cf_.fromUtil(context) or self.isParameter() or  (cf_.staticOperation.getCompiledJavaExtern() != "") then
											else
												result := result + "."
											end
											
										else
											if not cf_.staticProperty.isVoid() then
												result := result + "."
											end
											
										end												
									end
								end
							end
						end
					end
				else
					//added 08-08-10
					if result.contains(context.RETURN_EXPRESSION_TO_REPLACE) then
						//added 08-08-10
						result := result.replace(context.RETURN_EXPRESSION_TO_REPLACE, static_call + "(")
//context.beforeFunctionTypeResult := result.replace(context.RETURN_EXPRESSION_TO_REPLACE, static_call + "(")
//result := ""
					//added 08-08-10
					else
						result := static_call + "(" + result
					//added 08-08-10
					end
					if ppCast then
						result :=  "(" + result
					end
				end
				
									
				if self.isCallFeatureAsStaticOperation() and not self.callsFunctionType() then
					if static_call=="" then
						result := result + "("
					else
						static_call := ""
						if (not self.parameters.isVoid()) and (self.parameters.size()>0) then
							result := result + ", "
						end
					end
					
					self.beforeLambdaExpressionResult := ""
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context) + ")" + cf_prop_suffix
					context.beforeLambdaExpressionResult := self.beforeLambdaExpressionResult
					self.beforeLambdaExpressionResult := ""
					
					if ppCast then
						result := result + ")"
						ppCast := false
					end
				end
			end
			
			result := result + self.endOfExpressionFixer()
		end
		
	}
	
	aspect class CallVariable {
	
		reference lambdaExpression : LambdaExpression [0..1]
		
		operation printSuffix(context : KM2EcoreContext) : String is do
			result := ""
			
			if self.isLambdaExpressionParameter() then
			
				result := "_lbdExp" + self.getCorrespondingLambdaExpressionParameter().container.asType(LambdaExpression).cuid
			else
				if self.isDeclaredInAFunctionType() then
					if context.afterLbdExpActivation and (context.printFtSuffix()!="") then
						result := context.printFtSuffix()
					else
						result := "_ft" + self.getContainerAsType(Operation).asType(Operation).cuid.toString()
					end
				else
					if self.isDeclaredInLambdaExpression() then
						result := context.printFtSuffix()
					end
				end
			end
		end
		
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			super(context)
			result := ""

			if (context.tasks_stack.peek() == context.FUNCTION_TYPE_COMPILATION_TASK) and self.isFunctionTypeVariable() then
								
				context.ftSuffixActivation := false
				
				var theLambdaExp : LambdaExpression init self.getContainerAsType(Operation).asType(Operation).lambdaExpression
				
				self.lambdaExpression := theLambdaExp
						
				var str_toInclude : String init ""
				
				if theLambdaExp.staticType.isInstanceOf(FunctionType) then
					var lambdaExp_returnType : String init theLambdaExp.staticType.asType(FunctionType).right.createBehaviorJava(context)
					if not Operation.new().isVoidType(lambdaExp_returnType) then
						//context.pushResultLastStatementStack()
						//str_toInclude := str_toInclude + lambdaExp_returnType + " " + context.getResultLastStatementId() + "null;\n"
					end
				end
				
				var inc_param : Integer init 0
				theLambdaExp.parameters.each{ p |
					//str_toInclude := str_toInclude + self.parameters.elementAt(inc_param).staticType.createBehaviorJava(context) + " " + p.name
					
					context.ftSuffixActivation := false
					
					//Declare and initialize the function type parameters
					var type_param_ : String init context.ftProductTypeStack.peek().getTypeByIndex(inc_param).createBehaviorJava(context)
					
					// This case occurs when andThen and orElse are inlined
					// Maybe we could add 2 slashs for commenting the variable declaration 
					if Operation.new().isVoidType(type_param_) then
						type_param_ := "/*This variable should be never used*/ kermeta.language.structure.Object"
					end
					
					str_toInclude := str_toInclude + type_param_ + " " + p.name + "_lbdExp" + self.getContainerAsType(Operation).asType(Operation).cuid
					
					context.ftSuffixActivation := true
					
					str_toInclude := str_toInclude + " = " + self.parameters.elementAt(inc_param).createBehaviorJava(context) + ";\n"
					
					inc_param := inc_param + 1
				}
				
				
				//Add the compiled version of the body of the current LambdaExpression
				context.afterLbdExpActivation := false
				
				result := result + "//BIle:" + self.name + "\n"
				context.ftSuffixActivation := false
				result := result + str_toInclude + theLambdaExp.body.createBehaviorJava(context)
				context.ftSuffixActivation := true
				
				//added 08-08-09
				/*if type_label!="" then
					result := result + context.getResultLastStatementId()
					context.resultLastStatementStack.pop()
				end*/
				
				result := result + "//EIle:" + self.name + "\n"
				
				context.afterLbdExpActivation := true
				
				
			else

				// Special case for the stdio variable
				if self.name == "stdio" then
					result := result + "org.kermeta.compil.runtime.helper.io.StdIOUtil"
				else
					
					if (not self.isParameter()) and (not self.isParameterForOwningOperation()) then
						result := result + IdentifierHelper.new.getMangledIdentifier(self.name, context) + self.printSuffix(context)
					else
						if self.isParameterSingle() or self.isParameterForOwningOperationSingle() or self.isParameterManyAndForOwningOperation() then
							result := result + IdentifierHelper.new.getMangledIdentifier(self.name, context) + self.printSuffix(context)
						else
						
							var c_param : Parameter
							if self.isParameterForOwningOperation() then
								c_param := self.retrieveCorrespondingParameter()
							else
								c_param := self.getCallFeatureCorrespondingParameter()
							end
			
							var type_binding : String init self.staticType.asType(Class).typeParamBinding.first().type.createBehaviorJava(context)
								
							if self.isParameterMany() then
								result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsEList(" + result
							else
												
								if (not c_param.isUnique) and (not c_param.isOrdered) then
									result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsBag(" + result
								end
												
								if (c_param.isUnique) and (not c_param.isOrdered) then
									result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsSet(" + result
								end
												
								if (c_param.isUnique) and (c_param.isOrdered) then
									result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsOrderedSet(" + result
								end
												
								if (not c_param.isUnique) and (c_param.isOrdered) then
									result := context.COLLECTION_UTIL_CLASS + ".<" + type_binding + ">convertAsSequence(" + result
								end
							
							end
											
							result := result + IdentifierHelper.new.getMangledIdentifier(self.name, context) + self.printSuffix(context) + ")"
						end
					end
				end
				
				result := result + self.endOfExpressionFixer()
			
			end
		end
	}
	
	aspect class CallResult {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallVariable is do
			super(context)
			//Try to insert line number
			//result := "begin " + self.lineNumber.toString() + " " + self.fileName + "\n" + "result" + "\nend " + self.lineNumber.toString() + " " + self.fileName + "\n"
			result := "result"
			
			//if not self.getContainerAsType(LambdaExpression).isVoid() then
				result := result + context.printFtSuffix()
			//end
			
			result := result + self.endOfExpressionFixer()
		end
	}
	
	aspect class CallValue {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
		
			super(context)
			
			result := "value"
		end
	}
	
	/** Complete */
	aspect class CallSuperOperation {
	
		operation getCallStaticSignature(owningOperation : Operation, context : KM2EcoreContext) : String is do
			result := ""
			
			result := result + owningOperation.superOperation.container.asType(ClassDefinition).container.asType(Package).qualifiedName.replace("::", ".")
						+	".helper."
						+	owningOperation.superOperation.container.asType(ClassDefinition).name
						+ "Super.super_"
						+	IdentifierHelper.new.getMangledIdentifier(owningOperation.superOperation.getFinalName(), context) + "("
			
			// The this or self parameter is added by default
			if context.staticOperationMode then
				result := result + "self"
			else
				result := result + "this"
			end
			
			if self.parameters.size()>0 then
				result := result + ", "
			end
			
			// The super operation is added to the context for being compiled during the postprocess step
			if context.staticOperationMode then
				ModelingUnit.new().compileStaticOperation(owningOperation.superOperation, context)
			else
				context.mu.superOperationsToCompileInHelper.add(owningOperation.superOperation)
			end
		end
		
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
		
			super(context)
			
			var owningOperation : Operation init self.getContainerAsType(Operation).asType(Operation)
			
			var fromOperation_cd : String init owningOperation.superOperation.container.asType(ClassDefinition).qualifiedName.replace("::", ".")
			//FIXME: Perhaps, we should fix the type parameters of the class definition
			
			result := ""//"//Call of the super operation\n"
			
			var extended_class : EClass init self.getContainerAsType(ClassDefinition).asType(ClassDefinition).ecoreModelElement
			var super_class : EClass init owningOperation.superOperation.container.asType(ClassDefinition).ecoreModelElement
			
			if not owningOperation.isFunctionType() then
			
				if ModelAnalizer.new().isExtendedBy(extended_class, super_class) and (not context.staticOperationMode) then
					result := result + "super." + owningOperation.name + "("
				else
					result := result + self.getCallStaticSignature(owningOperation, context)
				end
				
				self.beforeLambdaExpressionResult := ""
				
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context) + ")"
					
				context.beforeLambdaExpressionResult := self.beforeLambdaExpressionResult
				self.beforeLambdaExpressionResult := ""
					
				result := result + self.endOfExpressionFixer()
				
			else
			
				stdio.writeln("A callSuperFunctionType has been detected: " + owningOperation.qualifiedName() + " - signature: " + getCallStaticSignature(owningOperation, context))
			
			end
			
		end
	}
	//**** End **** Managing of the CallExpression branch ****//
	
	aspect class VariableDecl {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)

			result := ""
			
			var localType : String init self.staticType.createBehaviorJava(context)
			var var_id : String init IdentifierHelper.new.getMangledIdentifier(self.identifier, context) + context.printFtSuffix()
			
			result := result + localType + " " + var_id
			
			if not self.initialization.isVoid() then
				if self.initialization.isInstanceOf(Conditional) then
					context.resultLastStatementStack.push(var_id + " = " + context.TYPE_SEPARATOR + localType)
					result := result + " = null;\n" + self.initialization.createBehaviorJava(context)
					context.resultLastStatementStack.pop()
				else
					result := result + " = " + self.initialization.createBehaviorJava(context)
				end
			else
				result := result + " = null;"
			end
			
		end
	}
	
	aspect class Assignment {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)
			
			result := ""
			
			var left : String init self.target.createBehaviorJava(context)
			
			var ppCast : String init ""
			if self.isCast() then
				//FIXME CF 08-08-01 When the bug#6018 will be fixed, self.target.staticType could be self.staticType
				ppCast := "(" + self.target.staticType.createBehaviorJava(context) + ") "
			end
			
			// We should use: self.staticType.createBehaviorJava(context), but this value is not setted rightly
			context.resultLastStatementStack.push(left + " = " + ppCast + context.TYPE_SEPARATOR + self.target.staticType.createBehaviorJava(context))
			
			var right : String init self.~value.createBehaviorJava(context)
		
			// Patch that adds the 'function' keyword in case the assigned value is a function type
			if self.~value.isInstanceOf(LambdaExpression) then
				stdio.errorln("Alert in createBehaviorJava Assignment")
				right := "function " + right
			end
						
			if self.target.isCallFeatureAsStaticProperty() then
			
				//stdio.writeln("left: " + left)
					
				var tabLeft : kermeta::standard::OrderedSet<String> init left.split("\\.")
				
				result := ""
				from var i : Integer init 0
				until i >= tabLeft.size()
				loop
					if i < (tabLeft.size()-1) then
						result := result + tabLeft.elementAt(i) + "."
					end
					if i == (tabLeft.size()-1) then
						result := result + self.target.asType(CallFeature).printSetAccessor() + "(" + ppCast + right + ");"
					end
					i := i+1
				end

			else
				if self.~value.isInstanceOf(Conditional) then
					result := right
				else
					if right.contains(context.RETURN_EXPRESSION_TO_REPLACE) then
						result := right.replace(context.RETURN_EXPRESSION_TO_REPLACE, left + " = " + ppCast)
					else
						if ( self.target.isInstanceOf(CallVariable) or self.target.isInstanceOf(CallResult) ) and (self.~value.callsFunctionType() or self.~value.isFunctionTypeVariable()) then
							result := right
						else
							result := left + " = " + ppCast + right
						end
					end
				end
			end
			context.resultLastStatementStack.pop()
		end
	}
	
	aspect class LambdaExpression {
	
		attribute cuid : String [0..1]
	
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := ""
		end
	}
	
	aspect class LambdaParameter {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			super(context)
			result := ""
		end
	}
	
	aspect class TypeReference {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			super(context)
			result := self.type.createBehaviorJava(context)
		end
	}
	
	//**** Begin **** Managing of the exception (wrapper to java.lang.Error) ****//
	/** Complete */
	aspect class Raise {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			
			super(context)
			
			result := "\nif (true)\n\tthrow new " + context.JAVA_CLASS_EXCEPTION_SWITCHER + "( " + self.expression.createBehaviorJava(context) + " );\n"
		end
	}
	
	/** Complete */
	aspect class Rescue {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
		
			super(context)
			
			result := ""
			
			if not self.exceptionType.isVoid() then
			
				var str_exceptionType : String init self.exceptionType.createBehaviorJava(context)
				
				result := result + "if( " + context.VARIABLE_EXCEPTION_SWITCHER + "_" + context.kRErrorStack.peek() + ".getRealException() instanceof " + str_exceptionType + " ) {\n"
				
				result := result + str_exceptionType + " " + self.exceptionName + " = (" + str_exceptionType + ") " + context.VARIABLE_EXCEPTION_SWITCHER + "_" + context.kRErrorStack.peek() + ".getRealException();\n"
				
				self.eachOwnedElement{e | 
					result := result + e.createBehaviorJava(context)
				}
				
				//end of the if
				result := result + "\n}"
				
			end

		end
	}
	//**** End **** Managing of the exception ****//
	
	/** Complete */
	aspect class SelfExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			
			result := "this"
			
			if (not context.current_valueType.isVoid()) or context.staticOperationMode then
				result := "self"
			end
			
			if context.ftSuffixActivation then
				result := context.ftContextualSelf
			end
			
			/*if not self.getContainerAsType(Operation).isVoid() then
				if self.getContainerAsType(Operation).asType(Operation).isFunctionType()
					and self.getContainerAsType(LambdaExpression).isVoid() then
					result := context.ftContextualSelf
				end
			end*/

			result := result + self.endOfExpressionFixer()
		end
	}
	
	/** Complete */
	aspect class Conditional {
		
		operation conditionIsCallFeatureThatCallsFunctionType() : Boolean is do
			result := false
			
			if self.condition.isInstanceOf(CallFeature) then
				if self.condition.asType(CallFeature).callsFunctionType() then
					result := true
				end
			end
		end
		
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			
			super(context)
			
			context.pushCondStack()
			
			result := "java.lang.Boolean " + context.getIfConditionId() + " = false;"
			
			var str_condition : String init ""
			
			
			if self.conditionIsCallFeatureThatCallsFunctionType() then
							
				context.resultLastStatementStack.push(context.getIfConditionId() + " = " + context.TYPE_SEPARATOR + "java.lang.Boolean")	
				str_condition := str_condition + "\n" + self.condition.createBehaviorJava(context)
				context.resultLastStatementStack.pop()

			else
			
				if context.printFtSuffix()=="" then
					str_condition := str_condition + "\n\t" + context.getIfConditionId() + " = " + self.condition.createBehaviorJava(context)
				else
					// The condition is a CallVariable
					if self.condition.isInstanceOf(CallVariable) or self.condition.isInstanceOf(SelfExpression) or self.condition.isInstanceOf(CallResult) then
			
						var ftParam : Parameter init void
						
						if self.condition.isInstanceOf(CallVariable) then
							ftParam := self.condition.asType(CallVariable).getFunctionTypeParameter()
						end
						
						if not ftParam.isVoid() then
						
							if ftParam.isBooleanFunctionType(context) then
								context.resultLastStatementStack.push(context.getIfConditionId() + " = " + context.TYPE_SEPARATOR + "java.lang.Boolean")
								str_condition := str_condition + "\n" + self.condition.createBehaviorJava(context)
								context.resultLastStatementStack.pop()
							else
								str_condition := str_condition + "\n\t" + context.getIfConditionId() + " = " + self.condition.createBehaviorJava(context)
							end
						end
					end
					
					if self.condition.isInstanceOf(SelfExpression) then
						str_condition := str_condition + "\n\t" + context.getIfConditionId() + " = " + self.condition.createBehaviorJava(context)
					end					
				end				
			end
			
			result := result + str_condition
			
			/*if not Operation.new().isVoidType(self.staticType.getTypeName()) then
				context.pushResultLastStatementStack()
				result := result + "\n" + self.staticType.createBehaviorJava(context) + " " + context.getResultLastStatementId() + " = null;" 
			end*/
			
			result := result + "\n\n\tif( " + context.getIfConditionId() + " ) "
			
			if not self.thenBody.isVoid() then 
				result := result + self.thenBody.createBehaviorJava(context) + "\n"
			end
			if not self.elseBody.isVoid() then
				result := result + " else "
				result := result + self.elseBody.createBehaviorJava(context) + "\n"
			end
			
			/*if not Operation.new().isVoidType(self.staticType.getTypeName()) then
				context.resultLastStatementStack().pop()
			end*/
			
			context.condStack.pop()
			
		end
	}
	
	/** Complete */
	aspect class Loop {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := ""
			
			context.pushCondStack()
			
			if self.initialization.isInstanceOf(CallVariable) then
				//FIXME CF Maybe we should do something here
			else
				//open a virtual block
				if self.initialization.isInstanceOf(VariableDecl) then
					result := result + "\n" + "{\n"
				end
		
				result := result + "\n\t" + self.initialization.createBehaviorJava(context)
			end
			
			result := result + "\n\tjava.lang.Boolean " + context.getLoopConditionId() + " = false;"
			result := result + "\n\twhile( !" + context.getLoopConditionId() + " ) {"
			result := result + "\n\t" + context.getLoopConditionId() + " = " + self.stopCondition.createBehaviorJava(context) + ";"
			result := result + "\n\tif ( " + context.getLoopConditionId() + " ) {"
			context.condStack.pop()
			result := result + "\n\t} else "
			result := result + self.body.createBehaviorJava(context)
			
			//close the while
			result := result + "\n\t}"
			
			//close the virtual block
			if self.initialization.isInstanceOf(VariableDecl) then
				result := result + "\n}\n"
			end
			
		end
	}
	
	/** Complete */
	aspect class JavaStaticCall {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do

			super(context)

			// The parameters are recalculated if they are removed in the super operation
			if context.compiledJavaExtern!="" then
				if context.compiledJavaExtern.replace("(", "%").split("%").size() < 2 then
					context.compiledJavaExtern := context.compiledJavaExtern + "(" + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context) + ")"
				end
			end
			
			
			if context.compiledJavaExtern!="" then
				result := context.compiledJavaExtern
				context.compiledJavaExtern := ""
			else
				if self.getContainerAsType(ClassDefinition).asType(ClassDefinition).isValueType() then
					result := "org.kermeta.compil.runtime.helper.basetypes." + self.getContainerAsType(ClassDefinition).asType(ClassDefinition).name + "Util." + self.jmethod
				else
					result := self.jclass.replace("::", ".") + "." + IdentifierHelper.new.getMangledIdentifier(self.jmethod, context)
				end
				
				self.beforeLambdaExpressionResult := ""
				result := result + "(" + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context) + ")"
				context.beforeLambdaExpressionResult := self.beforeLambdaExpressionResult
				self.beforeLambdaExpressionResult := ""
			
			end
			
			result := result + self.endOfExpressionFixer()
		end
	}
	
	
	//**** Begin **** Managing of the literal ****//
	aspect class Literal {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := ""
		end
	}
	
	/** Complete */
	aspect class StringLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			
			result := self.~value
			
			if result == "." then
				result := "\".\""
			else
				result := "\"" + result.replace("\"", "\\\"") + "\""
				result := result.replace("\n", "\\n")
				result := result.replace("\t", "\\t")
			end
			
			result := result + self.endOfExpressionFixer()
		end
	}
	
	/** Complete */
	aspect class IntegerLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.~value.toString
			result := result + self.endOfExpressionFixer()
		end
	}
	
	/** Complete */
	aspect class BooleanLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.~value.toString
			result := result + self.endOfExpressionFixer()
		end
	}
	
	aspect class TypeLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.typeref.createBehaviorJava(context)
		end
	}
	
	/** Complete */
	aspect class VoidLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := "null" // the VoidLiteral is "normally" mapped to the void singleton
			result := result + self.endOfExpressionFixer()
		end
	}
	//**** End **** Managing of the literal ****//
	
}