/* $Id: CreateBehavior.kmt,v 1.10 2008-02-26 14:09:41 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 *			Francois Tanguy <ftanguy@irisa.fr>
 */

package kermeta::language;

require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "../helper/KM2EcoreHelper.kmt"

using kermeta::language::structure
using kermeta::language::behavior
using kermeta::standard
using kermeta::utils
using ecore
using km2ecore::helper::ecore
using kermeta::language::compilerhelper

package structure {

	aspect class Object {
		operation createBehaviorJava(context : Integer) : String is do
			result := ""
		end
	}
	
	/** We have to visit property in order to print the behavior of the getter and setter */
	aspect class Property {
		method createBehaviorJava(context : Integer) : String is do
			result := void
			
			// The current property is derived
			if self.isDerived then
				// The current property could have a setter
				if not self.isReadOnly then
					// todo compile the setter in an EAnnotation
				end
				// todo compile the getter in an EAnnotation
			end
		end
	}
	
	/** We have to visit operation in order to print the result initialization and the return statement */
	aspect class Operation {
		method createBehaviorJava(context : Integer) : String is do
			result := void
			
			var javaCode : StringBuffer init StringBuffer.new
			
			//stdio.writeln("\tCurrent operation: " + self.name + " has for type: " + self.type.toString)
			
			// the body of the operation must be filled for being compiled
			if ( not self.body.isVoid() ) then
				var type_label : String init self.type.createBehaviorJava(context)
				
				// result is initialized only if the "return type" is not Void
				if ( type_label!="Void" and type_label!="VoidType" ) then
					javaCode.append("\n" + type_label + " result = null;\n")
				end
		
				// The Java source code is provided by: self.body.createBehaviorJava(context)
				javaCode.append(self.body.createBehaviorJava(context))
				
				// result is returned only if the "return type" is not Void
				if ( type_label!="Void" and type_label!="VoidType" ) then
					javaCode.append("\nreturn result;\n")
				end
			end
			
			// Finally add the EAnnotation containing the Java code in the Ecore model
	        EAnnotationHelper.new.addAnnotationGenModelImpl(self.ecoreModelElement, javaCode.toString)
	        
	        result := javaCode.toString
		end
	}
	
	aspect class Type {
		method createBehaviorJava(context : Integer) : String is do
			result := ""
		end
	}
	
	aspect class VoidType {
		method createBehaviorJava(context : Integer) : String from Type is do
			result := "Void" // the VoidType is "normally" mapped to the Void class
		end
	}
	
	aspect class PrimitiveType {
		method createBehaviorJava(context : Integer) : String is do
			result := self.instanceType.createBehaviorJava(context) // self.instanceType should be a ParameterizedType
		end
	}
	
	aspect class ParameterizedType {
		method createBehaviorJava(context : Integer) : String from Type is do
			result := self.typeDefinition.name
		end
	}
	
	/*aspect class ObjectTypeVariable {
		method createBehaviorJava(context : Integer) : String is do
			result := "//TODO\n" + self.toString
		end
	}*/

}

package behavior {
	
	aspect class Expression {
		method createBehaviorJava(context : Integer) : String is do
			//self.
			result := "//TODO content of the current expression\n" + self.toString + "\n\n"
		end
	}
	
	aspect class Block {
		method createBehaviorJava(context : Integer) : String from Expression is do
			var javaCode : StringBuffer init StringBuffer.new
			javaCode.append("{")
			self.statement.each{ stm |
				javaCode.append("\n\t")
				javaCode.append(stm.createBehaviorJava(context))
				javaCode.append("\n")
			}
			result := javaCode.append("}").toString()
		end
	}
	
	//**** Begin **** Managing of the CallExpression branch ****//
	aspect class CallExpression {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "//TODO content of the current CallExpression\n" + self.toString + "\n\n"
		end
	}
	
	aspect class CallFeature {
		method createBehaviorJava(context : Integer) : String from CallExpression is do
			result := "//IP content of the current CallFeature\n"
						+ self.target.createBehaviorJava(context) + "." + self.name
						
			if self.name == "writeln" then
				result := "println"
			end
		end
	}
	
	aspect class CallVariable {
		method createBehaviorJava(context : Integer) : String from CallExpression is do
			result := "//TODO content of the current CallVariable\n" + self.toString + "\n\n"
			if self.name == "stdio" then
				result := "System.out"
			end
		end
	}
	
	aspect class CallResult {
		method createBehaviorJava(context : Integer) : String from CallVariable is do
			result := "result"
		end
	}
	
	aspect class CallValue {
		method createBehaviorJava(context : Integer) : String from CallExpression is do
			result := "//TODO content of the current CallValue\n" + self.toString + "\n\n"
		end
	}
	
	aspect class CallSuperOperation {
		method createBehaviorJava(context : Integer) : String from CallExpression is do
			result := "//TODO content of the current CallSuperOperation\n" + "super" + "\n\n"
		end
	}
	//**** End **** Managing of the CallExpression branch ****//
	
	aspect class VariableDecl {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "//IP VariableDecl" + self.toString
			var localType : String init self.type.createBehaviorJava(context)
			result := result + localType + " " + self.identifier
			if not self.initialization.isVoid() then
				
				if self.initialization.createBehaviorJava(context).contains(".new()") then
					result := result + CompilerHelper.new.getCreateFactory(localType)
				else
					result := result + " = " + self.initialization.createBehaviorJava(context)
				end
		
			else
				//result := result + CompilerHelper.new.getCreateFactory(localType)
			end
		result := result + ";"
		end
	}
	
	aspect class Assignment {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "//TODO Assignment" + self.toString
		end
	}
	
	aspect class LambdaExpression {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "//TODO LambdaExpression" + self.toString
		end
	}
	
	aspect class LambdaParameter {
		method createBehaviorJava(context : Integer) : String is do
			result := "//TODO LambdaParameter" + self.toString
		end
	}
	
	aspect class TypeReference {
		method createBehaviorJava(context : Integer) : String is do
			result := "//TODO TypeReference" + self.toString
		end
	}
	
	aspect class EmptyExpression {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "//TODO EmptyExpression" + self.toString
		end
	}
	
	//**** Begin **** Managing of the exception ****//
	aspect class Raise {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "throw " + self.expression.createBehaviorJava(context)
		end
	}
	
	aspect class Rescue {
		method createBehaviorJava(context : Integer) : String is do
			result := "catch"
			if not self.exceptionName.isVoid() then
				result := result + "(" + self.exceptionName + " : " + self.exceptionType.createBehaviorJava(context) + ")"
			end
			result := result + "\n{"
			//pushPrefix();
			result := result + self.body.createBehaviorJava(context) + "}"
			//popPrefix();
		end
	}
	//**** End **** Managing of the exception ****//
	
	aspect class SelfExpression {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "this"
		end
	}
	
	aspect class Conditional {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "if( " + self.condition.createBehaviorJava(context) + ") {\n"
			//pushPrefix(); 
			// Both type of ThenBody and ElseBody are "Block" (see also KMT2KMPrimitiveExpressionBuilder)
			// And block textual syntax is already represented by "then..else..end"
			//alreadyPrefixed = false;
			if not self.thenBody.isVoid() then 
				result := result + self.thenBody.createBehaviorJava(context) + "\n"
			//popPrefix();
			end
			if not self.elseBody.isVoid() then
				result := result + /*getPrefix() +*/ "} else {\n"
				//pushPrefix();
				result := result + self.elseBody.createBehaviorJava(context) + "\n"
				//popPrefix();
			end
			result := result + /*getPrefix() +*/ "}"
		end
	}
	
	/** TODO */
	aspect class Loop {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := ""
		end
	}
	
	aspect class JavaStaticCall {
		method createBehaviorJava(context : Integer) : String from Expression is do
			//result := self.jclass.replace("::", ".") + "." + KMTHelper.getMangledIdentifier(node.getJmethod()) + "("
			//result := result + ppComaSeparatedNodes(node.getParameters());
			result := result + ")"
		end
	}
	
	//**** Begin **** Managing of the literal ****//
	aspect class Literal {
		method createBehaviorJava(context : Integer) : String from Expression is do
			result := "//TODO Literal" + self.toString
		end
	}
	
	aspect class StringLiteral {
		method createBehaviorJava(context : Integer) : String from Literal is do
			result := "//TODO StringLiteral" + self.toString
		end
	}
	
	aspect class IntegerLiteral {
		method createBehaviorJava(context : Integer) : String from Literal is do
			result := "//TODO IntegerLiteral" + self.toString
		end
	}
	
	aspect class BooleanLiteral {
		method createBehaviorJava(context : Integer) : String from Literal is do
			result := "//TODO BooleanLiteral" + self.toString
		end
	}
	
	aspect class TypeLiteral {
		method createBehaviorJava(context : Integer) : String from Literal is do
			result := "//TODO TypeLiteral" + self.toString
		end
	}
	
	aspect class VoidLiteral {
		method createBehaviorJava(context : Integer) : String from Literal is do
			result := "void" // the VoidLiteral is "normally" mapped to the void singleton
		end
	}
	//**** End **** Managing of the literal ****//
	
}

package compilerhelper {
	/** unused for the moment */
	class CompilerHelper {
		operation ppCRSeparatedNode(expressions : OrderedSet<Expression>, context : Integer) : String is do
			result := ""
			expressions.each{e |
				result := result + e.createBehaviorJava(context)
			}
		end
		
		/**
		 * Give the String corresponding to the CreateFactory  of a type
		 * @param localType
		 * @return
		 */
		operation getCreateFactory(localType : String) : String is do
			result := ""
			
			if localType == "String" then
				result := " = \"\""
				
			else
				//var localType2 : String init localType.replace(".", "%")
	
				//var name_set : OrderedSet<String> init localType2.split("%")
				
				//var allPackages_label : String init localType.substring(0, localType.size()-name_set.elementAt(name_set.size()-1).size())
				
				//if name_set.size()>=2 then
					//result := " = " + allPackages_label + /*CodeGenUtil.capName(*/name_set.elementAt(name_set.size-2)/*)*/ +"Factory.eINSTANCE.create" + name_set.elementAt(name_set.size()-1) + "()"
				//end
			end
		end
	}
}