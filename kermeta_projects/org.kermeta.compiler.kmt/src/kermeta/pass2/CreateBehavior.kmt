/* $Id: CreateBehavior.kmt,v 1.33 2008-07-16 08:14:46 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 */

package kermeta::language;

require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/KM2EcoreHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/StringHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/PrettyPrinterHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/common/ContainmentTraversable.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/common/TraceSource.kmt"

using kermeta::language::structure
using kermeta::language::behavior
using kermeta::utils
using ecore
using km2ecore
using km2ecore::helper::ecore
using km2ecore::helper::kermeta
using km2ecore::helper::java

package structure {

	aspect class Object {
		operation createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
		end
	}
	
	/** We have to visit property in order to print the behavior of the getter and setter */
	aspect class Property {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := void
			
			// The current property is derived
			if self.isDerived then
				// The current property could have a setter
				if not self.isReadOnly then
					// todo compile the setter in an EAnnotation
				end 
				// todo compile the getter in an EAnnotation
			end
		end
	}
	
	/** We have to visit operation in order to print the result initialization and the return statement */
	aspect class Operation {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := void
			
/*			var ft_parameters : Set<Parameter> init self.ownedParameter.detect{ p |
				if p.type.isInstanceOf(FunctionType)
			}*/
			/*
			var ft : FunctionType init p.type.asType(FunctionType)
			//ft.left
			//ft.right*/
			
			//if ft_parameters.detect{ p | p.name==cv.name} then
			//stdio.writeln("context.tasks_stack.peek(): " + context.tasks_stack.peek())
			 
			var javaCode : StringBuffer init StringBuffer.new
			
			//stdio.writeln("\tCurrent operation: " + self.name + " has for type: " + self.type.toString)
			
			// The body of the operation must be filled for being compiled
			if ( not self.body.isVoid() ) then
				var type_label : String init self.type.createBehaviorJava(context)
				
				// result is initialized only if the "return type" is not Void
				if not isVoidType(type_label) then
					javaCode.append("\n" + type_label + " result = null;\n")
				end

				// The Java source code is provided by: self.body.createBehaviorJava(context)
				javaCode.append(self.body.createBehaviorJava(context))
				
				// result is returned only if the "return type" is not Void
				if not isVoidType(type_label) then
					javaCode.append("\nreturn result;\n")
				end
				
			end
			
			// Finally add the EAnnotation containing the Java code in the Ecore model
			if context.tasks_stack.peek() != "FunctionType_Compilation" then
	        	EAnnotationHelper.new.addAnnotationGenModelImpl(self.ecoreModelElement, javaCode.toString)
	        end
	        result := javaCode.toString()
		end
		
		operation isVoidType(type_label : String) : Boolean is do
			result := true
			if (type_label!="null") and (type_label!="Void") and (type_label!="VoidType") and (type_label!="kermeta::standard::Void") and (type_label!="kermeta::language::structure::VoidType") then
				result := false
			end
		end
	}
	
	aspect class Type {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
		end
	}
	
	/** Complete */
	aspect class VoidType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do
			result := "null" // the VoidType is "normally" mapped to the Void class
		end
	}
	
	aspect class PrimitiveType {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := self.instanceType.createBehaviorJava(context) // self.instanceType should be a ParameterizedType
		end
	}
	
	aspect class ParameterizedType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do

			if self.typeDefinition.getEMFInstanceClassName()!="" then
				result := self.typeDefinition.getEMFInstanceClassName()
			else
				@deprecated "It should be never used, these mappings has been replaced by the Tag @EMF_instanceClassName"		
				//result := context.javaTypeMapping.getTypeMapping(self.typeDefinition.qualifiedName)
			
				//result := result.replace("::",".")
				
				result := self.getTypeName().replace("::",".")
			end
			
			//Look the param binding
			var str_tpb : String init ""
			var i : Integer init 0
			self.typeParamBinding.each{ tpb |
				/*if tpb.type.isInstanceOf(ParameterizedType) then
					str_tpb := str_tpb + tpb.type.asType(ParameterizedType).typeDefinition.name
				else
					if tpb.type.isInstanceOf(PrimitiveType) then
						str_tpb := str_tpb + tpb.type.asType(ParameterizedType).typeDefinition.name
					end
					stdio.writeln("tpb.type.asType(ParameterizedType)" + tpb.type.toString())
				end*/
				
				if i==1 then
					str_tpb := str_tpb + ", "
				else
					i := 1
				end
				
				str_tpb := str_tpb + tpb.type.createBehaviorJava(context)
				//str_tpb := str_tpb + tpb.type.getTypeName().replace("::",".")
				
			}
			if str_tpb!="" then
				result := result + "<" + str_tpb + ">"
			end
			result := result + ""
		end
	}
	
	aspect class ObjectTypeVariable {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := self.name
		end
	}

}


package behavior {
	
	/** Complete */
	aspect class Expression {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
		
			if (self.getCompiledJavaExtern()!="") and (context.compiledJavaExtern=="") then
				context.compiledJavaExtern := getCompiledJavaExtern()
			end
			
			//This method must be returned nothing
			result := ""
		end
		
		/**
		 * Check if the current element is at the end of an Expression
		 */
		operation endOfExpressionFixer() : String is do
			result := ""
			if self.container.isInstanceOf(Conditional) or self.container.isInstanceOf(Block) or self.container.isInstanceOf(Assignment) or self.container.isInstanceOf(VariableDecl) then
				if self.container.isInstanceOf(Assignment) then
					if self.container.asType(Assignment).target == self then
						result := ""
					else
						result := ";"
					end
				else
					result := ";"
				end
				
			end
		end
	}
	
	/** Complete */
	aspect class Block {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)
			
			var javaCode : StringBuffer init StringBuffer.new
			
			//At the beginning of each block, the need of "try" block is checked
			if self.containsRescue() then
				javaCode.append("try ")
			end
			
			//EMF adds automatically the first {, thus we are checking if the container of the current block
			//is an Operation, else a { is printed
			if (not self.container.isInstanceOf(Operation)) or  self.containsRescue() then
				javaCode.append("{")
			end
			
			self.eachOwnedElement{ stm |
				javaCode.append("\n\t")
				javaCode.append(stm.createBehaviorJava(context))
				javaCode.append("\n")
			}
			
			//end of a block 
			if (not self.container.isInstanceOf(Operation)) or self.containsRescue() then
				javaCode.append("}")
			end
		
		
			if self.containsRescue() then
				
				javaCode.append(" catch( " + context.JAVA_CLASS_EXCEPTION_SWITCHER + " " + context.VARIABLE_EXCEPTION_SWITCHER + " ) {\n")
				//result := result + "(" + self.exceptionType.createBehaviorJava(context) + " " + self.exceptionName + ")"
				
				self.rescueBlock.each{ e |
					javaCode.append(e.createBehaviorJava(context))
				}
				javaCode.append("\n}")
			end
		
			
			result := javaCode.toString()
		end
		
		operation containsRescue() : Boolean is do
			result := false
			if (not self.rescueBlock.isVoid()) and (self.rescueBlock.size()>0) then
				result := true
			end
		end 
	}
	
	//**** Begin **** Managing of the CallExpression branch ****//
	aspect class CallExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := self.toString
		end
	}
	
	aspect class CallFeature {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			super(context)
			result := ""

			var tgt : Expression init self.target
			var fName : String  init self.name
			
			/*if not self.containedType.at(0).isVoid() and self.containedType.at(0).isInstanceOf(FunctionType) then
				var t0 : FunctionType init self.containedType.at(0).asType(FunctionType)
				if not t0.containedType.at(0).isVoid() and t0.containedType.at(0).isInstanceOf(ProductType) then
					var t1 : ProductType init t0.containedType.at(0).asType(ProductType)
					if not t1.isVoid() and t1.containedType.at(0).isInstanceOf(FunctionType) then
						var t2 : FunctionType init t1.containedType.at(0).asType(FunctionType)
						
						if (not t2.isVoid()) and (t2.isInstanceOf(FunctionType)) then
							self.staticOperation//.createBehaviorJava(context)
						end
					end
				end
			end*/
			
			/*var ft1 : FunctionType init self.containedType.detect{ t | t.isInstanceOf(FunctionType) }.asType(FunctionType)
			
			if not ft1.isVoid() then
				result := result + "FT1 is detected"
				var pt : ProductType init ft1.containedType.detect{ t | t.isInstanceOf(ProductType) }.asType(ProductType)
				
				if not pt.isVoid() then
					result := result + "PT is detected"
					var ft2 : FunctionType init pt.containedType.detect{ t | t.isInstanceOf(FunctionType) }.asType(FunctionType)
					
					if not ft2.isVoid() then
						result := result + "FT2 is detected"
						result := result + "CallFeature_FunctionType"
					end
				end
			end*/
			
			//stdio.writeln("self.staticOperation: " + self.staticOperation.toString())
			
			var static_mode : Boolean init false
			
			if not self.staticOperation.isVoid() then
				if self.staticOperation.isFunctionType() then
					context.tasks_stack.push("FunctionType_Compilation")
					//Stack Over Flow to solve:
					stdio.writeln("context.tasks_stack.peek(): " + context.tasks_stack.peek() + " - " + self.staticOperation.name)
					self.staticOperation.createBehaviorJava(context)
					context.tasks_stack.pop()
				end
				
				if self.staticOperation.container().asType(ClassDefinition).isValueType() or self.staticOperation.container().asType(ClassDefinition).isCollection() then
					static_mode := true
				end
			end
			
			if not tgt.isVoid() then
				result := result + tgt.createBehaviorJava(context)
				if not static_mode then
					result := result + "."
				end
			end

			if self.name == "writeln" then
				result := result + "println"
			else
				if not static_mode then
					result := result + self.name
				else
					result := self.staticOperation.container().asType(ClassDefinition).qualifiedName.replace("::",".") + "Util." + self.name + "(" + result
				end
			end

			
			if not self.staticOperation.isVoid() then
				if not static_mode then
					result := result + "("
				else
					if (not self.parameters.isVoid()) and (self.parameters.size()>0) then
						result := result + ", "
					end
				end
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context) + ")"
			end
			
			result := result + self.endOfExpressionFixer()
		end
		
		/** Definition in progress */
		operation getPP(tgt : Expression, fName : String, context : KM2EcoreContext) : String is do
			result := ""
			
			var isBoolean : Boolean init GenericTypeDefinitionHelper.new.isBooleanTypeDef(tgt.staticType, context)
			var isNumeric : Boolean init GenericTypeDefinitionHelper.new.isNumericalTypeDef(tgt.staticType, context)
			
			if(fName == "not" and isBoolean) then
					result := result + "! ("
					result := result + tgt.createBehaviorJava(context)
					result := result + ")"
				
				else if (fName == "and" and isBoolean) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") && ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if (fName == "or" and isBoolean) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") || ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if (fName == "plus" and isNumeric) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") + ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "minus" and isNumeric) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") - ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "mult" and isNumeric) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") * ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "div" and isNumeric) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") / ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "isGreater" and isNumeric) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") > ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "isLower" and isNumeric) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") < ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "isGreaterOrEqual" and isNumeric) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") >= ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "isLowerOrEqual" and isNumeric) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") <= ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "equals" and (isBoolean or isNumeric)) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") == ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
				else if(fName == "isNotEqual" and (isBoolean or isNumeric)) then
					result := result + "("
					result := result + tgt.createBehaviorJava(context)
					result := result + ") != ("
					result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
					result := result + ")"
				
			
				else
					var ppParam : String init ""
					if tgt.isInstanceOf(CallFeature) then
						ppParam := "(" + CompilerHelperJava.new.ppComaSeparatedNodes(tgt.asType(CallExpression).parameters, context) + ")"
					end
					result := result + tgt.createBehaviorJava(context) + ppParam + "."
				
				end
				end
				end
				end
				end
				end
				end
				end
				end
				end
				end
				end
				end
		end
	}
	
	aspect class CallVariable {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			super(context)
			result := ""

			if self.name == "stdio" then
				result := result + "System.out"
			else
				result := result + IdentifierHelper.new.getMangledIdentifier(self.name, context)
			end
			
			result := result + self.endOfExpressionFixer()
		end
	}
	
	aspect class CallResult {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallVariable is do
			super(context)
			//Try to insert line number
			//result := "begin " + self.lineNumber.toString() + " " + self.fileName + "\n" + "result" + "\nend " + self.lineNumber.toString() + " " + self.fileName + "\n"
			result := "result"
		end
	}
	
	aspect class CallValue {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
		
			super(context)
			
			result := self.toString
		end
	}
	
	aspect class CallSuperOperation {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
		
			super(context)
			
			result := "//IP content of the current CallSuperOperation\n"
			result := result + "super"
		end
	}
	//**** End **** Managing of the CallExpression branch ****//
	
	aspect class VariableDecl {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)
			
			result := ""
			var localType : String init self.type.createBehaviorJava(context)
			result := result + localType + " " + IdentifierHelper.new.getMangledIdentifier(self.identifier, context)
			if not self.initialization.isVoid() then
				
				//if self.initialization.createBehaviorJava(context).contains(".new()") or self.initialization.createBehaviorJava(context).contains(".new") then
					//result := result + " /*VariableDecl with new*/ " + CompilerHelperJava.new.ppEmfLikeCreateFactory(localType)
				//else
					//result := result + " /*VariableDecl without new*/ " + self.initialization.createBehaviorJava(context)
				//end
				
				//result := result + " = CreateFactory.new(" + localType + ")"
				result := result + " = " + self.initialization.createBehaviorJava(context)
		
			else
				result := result + " = null;"//CompilerHelperJava.new.ppEmfLikeCreateFactory(localType)
			end
			
			//result := result + ";"
			
		end
	}
	
	aspect class Assignment {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
		
			super(context)
			
			result := ""//TODO Assignment" + self.toString + "\n"
			var left : String init self.target.createBehaviorJava(context)
			var right : String init self.~value.createBehaviorJava(context)
		
			// Patch that adds the 'function' keyword in case the assigned value is a function
			if self.~value.isInstanceOf(LambdaExpression) then
				right := "function " + right
			end
			
			var ppCast : String init ""
			if self.isCast() then
				ppCast := "(" + self.staticType.createBehaviorJava(context) + ") "
			end
			
			if self.target.isInstanceOf(CallFeature) then
				//stdio.writeln(self.target.name)
				result := result + "get" + self.target.name.capName()
			else
			
				if self.target.isInstanceOf(CallFeature) then
					//left = left.substring(0,left.length()-2);
					
					//left.replace(".", "%")
					
					var tabLeft : kermeta::standard::OrderedSet<String> init left.split("\\.")
					
					result := ""
					from var i : Integer init 0
					until i < tabLeft.size()
					loop
						if i < (tabLeft.size()-1) then
							result := result + tabLeft.elementAt(i) + "."
						end
						if i == (tabLeft.size()-1) then
							result := result + "set" + tabLeft.elementAt(i).capName()
						end
						i := i+1
					end
				
					result := result + "(" + right + ")"
				else
					result := left + " = " + ppCast + right
				end
				
				//result := result + ";"
			end
			
		end
	}
	
	aspect class LambdaExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := "//TODO LambdaExpression" + self.toString
		end
	}
	
	aspect class LambdaParameter {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			super(context)
			result := "//TODO LambdaParameter" + self.toString
		end
	}
	
	aspect class FunctionType {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			super(context)
			result := "//TODO FunctionType" + self.toString
		end
	}
	
	aspect class TypeReference {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			super(context)
			result := "//TODO TypeReference" + self.toString
			result := CompilerHelperJava.new().ppTypeFromMultiplicityElement(self, context)
		end
	}
	
	aspect class EmptyExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := "//TODO EmptyExpression" + self.toString()
		end
	}
	
	//**** Begin **** Managing of the exception ****//
	/** Complete */
	aspect class Raise {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			
			super(context)
		
			var newEGenericType : EGenericType init EGenericType.new()
			newEGenericType.eClassifier := context.mu.getEClassifierByQualifiedName("kermeta::exceptions::KRuntimeException")
			//newEGenericType.eClassifier := self.expression.staticType.asType(ParameterizedType).typeDefinition.asType(ClassDefinition).ecoreModelElement
			if (not newEGenericType.eClassifier.isVoid()) and (not self.getContainerAsType(Operation).isVoid()) then
				
				if (self.getContainerAsType(Operation).asType(Operation).ecoreModelElement.eGenericExceptions.isVoid()) or (self.getContainerAsType(Operation).asType(Operation).ecoreModelElement.eGenericExceptions.size==0) then
					self.getContainerAsType(Operation).asType(Operation).ecoreModelElement.eGenericExceptions.add(newEGenericType)
				end
				
			end
			
			result := self.expression.createBehaviorJava(context) + "\n"
			result := result + "throw new " + context.JAVA_CLASS_EXCEPTION_SWITCHER + "(" + self.expression.createBehaviorJava(context) + ");\n"
		end
	}
	
	/** Complete */
	aspect class Rescue {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
		
			super(context)
			
			result := ""
			
			if not self.exceptionType.isVoid() then
			
				var str_exceptionType : String init self.exceptionType.createBehaviorJava(context)
				
				result := result + "if( " + context.VARIABLE_EXCEPTION_SWITCHER + ".getRealException() instanceof " + str_exceptionType + " ) {\n"
				
				result := result + str_exceptionType + " " + self.exceptionName + " = (" + str_exceptionType + ") ex_SWITCHER.getRealException();\n"
				
				self.eachOwnedElement{e | 
					result := result + e.createBehaviorJava(context)
				}
				
				//end of the if
				result := result + "\n}"
				
			end

		end
	}
	//**** End **** Managing of the exception ****//
	
	/** Complete */
	aspect class SelfExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := "this"
		end
	}
	
	/** Complete */
	aspect class Conditional {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			
			super(context)
			context.inc := context.inc + 1
			context.cond_stack.push(context.inc.toString())
			
			result := "java.lang.Boolean eval_" + context.cond_stack.peek() + " = false;\n"
			result := result + "eval_" + context.cond_stack.peek() + " = " + self.condition.createBehaviorJava(context)
			
			result := result + "\nif( eval_" + context.cond_stack.pop() + " ) "
			//pushPrefix(); 
			// Both type of ThenBody and ElseBody are "Block" (see also KMT2KMPrimitiveExpressionBuilder)
			// And block textual syntax is already represented by "then..else..end"
			//alreadyPrefixed = false;
			if not self.thenBody.isVoid() then 
				result := result + self.thenBody.createBehaviorJava(context) + "\n"
			//popPrefix();
			end
			if not self.elseBody.isVoid() then
				result := result + /*getPrefix() +*/
				 " else \n"
				//pushPrefix();
				result := result + self.elseBody.createBehaviorJava(context) + "\n"
				//popPrefix();
			end
			
		end
	}
	
	/** TODO */
	aspect class Loop {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := ""
		end
	}
	
	/** Complete */
	aspect class JavaStaticCall {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			//stdio.writeln(self.jmethod)

			super(context)
			
			if context.compiledJavaExtern!="" then
				result := context.compiledJavaExtern
				context.compiledJavaExtern := ""
			else
				result := self.jclass.replace("::", ".") + "." + IdentifierHelper.new.getMangledIdentifier(self.jmethod, context) + "("
				result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
				result := result + ")"
			end
		end
	}
	
	
	//**** Begin **** Managing of the literal ****//
	aspect class Literal {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			super(context)
			result := ""
		end
	}
	
	/** Complete */
	aspect class StringLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := "\"" + self.~value.replace("\"", "\\\"") + "\""
			result := result + self.endOfExpressionFixer()
		end
	}
	
	/** Complete */
	aspect class IntegerLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.~value.toString
			result := result + self.endOfExpressionFixer()
		end
	}
	
	/** Complete */
	aspect class BooleanLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.~value.toString
			result := result + self.endOfExpressionFixer()
		end
	}
	
	aspect class TypeLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := self.typeref.createBehaviorJava(context)
		end
	}
	
	/** Complete */
	aspect class VoidLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			super(context)
			result := "null" // the VoidLiteral is "normally" mapped to the void singleton
			result := result + self.endOfExpressionFixer()
		end
	}
	//**** End **** Managing of the literal ****//
	
}