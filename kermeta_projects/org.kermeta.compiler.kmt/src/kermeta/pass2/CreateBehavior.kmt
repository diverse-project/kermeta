/* $Id: CreateBehavior.kmt,v 1.12 2008-02-27 15:53:10 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 *			Francois Tanguy <ftanguy@irisa.fr>
 */

package kermeta::language;

require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/KM2EcoreContext.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/KM2EcoreHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/StringHelper.kmt"
require "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/helper/kermeta/PrettyPrinterHelper.kmt"

using kermeta::language::structure
using kermeta::language::behavior
using kermeta::standard
using kermeta::utils
using ecore
using km2ecore
using km2ecore::helper
using km2ecore::helper::ecore
using km2ecore::helper::kermeta

package structure {

	aspect class Object {
		operation createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
		end
	}
	
	/** We have to visit property in order to print the behavior of the getter and setter */
	aspect class Property {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := void
			
			// The current property is derived
			if self.isDerived then
				// The current property could have a setter
				if not self.isReadOnly then
					// todo compile the setter in an EAnnotation
				end
				// todo compile the getter in an EAnnotation
			end
		end
	}
	
	/** We have to visit operation in order to print the result initialization and the return statement */
	aspect class Operation {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := void
			
			var javaCode : StringBuffer init StringBuffer.new
			
			//stdio.writeln("\tCurrent operation: " + self.name + " has for type: " + self.type.toString)
			
			// the body of the operation must be filled for being compiled
			if ( not self.body.isVoid() ) then
				var type_label : String init self.type.createBehaviorJava(context)
				
				// result is initialized only if the "return type" is not Void
				if ( type_label!="Void" and type_label!="VoidType" ) then
					javaCode.append("\n" + type_label + " result = null;\n")
				end
		
				// The Java source code is provided by: self.body.createBehaviorJava(context)
				javaCode.append(self.body.createBehaviorJava(context))
				
				// result is returned only if the "return type" is not Void
				if ( type_label!="Void" and type_label!="VoidType" ) then
					javaCode.append("\nreturn result;\n")
				end
			end
			
			// Finally add the EAnnotation containing the Java code in the Ecore model
	        EAnnotationHelper.new.addAnnotationGenModelImpl(self.ecoreModelElement, javaCode.toString)
	        
	        result := javaCode.toString
		end
	}
	
	aspect class Type {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := ""
		end
	}
	
	aspect class VoidType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do
			result := "Void" // the VoidType is "normally" mapped to the Void class
		end
	}
	
	aspect class PrimitiveType {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := self.instanceType.createBehaviorJava(context) // self.instanceType should be a ParameterizedType
		end
	}
	
	aspect class ParameterizedType {
		method createBehaviorJava(context : KM2EcoreContext) : String from Type is do
			result := self.typeDefinition.name
		end
	}
	
	/*aspect class ObjectTypeVariable {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := "//TODO\n" + self.toString
		end
	}*/

}

package behavior {
	
	aspect class Expression {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			//self.
			result := "//TODO content of the current expression\n" + self.toString + "\n\n"
		end
	}
	
	aspect class Block {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			var javaCode : StringBuffer init StringBuffer.new
			javaCode.append("{")
			self.statement.each{ stm |
				javaCode.append("\n\t")
				javaCode.append(stm.createBehaviorJava(context))
				javaCode.append("\n")
			}
			result := javaCode.append("}").toString()
		end
	}
	
	//**** Begin **** Managing of the CallExpression branch ****//
	aspect class CallExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "//TODO content of the current CallExpression\n" + self.toString + "\n\n"
		end
	}
	
	aspect class CallFeature {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			result := "/*IP content of the current CallFeature*/"

			if not self.target.isVoid() then
				result := result + self.target.createBehaviorJava(context) + "."
			end
			result := result + self.name
						
			if self.name == "writeln" then
				result := "println"
			end
		end
	}
	
	aspect class CallVariable {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			result := "//TODO content of the current CallVariable\n" + self.toString + "\n\n"
			//result := result + "\n CallVariable.name = " + self.name
			if self.name == "stdio" then
				result := result + "System.out"
			else
				result := result + self.name
			end
		end
	}
	
	aspect class CallResult {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallVariable is do
			result := "result"
		end
	}
	
	aspect class CallValue {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			result := "//TODO content of the current CallValue\n" + self.toString + "\n\n"
		end
	}
	
	aspect class CallSuperOperation {
		method createBehaviorJava(context : KM2EcoreContext) : String from CallExpression is do
			result := "//IP content of the current CallSuperOperation\n"
			result := result + "super"
		end
	}
	//**** End **** Managing of the CallExpression branch ****//
	
	aspect class VariableDecl {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "//IP VariableDecl" + self.toString + "\n"
			var localType : String init self.type.createBehaviorJava(context)
			result := result + localType + " " + self.identifier
			if not self.initialization.isVoid() then
				
				if self.initialization.createBehaviorJava(context).contains(".new()") then
					result := result + CompilerHelperJava.new.ppEmfLikeCreateFactory(localType)
				else
					result := result + " = " + self.initialization.createBehaviorJava(context)
				end
		
			else
				result := result + CompilerHelperJava.new.ppEmfLikeCreateFactory(localType)
			end
		result := result + ";"
		end
	}
	
	aspect class Assignment {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "//TODO Assignment" + self.toString + "\n"
			var left : String init self.target.createBehaviorJava(context)
			var right : String init self.~value.createBehaviorJava(context)
		
			// Patch that adds the 'function' keyword in case the assigned value is a function
			if self.~value.isInstanceOf(LambdaExpression) then
				right := "function " + right
			end
			
			var op : String init ""//(node.isIsCast())?"?":":";
			
			if self.target.isInstanceOf(CallFeature) then
				//stdio.writeln(self.target.name)
				result := result + "get" + KM2EcoreHelper.new.getMangledIdentifier(self.target.name, context).capName()
			else
			
				if self.target.isInstanceOf(CallFeature) then
					//left = left.substring(0,left.length()-2);
					
					left.replace(".", "%")
					
					var tabLeft : OrderedSet<String> init left.split("%")
					
					result := ""
					from var i : Integer init 0
					until i < tabLeft.size()
					loop
						if i < (tabLeft.size()-1) then
							result := result + tabLeft.elementAt(i) + "."
						end
						if i == (tabLeft.size()-1) then
							result := result + "set" + tabLeft.elementAt(i).capName()
						end
						i := i+1
					end
				
					result := result + "(" + right + ");"
				else
					result := left + " " + op + "= " + right + ";"
				end
			end
			
		end
	}
	
	aspect class LambdaExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "//TODO LambdaExpression" + self.toString
		end
	}
	
	aspect class LambdaParameter {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := "//TODO LambdaParameter" + self.toString
		end
	}
	
	aspect class TypeReference {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := "//TODO TypeReference" + self.toString
			result := CompilerHelperJava.new.ppTypeFromMultiplicityElement(self, context)
		end
	}
	
	aspect class EmptyExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "//TODO EmptyExpression" + self.toString
		end
	}
	
	//**** Begin **** Managing of the exception ****//
	aspect class Raise {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "throw " + self.expression.createBehaviorJava(context)
		end
	}
	
	aspect class Rescue {
		method createBehaviorJava(context : KM2EcoreContext) : String is do
			result := "catch"
			if not self.exceptionName.isVoid() then
				result := result + "(" + self.exceptionName + " : " + self.exceptionType.createBehaviorJava(context) + ")"
			end
			result := result + "\n{"
			//pushPrefix();
			result := result + self.body.createBehaviorJava(context) + "}"
			//popPrefix();
		end
	}
	//**** End **** Managing of the exception ****//
	
	aspect class SelfExpression {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "this"
		end
	}
	
	aspect class Conditional {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "if( " + self.condition.createBehaviorJava(context) + ") {\n"
			//pushPrefix(); 
			// Both type of ThenBody and ElseBody are "Block" (see also KMT2KMPrimitiveExpressionBuilder)
			// And block textual syntax is already represented by "then..else..end"
			//alreadyPrefixed = false;
			if not self.thenBody.isVoid() then 
				result := result + self.thenBody.createBehaviorJava(context) + "\n"
			//popPrefix();
			end
			if not self.elseBody.isVoid() then
				result := result + /*getPrefix() +*/ "} else {\n"
				//pushPrefix();
				result := result + self.elseBody.createBehaviorJava(context) + "\n"
				//popPrefix();
			end
			result := result + /*getPrefix() +*/ "}"
		end
	}
	
	/** TODO */
	aspect class Loop {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := ""
		end
	}
	
	aspect class JavaStaticCall {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			//stdio.writeln(self.jmethod)
			result := self.jclass.replace("::", ".") + "." + KM2EcoreHelper.new.getMangledIdentifier(self.jmethod, context) + "("
			result := result + CompilerHelperJava.new.ppComaSeparatedNodes(self.parameters, context)
			result := result + ")"
		end
	}
	
	
	//**** Begin **** Managing of the literal ****//
	aspect class Literal {
		method createBehaviorJava(context : KM2EcoreContext) : String from Expression is do
			result := "//TODO Literal" + self.toString
		end
	}
	
	aspect class StringLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			result := "\"" + self.~value.replace("\"", "\\\"") + "\""
		end
	}
	
	aspect class IntegerLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			result := self.~value.toString
		end
	}
	
	aspect class BooleanLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			result := self.~value.toString
		end
	}
	
	aspect class TypeLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			result := "//TODO TypeLiteral" + self.toString
			result := result + self.typeref.createBehaviorJava(context)
		end
	}
	
	aspect class VoidLiteral {
		method createBehaviorJava(context : KM2EcoreContext) : String from Literal is do
			result := "void" // the VoidLiteral is "normally" mapped to the void singleton
		end
	}
	//**** End **** Managing of the literal ****//
	
}