/* $Id: StructureCompiler.kmt,v 1.43 2008-08-21 15:56:56 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Cyril Faucher <cfaucher@irisa.fr>
 *			Francois Tanguy <ftanguy@irisa.fr>
 */

@usage "launcher"
@mainClass "kermeta::compiler::Main"
@mainOperation "main_inner"

@uri "http://www.kermeta.org/kermeta/compiler"
package kermeta::compiler;

require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "pass1/Pass1.kmt"
require "pass2/Pass2.kmt"
require "pass2/Preprocess.kmt"
require "KM2EcoreContext.kmt"
require "helper/kermeta/KermetaHelper.kmt"


using ecore
using kermeta::persistence
using kermeta::language::structure
using km2ecore
using kermeta::standard

class Main {	
	reference context : KM2EcoreContext [1..1]

    operation main_inner() : Void is do
    	
    	//var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/Attempt02.km"
		//var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/Attempt02.ecore"
		//var traceInput : String init ""//platform:/resource/org.kermeta.compiler.kmt/models/Attempt02.traceability"
		
		//var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/Attempt01.km"
		//var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/Attempt01.ecore"
		//var traceInput : String init ""//platform:/resource/org.kermeta.compiler.kmt/models/Attempt01.traceability"

/*
		var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/framework.km"
		var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/framework.ecore"
		var traceInput : String init ""
*/
		
		//var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/EDataType.main_merged.km"
		//var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/EDataType.main_merged.ecore"
		//var traceInput : String init ""
		
		//var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/common/TraceStructure.km"
		//var output : String init "platform:/resource/org.kermeta.compiler.kmt/src/kermeta/common/TraceStructure.ecore"
		//var traceInput : String init ""
		
/*
		var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/NewInteger.km"
		var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/NewInteger.ecore"
		var traceInput : String init ""
*/

/*
		var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/StructureCompiler.km"
		var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/StructureCompiler.ecore"
		var traceInput : String init ""
*/

/*
		var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/ExpressionEvaluation.km"
		var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/ExpressionEvaluation.ecore"
		var traceInput : String init ""
*/


		var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/compilertest.km"
		var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/compilertest.ecore"
		var traceInput : String init ""


/*
		var modelInput : String init "platform:/resource/org.kermeta.compiler.kmt/models/fsm.km"
		var output : String init "platform:/resource/org.kermeta.compiler.kmt/models/fsm.ecore"
		var traceInput : String init ""
*/

		main_mode(modelInput, traceInput, output, CompilingMode.behaviorJava)
	end
	
    operation main(modelInput : String, traceInput : String, output : String) : Void is do
    	main_mode(modelInput, traceInput, output, CompilingMode.behaviorJava)
    end
    
    operation main_km2ecore_onlyEcore(modelInput : String, traceInput : String, output : String) : Void is do
    	main_mode(modelInput, traceInput, output, CompilingMode.onlyEcore)
    end
    
    operation main_km2ecore_behaviorJava(modelInput : String, traceInput : String, output : String) : Void is do
    	main_mode(modelInput, traceInput, output, CompilingMode.behaviorJava)
    end
    	
	operation main_mode(modelInput : String, traceInput : String, output : String, mode : CompilingMode) : Void is do

		// Creating and initializing the context
		context := KM2EcoreContext.new
		context.initialize( modelInput, traceInput )
		context.mode := mode
		
		//The compilation of the structure is composed of 2 passes: the first is dedicated to the creation of all the Ecore elements
		// the second one consits to set the link between the created elements
		context.mu.applyPass1(context)
		
		if context.mode == CompilingMode.onlyEcore then
			context.mu.applyPass2(context)
		end
		stdio.writeln("KermetaCompiler - Pass 1 is finished")
		
		if context.mode == CompilingMode.behaviorKmt then
			context.mu.applyPass2BehaviorKmt(context)
		end
		
		if context.mode == CompilingMode.behaviorJava then
			context.mu.preprocess(context)
			stdio.writeln("KermetaCompiler - Pass 2 with the mode: " + context.mode.name)
			context.mu.applyPass2BehaviorJava(context)
		end
		
		stdio.writeln("KermetaCompiler - Pass 2 is finished")
		
		// Save the generated ecore
		context.ecoreOutputs.add(output)
   		var ecore_resource : Resource init context.outputRepository.createResource(output, "http://www.eclipse.org/emf/2002/Ecore")
		ecore_resource.instances.add(context.mu.ecoreModelElement)
		//stdio.writeln("context.mu.ecoreModelElement: " + context.mu.ecoreModelElement.toString)
		
		context.mu.entryPoints.each{ e |
			ecore_resource.instances.add(e)
		}
		context.mu.ecorePackages.each{ p |
			//stdio.writeln("I have found a package: " + p.toString)
			ecore_resource.instances.add(p)
		}
		
		stdio.writeln("Save the Ecore Model")
		ecore_resource.save()
		stdio.writeln("The Ecore Model has been saved")
		
		// Save the context to reuse it during the EMF Java generation
		
		context.save()
		
		stdio.writeln("Stats:\n\tconditional + loop: " + context.inc_condStack.toString()
			+ "\n\tfunction type: " + context.inc_ftSuffix.toString())
				
		stdio.writeln("Finish")
		
    end
    
    
    
    /*****************************************/
    /********** METHODS FOR TESTING **********/
    /*****************************************/
    
    operation main_mode2(modelInput : String, traceInput : String, output : String, mode : CompilingMode) : Void is do

		// Creating and initializing the context
		context := KM2EcoreContext.new
		context.initialize( modelInput, traceInput )
		context.mode := mode
		
		stdio.writeln(typeDefinitionToString(getTypeDefinitionByQualifiedName("kermeta::standard::Integer")))
		//stdio.writeln(typeDefinitionToString(getTypeDefinitionByQualifiedName("kermeta::standard::Integer")))
		stdio.writeln(typeDefinitionToString(getTypeDefinitionByQualifiedName("kermeta::standard::Boolean")))
		stdio.writeln(typeDefinitionToString(getTypeDefinitionByQualifiedName("kermeta::standard::Real")))
		stdio.writeln(typeDefinitionToString(getTypeDefinitionByQualifiedName("kermeta::standard::Character")))
		stdio.writeln(typeDefinitionToString(getTypeDefinitionByQualifiedName("kermeta::standard::String")))
		stdio.writeln(typeDefinitionToString(getTypeDefinitionByQualifiedName("kermeta::standard::Numeric")))
		
				
    end
    
    operation getTypeDefinitionByQualifiedName( qn : String ) : TypeDefinition is do
    	var td : TypeDefinition init TypeDefinition.new
		
		var td_tmp : TypeDefinition init context.mu.getTypeDefinitionByQualifiedName(qn)
		if not td_tmp.isVoid() then
			td := td_tmp
		end
		
		result := td
    end
    
    operation typeDefinitionToString( td : TypeDefinition ) : String is do
    	if (not td.isVoid()) and (td.isInstanceOf(ClassDefinition)) then
			var cd : ClassDefinition init td.asType(ClassDefinition)
			result := cd.name + " " + cd.isValueType().toString()
		end
    end
    
    
    
    
    operation main_mode3(modelInput : String, traceInput : String, output : String, mode : CompilingMode) : Void is do

		// Creating and initializing the context
		context := KM2EcoreContext.new
		context.initialize( modelInput, traceInput )
		
		context.mode := mode
		
		stdio.writeln("Input model: " + modelInput + "\n")
		
		context.mu.getAllPackages().each{ p |
			
			//stdio.writeln(p.asType(Package).name)
			
			p.asType(Package).eachOwnedElement{ cd |
				if cd.isInstanceOf(ClassDefinition) then
				cd.asType(ClassDefinition).eachOwnedElement{ op |
					if op.isInstanceOf(Operation) then
					
						if /*op.asType(Operation).name == "withAssign"
							or op.asType(Operation).name == "withoutAssign"
							or op.asType(Operation).name == "compareTo"
							or op.asType(Operation).name == "toString"
							or op.asType(Operation).name == "isSet"
							or op.asType(Operation).name == "containsKey"
							or op.asType(Operation).name == "checkInvariants"
							or op.asType(Operation).name == "count"
							or op.asType(Operation).name == "flatten"
							op.asType(Operation).name == "addAllTestCasesFrom"
							or op.asType(Operation).name == "count"
							or op.asType(Operation).name == "addAt"
							or op.asType(Operation).name == "createResource"
							or op.asType(Operation).name == "saveAndValidateWithEMF"
							or*/ op.asType(Operation).name == "addAt" then
					
							stdio.writeln("================= " + op.asType(Operation).qualifiedName + " =================")
							var javaSourceCode : String init op.createBehaviorJava(context)
							stdio.writeln(javaSourceCode)
						
						end
						
					end
					}
				end
			}
			
		}
				
		stdio.writeln("\nFinish, warning: this exec mode has not filtered the FunctionTypes.")
		
    end
   	
}