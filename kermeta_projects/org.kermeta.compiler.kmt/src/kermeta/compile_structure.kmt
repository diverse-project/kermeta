/* $Id: compile_structure.kmt,v 1.11 2008-01-30 16:42:11 cfaucher Exp $
 * Creation date: January 21, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: Francois Tanguy <ftanguy@irisa.fr>
 */

package kermeta::language::structure;
 
require kermeta
require "http://www.eclipse.org/emf/2002/Ecore"
require "containment_traversable.kmt"
require "trace_structure.kmt"
require "compile_builder.kmt"
require "compile_structure_common.kmt"
require "helper/CompilerHelper.kmt"
  
using kermeta::language::structure
using kermeta::language::behavior
using kermeta::standard
using kermeta::utils
using ecore
using compiler::helper::ecore
using compiler::helper::kermeta

 
aspect class ModelingUnit {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore package
		var ecoreAnnotation : EAnnotation init build()
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
		// Compile the owned elements
		self.eachOwnedElement{ p | p.compile(context) }
		// Getting the ecore packages
		self.packages.each{p|
			self.ecorePackages.add( p.asType(Package).ecoreModelElement )
		}
	end
}

aspect class Package {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore package
		var ecorePackage : EPackage init build()
		// Setting the container
		var p : Package init self.nestingPackage.asType(Package)
		//p ?= self.container()
		if ( p != void ) then
			p.ecoreModelElement.eSubpackages.add(ecorePackage)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecorePackage
		// Compile the owned elements
		self.eachOwnedElement{ cd | cd.compile(context) }
	end
}
  
aspect class PrimitiveType {
	method compile(context : Integer) : String from Type is do
		result := ""
		// Creating the associated ecore class
		var ecoreDataType : EDataType init build()
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(ecoreDataType)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreDataType
		// Compile the owned elements
		self.eachOwnedElement{ cd | cd.compile(context) }
	end 
}

aspect class Enumeration { 
	method compile(context : Integer) : String from TypeDefinition is do
		result := ""
		// Creating the associated ecore class
		var ecoreEnumeration : EEnum init build()
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(ecoreEnumeration)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreEnumeration
		// Compile the owned elements
		self.eachOwnedElement{ l | l.compile(context) }
		
	end
} 
  
aspect class EnumerationLiteral {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore class
		var ecoreEnumLiteral : EEnumLiteral init build()
		// Setting the container
		var e : Enumeration init self.~enumeration.asType(Enumeration)
		e.ecoreModelElement.eLiterals.add(ecoreEnumLiteral)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreEnumLiteral
	end
}  
  
aspect class ClassDefinition {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore class
		var ecoreClass : EClass init build()		
		// Setting the container
		var p : Package init self.container().asType(Package)
		p.ecoreModelElement.eClassifiers.add(ecoreClass)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreClass
		// Compile the owned elements
		self.eachOwnedElement{ o | o.compile(context) }
	end
	
} 
  
aspect class Property {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore class
		var ecoreStructuralFeature : EStructuralFeature init build()
		// Setting the container
		var c : ClassDefinition
		c ?= self.container()
		c.ecoreModelElement.eStructuralFeatures.add( ecoreStructuralFeature )
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreStructuralFeature
		// Compile the owned elements
		self.eachOwnedElement{ o | o.compile(context) }
	end 
}

aspect class Operation {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore class
		var ecoreOperation : EOperation init build()
		// Setting the container
		var c : ClassDefinition
		c ?= self.container()
		c.ecoreModelElement.eOperations.add(ecoreOperation)
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreOperation
		// Compile the owned elements
		self.eachOwnedElement{ o | o.compile(context) }
	end
}

aspect class Parameter {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore class
		var ecoreParameter : EParameter init build()
		// Setting the container
		var o : Operation init self.container().asType(Operation)
		o.ecoreModelElement.eParameters.add( ecoreParameter )
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreParameter
	end
}

aspect class Constraint {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore class
		var ecoreAnnotation : EAnnotation init build()
		// Setting the container
		var c : Object init self.container
		var p : Property init ObjectHelper.new.getPropertyValue(c, "ecoreModelElement")
		if ( p!= void ) then
			var ecoreModelElement : EModelElement init c.get(p).asType(EModelElement)
			ecoreModelElement.eAnnotations.add(ecoreAnnotation)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
	end
}

aspect class ObjectTypeVariable {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore class
		var ecoreTypeParameter : ETypeParameter init build()
		// Setting the container
		var container : Object init self.container
		if ( container.isInstanceOf(ClassDefinition) ) then		
			container.asType(ClassDefinition).ecoreModelElement.eTypeParameters.add(ecoreTypeParameter)
		else
			container.asType(Operation).ecoreModelElement.eTypeParameters.add(ecoreTypeParameter)
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreTypeParameter
	end
}

aspect class Tag {
	method compile(context : Integer) : String is do
		result := ""
		// Creating the associated ecore class
		var ecoreAnnotation : EAnnotation init build()
		// Setting the container
		var c : Object init self.container
		if ( c.isInstanceOf(ModelingUnit) ) then
			c.asType(ModelingUnit).entryPoints.add(ecoreAnnotation)
		else
			var p : Property init ObjectHelper.new.getPropertyValue(c, "ecoreModelElement")
			if ( p!= void ) then
				var ecoreModelElement : EModelElement init c.get(p).asType(EModelElement)
				ecoreModelElement.eAnnotations.add(ecoreAnnotation)
			end
		end
		// Setting the ecore proxy
		self.ecoreModelElement := ecoreAnnotation
	end
}