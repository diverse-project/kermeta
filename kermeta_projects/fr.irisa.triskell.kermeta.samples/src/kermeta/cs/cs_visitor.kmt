@mainClass "sample::Main"
@mainOperation "main"
package sample;
require "cs.ecore"
require kermeta
using kermeta::standard
using kermeta::persistence
using kermeta::interpreter
using kermeta::utils

class Main
{
	operation initialize(uri : String, mm_uri : String) : Set<Object> is do
		
		/* Initialize the EMF repository */
		var repository    : EMFRepository init EMFRepository.new
		/* Create an EMF Resource */
		var resource : EMFResource init repository.createResource(uri, mm_uri)
		/* Load the resource : this loads all the instances contained in the EMF model */
		resource.load()
		/* Get the loaded instances (a Set<Object>) */
		result := resource.instances
	end

	operation main() is do
		var csvisitor : CSVisitorHandler init CSVisitorHandler.new
		var instances : Set<Object> init self.initialize("Test_0.cs", "cs.ecore")
		csvisitor.initialize(instances)
		csvisitor.visitInstances()
	end
}

/**
 * I use here Set<Object> instead of Object because I cannot define a formal 
 * Parameter of type 'Object' (kermeta::standard::Object??)
 */
class BasicCSVisitor
{
	attribute root : cs::Root
	attribute template : cs::Template
	attribute decision : cs::Decision
	
	operation visitRoot(v : Set<Object>) : String is do
		result := " "
		root ?= v.one 
		
		result := "root : " + root.toString
		result.append("\n    { template list : ")
		result.append(iterate(root.template.iterator))
		result.append(" }\n")
	end
	
	operation visitDecision(v : Set<Object>) : String is do
		decision ?= v.one
		result := "decision : " + decision.toString
		result.append("\n   {  name : " + decision.name + " }" )
		result.append("\n   {  source : " + decision.source.toString + " }" )
		result.append("\n   {  targets : " + iterate(decision.target.iterator)+ "}\n ")
		
	end
	
	operation visitTemplate(v : Set<Object>) : String is do
		template ?= v.one
		result := "template : " + template.toString
		result.append("\n   { content :" + template.content + " }" )
		result.append("\n   { name :" + template.name + " }" )
		result.append("\n   { decision :" + iterate(template.decision.iterator) + " }" ) 
		result.append("\n   { referer : " + template.referer.toString + " }")
		result.append("\n   { root : " + template.root.toString + " }\n")
	end
	
	operation iterate<T>(pit : Iterator<T>) : String is do
		result := ""
		from var it : Iterator<T> init pit
		until it.isOff
		loop
			result.append(it.next.toString)
			if (it.hasNext)  then result.append(", ") end
		end
	end
	
	/** Iteration -> Iteration */
	operation visitIteration(v : Set<Object>) : String is do
		stdio.writeln("visit Iteration->Decision!")
		result := "iteration"
	end
}

/**
 * This is a manually written class to illustrate the loading of an EMF model in Kermeta, with
 * examples from cs.ecore metamodel.
 * This visitor does not respect the pattern visitor.
 * The pattern visitor could be implemented in the following steps :
 *     - allow dynamic code programming, in order to add an accept() abstract method to the meta-model's
 *       types.
 *     - [to complete]
*/
class CSVisitorHandler
{
	/**
	 *   Hashtable that contains the classes of the CS meta-model 
	 */
	attribute metaclasses : kermeta::utils::Hashtable<String, kermeta::reflection::Class>
	attribute instances : Set<Object>

	operation initialize(instances : Set<Object>) is do
		self.instances := instances
		self.metaclasses := kermeta::utils::Hashtable<String, kermeta::reflection::Class>.new
		self.setMetaClasses
	end

	/** 
	 * Loop in the instances of the loaded EMF resource and call a visitor on each
	 * of its elements.
	*/
	operation visitInstances() is do
		from var it : Iterator<Object> init instances.iterator
		until it.isOff
		loop
			self.accept(it.next)
		end
	end
	
	/**
	 * A pseudo accept method...
	 * 
	 */
	operation accept(instance : Object) is do
		// Get all the available types of Objects
		// 2 methods are possible :
		// 	   1/ We can create a reference to the Ecore loaded meta model in the resource that
		//        manages the EMF model (using xmlns:metamodel_prefix in the EMF model)
		//     2/ We can find all the available classes in the model by reflexive method (this method
		// we choose)
		
		// Loop in the list of existing meta classes
		
		from var it : Iterator<String> init metaclasses.keyIterator
		until it.isOff
		loop
			var claz_name : String init it.next
			var claz : kermeta::reflection::Class init metaclasses.get(claz_name)
			// FIXME : for inherited classes, this method is really bad (we should code
			// a kind of "isExactInstance")
			if (claz.isInstance(instance)) then
				//stdio.writeln(claz.classDefinition.name + " : " + instance.toString)
				// Wrap instance (FIXME : patch)
				var setinstance : Set<Object> init Set<Object>.new
				setinstance.add(instance)
				
				var str : String 
				// invoke "visit"+"claz.
				// TODO : find the pmore specialised class for the given object!
				str := self.invoke(claz.classDefinition.name, setinstance)
				stdio.writeln(str)
			end
		end
	end
	
	/**
	 * Invoke the visit method according to the type of the visitable Object
	*/
	operation invoke(cname : String, visitable : Object) : String is do
	
		var de : DynamicExpression init DynamicExpression.new
		de.initializeDefaults
		de.formalParameters.put("v", Set<Object>)
		de.parse("sample::VisitCS.new.visit"+cname+"(v)")
		
		var params : Hashtable<String, Object> init Hashtable<String, Object>.new
		params.put("v", visitable)
		result := de.execute(void, params).toString
		
	end
	
	/**
	 * Traverse the collection of instances and add any new meta class created in the hashtable
	 * <metaclasses>
	*/
	operation setMetaClasses() is do
		from var it : Iterator<Object> init instances.iterator
		until it.isOff
		loop
			var o : Object init it.next
			// Get the name of the class of o
			var qname : String init o.getMetaClass.classDefinition.qualifiedName
			// Is it in the hashtable?
			if (metaclasses.get(qname) == void) then
				metaclasses.put(qname, o.getMetaClass)
			end
		end
	end

}




/**
 * This class generates a generic Visitor for an EMF model according to its metamodel
 * Completely uncomplete. This class is just an idea. 
*/
class EMFVisitorGenerator 
{
	attribute mm_uri : String
	/** URI of the instance to visit */
	attribute uri : String
	attribute resource : kermeta::persistence::EMFResource
	/** The content of the generated code for EMF visitor */
	attribute visitorString : String

	//  todo : a constructor with resource already loaded?
	 
	/**
	 * Pseudo constructor. It does the following initialisations :
	 *  - the meta model uri (later we will try to find it in the information NS_URI contained in the model)
	 *  - the model uri
	 *  - the EMF resource (we also load it)
	 */
	operation initialize(p_uri : String, p_mm_uri : String) is do
		mm_uri := p_mm_uri
		uri    := p_uri
		/* Initialize the EMF repository */
		var repository    : EMFRepository init EMFRepository.new
		/* Create an EMF Resource */
		var resource : EMFResource init repository.createResource(uri, mm_uri)
		/* Load the resource : this loads all the instances contained in the EMF model */
		resource.load()
		/* Get the loaded instances (a Set<Object>) */
		var instances : Object init resource.instances

	end
	
	
	/**
	 * visit the instances loaded in the resource, by calling, for each of them, an accept method.
	*/
	operation createMainOperation() : String is do
	
		var prefix : String init "    "
		visitorString := ""
		visitorString.append(
			"\n" +
			"operation visitInstances(instances : Set<Object>) : Object is do")
			
		// the body
		visitorString.append(
			"\n" + 
			"from var it : Iterator<Object> init instances.iterator " +
			"until it.isOff" +
			"loop" +
			"    self.accept(it.next)" +
			"end" 
		)
			
		visitorString.append(
			"\nend")
	
	end
}













