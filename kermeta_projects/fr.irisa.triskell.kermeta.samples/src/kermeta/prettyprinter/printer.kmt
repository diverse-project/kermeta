//@mainClass "kermeta::utils::PrettyPrinter"
//@mainmethod "visit"
/*
 * Date : 
 * 
 * TODO : 
 *    - separate in two files the expression visitor and the structure visitor
 */

package kermeta::utils;
require kermeta
using kermeta::language::structure
using kermeta::language::behavior
using kermeta::standard


/**
 * Prints in its textual representation a parsed kermeta entity.
 * self.pretty printer only visits :
 *  - package,
 *	- class,
 *  - method,
 *  - attribute.
 *  Indeed, the tags (as MOF elements attached to any MOF entity) are only handled yet
 *  for these types.
 */
class BasicPrettyPrinter inherits 
	kermeta::language::structure::KMStructureVisitor<Integer, String>,
	kermeta::language::behavior::KMExpressionVisitor<Integer, String>
{
	/** self.is a print helper */
 	attribute pp : PrintHelper
 	attribute aset : set TypeVariable[0..*]
 	attribute indent : String
 	attribute typedef : Boolean
 	attribute current_pname : String
 	
 	operation initialize() is do
 		pp := PrintHelper.new
 		pp.initialize(self)
 		indent := ""
 		typedef := false
 		current_pname := ""
 	end
 	 
    /** visit a class and transcript it in the Kermeta Text format */
    method visitClass(node : Class, context : Integer) : String is do
    	// TODO : do not print qualified name if class belongs to current package
    	result := node.classDefinition.qualifiedName
		if (node.typeParamBinding.size > 0) then
			result.append("<" + self.visitTypeVariableBindingSet(node.typeParamBinding, context) + ">")
		end
    end
    
    method visitMultiplicityElement(node : MultiplicityElement, context : Integer) : String is do
	    result := "multi" 
    end
    
    /**
	 * Visit a property (attribute, reference, property)
	 */
	method visitOperation(node : Operation, context : Integer) : String is do
		result := ""
		result.append(indent)
		// result = ppTags(node.getFTag());
		if (node.superOperation != void) then result.append( "method ")
		else result.append("operation ")
		end
		// node name
		result.append( node.name)
		// type parameters of operation
		if (node.typeParameter.size() > 0) then
			result.append( "<")
			result.append( pp.ppTypeVariableDeclaration(node.typeParameter))
			result.append( ">")
		end
		// arguments
		result.append( "(")
		result.append( self.visitTypeParameters(node.ownedParameter, context))
		result.append( ")")
		if(node.type != void) then
			result.append( " : " + pp.ppTypeFromMultiplicityElement(node))
		end
	 
		if (node.superOperation != void) then
			result.append( " from " + node.superOperation.owningClass.qualifiedName )
		end
		if (node.raisedException.size > 0) then
			result.append( " raises " + self.visitSet(node.raisedException, context, ", "))
		end
		if (node.body != void) then
			result.append( " is\n")
			pushIndent()
			result.append(self.accept(node.body, context))
			popIndent()
		
		else 
			if (node.isAbstract) then result.append( " is abstract")

			else 
				result.append( " is do\n")
				pushIndent()
				result.append( indent + "//TODO: implement operation " + node.name + "\n") 
				popIndent()
				result.append( indent + "end")
			end
		end
	end
	
	method visitTag(node : Tag, context : Integer) : String is do 
	    result := "" 
	end
	
	/**
	 * Visit a property (attribute, reference, property)
	 */
	method visitProperty(node : Property, context : Integer) : String is do
		result := "" // weird behavior when we directly write : result := indent???
		result.append(indent)
		if (node.isDerived) then
			result.append( "property " )
		else 
			if (node.isComposite) then 
				result.append("attribute ")
			else 
				result.append("reference ")
			end
		end
			
		if (node.isReadOnly) then result.append("readonly ")
		end
		
		// print the attribute def
		result.append(indent)
		result.append(node.name + " : " + pp.ppTypeFromMultiplicityElement(node))
		
		if (node.opposite != void) then
			result.append("#" + node.opposite.name)
		end
		
		if (node.isDerived) then
			pushIndent()
			result.append("\n" + indent + "getter is " )
			if (node.getterbody != void) then
				//result.append(node.getterbody.acceptKMExpressionVisitor(self, node.getterbody))
			else
				result.append("do\n")
				pushIndent()
				result.append(indent + "//TODO: implement getter for derived property " + node.name + "\n") 
				popIndent()
				result.append(indent + "end")
			end
			
			if (not node.isReadOnly) then
				result.append("\n" + indent + "setter is ")
				if (node.getterbody != void) then 
					//result.append(node.getterbody.acceptKMExpressionVisitor(self, node.getterbody))
				else 
					result.append("do\n")
					pushIndent()
					result.append(indent + "//TODO: implement setter for derived property " + node.name + "\n")
					popIndent()
					result.append(indent + "end")
				end
			end
			popIndent()
		end
		result.append("\n")

	end
	
	method visitClassDefinition(node : ClassDefinition, context : Integer) : String from kermeta::language::structure::KMStructureVisitor is do
	    var a : String
		result := ""
	    if (node.isAbstract) then 
			result.append("abstract ")
		end
	    
		result.append("class " + node.qualifiedName)
		var s : Set<kermeta::reflection::TypeVariable>
		var it : Iterator<kermeta::reflection::TypeVariable>
		it := 	node.typeParameter.iterator
		
		
		if (node.typeParameter.size > 0) then
			//result.append("<"+pp.ppTypeVariableDeclaration(node.typeParameter)+">")
		end
		
		if (node.superType.size > 0) then
			result.append(" inherits ")
			// need a cast...S
			// FIXME : not sure self.works (not param types)
			result.append(self.visitSet(node.superType, context, ", "))
			//result.append(self.basicVisitSet(node.superType, context, ", ", ""))
		end
		
		// print the attributes
		result.append("\n"+self.indent+"{\n")
		self.pushIndent()
		result.append(self.visitFeatures(node.ownedAttributes, context))
		
		// print the operations
		result.append(self.visitFeatures(node.ownedOperation, context))
		self.popIndent()
		result.append("\n"+self.indent+"}")
	end
	
	method visitTypedElement(node : TypedElement, context : Integer) : String is do
		result := "[typed element]"
	end
	
	method visitTypeVariable(node : TypeVariable, context : Integer) : String is do
		result := "[type variable]"
	end
	
	method visitProductType(node : ProductType, context : Integer) : String is do
		result := "[product type]"
	end
	
	method visitFunctionType(node : FunctionType, context : Integer) : String is do
		result := "[function type]"
	end
	
	method visitType(node : Type, context : Integer) : String is do
		result := node.toString
	end
	
	method visitTypeVariableBinding(node : TypeVariableBinding, context : Integer) : String is do
		result := self.accept(node.type, context)
	end
	
	method visitPrimitiveType(node : PrimitiveType, context : Integer) : String is do
		result := "primitive type"
		if (typedef == true) then
			typedef := false
			result := "alias " + node.name + " : " + self.accept(node.instanceType, context) + ";"
			typedef := true
		else 
			result := node.getMetaClass.classDefinition.qualifiedName
		end
	end
	
	method visitNamedElement(node : NamedElement, context : Integer) : String is do
		result := "[named element]"
	end
	
	method visitSelfType(node : SelfType, context : Integer) : String is do
		result := "self"
	end
	
	method visitPackage(node : Package, context : Integer) : String is do
		result := "package " + node.qualifiedName // TODO : the ppIdentifier of the Java KM2KMTPrettyPrinter

		result.append( indent + "{\n")
		var old_cname : String init current_pname
		var current_pname : String init node.qualifiedName
		pushIndent()
		typedef := true
		if (node.ownedTypeDefinition.size > 0) then
			result.append( self.visitExpressionSet(node.ownedTypeDefinition, context, "\n"))
		end
		if (node.nestedPackage.size > 0) then
			result.append( self.visitExpressionSet(node.nestedPackage, context, "\n"))
		end
		popIndent()
		current_pname := old_cname
		result.append( indent + "}\n")
		
	end
	
	method visitTypeDefinition(node : TypeDefinition, context : Integer) : String is do
		result := node.name
	end
	
	method visitVoidType(node : VoidType, context : Integer) : String is do
		result := "void"
	end
	
	method visitDataType(node : DataType, context : Integer) : String is do
		result := "[DataType]"
	end
	
	method visitEnumeration(node : Enumeration, context : Integer) : String is do
		result := "[enum]"
	end
	
	method visitEnumerationLiteral(node : EnumerationLiteral, context : Integer) : String is do
		result := "[enum literal]"
	end
	
	method visitParameter(node : Parameter, context : Integer) : String is do
		result := "[param]"
    end
    
    
    /*
     *
     *  Here begins the inheritance of the KMExpressionVisitor methods
     *
     *
     */
     method visitTypeReference(node : kermeta::language::behavior::TypeReference, context : Integer) : String is do
    	result := pp.ppTypeFromMultiplicityElement(node)
     end
     
     method visitBlock(node : kermeta::language::behavior::Block, context : Integer) : String is do
     	result := ""
     	result.append(indent)
     	result.append("do\n")
		pushIndent()
		result.append(self.visitExpressionSet(node.statement, context, "\n"+indent))
		popIndent()
		from var it : Iterator<Rescue> init node.rescueBlock.iterator
		until it.isOff
		loop 
			var resc : Rescue
			resc := it.next
			result.append(indent + self.accept(resc, context) + "\n") 
		end
		result.append("\n" + indent + "end\n")
     end
    
	method visitAssignement(node : Assignement, context : Integer) : String is do
		var left : String init self.accept(node.target, context).toString
		var right : String init self.accept(node.value, context).toString
		var op : String
		if (node.isCast) then op := "?" else op :=":" end
		result := left + " " + op + "= " + right
	end     

	method visitCallResult(node  : CallResult, context : Integer) : String is do
		result := "result"
	end
	
	method visitCallFeature(node : CallFeature, context : Integer) : String is do
		result := ""
		if (node.target != void) then result.append( self.accept(node.target, context))
		else result.append( "self") end
		result.append( "." + node.name)
		// handle the special case where there is 1 parameter, and when This
		// parameter is a lambdaPostFix
		//	TODO : throw an exception if type is not a LambdaExpression
		if (node.parameters.size==1) then
			if (LambdaExpression.isInstance(node.parameters.one )) then
		   		result.append(self.visitExpressionSet(node.parameters, context, ", "))
			end
		// the classic case : a list of parameters
		else 
			if (node.parameters.size> 0) then
				result.append( "(" + self.visitExpressionSet(node.parameters, context, ", ")+ ")")
			end
		end
		
//		rescue kermeta::exceptions::EmptyCollection 
	end
	
	method visitCallSuperOperation(node : CallSuperOperation, context : Integer) : String is do
		result := "super("
		result.append( self.visitExpressionSet(node.parameters, context, ", "))
		result.append( ")")
	end
	
	method visitCallVariable(node : CallVariable, context : Integer) : String is do
		result := node.name
		if (node.parameters.size> 0) then
			result.append("(" + visitExpressionSet(node.parameters, context, ", ") + ")")
		end
	end

	method visitConditionnal(node : Conditionnal, context : Integer) : String is do 
		result := ""
		result.append("if " + self.accept(node.condition, context) + " then\n")
		pushIndent()
		if (node.thenBody != void) then
			result.append(self.accept(node.thenBody, context) + "\n")
		end
		popIndent()
		if (node.elseBody != void) then
			result.append( indent + "else\n")
			pushIndent()
			result.append(self.accept(node.elseBody, context) + "\n")
			popIndent()
		end
		result.append(indent + "end")
	end
	
	method visitEmptyExpression(node : EmptyExpression, context : Integer) : String is do
		result := " "
	end
	method visitIntegerLiteral(node : IntegerLiteral, context : Integer) : String is do
		result := node.value.toString
	end

	method visitStringLiteral(node : StringLiteral, context : Integer) : String is do
		result := "\""+node.value+"\""
	end
	
	method visitBooleanLiteral(node : BooleanLiteral, context : Integer) : String is do
		result := node.value.toString
	end
	
	method visitTypeLiteral(node : TypeLiteral, context : Integer) : String is do
		result := self.accept(node.typeref, context) 
	end
	
	method visitVoidLiteral(node : VoidLiteral, context : Integer) : String is do 
		result := "void"
	end
	
	method visitLoop(node : Loop, context : Integer) : String is do
		result := "from "
		result.append( self.accept(node.initiatization, context) + "\n")
		result.append( indent + "until " + self.accept(node.stopCondition, context) + "\n")
		result.append( indent +"loop\n") 
		pushIndent()
		result.append( self.accept(node.body, context))
		popIndent()
		result.append( indent +"end")
	end
	
	method visitSelfExpression(node : SelfExpression, context : Integer) : String is do 
		result := "self"
	end
	
	method visitVariableDecl(node : VariableDecl, context : Integer) : String is do 
		result := "var" + node.identifier + " : " + self.accept(node.type, context)
		
		if (node.initialization != void) then
			result.append(" init " + self.accept(node.initialization, context))
		end
	end 
	
	method visitRaise(node : Raise, context : Integer) : String is do
		result := "raise"
	end
	
	method visitRescue(node : Rescue, context : Integer) : String is do 
		result := "rescue"
	end
	
	method visitJavaStaticCall(node : JavaStaticCall, context : Integer) : String is do 
		result := "[extern]"
	end
	
	method visitLambdaExpression(node : LambdaExpression, context : Integer) : String is do 
		result := "{"
		result.append(self.visitExpressionSet(node.parameters, context, ", "))
		result.append(" | ")
		pushIndent()
		result.append(self.accept(node.body, context))
		popIndent()
		result.append("}")
	end
	
	method visitLambdaParameter(node : LambdaParameter, context : Integer) : String is do
		result := node.name 
		if (node.type != void) then
			result.append(" : " + self.accept(node.type, context))
		end
    end

    /**
     * Visit a set that contains visitable elements
     * @param pset : the set to visit
     * @param context : the context attached to self.visitor
     * @param Indent : the indentation (can be an empty string)
    */
    operation visitSet
    	(pset : Set<kermeta::reflection::Type>, context : Integer, sep : String) : String is do
//    	result := basicVisitSet(pset, context, ", ", "")	
    	result := ""
		from var it : Iterator<kermeta::reflection::Type> init pset.iterator
		until it.isOff
		loop
			var next : kermeta::reflection::Type init it.next
			var cnext : Type
			cnext ?= next
			// TODO : a real visit..
			result.append(cnext.toString)
//			result.append(self.accept(cnext, context))
			if (it.hasNext) then
				result.append(", ")
			end
		end
    end
    
    /**
     * Visit a set of Expression.
     * (note : we could create a generic method for visiting Sets, but )
     */
     operation visitGenericSet<ConcreteType, AbstractType>
    	(typedElement : ConcreteType, pset : Set<AbstractType>, context : Integer, sep : String) : String is do
    	result := ""
		from var it : Iterator<AbstractType> init pset.iterator
		until it.isOff
		loop
			var next : AbstractType init it.next
			var cnext : ConcreteType
			//cnext ?= next
			result.append(self.accept(cnext, context))
			if (it.hasNext) then
				result.append(sep)
			end
		end
    end
    
    /**
     * Visit a set of Expression.
     * (note : we could create a generic method for visiting Sets, but )
     */
     operation visitExpressionSet<BExpression>
    	(pset : Set<BExpression>, context : Integer, sep : String) : String is do
    	result := ""
    	// FIXME : quite dirty that...
    	if (sep.equals("\n"+indent)) then result.append(indent) end
		from var it : Iterator<BExpression> init pset.iterator
		until it.isOff
		loop
			var next : BExpression init it.next
			result.append(self.accept(next, context))
			if (it.hasNext) then
				result.append(sep) 
			end
		end
    end

    
    /**
     * Visit the type parameters.
     * TODO : create a generic operation, and find a way to get the concrete implementation
     * of the element in the set that we want to pretty print
     */
    operation visitTypeParameters
    	(pset : Set<kermeta::reflection::Parameter>, context : Integer) : String is do
    	result := ""
		from var it : Iterator<kermeta::reflection::Parameter> init pset.iterator
		until it.isOff
		loop
			var next : Parameter
			next ?= it.next
			// TODO : a real visit..
			result.append(next.name)
//			result.append(self.accept(cnext, context))
			if (it.hasNext) then
				result.append(", ")
			end
		end
    end
 
 
     /**
     * Visit the type parameters.
     * TODO : create a generic operation, and find a way to get the concrete implementation
     * of the element in the set that we want to pretty print
     */
    operation visitTypeVariableBindingSet
    	(pset : Set<kermeta::reflection::TypeVariableBinding>, context : Integer) : String is do
    	result := ""
		from var it : Iterator<kermeta::reflection::TypeVariableBinding> init pset.iterator
		until it.isOff
		loop
			var next : TypeVariableBinding
			next ?= it.next
			result.append(self.accept(next, context))
			if (it.hasNext) then
				result.append(", ")
			end
		end
    end
   
      /**
     * Visit a set that contains visitable elements
     * @param pset : the set to visit
     * @param context : the context attached to self.visitor
     * @param Indent : the indentation (can be an empty string)
     * @param sep : the separator for the printed set
    */
    operation basicVisitSet<T>(
    	pset : Set<T>, 
    	context : Integer,
    	sep : String,
    	prefix : String) : String is do
    	
    	result := ""
		from var it : Iterator<T> init pset.iterator
		until it.isOff
		loop
			var next : T init it.next
			result.append(next.toString) 
			if (it.hasNext) then
				result.append(sep)
			end
		end
    end
    
    /**
     * Visit a set that contains elements that 
     * : kermeta::language::structure::KMStructureVisitable
     */
    operation visitFeatures<T : kermeta::language::structure::KMStructureVisitable>(pset : Set<T>,	context : Integer) : String is do
   	// basicVisitSet()
    	result := ""
		from var it : Iterator<T> init pset.iterator
		until it.isOff
		loop
			var next : T init it.next
			result.append(next.acceptKMStructureVisitor(self, context ))
			
		end
    end
    
	/**
	 * Calls acceptKMExpressionVisitor oR acceptKMStructureVisitor according to the 
	 * type of parsed node
	 */
    operation accept(node : Object, context : Integer) : String is do
    	// structurevisitable node
		var snode : KMStructureVisitable init void
		var enode : KMExpressionVisitable init void
		
		var node_qname : String init node.getMetaClass.classDefinition.qualifiedName
		var node_name : String init node.getMetaClass.classDefinition.name
		var diff_size : Integer init node_qname.size-node_name.size
		//stdio.writeln(node_name+"->"+node_qname)
		// FIXME : ok until isInstance "works"
		if (node_qname.substring(0, diff_size).equals("kermeta::language::behavior::")) then
			enode ?= node
			result := enode.acceptKMExpressionVisitor(self, context)
		else 
			if (node_qname.substring(0, diff_size).equals("kermeta::language::structure::")) then
				snode := node
				result:= snode.acceptKMStructureVisitor(self, context)
			else
				stdio.writeln("ouuup")
				result := "[not found!]"
			end
		end
		
//		if (node_name.
  // isInstance does not work yet
/*		if (claz.isInstance(node)) then

			enode ?= node
			enode.acceptKMExpressionVisitor(self, context)
		else
			snode := node
			snode.acceptKMStructureVisitor(self, context)
		end
*/		
    end
    

    operation pushIndent() is do
    	self.indent.append("    ")
    end
    
    operation popIndent() is do
    	if (indent != void and indent.size>0) then
	    	indent := indent.substring(0, indent.size-4)
	    end
    end
    
    
}

/**
 * Provides a set of methods that help the pretty printer
 */
class PrintHelper 
{

	/** The current package name */ 
	attribute current_pname : String
	reference pprinter : BasicPrettyPrinter
	
	operation initialize(p : BasicPrettyPrinter) is do
		pprinter := p
	end
	
	operation ppTypeName(qname : String, name : String) : String is do
		result := ""
		if (qname.equals(current_pname + "::" + name)) then
			 result := result + name
		
		else
			result := "grezlzieuds"
		end
	end
	
	/** Pretty prints a set of TypeVariables, separated by a comma */
	operation ppTypeVariableDeclaration(tparams : Set<kermeta::reflection::TypeVariable>) : String is do
		result := ""
		var it : Iterator<kermeta::reflection::TypeVariable> init tparams.iterator
		from var it : Iterator<kermeta::reflection::TypeVariable> init tparams.iterator
		until it.isOff
		loop
			var next : TypeVariable 
			next ?= it.next
			result.append(next.name)
			if (it.hasNext) then
				result.append(", ")
			end
		end
	end
	
	operation ppIdentifier(name : String) : String is do
		result := ""
	end
	
	operation ppTypeFromMultiplicityElement(elem : kermeta::reflection::MultiplicityElement) : String is do
	 
		result := ""
		if (elem.upper != 1) then
			if (elem.isOrdered) then
				if (not elem.isUnique) then result.append("seq ") end
			
			else 
				if (elem.isUnique) then result.append("set ")
				else result.append("bag ") end
			end
		end
		
		// need to cast into concrete type
		var ctype : Type
		ctype ?= elem.type

		result.append( pprinter.visitType(ctype, 0))
		
		if (elem.lower != 0 or elem.upper  != 1) then
			result.append( "[" + elem.lower.toString + "..")
			if (elem.upper<0) then result.append("*") else result.append(elem.upper.toString) end
			result.append( "]")
		end
	
	end
	
	operation ppComaSeparatedNode<T>(pset : Set<T>, context : Integer) : String is do
		result := ""
		from var it : Iterator<T> init pset.iterator
		until it.isOff
		loop
			var next : T init it.next
			//result.append( self.accept(next, context) )
		end
	end

}

