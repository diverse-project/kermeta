/**
 * Automata
 *
 * The following code defines a simple meta model for automata (eq. FSM), and will prepare the following work :
 *   - implementation of the algorithm of determinisation
 *	 - implementation of the algorithm of minimisation
 *   - how to "compose" and/or chain those two transformation 
 *
 
 	Questions : 
 	
 	- should the determinist-property appear in the meta model? (as a derived property for example)
 	
 	- 
  
 *
 *
 */
package automaton;

require kermeta
require "ecore.kmt" 
using kermeta::standard
using kermeta::persistence 
/*********************************
 * SIMPLE STATE MACHINE METAMODEL
 *********************************/
 
/**
 * A Finite Automaton : 
 *   A = ( E, S, T, s0, F ) where :
 *    E -> The alphabet (labels of the transition
 *    S -> A finite set of the available states
 *    T -> A set of transitions rules ( si (t) sj )
 *	  s0 -> The initial state
 *    F ->  a subset of S called the set of final states
 
 * Question to clarify :
 *   - should we allow empty word as a transition label?
*/
class FiniteAutomaton
{
	attribute stateSet : State[0..*]
	reference initialState : State 
	reference finalStateSet : State[0..*]
	attribute transitionSet : Transition[0..*]

	property readonly alphabet : Set<String>
		getter is do
			result := self.seqToSet( self.transitionSet.collect { e | e.letter } )
		end

	operation conformityChecker() : Boolean is do
		result := transitionSet.detect { t | 
			stdio.writeln("transitions : " + t.source.toString + ", " + t.target.toString)
			not (stateSet.contains(t.source) and stateSet.contains(t.target))}==void
	end
	
	/** Initialize a new automaton from an existing one 
	 *  param :
	 *    initState : the initial state
	 *    initComb
	 */
	operation initialize(p_state : State, isInitComb : Boolean) is do
		var initState : State init p_state.copy
		stateSet.add(initState)
		initialState := initState 
		if (isInitComb == true) then initialState.combination := Set<State>.new end 
	end
	
	operation dotprint() is do
       stdio.writeln("digraph finite_state_machine {")
       stdio.writeln("  rankdir=LR;")
       stdio.writeln("  node [shape = doublecircle];")
       finalStateSet.each{ s | stdio.write("  " + s.name + " ")}
       stdio.writeln(";")
       stdio.writeln("  node [shape = circle];")
       transitionSet.each{ t |
           stdio.writeln(    "  " + t.source.name + " -> " + t.target.name +
                           " [ label=\"" + t.letter + "\" ];")
       }
       stdio.writeln("}")
	end
	
	/** Quick transformation of a Set into a Sequence */
	operation seqToSet<G>( iseq : Sequence<G> ) : Set<G> is do
    	result := Set<G>.new
    	iseq.each { n | if n != void and not result.contains(n) then result.add(n) end	}
    end
    
}

class State
{
	reference combination : Set<State>
	reference name : String
	reference arriving : Transition[0..*]#target
	reference going : Transition[0..*]#source
	
	/** Create a new state from self state. */
	method copy() : State is do
		result := State.new
		result.name := String.clone(name)
		result.combination := Set<State>.new
	end
}

class Transition
{
	reference source : State#going
	reference target : State#arriving 
	reference letter : String
}


/** A pair of States, as a equivalence relation */
class Pair
{
	reference left : State
	reference right : State	
}

/** 
 * A set of helper methods to ease the determinisation/minimization
 */
class AutomatonHelper
{	
	operation seqToSet<G>( iseq : Sequence<G> ) : Set<G> is do
    	result := Set<G>.new
    	iseq.each { n | if n != void and not result.contains(n) then result.add(n) end	}
    end
    
    operation join( str_seq : Collection<String>) : String is do
    	result := ""
    	str_seq.each { str | result.append(str) }
    end
    
    operation createPair(p : State, q : State) : Pair is do
    	result := Pair.new
    	result.left := p.copy
    	result.right := q.copy
    end
    
    operation createTransition( s : State, t : State, l : String) : Transition is do
    	result := Transition.new
		result.source := s
		result.target := t 
		result.letter := l
	end
	
	/** 
	 * Serialization helpers
	 */  
    operation saveEMFAutomaton(repository : EMFRepository, a : FiniteAutomaton, uri : String, mmuri : String) : FiniteAutomaton is do
		if a.conformityChecker == true then 
	    	var resource : EMFResource init repository.createResource(uri , mmuri)
	    	resource.instances.add(a)
	    	//a.stateSet.each { z | resource.instances.add(z)}
	    	resource.save()
	    else
	    	stdio.writeln("I'm sorry, I'm afraid that your automaton is not valid; please check the following rules : ")
	    	stdio.writeln(" - Do the transitions source and target states belong to the set of states of the automaton?")
	    end
    end
    
     operation loadEMFAutomaton(repository : EMFRepository, uri : String, mmuri : String) : FiniteAutomaton is do
    	var resource : EMFResource init repository.createResource(uri , mmuri)
    	resource.instances
    	resource.load
    	var instances : Set<Object> init resource.instances
    	result ?= instances.detect { e | FiniteAutomaton.isInstance(e)}
    end
    
    /**
     * Interactive commands
     */
    operation ask_dotprint() is do
    	ask_emfmodel("Entrez un modele EMF de l'automate à 'dot-printer' : ").dotprint
    end
    
    operation ask_emfmodel(prompt : String) : FiniteAutomaton is do
    	var file : String init stdio.read(prompt)
    	var r : EMFRepository init EMFRepository.new
    	result := loadEMFAutomaton(r, file, "../metamodels/automata.ecore")
    end
	 
}
 





