/**
 * Automata
 *
 * The following code defines a simple meta model for automata (eq. FSM), and will prepare the following work :
 *   - implementation of the algorithm of determinisation
 *	 - implementation of the algorithm of minimisation
 *   - how to "compose" and/or chain those two transformation 
 * Questions : 
 * 	- should the determinist-property appear in the meta model? (as a derived property for example)	
 *
 *
 */
@mainClass "automaton::AutomatonHelper"
@mainOperation "run_demo"

package automaton;

require kermeta

using kermeta::standard
using kermeta::persistence 
/*********************************
 * SIMPLE STATE MACHINE METAMODEL
 *********************************/
 
/**
 * A Finite Automaton : 
 *   A = ( E, S, T, s0, F ) where :
 *    E -> The alphabet (labels of the transition
 *    S -> A finite set of the available states
 *    T -> A set of transitions rules ( si (t) sj )
 *	  s0 -> The initial state
 *    F ->  a subset of S called the set of final states
 
 * Question to clarify :
 *   - should we allow empty word as a transition label?
*/
class FiniteAutomaton
{
	attribute stateSet : State[0..*]
	reference initialState : State 
	reference finalStateSet : State[0..*]
	attribute transitionSet : Transition[0..*]

	property readonly alphabet : Set<String>
		getter is do
			result := self.seqToSet( self.transitionSet.collect { e | e.letter } )
		end
		
	/** Transient references */
	reference currentState : State  
	reference read_word : String // the output word after a step

	/** Initialize a new automaton from an existing one 
	 *  param :
	 *    initState : the initial state
	 *    initComb
	 */
	operation initialize(p_state : State, isInitComb : Boolean) is do
		var initState : State init p_state.copy
		stateSet.add(initState)
		initialState := initState 
		if (isInitComb == true) then initialState.combination := Set<State>.new end 
	end
	

	/** Quick transformation of a Set into a Sequence */
	operation seqToSet<G>( iseq : Sequence<G> ) : Set<G> is do
    	result := Set<G>.new
    	iseq.each { n | if n != void and not result.contains(n) then result.add(n) end	}
    end

	/** Run operation that execute the FiniteAutomaton*/	
	operation run() : Void is do  
		// reset if there is no current state
		if currentState == void then reset end
		read_word := ""
		
		stdio.writeln("Initial state : " + currentState.name)
		from var str : String init "init"
		until finalStateSet.contains(currentState) and currentState.outgoingTransitions.size==0
		loop
			stdio.writeln("\n>> read word : " + currentState.step)
			stdio.write(">> step to next state : " + currentState.name)
		end
		stdio.writeln("\nFinal state " + currentState.name + " is reached.\n")
	end
	
	operation reset() : Void is do
		if (initialState == void) then
			raise NoInitialStateException.new
		end
		currentState := initialState
	end

}

class State
{
	reference combination : Set<State>
	reference name : String
	reference incomingTransitions : Transition[0..*]#target
	reference outgoingTransitions : Transition[0..*]#source
	
	/** Create a new state from self state. */
	method copy() : State is do
		result := State.new
		result.name := String.clone(name)
		result.combination := Set<State>.new
	end
	
	
	/** Operation that define a behaviour on the FiniteAutomaton */
	operation step() : String is do
		var owner : FiniteAutomaton 
		owner ?= self.container
		// Check if there is a valid transition
		var validLetters : Collection<String> init outgoingTransitions.collect { e | e.letter }
		if validLetters.empty then raise NoTransition.new end
		automated_step(validLetters)
		var theletter : String init validLetters.one
		// var theletter : String init interactive_step(validLetters)

		// Fire the transition
		var t : Transition init outgoingTransitions.detect { t | t.letter == theletter }
		t.fire
		result := owner.read_word + theletter
		owner.read_word := result
	end
	
	operation automated_step(validLetters :Collection<String>) : String is do
		if validLetters.size > 1 then 
			var str : String init AutomatonHelper.new.join_with(outgoingTransitions.collect { e | e.source.name+"-"+e.letter+"-"+e.target.name }, ", ")
			stdio.writeln("\nMany transitions are available ("+ str +")." + "We choose : " + validLetters.one)
		end
		result := validLetters.one
	end
	
	operation interactive_step(validLetters : Collection<String>) : String is do
	
		if validLetters.size > 1 then
			stdio.writeln("More than one valid transition\n")
			var ol : String init stdio.read("\nPlease choose a transition between : {" + AutomatonHelper.new.join_with(validLetters, ", ")+"}" )
			var t_set : Sequence<Transition> init outgoingTransitions.select { t | t.letter == ol } 
			if not validLetters.contains(ol) then 
				stdio.writeln("No such letter in the available transitions")
				raise NoTransition.new 
			end
			if (t_set.size > 1) then 
				stdio.writeln("\n*****************************************************")
				stdio.writeln("\nThe letter you chose lead to an undeterminable state.")
				stdio.writeln("Please determinize your automaton first.")
				stdio.writeln("\n*****************************************************")
				raise NonDeterminism.new 
			end
			result := ol
		else
			result := validLetters.one
		end
	end
/*	
	operation rescue_non_det() : Boolean is do
		// rescue?
		rescue ( e : NonDeterminism )
			var answer : String init stdio.read("NonDeterminismException : do you want to determinize the automaton ? (yes/no)")
			if (answer == "yes") then
				result := true
				
			end
		result := false
	end
*/
}

class Transition
{
	reference source : State#outgoingTransitions
	reference target : State#incomingTransitions 
	reference letter : String
	
	/** Fired transition modifies the output word and updates the currentState*/
	operation fire() is do
		var owner : FiniteAutomaton
		owner ?= source.container
		owner.currentState := target
	end
}


/** A pair of States, as a equivalence relation */
class Pair
{
	reference left : State
	reference right : State	
}

 
// Exceptions
abstract class AutomatonException {}
class NonDeterminism inherits AutomatonException {}
class NoTransition inherits AutomatonException {}
class NoInitialStateException inherits AutomatonException{}



/** 
 * A set of helper methods to ease the determinisation/minimization
 */
class AutomatonHelper
{	
	operation seqToSet<G>( iseq : Sequence<G> ) : Set<G> is do
    	result := Set<G>.new
    	iseq.each { n | if n != void and not result.contains(n) then result.add(n) end	}
    end
    
    operation join( str_seq : Collection<String>) : String is do
    	result := ""
    	str_seq.each { str | result.append(str) }
    end
    
    operation join_with( str_seq : Collection<String>, sep : String) : String is do
    	result := ""
    	str_seq.each { str | result.append(str + sep) }
    	result :=  result.substring(0, result.size-sep.size)
    end
    
    operation createPair(p : State, q : State) : Pair is do
    	result := Pair.new
    	result.left := p.copy
    	result.right := q.copy
    end
    
    operation createTransition( s : State, t : State, l : String) : Transition is do
    	result := Transition.new
		result.source := s
		result.target := t 
		result.letter := l
	end
	
	/** 
	 * Serialization helpers
	 */  
    operation saveEMFAutomaton(repository : EMFRepository, a : FiniteAutomaton, uri : String, mmuri : String) : FiniteAutomaton is do
		if AutomatonHelper.new.conformityChecker(a) == true then 
	    	var resource : EMFResource 
		    resource ?= repository.createResource(uri , mmuri)
	    	resource.instances.add(a)
	    	//a.stateSet.each { z | resource.instances.add(z)}
	    	resource.save()
	    else
	    	stdio.writeln("I'm sorry, I'm afraid that your automaton is not valid; please check the following rules : ")
	    	stdio.writeln(" - Do the transitions source and target states belong to the set of states of the automaton?")
	    end
    end
    
     operation loadEMFAutomaton(repository : EMFRepository, uri : String, mmuri : String) : FiniteAutomaton is do
    	var resource : EMFResource 
		resource ?= repository.createResource(uri , mmuri)
    	resource.load
    	var instances : Set<Object> init resource.instances
    	result ?= instances.detect { e | FiniteAutomaton.isInstance(e)}
    end
    
    /** Print in dot format the given automaton */
    operation dotprint(fsm : FiniteAutomaton) is do
       stdio.writeln("\ndigraph finite_state_machine {")
       stdio.writeln("  rankdir=LR;")
       stdio.writeln("  node [shape = doublecircle];")
       fsm.finalStateSet.each{ s | stdio.write("  " + s.name + " ")}
       stdio.writeln(";")
       stdio.writeln("  node [shape = circle];")
       fsm.transitionSet.each{ t |
           stdio.writeln(    "  " + t.source.name + " -> " + t.target.name +
                           " [ label=\"" + t.letter + "\" ];")
       }
       stdio.writeln("}")
	end
	
    
    /**
     * Interactive commands
     */
    operation ask_dotprint() is do
    	dotprint(ask_emfmodel("Entrez un modele EMF de l'automate à 'dot-printer' : "))
    end
    
    operation ask_emfmodel(prompt : String) : FiniteAutomaton is do
    	var file : String init stdio.read(prompt)
    	stdio.writeln("\n"+file)
    	var r : EMFRepository init EMFRepository.new
    	result := loadEMFAutomaton(r, file, "../metamodels/automata.ecore")
    end
    
    /** Operation that tries to check the validity of the given automaton 
     *  (the states referenced in all the transitions must appear in the stateSet of the
     *  given automaton)
    */
    operation conformityChecker(fsm : FiniteAutomaton) : Boolean is do
		result := fsm.transitionSet.detect { t |  
			stdio.writeln("transitions : " + t.source.toString + ", " + t.target.toString)
			not (fsm.stateSet.contains(t.source) and fsm.stateSet.contains(t.target))}==void
	end
	
	/** Operation for Workshop demo */
	operation run_demo() : FiniteAutomaton is do
/*    	var file : String init "../models/fsm.demo.1.xmi"*/
		var file : String init stdio.read("Give me a model please :")
    	stdio.writeln("Reading the following EMF Model : "+file)
    	var r : EMFRepository init EMFRepository.new
    	result := loadEMFAutomaton(r, file, "../metamodels/automata.ecore")
    	result.run()
    end
	 
}

