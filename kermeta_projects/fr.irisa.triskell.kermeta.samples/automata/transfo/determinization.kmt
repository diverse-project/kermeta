@mainClass "automaton::Determinization"
@mainOperation "main"
    

package automaton;

 
require kermeta 

require "../metamodels/automata.kmt"
//require "../models/samples.kmt"
using kermeta::standard
using automaton::samples
using kermeta::persistence
 
class Determinization 
{
	reference processed_states : Set<State>
	reference repository : EMFRepository
	reference helper : AutomatonHelper
	
    operation main() : Void is do 
    
    	// Input automaton (non-determinist)
    	//var input : FiniteAutomaton init Sampler.new.createSample2()
    	var input : FiniteAutomaton
		var output : FiniteAutomaton init FiniteAutomaton.new

		// Initialize attributes
		processed_states := Set<State>.new
		repository := EMFRepository.new
		helper := AutomatonHelper.new 
		 
		input :=  helper.loadEMFAutomaton(repository, "../models/sample1.automaton", "../metamodels/automata.ecore")

	   	output.initialize(input.initialState, true)

    	determinize(input, output, output.initialState)

	    // Define the final states : q' intersection initial Final states is void
	    output.finalStateSet.addAll
	    ( 
		output.seqToSet( output.stateSet.select { 
		e | e.combination.detect{ a | 
		    input.finalStateSet.contains(a) } != void  } )
		)
		
    	// We don't need combination to be stored
    	output.stateSet.each { e | e.combination.clear } 

    	// Save the automaton
    	helper.saveEMFAutomaton(repository, output, "../models/sample1det.xmi", "../metamodels/automata.ecore")
    	
    end
    
    operation determinize(input : FiniteAutomaton, output : FiniteAutomaton, output_state : State) is do
    
    	if not processed_states.contains(output_state) then
   			processed_states.add(output_state)
	    	// For each letter of the alphabet
			from var lit : Iterator<String> init input.alphabet.iterator
    		until lit.isOff
    		loop
    			// There exists a state x of q' (where q' is a P(Q))
    			// and state-y from Q so that : x --l-->  y belongs to input.transitionSet
    			var nextl : String init lit.next
		    	var newq : State init State.new
				newq.combination := input.seqToSet(
    				input.transitionSet.select { e | e.letter.equals(nextl) }.
    				select { a | output_state.name == a.source.name or output_state.combination.detect { i | i.name==a.source.name } != void }.
    				collect { b | b.target }  
    				)
    				
    			newq.name := join(newq.combination.collect{ a | a.name })

    			// Add the state to the output automaton if we found one
    			if (newq.name.size > 0) then  
					// Add the new state
					if (output.stateSet.detect { e | newq.name == e.name } == void) then  
						output.stateSet.add(newq)
					else
						newq := output.stateSet.detect { e | e.name == newq.name }
					end
					// Add the new transition
					var newt : Transition init Transition.new
					newt.initialize(output_state, newq, nextl) 
					output.transitionSet.add(newt)
					self.determinize(input, output, newq)
	    		end
			end		// End of Loop
    	end
    end
   
    operation join( str_seq : Collection<String>) : String is do
    	result := ""
		from var it : Iterator<String> init str_seq.iterator
		until it.isOff
		loop
			result.append(it.next)
		end
    end
    
}
/*
Algorithme: on part d'un automate non-déterministe . On construit l'automate déterministe ayant

   1. comme états les parties de Q
   2. comme état initial I
   3. comme transitions: (U,a,V) si V est l'ensemble des états atteignables depuis U par une transition a
   4. comme états terminaux les états dont la combinaison contient l'état final de l'automate de départ
   */