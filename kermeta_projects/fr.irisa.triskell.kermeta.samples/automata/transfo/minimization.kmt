@mainClass "automaton::Minimization"
@mainOperation "main"

 
package automaton;

require kermeta
require "../metamodels/automata.kmt"
require "../models/samples.kmt"
using automaton::samples
using automaton
using kermeta::standard

class Minimization
{
	reference timeout : Integer
	reference equivalent_pairs : set Pair[0..*]  // The initial pairSet of the equivalence relation { F \ Q }² ^ F²
	reference all_input_pairs : set Pair[0..*]       // The QxQ set of possible pairs, where Q is the stateSet
	reference helper : AutomatonHelper
	
    operation main() : Void is do 
    
    	// Input automaton (non-determinist)
    	var input : FiniteAutomaton
		var output : FiniteAutomaton init FiniteAutomaton.new
		var output_path : String init "../models/sampleM1min.automaton"
		
		// Initialize attributes
	   	helper := AutomatonHelper.new
		//input := Sampler.new.createSampleM1()
		
		input := helper.ask_emfmodel("Enter the EMF model of the automaton to minimize :")
		output_path := stdio.read("Enter the output file where to store the minimal automaton :")

	   	// Initialize equivalent_pairs and possible all_input_pairs
	   	input.stateSet.each { p | input.stateSet.each { b | 
	   		// Check : (p,q) is in Eo, i.e either both are final states or both are NOT final states
	   		var isFinalLeft : Boolean init input.finalStateSet.detect { e | p.name == e.name }!=void
	   		var isFinalB    : Boolean init input.finalStateSet.detect { e | b.name == e.name }!=void
	   		// Also fill the all input pairs
	   		if find_one(all_input_pairs, p, b) == void then all_input_pairs.add(helper.createPair(p, b)) end
	   		if  ((isFinalLeft and isFinalB) or (not isFinalLeft and not isFinalB)) 
		      and
			      find_one(equivalent_pairs, p, b) == void
		    then 
		    	stdio.write("{"+p.name + ","+b.name+"} ,")
		   		equivalent_pairs.add(helper.createPair(p, b))
	   	    end
	   	    } } 
		stdio.writeln("Eo = {F-Q}²^F² is initialized")	   	     

	   	// Minimalize 
    	minimalize(input, output)
    	//output.prettyprint
    	// We do not want to store combination
    	output.stateSet.each { s | s.combination.clear }
		output.dotprint 
		helper.saveEMFAutomaton(kermeta::persistence::EMFRepository.new, output, output_path, "../metamodels/automata.ecore" )
    end


    /**
     * MINIMIZATION ALGORITHM
     * params : 
     *    - input : the non-minimalized automaton
     *    - output : the minimal automaton equivalent to input
     */
    operation minimalize(input : FiniteAutomaton, output : FiniteAutomaton) is do
    	// TODO Remove not accessible states
    
    	// final_equivalent_pairs : the smallest equivalent pair set
		var final_equivalent_pairs : Set<Pair> init Set<Pair>.new
		final_equivalent_pairs.addAll(equivalent_pairs)
		var old_equivalent_pairs : Set<Pair> init all_input_pairs
    	from var it : Iterator<Pair> init old_equivalent_pairs.iterator
    	until old_equivalent_pairs == final_equivalent_pairs
    	loop
    		old_equivalent_pairs := final_equivalent_pairs
    		// For each pair
    		old_equivalent_pairs.each { eqPair |
    			// For all letters of input, if eqPair is not valid, remove it
	    		if (isNotOwnedTransition(input, eqPair, old_equivalent_pairs) == true) then 
	    			// remove this pair from final eq. pairs (H)
	    			final_equivalent_pairs := old_equivalent_pairs
	    			var fp : Pair init find_one(final_equivalent_pairs, eqPair.left, eqPair.right)
	    			if (fp!=void) then
	    				if (fp.left.name!=fp.right.name) then // the twin pairs are always valid!
		    				final_equivalent_pairs.remove(fp)
		    			end 
	    			end
	    		end
    		}
    	end
    	stdio.writeln("Minimalize succeeded")
    	// Create the equivalent classes, which become the new states
    	createEquivalenceClasses(output, input.stateSet, old_equivalent_pairs)
    	stdio.writeln("Equivalence classes creation succeeded : " + output.stateSet.size.toString)
		output.stateSet.each { s | s.name := String.clone(helper.join(s.combination.collect{ a | a.name }))  }
		// Create the transition between the new states -- inputStates contains the links to their eq.class
    	output.transitionSet := createEquivalentTransitions(output.stateSet, input.stateSet, input.transitionSet)
    	stdio.writeln("Transition set creation succeeded")
    	// Set the initial and the final states
    	output.initialState := input.initialState.combination.one
    	output.finalStateSet := input.finalStateSet.one.combination 
    end     
               
    // Find the pair in pairSet which equals (left, right) or (right, left) (xRy => yRx)
    operation find_one(pairSet : Set<Pair>, left : State, right : State) : Pair is do
    	result := pairSet.detect { p | 
   		(p.left.name == left.name and p.right.name == right.name) or
   		(p.right.name == left.name and p.left.name == right.name) }
    end
         
    /** 
     *  If the result state-pair ( T(pair.left), T(pair.right) ) does not belong to equivalent pairs then
     *  return true otherwise false
     *  params : 
     *    - automaton : the automaton in which we test the validity of the result state-pair
     *    - pair : the pair on which we apply each transition of automaton
     *    - equivalent_pairs : the equivalent_pairs in which we search the result state-pair
     */
    operation isNotOwnedTransition(automaton : FiniteAutomaton, pair : Pair, equivalent_pairs : Set<Pair>) : Boolean is do 
    	//  if there exists a letter a in the automaton such as T(pair.left, a), T(pair.right, a) belongs to distinct_pairs
    	//  "void" pair is allowed!
    	result := false
    	from var it : Iterator<String> init automaton.alphabet.iterator
    	until it.isOff or result == true
    	loop
    		var letter : String init it.next
    		var tleft : Transition init automaton.transitionSet.detect { t | t.source.name==pair.left.name and t.letter == letter }
    		var tright : Transition init automaton.transitionSet.detect { t | t.source.name==pair.right.name and t.letter == letter }    		
    		if (tleft!=void and tright!=void) then // empty word belongs to accepted words
    			if find_one(equivalent_pairs, tleft.target, tright.target) == void then
	    			result := true
	    		end
	    	else if (tleft==void or tright==void) then result := true end
    		end
    	end
    end
    
    /**
     * Principle of the creation of the equivalent classes :
     *     for each state of the initial automaton do :
     *           select all the pairs which first element is this state
     *                for each of these pairs, if right element is not "classed" yet, do :
     *                    * if a class does not exist for the left element, create one
     *                    * add the right element to the class of the left one
     *                end
     *     end
     */
    operation createEquivalenceClasses(output : FiniteAutomaton, stateSet : Set<State>, equivalent_pairs : Set<Pair>) is do
    	var eqClass : Set<State> init Set<State>.new
    	from var it : Iterator<State> init stateSet.iterator
    	until it.isOff
    	loop
    		var state : State init it.next
    		var news : State init State.new// eqClass as new state of output
	    	equivalent_pairs.select
	    	{ pair | pair.left.name == state.name }.each
	    	{ pair |
	    		// combination becomes an improvised "marker"
	    		// if it is void, it means that it does not belong to a eqclass yet
    			if (state.combination == void) then 
    				// create the eq. class and the state
	    			news.combination := Set<State>.new
	    			news.combination.add(pair.left)
	    			output.stateSet.add(news)
	    			// Mark state that is already added // we use combination to ease the transition computation
	    			state.combination := Set<State>.new 
	    			state.combination.add(news)
	    		end
	    		// Process the right element of the pair : add it to the eq.class of the left element!
	    		var sright : State init stateSet.detect { s | pair.right.name == s.name and s.combination == void }
    			if (sright != void) then
    				// Complete the eq. class
    				var found_eq : State init output.stateSet.detect{ c | c.combination.detect{ s| s.name==state.name }!=void }
    				found_eq.combination.add(pair.right) 
    				if (sright.combination == void) then
	    				sright.combination := Set<State>.new 
	    				sright.combination.add(found_eq)
	    			end
    			end
    		}
    	end
    end
    
    // eqClassStateSet : the minimal automaton set of states
    // stateSet : the input automaton set of states
    // transitionSet : the intput automaton set of transitions
    operation createEquivalentTransitions(
    	eqClassStateSet : Set<State>, stateSet : Set<State>, transitionSet : Set<Transition>) : Set<Transition> is do
    	result := Set<Transition>.new
    	// for each eq-class
    	from var it : Iterator<State> init stateSet.iterator 
    	until it.isOff
    	loop
    		var nextInputState : State init it.next
    		// Get the eq.class to which the current state belongs
    		var nextEqClassState : State init nextInputState.combination.one 
			// For each letter, Get the transition for which the current state is a source
			var nextTransitionSet : Sequence<Transition> init transitionSet.select { t | t.source == nextInputState }
			// The target combination is the eq. class target of the new transition!
			nextTransitionSet.each { t |
			// Add this transition		
			if result.detect {  rt | rt.source == nextEqClassState and rt.letter == t.letter } == void then
				var newt : Transition init Transition.new
				var nextEqClassStateTarget : State init eqClassStateSet.detect { s | s.combination.detect{ cs | cs.name==t.target.name }!=void }
				newt.initialize(nextEqClassState, nextEqClassStateTarget, t.letter)
				result.add(newt)
			end
			}
    	end
    end
}