/* $Id: kmLogo.kmt,v 1.7 2006-11-28 12:21:08 dvojtise Exp $
 * Project    : fr.irisa.triskell.kermeta.samples
 * File       : kmLogo.kmt
 * License    : EPL
 * Copyright  : IRISA / INRIA / Universite de Rennes 1
 * -------------------------------------------------------------------
 * Creation date : juil. 2005
 * Authors : 
 *        Jean-Marc Jézéquel <jezequel@irisa.fr>
 * Description : 
 *       Sample of metamodel with behavior in Kermeta
 */
@mainClass "kmLogo::actions::Main"
@mainOperation "main"

package kmLogo;
 
require kermeta
using kermeta::standard
using kermeta::utils
using kermeta::persistence

package semanticDomain
{
	
	class Turtle
	{
		reference position : Point
		reference drawings : Segment[0..*]
		attribute heading : Integer
		attribute penUp : Boolean
		operation reset() is do
			position := Point.new
			position.x := 0
			position.y := 0
			heading := 0
			drawings.clear
		end
		operation setPenUp(b : Boolean) is do
			penUp := b
		end
		operation rotate(angle : Integer) is do
			heading := heading + angle
			// let's approxiamte a modulo
			if heading < 0 then heading := heading + 360 end
			if heading > 360 then heading := heading - 360 end
		end
		operation move(dx : Integer, dy : Integer)  is do
			var newPos : Point
			newPos := position.getDelta(dx,dy)
			if penUp then
				stdio.writeln("Tortue se deplace en "+newPos.toString)
			else
				stdio.writeln("Tortue trace vers "+newPos.toString)
				var trace : Segment init Segment.new
				trace.make(position,newPos)
				drawings.add(trace)
			end
			position := newPos
		end
		operation forward(steps : Integer)  is do
		// let's approximate sin/cos for square moves only
			if heading == 0 then move (0,steps) end
			if heading == 90 then move (steps,0) end
			if heading == 180 then move (0,-steps) end
			if heading == 270 then move (-steps,0) end
		end
	}
	class Point
	{
		attribute x : Integer
		attribute y : Integer
		operation getDelta(dx : Integer, dy : Integer) : Point is do
			result := Point.new
			result.x := x + dx
			result.y := y + dy			
		end
		method toString() : String is do
			result := "[" + x.toString + "," + y.toString + "]"
		end
	}
	class Segment
	{
		reference origin : Point[1..1]
		reference destination : Point[1..1]
		operation make (orig : Point, dest : Point) is do
			origin := orig
			destination := dest
		end
	}
}

package abstractSyntax
{
	abstract class Instruction
	{
		reference enclosingBlock : Block[1..1]#instructions
		operation traverse(v : actions::AbstractVisitor) is abstract
	}
	abstract class Primitive inherits Instruction
	{
	}
	class Back inherits Primitive
	{
		reference steps : Expression[1..1]
		method traverse(v : actions::AbstractVisitor)  is do
			//TODO: implement method traverse
			v.visitBack(self)
		end
	}
	class Forward inherits Primitive
	{
		reference steps : Expression[1..1]
		method traverse(v : actions::AbstractVisitor)  is do
			//TODO: implement method traverse
			v.visitForward(self)
		end
	}
	class Left inherits Primitive
	{
		method traverse(v : actions::AbstractVisitor)  is do
			//TODO: implement method traverse
			v.visitLeft(self)
		end
	}
	class Right inherits Primitive
	{
		method traverse(v : actions::AbstractVisitor) is do
			//TODO: implement method traverse
			v.visitRight(self)
		end
	}
	class PenDown inherits Primitive
	{
		method traverse(v : actions::AbstractVisitor) is do
			//TODO: implement method traverse
			v.visitPenDown(self)
		end
	}
	class PenUp inherits Primitive
	{
		method traverse(v : actions::AbstractVisitor) is do
			//TODO: implement method traverse
			v.visitPenUp(self)
		end
	}
	class Clear inherits Primitive
	{
		method traverse(v : actions::AbstractVisitor) is do
			//TODO: implement method traverse
			v.visitClear(self)
		end
	}
	abstract class Expression inherits Instruction
	{
		
	}
	class BinaryExp inherits Expression
	{
		attribute operator : String
		attribute lhs : Expression[1..1]
		attribute rhs : Expression[1..1]
		method traverse(v : actions::AbstractVisitor) is do
			//TODO: implement method traverse
			v.visitBinaryExp(self)
		end
	}
	class Constant inherits Expression
	{
		attribute myValue : Integer
		method traverse(v : actions::AbstractVisitor)  is do
			//TODO: implement method traverse
			v.visitConstant(self)
		end
	}
	class ProcCall inherits Instruction
	{
		attribute actualArgs : Expression[0..*]
		reference declaration : ProcDeclaration[1..1]#procCall
		method traverse(v : actions::AbstractVisitor)  is do
			//TODO: implement method traverse
			v.visitProcCall(self)
		end
	}
	class ProcDeclaration inherits Instruction
	{
		attribute name : String
		attribute args : Variable[0..*]
		attribute block : Block#procDeclaration
		reference procCall : ProcCall[0..*]#declaration
		method traverse(v : actions::AbstractVisitor)  is do
			//TODO: implement method traverse
			v.visitProcDeclaration(self)
		end
	}
	class Block inherits Instruction
	{
		attribute instructions : Instruction[0..*]#enclosingBlock
		reference procDeclaration : ProcDeclaration[1..1]#block
		method traverse(v : actions::AbstractVisitor)  is do
			//TODO: implement method traverse
			v.visitBlock(self)
		end
	}
	class If inherits ControlStructure
	{
		attribute thenPart : Block[1..1]
		attribute elsePart : Block
		method traverse(v : actions::AbstractVisitor) is do
			//TODO: implement method traverse
			v.visitIf(self)
		end
	}
	abstract class ControlStructure inherits Instruction
	{
		attribute condition : Expression
	}
	class Repeat inherits ControlStructure
	{
		attribute block : Block[1..1]
		method traverse(v : actions::AbstractVisitor) is do
			//TODO: implement method traverse
			v.visitRepeat(self)
		end
	}
	class While inherits ControlStructure
	{
		attribute block : Block[1..1]
		method traverse(v : actions::AbstractVisitor) is do
			//TODO: implement method traverse
			v.visitWhile(self)
		end
	}
	class Variable inherits Expression
	{
		attribute name : String
		method traverse(v : actions::AbstractVisitor)  is do
			//TODO: implement method traverse
			v.visitVariable(self)
		end
	}
}

package actions
{
	abstract class AbstractVisitor
	{
		operation visitBack(node : abstractSyntax::Back) is abstract
		operation visitForward(node : abstractSyntax::Forward) is abstract
		operation visitLeft(node : abstractSyntax::Left) is abstract
		operation visitRight(node : abstractSyntax::Right) is abstract
		operation visitPenDown(node : abstractSyntax::PenDown) is abstract
		operation visitPenUp(node : abstractSyntax::PenUp) is abstract
		operation visitClear(node : abstractSyntax::Clear) is abstract
		operation visitBinaryExp(node : abstractSyntax::BinaryExp) is abstract
		operation visitConstant(node : abstractSyntax::Constant) is abstract
		operation visitProcCall(node : abstractSyntax::ProcCall) is abstract
		operation visitProcDeclaration(node : abstractSyntax::ProcDeclaration) is abstract
		operation visitBlock(node : abstractSyntax::Block) is abstract
		operation visitIf(node : abstractSyntax::If) is abstract
		operation visitRepeat(node : abstractSyntax::Repeat) is abstract
		operation visitWhile(node : abstractSyntax::While) is abstract
		operation visitVariable(node : abstractSyntax::Variable) is abstract
		
	}
	class Interpreter inherits AbstractVisitor
	{
		reference turtle : semanticDomain::Turtle
		attribute stack : Stack<Bindings>
		attribute accumulator : Integer
		operation initialize (t : semanticDomain::Turtle) is do
			turtle := t
			stack := Stack<Bindings>.new()
		end
		method visitBack(node : abstractSyntax::Back) is do
			node.steps.traverse(self)
			turtle.forward(-accumulator)
		end
		method visitForward(node : abstractSyntax::Forward) is do
			node.steps.traverse(self)
			turtle.forward(accumulator)
		end
		method visitLeft(node : abstractSyntax::Left) is do
			turtle.rotate(-90)
		end
		method visitRight(node : abstractSyntax::Right) is do
			turtle.rotate(90)			
		end
		method visitPenDown(node : abstractSyntax::PenDown) is do
			stdio.writeln("pendown") 
			turtle.setPenUp(false)			
		end
		method visitPenUp(node : abstractSyntax::PenUp) is do
			turtle.setPenUp(true)						
		end
		method visitClear(node : abstractSyntax::Clear) is do
			turtle.reset
		end
		method visitBinaryExp(node : abstractSyntax::BinaryExp) is do
			    stdio.writeln("visitBinExp"+accumulator.toString) 
			var left : Integer
			node.lhs.traverse(self)
			left := accumulator 
			node.rhs.traverse(self)
			if node.operator == "+" then accumulator := left + accumulator end
			if node.operator == "-" then accumulator := left - accumulator end
			if node.operator == "*" then accumulator := left * accumulator end
			if node.operator == "/" then accumulator := left / accumulator end
			if node.operator == "=" then 
				if left == accumulator then accumulator := 1 else accumulator := 0 end
			end
			if node.operator == "<" then 
				if left < accumulator then accumulator := 1 else accumulator := 0 end
			end
			if node.operator == ">" then 
				if left > accumulator then accumulator := 1 else accumulator := 0 end
			end
		end
		method visitConstant(node : abstractSyntax::Constant) is do
			accumulator := node.myValue
		end
		method visitProcCall(node : abstractSyntax::ProcCall) is do
			// create a new stack frame
			var frame : Bindings init Bindings.new
			// push it on the stack
			stack.push(frame)
			// for each formal arg, create a binding with actual value
			stdio.writeln("node.actualArgs.size="+node.actualArgs.size.toString) 
			from var i : Integer init 0
			until i >= node.actualArgs.size
			loop
			
				node.actualArgs.elementAt(i).traverse(self) 
				frame.put(node.declaration.args.elementAt(i).name, accumulator)
			    stdio.writeln("accumulator="+accumulator.toString) 
				i := i + 1
				
			end
			// transfert control to procedure body
			node.declaration.block.traverse(self)
			// pop stack frame
			stack.pop
		end
		method visitProcDeclaration(node : abstractSyntax::ProcDeclaration) is do
			// nothing to do
		end
		method visitBlock(node : abstractSyntax::Block) is do
			node.instructions.each{i  | i.traverse(self)}
		end
		method visitIf(node : abstractSyntax::If) is do
			node.condition.traverse(self)
			if accumulator != 0 then
				node.thenPart.traverse(self)
			else
				node.elsePart.traverse(self)
			end						
		end
		method visitRepeat(node : abstractSyntax::Repeat) is do
			node.condition.traverse(self)
			from var i : Integer init accumulator
			until i < 1
			loop
				node.block.traverse(self)
				i := i - 1
			end
		end
		method visitWhile(node : abstractSyntax::While) is do
			from node.condition.traverse(self)
			until accumulator == 0
			loop
				node.block.traverse(self)
				node.condition.traverse(self)
			end			
		end
		method visitVariable(node : abstractSyntax::Variable) is do
			accumulator := stack.first.getValue(node.name)		
		end
	}
	class PrettyPrinter inherits AbstractVisitor
	{
		method visitBack(node : abstractSyntax::Back) is do
			stdio.write("back ")
			node.steps.traverse(self)
		end
		method visitForward(node : abstractSyntax::Forward) is do
			stdio.write("forward ")
			node.steps.traverse(self)
		end
		method visitLeft(node : abstractSyntax::Left) is do
			stdio.write("left ")		
		end
		method visitRight(node : abstractSyntax::Right) is do
			stdio.write("right ")			
		end
		method visitPenDown(node : abstractSyntax::PenDown) is do
			stdio.write("pendown ")
		end
		method visitPenUp(node : abstractSyntax::PenUp) is do
			stdio.write("penup ")
		end
		method visitClear(node : abstractSyntax::Clear) is do
			stdio.writeln("clear ")			
		end
		method visitBinaryExp(node : abstractSyntax::BinaryExp) is do
			node.lhs.traverse(self)
			stdio.write(node.operator)	
			node.rhs.traverse(self)
			stdio.write(" ")	
		end
		method visitConstant(node : abstractSyntax::Constant) is do
			stdio.write(node.myValue.toString+" ")
		end
		method visitProcCall(node : abstractSyntax::ProcCall) is do
			stdio.write(node.declaration.name+" ")
			node.actualArgs.each{e  | e.traverse(self)}
		end
		method visitProcDeclaration(node : abstractSyntax::ProcDeclaration) is do
			stdio.writeln(" ")	
			stdio.write("to "+node.name+" ")
			node.args.each{arg  | arg.traverse(self)}
			stdio.writeln(" ")
			node.block.traverse(self)
			stdio.writeln("end")			
		end
		method visitBlock(node : abstractSyntax::Block) is do
			node.instructions.each{i  | i.traverse(self)}
		end
		method visitIf(node : abstractSyntax::If) is do
			
		end
		method visitRepeat(node : abstractSyntax::Repeat) is do
			stdio.write("repeat ")
			node.condition.traverse(self)
			stdio.write(" [ ")
			node.block.traverse(self)
			stdio.writeln(" ]")
		end
		method visitWhile(node : abstractSyntax::While) is do
			
		end
		method visitVariable(node : abstractSyntax::Variable) is do
			stdio.write(":"+node.name+" ")
		end
	}
	class Bindings inherits Hashtable<String,Integer>   
	{
	}
	class Main
	{
		operation pointille() : abstractSyntax::Instruction is do
		// tracer des pointillés
			var cst3 : abstractSyntax::Constant init abstractSyntax::Constant.new()
			var cst4 : abstractSyntax::Constant init abstractSyntax::Constant.new()
			var fo1 : abstractSyntax::Forward init abstractSyntax::Forward.new()
			var fo2 : abstractSyntax::Forward init abstractSyntax::Forward.new()
			var penup : abstractSyntax::PenUp init abstractSyntax::PenUp.new()
			var pendown : abstractSyntax::PenDown init abstractSyntax::PenDown.new()
			var block : abstractSyntax::Block init abstractSyntax::Block.new()
			var repeat : abstractSyntax::Repeat init abstractSyntax::Repeat.new()
			// initialize and set up links
			cst3.myValue := 3
			cst4.myValue := 4
			fo1.steps := cst3
			fo2.steps := cst4
			block.instructions.add(pendown)
			block.instructions.add(fo1)
			block.instructions.add(penup)
			block.instructions.add(fo2)
			repeat.condition := cst3
			repeat.block := block
			result := repeat
		end
		operation square() : abstractSyntax::Instruction is do
		// simulates the following logo program
		// to square :width repeat 4 [ forward :width right ] end
		// pendown square 4
			var varwidth : abstractSyntax::Variable init abstractSyntax::Variable.new()
			varwidth.name := "width"
			var forward : abstractSyntax::Forward init abstractSyntax::Forward.new()
			forward.steps := varwidth
			var right : abstractSyntax::Right init abstractSyntax::Right.new()
			var block : abstractSyntax::Block init abstractSyntax::Block.new()
			block.instructions.add(forward)
			block.instructions.add(right)
			var cst4 : abstractSyntax::Constant init abstractSyntax::Constant.new()
			cst4.myValue := 4
			var repeat : abstractSyntax::Repeat init abstractSyntax::Repeat.new()
			repeat.condition := cst4
			repeat.block := block
			var squareblock : abstractSyntax::Block init abstractSyntax::Block.new()
			squareblock.instructions.add(repeat)
			var squaredecl : abstractSyntax::ProcDeclaration init abstractSyntax::ProcDeclaration.new()
			squaredecl.name := "square"
			squaredecl.block := squareblock
			squaredecl.args.add(varwidth)
			var pendown : abstractSyntax::PenDown init abstractSyntax::PenDown.new()
			var squarecall : abstractSyntax::ProcCall init abstractSyntax::ProcCall.new()
			var cst10a : abstractSyntax::Constant init abstractSyntax::Constant.new()
			cst10a.myValue := 10
			var cst10b : abstractSyntax::Constant init abstractSyntax::Constant.new()
			cst10b.myValue := 10
			var binexp : abstractSyntax::BinaryExp init abstractSyntax::BinaryExp.new()
			binexp.operator := "*"
			binexp.lhs := cst10a
			binexp.rhs := cst10b
			squarecall.declaration := squaredecl
			squarecall.actualArgs.add(binexp)
			var fullprog : abstractSyntax::Block init abstractSyntax::Block.new()
			fullprog.instructions.add(squaredecl)
			fullprog.instructions.add(pendown)
			fullprog.instructions.add(squarecall)
			result := fullprog
		
		end
		operation main() is
		do
			var pp : PrettyPrinter init PrettyPrinter.new()
			var interp : Interpreter init Interpreter.new()
			var tortue : semanticDomain::Turtle init semanticDomain::Turtle.new()
			var root : abstractSyntax::Instruction
			tortue.reset
			interp.initialize(tortue)
			// root := pointille()
			// run prettyprinter
			// root.traverse(pp) 
			// run interpretor
			// root.traverse(interp) 
			root := square()
			// run prettyprinter
			root.traverse(pp) 
			// run interpretor
			stdio.writeln(" --- ")
			root.traverse(interp) 
		end
		
		operation loadSquareProg(): abstractSyntax::Instruction is do
	 	   stdio.writeln("Loading square prog...")
		   var repository : EMFRepository init EMFRepository.new
	   	   // var resource : Resource init  repository.getResource("../models/squareProg.xmi")
	   	   //var resource : Resource
		   //resource :=	repository.createResource("../models/squareProg.xmi",
           //                                         "../ecore/kmLogo.ecore")
           var resource : EMFResource
           resource ?= repository.getResource("../models/squareProg.xmi")
	       resource.load()

	       from var it : Iterator<Object> init resource.instances.iterator
	       until it.isOff
	       loop
	           var next : Object init it.next
	           if (abstractSyntax::Instruction.isInstance(next)) then
	           		result ?= next
	           end
	       end

	 		stdio.writeln("Square prog loaded")
		end
		
		/** used to create the same square prog but in xmi format */
		operation saveSquareProg() is do
			var root : abstractSyntax::Instruction
			root := square()

			var repository : EMFRepository init EMFRepository.new
        	var resource : EMFResource
			resource ?=	repository.createResource("../models/squareProg.xmi",
        							  "../ecore/kmLogo.ecore")
	 		// Define a Root ...
	 		resource.instances.add(root)

	 		resource.save()
	 		stdio.writeln("Square prog saved")

		end
		/** used to create the same square prog but in xmi format */
		operation savePointille() is do
			var root : abstractSyntax::Instruction
			root := pointille()
			//root := square()

			var repository : EMFRepository init EMFRepository.new
        	var resource : EMFResource
			resource ?=	repository.createResource("../models/pointilleProg.xmi",
        							  "../ecore/kmLogo.ecore")
	 		// Define a Root ...
	 		resource.instances.add(root)

	 		resource.save()
	 		stdio.writeln("Pointille prog saved")

		end
	}
}
