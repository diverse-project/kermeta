/*****************************************************************************
 * $Id: 035_testHashtableObjectEqualsKey.main.kmt,v 1.1 2007-09-10 08:35:04 cfaucher Exp $
 * Project : Kermeta interpreter
 * 		
 * License : EPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * Creation date : Feb 2007
 * Authors : dvojtise
 * Description : 
 *		test for Hashtable using an Object key that redefines the equals and hashcode method 
 ***************************************************************************
 */

@testOperation "yes"
@mainClass "testHashtableObjectEqualsKey::TestHashtable"
@mainOperation "mainTest"

package testHashtableObjectEqualsKey;

require kermeta

using kermeta::kunit

alias Integer : kermeta::standard::Integer;
alias String : kermeta::standard::String;

class MyKeyType inherits kermeta::standard::ValueType
{
	attribute name : String
	method hashcode() : kermeta::standard::Integer is do
		
		result := name.hashcode
		stdio.writeln("hashcode on MyKeytype = " + result.toString)
	end
	method equals(other : kermeta::standard::Object) : kermeta::standard::Boolean is do		
		var otherKey : MyKeyType
		otherKey ?= other
		if(not otherKey.isVoid) then	
			if(not otherKey.name.isVoid) then
				result := otherKey.name.equals(name)
			else 
				result := name.isVoid
			end
		else
			result := false
		end
		/*stdio.writeln("equals on MyKeytype = " + result.toString  )*/
	end
}

class TestHashtable inherits kermeta::kunit::TestCase
{
	
	reference hashtable : kermeta::utils::Hashtable<MyKeyType, String>
	
	attribute testKeySet : MyKeyType[0..*]
	
	/** used to manually start the test
	 */
	operation mainTest() is do
        var testRunner : TestRunner init TestRunner.new
		testRunner.run(TestHashtable)
		testRunner.printTestResult()
	end
	
	/** initialize things 
	 * automatically called by the test runner
	 */
	method setUp() : Void is do
	
	    stdio.writeln("		----- setup ---")
		if(testKeySet.empty) then
			var aKey : MyKeyType  init MyKeyType.new
			aKey.name := "un"
			testKeySet.add(aKey)
			aKey := MyKeyType.new
			aKey.name := "deux"
			testKeySet.add(aKey)
			aKey := MyKeyType.new
			aKey.name := "trois"
			testKeySet.add(aKey)
		end
		hashtable := kermeta::utils::Hashtable<MyKeyType, String>.new
		testKeySet.elementAt(0)
		hashtable.put(testKeySet.elementAt(0),"one")
		hashtable.put(testKeySet.elementAt(1),"two")
		hashtable.put(testKeySet.elementAt(2),"three")
	end
	
	/**
	 * returns an iterator on the keys of the map
	 */
	operation testKeyIterator() : Void is do
		var it : kermeta::standard::Iterator<MyKeyType>
		
		it := hashtable.keyIterator()
		stdio.writeln(it.next.toString)
		stdio.writeln(it.next.toString)
		stdio.writeln(it.next.toString)
	end

	
	/**
	 * returns an iterator on the keys of the map
	 */
	operation testValueIterator() : Void is do
		var it : kermeta::standard::Iterator<String>
		
		it := hashtable.valueIterator()
		stdio.writeln(it.next.toString)
		stdio.writeln(it.next.toString)
		stdio.writeln(it.next.toString)
	end
	
	/**
	 * test the GetValue from the very same object
	 */
	operation testGetFromSame() : Void is do
  	    
		assert(hashtable.getValue(testKeySet.elementAt(0)) == "one")
		assert(hashtable.getValue(testKeySet.elementAt(1)) == "two")
		assert(hashtable.getValue(testKeySet.elementAt(2)) == "three")
	end
	/**
	 * test the GetValue from objects that are equals (ie. not the very same but reply true with the method "equals"
	 * this is because MyKeyType inherits from ValueType
	 */
	operation testGetFromEquals() : Void is do
  	    
  	    var aKey : MyKeyType  init MyKeyType.new
		aKey.name := "un"
		assert(aKey.equals(testKeySet.elementAt(0)))
		assert(hashtable.getValue(aKey) == "one")
		//---
		aKey := MyKeyType.new
		aKey.name := "deux"
		assert(aKey.equals(testKeySet.elementAt(1)))
		assert(hashtable.getValue(aKey) == "two")
		//---
		aKey := MyKeyType.new
		aKey.name := "trois"
		assert(aKey.equals(testKeySet.elementAt(2)))
		assert(hashtable.getValue(aKey) == "three")
	end
	
	/**
	 * replaces an entry in the Hashtable
	 * adds an entry
	 */
	operation testPut() : Void is do
	   
		hashtable.put(testKeySet.elementAt(0), "ONE")
		assert(hashtable.getValue(testKeySet.elementAt(0)) == "ONE")
		assert(hashtable.getValue(testKeySet.elementAt(1)) == "two")
		assert(hashtable.size == 3)
		var aKey : MyKeyType  init MyKeyType.new
		aKey.name := "quatre"
		hashtable.put(aKey, "four")
		assert(hashtable.size == 4)
	end
	
	/**
	 * Removes the entry which key equals 'key'
	 */
	operation testRemove() : Void is do
	    
		hashtable.remove(testKeySet.elementAt(1))
		assert(hashtable.size == 2)
//		fail(hashtable.keyIterator.next == 1)
	end
	
	/**
	 * Remove all elements from the Hashtable
	 */
	operation testClear() : Void is do
	    
		hashtable.clear()
		assert(hashtable.size == 0)
		assert(hashtable.getValue(testKeySet.elementAt(0)).isVoid)
	end
	
//	/** test that the values() method contains the values of the hashtable */ 
	operation testValues() : Void is do 
	    
		assert(hashtable.values.size == hashtable.size) 
		assert(hashtable.values.contains("one"))
		assert(hashtable.values.contains("two"))
		assert(hashtable.values.contains("three"))
	end
	/** test that the keys() method contains the values of the hashtable */
	operation testKeysFromSame() : Void is do
	    
		assert(hashtable.keys.size == hashtable.size)
		assert(hashtable.keys.contains(testKeySet.elementAt(0)))
		assert(hashtable.keys.contains(testKeySet.elementAt(1)))
		assert(hashtable.keys.contains(testKeySet.elementAt(2)))
	end
	/** test that the keys() method contains the values of the hashtable */
	operation testKeysFromEquals() : Void is do
	    
		assert(hashtable.keys.size == hashtable.size)
		
		var aKey : MyKeyType  init MyKeyType.new
		aKey.name := "un"
		assert(aKey.equals(testKeySet.elementAt(0)))	
		assert(hashtable.keys.contains(aKey))
		//---
		aKey := MyKeyType.new
		aKey.name := "deux"
		assert(aKey.equals(testKeySet.elementAt(1)))
		assert(hashtable.keys.contains(aKey))
		//---
		aKey := MyKeyType.new
		aKey.name := "trois"
		assert(aKey.equals(testKeySet.elementAt(2)))
		assert(hashtable.keys.contains(aKey))
		
	end

}
