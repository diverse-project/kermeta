/* $Id: 071_DynamicInstanceLoadSaveUsingRelativePath.main.kmt,v 1.4 2008-07-31 08:34:13 dvojtise Exp $ 
 * Creation : June 11, 2008
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise
 * This suite tests that we can add by aspect an opposite and that we can load a model 
 * the opposite information will be filled for use at run time
 */
@mainClass "loadOppositeByAspect::Main"
@mainOperation "main"


package loadOppositeByAspect;


require kermeta

require "../metamodels/072_OppositeTestMM.ecore"
require "072_OppositeTestAspect.kmt"

using kermeta::standard
using kermeta::persistence
using kermeta::kunit
using oppositetestmm

class Main inherits TestCase
{
	operation main() : Void is do
    	var tr : TestRunner init TestRunner.new
		tr.run(Main)
		tr.printTestResult
		
		// test005CreateRootRelativeResourceSaveAbsolute
		//test006CreateAbsoluteResourceSaveRootRelative
		
		stdio.writeln("end")
    end
    
    
    operation test001LoadOppositeSingle2Single() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|     	
       		// this is a single2singleSrc
			var src1 : Single2SingleSrc
			src1 ?= e
			if src1 != void then
				assertTrueWithMsg(src1.dest.src == src1,"Cannot navigate back using reference src")        
			end
		}        
    end
    
    /*
     */
    operation test002LoadOppositeSingle2Bag() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|
       	
       		var src1 : Single2BagSrc
			src1 ?= e
			if src1 != void then
				// navigate the attribute "classes"
				src1.destBag.each{ c |
					// check that the object can navigate back to the original Object
					assertTrueWithMsg(c.src == src1, "Cannot navigate back using reference src")        
				}
			end
		}        
    end
    
    operation test003LoadOppositeBag2Single() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|
       	
       		var src1 : Bag2SingleSrc
			src1 ?= e
			if src1 != void then
				assertTrueWithMsg(src1.dest.srcBag.contains(src1), "Cannot navigate back using reference srcBag")        
				
			end
		}        
    end
  
  	operation test004LoadOppositeBag2Bag() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|
       	
       		var src1 : Bag2BagSrc
			src1 ?= e
			if src1 != void then
				assertTrueWithMsg(src1.destBag.size == 3, "Bag2BagSrc should refer 3 Bag2BagDest, it currently refers " + src1.destBag.size.toString)
				src1.destBag.each{ c |
					// check that the object can navigate back to the original Object
					assertTrueWithMsg(c.srcBag.contains(src1), "Cannot navigate back using reference srcBag")
					if "AddedTwice" == c.name then
						// as it has been added twice it should contain src1 twice too
						assertTrueWithMsg(c.srcBag.size == 2, "as it has been added twice it should contain src1 twice too")
					end        
				}
			end
		}        
    end
    
    operation test005LoadOppositeSingle2Set() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|
       	
       		var src1 : Single2SetSrc
			src1 ?= e
			if src1 != void then
				src1.destSet.each{ c |
					// check that the object can navigate back to the original Object
					assertTrueWithMsg(c.src == src1, "Cannot navigate back using reference src")        
				}
			end
		}        
    end
    operation test006LoadOppositeSet2Single() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|
       	
       		var src1 : Set2SingleSrc
			src1 ?= e
			if src1 != void then
				assertTrueWithMsg(src1.dest.srcSet.contains(src1), "Cannot navigate back using reference srcSet")        
				
			end
		}        
    end
    operation test007LoadOppositeSet2Set() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|
       	
       		var src1 : Set2SetSrc
			src1 ?= e
			if src1 != void then
				src1.destSet.each{ c |
					// check that the object can navigate back to the original Object
					assertTrueWithMsg(c.srcSet.contains(src1), "Cannot navigate back using reference srcSet")        
				}
			end
		}        
    end
    
    operation test008LoadOppositeBag2Set() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|
       	
       		var src1 : Bag2SetSrc
			src1 ?= e
			if src1 != void then
				src1.destSet.each{ c |
					// check that the object can navigate back to the original Object
					assertTrueWithMsg(c.srcBag.contains(src1), "Cannot navigate back using reference srcBag")        
				}
			end
		}        
    end
    
    operation test009LoadOppositeSet2Bag() : Void is
    do
    	var resource : Resource init loadOppositeInputModelResource()
    	    	
       	stdio.writeln("\n  model elements: "+resource.size.toString)
       	
       	// for each element in the resource check that the opposite are correctly navigable
       	resource.each{e|
       	
       		var src1 : Set2BagSrc
			src1 ?= e
			if src1 != void then
				src1.destBag.each{ c |
					// check that the object can navigate back to the original Object
					assertTrueWithMsg(c.srcSet.contains(src1), "Cannot navigate back using reference srcSet")        
				}
			end
		}        
    end
    operation loadOppositeInputModelResource() : Resource is
    do
    	var ifileName : String init "../instances/072_OppositeTestSample.xmi"
    	var ofileName : String init "platform:/resource/fr.irisa.triskell.kermeta.tests/test/interpreter/emf_testcases/output/072_OppositeTestSample.out.xmi"
    	var mmfileName : String init "platform:/resource/fr.irisa.triskell.kermeta.tests/test/interpreter/emf_testcases/metamodels/072_OppositeTestMM.ecore"

		var repository : kermeta::persistence::EMFRepository	init kermeta::persistence::EMFRepository.new
		repository.registerEcoreFile(mmfileName)
    	var resource : Resource
    	
    	resource :=repository.getResource(ifileName)
    	
    	result := resource
    end
    
}

