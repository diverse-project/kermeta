package uml2;

require "http://www.eclipse.org/emf/2002/Ecore"
require "kermeta"
alias Integer : kermeta::standard::Integer;
alias Boolean : kermeta::standard::Boolean;
alias String : kermeta::standard::String;
alias UnlimitedNatural : kermeta::standard::Integer;
alias Sequence : kermeta::language::structure::Object;
alias Set : kermeta::language::structure::Object;
abstract class Element inherits ecore::EModelElement
{
	/**The Elements owned by this element. This is a derived union.*/
@overloadable "true"
	property ownedElement : set Element[0..*]#owner
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**The Element that owns this element. This is a derived union.*/
@overloadable "true"
	property owner : Element#ownedElement
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**The Comments owned by this element. Subsets Element::ownedElement.*/
	attribute ownedComment : set Comment[0..*]

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
not self.allOwnedElements()->includes(self)
</code>*/
	operation not_own_self(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.mustBeOwned() implies owner->notEmpty()
</code>*/
	operation has_owner(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
ownedElement->union(ownedElement->collect(e | e.allOwnedElements()))
</code>*/
	operation allOwnedElements() : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
true
</code>*/
	operation mustBeOwned() : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
abstract class MultiplicityElement inherits Element
{
	/**For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of this element are sequentially ordered. Default is false.*/
	attribute isOrdered : Boolean

	/**For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of this element are unique. Default is true.*/
	attribute isUnique : Boolean

	/**Specifies the lower bound of the multiplicity interval, if it is expressed as an integer.*/
@overloadable "true"
	property lower : Integer
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies the upper bound of the multiplicity interval, if it is expressed as an unlimited natural.*/
@overloadable "true"
	property upper : UnlimitedNatural
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**The specification of the upper bound for this multiplicity. Subsets Element::ownedElement.*/
	attribute upperValue : ValueSpecification

	/**The specification of the lower bound for this multiplicity. Subsets Element::ownedElement.*/
	attribute lowerValue : ValueSpecification

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if lowerValue->isEmpty() then 1 else lowerValue.integerValue() endif
</code>*/
	operation lowerBound() : Integer is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if upperValue->isEmpty() then 1 else upperValue.unlimitedValue() endif
</code>*/
	operation upperBound() : UnlimitedNatural is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
upperBound() > 1
</code>*/
	operation isMultivalued() : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
(lowerBound() <= C) and (upperBound() >= C)

</code>*/
	operation includesCardinality(C : Integer) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
(self.lowerBound() <= M.lowerBound()) and (self.upperBound() >= M.upperBound())
</code>*/
	operation includesMultiplicity(M : MultiplicityElement) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
upperBound()->notEmpty() implies upperBound() > 0
</code>*/
	operation upper_gt_0(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
lowerBound()->notEmpty() implies lowerBound() >= 0
</code>*/
	operation lower_ge_0(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
(upperBound()->notEmpty() and lowerBound()->notEmpty()) implies upperBound() >= lowerBound()
</code>*/
	operation upper_ge_lower(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
lower=lowerBound()
</code>*/
	operation lower_eq_lowerbound(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
upper = upperBound()
</code>*/
	operation upper_eq_upperbound(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
lowerBound()
</code>*/
	operation op_lower() : Integer is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
upperBound()
</code>*/
	operation op_upper() : UnlimitedNatural is
		raise kermeta::exceptions::NotImplementedException.new

}
abstract class NamedElement inherits TemplateableElement
{
	/**The name of the NamedElement.*/
	attribute name : String

	/**A name which allows the NamedElement to be identified within a hierarchy of nested Namespaces. It is constructed from the names of the containing namespaces starting at the root of the hierarchy and ending with the name of the NamedElement itself. This is a derived attribute.*/
@overloadable "true"
	property qualifiedName : String
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Determines the visibility of the NamedElement within different Namespaces within the overall model. Package Dependencies (“Dependencies” on page 94)*/
	attribute visibility : VisibilityKind

	reference clientDependency : set Dependency[0..*]#client

	/**The expression used to define the name of this named element.*/
	attribute nameExpression : StringExpression

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.name->isEmpty() or self.allNamespaces()->select(ns | ns.name->isEmpty())->notEmpty()
	implies self.qualifiedName->isEmpty()
</code>*/
	operation no_name(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
(self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()) implies
self.qualifiedName =
 self.allNamespaces()->iterate( ns : Namespace; result: String = self.name |
		ns.name->union(self.separator())->union(result))
</code>*/
	operation qualified_name(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if self.namespace->isEmpty()
then Sequence{}
else self.namespace.allNamespaces()->prepend(self.namespace)
endif
</code>*/
	operation allNamespaces() : Sequence is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if self.oclIsKindOf(n.oclType) or n.oclIsKindOf(self.oclType)
then ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()
else true
endif
</code>*/
	operation isDistinguishableFrom(n : NamedElement, ns : Namespace) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
'::'
</code>*/
	operation separator() : String is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()
then 
    self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))
else
    Set{}
endif
</code>*/
	operation op_qualifiedName() : String is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
namespace->isEmpty() implies visibility->isEmpty()
</code>*/
	operation visibility_needs_ownership(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
abstract class Namespace inherits NamedElement
{
	/**A collection of NamedElements identifiable within the Namespace, either by being owned or by being introduced by importing or inheritance. This is a derived union.*/
@overloadable "true"
	property member : set NamedElement[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies a set of Constraints owned by this Namespace. Subsets Namespace::ownedMember.*/
	attribute ownedRule : set Constraint[0..*]#namespace

	/**References the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports. Subsets Namespace::member.*/
@overloadable "true"
	property importedMember : set PackageableElement[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**References the ElementImports owned by the Namespace. Subsets Element::ownedElement.*/
	attribute elementImport : set ElementImport[0..*]#importingNamespace

	/**References the PackageImports owned by the Namespace. Subsets Element::ownedElement.*/
	attribute packageImport : set PackageImport[0..*]#importingNamespace

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
membersAreDistinguishable()
</code>*/
	operation members_are_distinguishable(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if self.ownedMember->includes(element)
then Set{}->include(element.name)
else let elementImports: ElementImport = self.elementImport->select(ei | ei.importedElement = element) in
    if elementImports->notEmpty()
    then elementImports->collect(el | el.getName())
    else 
        self.packageImport->select(pi | pi.importedPackage.visibleMembers()->includes(element))->collect(pi | pi.importedPackage.getNamesOfMember(element))
    endif
endif
</code>*/
	operation getNamesOfMember(element : NamedElement) : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
self.member->forAll( memb |
	self.member->excluding(memb)->forAll(other |
		memb.isDistinguishableFrom(other, self)))
</code>*/
	operation membersAreDistinguishable() : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.importedMember->includesAll(self.importedMembers(self.elementImport.importedElement.asSet()->union(self.packageImport.importedPackage->collect(p | p.visibleMembers()))))
</code>*/
	operation importedMember_derived(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
self.importedMembers(self.elementImport.importedElement.asSet()->union(self.packageImport.importedPackage->collect(p | p.visibleMembers())))
</code>*/
	operation op_importedMember() : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
self.excludeCollisions(imps)->select(imp | self.ownedMember->forAll(mem | mem.imp.isDistinguishableFrom(mem, self)))
</code>*/
	operation importMembers(imps : Set) : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
imps->reject(imp1 | imps.exists(imp2 | not imp1.isDistinguishableFrom(imp2, self)))
</code>*/
	operation excludeCollisions(imps : Set) : Set is
		raise kermeta::exceptions::NotImplementedException.new

}
class OpaqueExpression inherits ValueSpecification
{
	/**The text of the expression.*/
	attribute body : String

	/**Specifies the language in which the expression is stated. The interpretation of the expression body depends on the language. If language is unspecified, it might be implicit from the expression body or the context.*/
	attribute language : String

	/**Restricts an opaque expression to return exactly one return result. When the invocation of the opaque expression completes, a single set of values is returned to its owner. This association is derived from the single return result parameter of the associated behavior.*/
@overloadable "true"
	property ~result : Parameter
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies the behavior of the opaque expression.*/
	reference behavior : Behavior

}
abstract class ValueSpecification inherits TypedElement, ParameterableElement
{
	@overloadable "true"
/**A query based on the following OCL expression:
<code>
false
</code>*/
	operation isComputable() : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
Set{}
</code>*/
	operation integerValue() : Integer is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
Set{}
</code>*/
	operation booleanValue() : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
Set{}
</code>*/
	operation stringValue() : String is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
Set{}
</code>*/
	operation unlimitedValue() : UnlimitedNatural is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
false
</code>*/
	operation isNull() : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
class Expression inherits OpaqueExpression
{
	/**The symbol associated with the node in the expression tree.*/
	attribute symbol : String

	/**Specifies a sequence of operands. Subsets Element::ownedElement.*/
	attribute operand : ValueSpecification[0..*]

}
class Comment inherits TemplateableElement
{
	/**Specifies a string that is the comment.*/
	attribute body : String

	/**References the Element(s) being commented.*/
	reference annotatedElement : set Element[0..*]

	attribute bodyExpression : StringExpression

}
abstract class DirectedRelationship inherits Relationship
{
	/**Specifies the sources of the DirectedRelationship. Subsets Relationship::relatedElement. This is a derived union.*/
@overloadable "true"
	property source : set Element[1..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies the targets of the DirectedRelationship. Subsets Relationship::relatedElement. This is a derived union.*/
@overloadable "true"
	property target : set Element[1..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

}
abstract class Relationship inherits Element
{
	/**Specifies the elements related by the Relationship. This is a derived union.*/
@overloadable "true"
	property relatedElement : set Element[1..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

}
class Class inherits BehavioredClassifier, EncapsulatedClassifier
{
	/**The operations owned by the class. The association is ordered. Subsets Classifier::feature and Namespace::ownedMember.*/
	attribute ownedOperation : Operation[0..*]#class_

	/**This gives the superclasses of a class. It redefines Classifier::general. This is derived.*/
@overloadable "true"
	property superClass : set Class[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property extension : set Extension[0..*]#metaclass
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**References all the Classifiers that are defined (nested) within the Class. Subsets Element:: ownedMember.*/
	attribute nestedClassifier : Classifier[0..*]

	/**Determines whether an object specified by this class is active or not. If true, then the owning class is referred to as an active class. If false, then such a class is referred to as a passive class.*/
	attribute isActive : Boolean

	/**Receptions that objects of this class are willing to accept. (Specializes Namespace.owned- Member and Classifier.feature.)*/
	attribute ownedReception : set Reception[0..*]

}
abstract class Type inherits PackageableElement
{
	/**References the owning package of a package. Subsets NamedElement::namespace.*/
@overloadable "true"
	property ~package : Package#ownedType
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
false
</code>*/
	operation conformsTo(other : Type) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
class Property inherits StructuralFeature, ConnectableElement, DeploymentTarget
{
	@overloadable "true"
	property default : String
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property isComposite : Boolean
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies whether the Property is derived, i.e., whether its value or values can be computed from other information. The default value is false.*/
	attribute isDerived : Boolean

	reference class_ : Class

	@overloadable "true"
	property opposite : Property
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies whether the property is derived as the union of all of the properties that are constrained to subset it. The default value is false.*/
	attribute isDerivedUnion : Boolean

	/**References the owning association of this property. Subsets Property::association, NamedElement::namespace, Feature::featuringClassifier, and RedefinableElement:: redefinitionContext.*/
	reference owningAssociation : Association#ownedEnd

	reference redefinedProperty : set Property[0..*]

	reference subsettedProperty : set Property[0..*]

	/**The DataType that owns this Property. Subsets NamedElement::namespace, Feature::featuringClassifier, and Property::classifier.*/
	reference datatype : DataType#ownedAttribute

	/**References the association of which this property is a member, if any.*/
	reference association : Association#memberEnd

	/**Specifies the kind of aggregation that applies to the Property. The default value is none.*/
	attribute aggregation : AggregationKind

	/**A ValueSpecification that is evaluated to give a default value for the Property when an object of the owning Classifier is is instantiated. Subsets Element::ownedElement.*/
	attribute defaultValue : ValueSpecification

	attribute qualifier : Property[0..*]#associationEnd

	reference associationEnd : Property#qualifier

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
opposite = 
	if owningAssociation->notEmpty() and association.memberEnd->size() = 2 then 
		let otherEnd = (association.memberEnd - self)->any() in 
			if otherEnd.owningAssociation->notEmpty then otherEnd else Set{} endif
	else Set {}
	endif
</code>*/
	operation opposite_is_other_end(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if owningAssociation->notEmpty() and association.memberEnd->size() = 2 then 
		let otherEnd = (association.memberEnd - self)->any() in 
			if otherEnd.owningAssociation->notEmpty then otherEnd else Set{} endif
	else Set {}
	endif
</code>*/
	operation op_opposite() : Property is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
isComposite implies (upperBound()->isEmpty() or upperBound() <= 1)
</code>*/
	operation multiplicity_of_composite(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
subsettedProperty->notEmpty() implies
	(subsettingContext()->notEmpty() and subsettingContext()->forAll (sc |
		subsettedProperty->forAll(sp | 
			sp.subsettingContext()->exists(c | sc.conformsTo(c)))))
</code>*/
	operation subsetting_context(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
(subsettedProperty->exists(sp | sp.class->notEmpty())	
		implies class->notEmpty())
and
(redefinedProperty->exists(rp | rp.class->notEmpty())	
		implies class->notEmpty())
</code>*/
	operation navigable_property_redefinition(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
subsettedProperty->forAll(sp |
	type.conformsTo(sp.type) and
		((upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies
			upperBound()<=sp.upperBound() ))
</code>*/
	operation subsetting_rules(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
isReadOnly implies class->notEmpty()
</code>*/
	operation navigable_readonly(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
isDerivedUnion implies isDerived
</code>*/
	operation derivedUnion_is_derived(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if association->notEmpty()
then association.endType-type 
else if classifier->notEmpty then Set{classifier} else Set{} endif
endif
</code>*/
	operation subsettingContext() : Set is
		raise kermeta::exceptions::NotImplementedException.new

}
class Operation inherits BehavioralFeature, TypedElement, MultiplicityElement, ParameterableElement
{
	attribute ownedParameter : Parameter[0..*]#~operation

	reference class_ : Class#ownedOperation

	/**Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged (isQuery=true) or whether side effects may occur (isQuery=false). The default value is false.*/
	attribute isQuery : Boolean

	reference datatype : DataType#ownedOperation

	/**An optional set of Constraints on the state of the system when the Operation is invoked. Subsets Namespace::ownedMember.*/
	reference precondition : set Constraint[0..*]

	/**An optional set of Constraints specifying the state of the system when the Operation is completed. Subsets Namespace::ownedMember.*/
	reference postcondition : set Constraint[0..*]

	/**the Operations that are redefined by this Operation. Subsets RedefinableElement. redefinedElement.*/
	reference redefinedOperation : set Operation[0..*]

	/**optional Constraint on the result values of an invocation of this Operation. Subsets Namespace::ownedMember.*/
	reference bodyCondition : Constraint

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
if returnResult->size() = 1 then
  type = returnResult.type
else
  type = nil
endif

</code>*/
	operation type_of_result(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if returnResult->size() = 1 then returnResult->any().isOrdered else false endif
</code>*/
	operation op_isOrdered() : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
 if returnResult->size() = 1 then returnResult->any().isUnique else true endif
</code>*/
	operation op_isUnique() : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if returnResult->size() = 1 then returnResult->any().type else Set{} endif
</code>*/
	operation op_type() : Classifier is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
bodyCondition->notEmpty() implies isQuery
</code>*/
	operation only_body_for_query(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
abstract class TypedElement inherits NamedElement
{
	/**The type of the TypedElement.*/
	reference type : Type

}
class Parameter inherits ConnectableElement, TypedElement, MultiplicityElement
{
	/**References the Operation for which this is a formal parameter. Subsets NamedElement:: namespace.*/
	reference ~operation : Operation#ownedParameter

	@overloadable "true"
	property default : String
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Indicates whether a parameter is being sent into or out of a behavioral element. The default value is in.*/
	attribute direction : ParameterDirectionKind

	/**Specifies a ValueSpecification that represents a value to be used when no argument is supplied for the Parameter. Subsets Element::ownedElement.*/
	attribute defaultValue : ValueSpecification

	attribute isException : Boolean

	attribute isStream : Boolean

	attribute effect : ParameterEffectKind

	reference parameterSet : set ParameterSet[0..*]#parameter

}
class Package inherits Namespace, PackageableElement
{
	/**References the owned members that are Packages. Subsets Package::ownedMember.*/
@overloadable "true"
	property nestedPackage : set Package[0..*]#nestingPackage
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property nestingPackage : Package#nestedPackage
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**References the owned members that are Types. Subsets Package::ownedMember.*/
@overloadable "true"
	property ownedType : set Type[0..*]#~package
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies the members that are owned by this Package. Redefines Namespace::ownedMember.*/
	attribute ownedMember : set PackageableElement[0..*]

	attribute packageMerge : set PackageMerge[0..*]#mergingPackage

	reference appliedProfile : set ProfileApplication[0..*]

	attribute packageExtension : set PackageMerge[0..*]

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.ownedElements->forAll(e | e.visibility->notEmpty() implies e.visbility = #public or e.visibility = #private)
</code>*/
	operation elements_public_or_private(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
member->select( m | self.makesVisible(m))
</code>*/
	operation visibleMembers() : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
el.visibility->isEmpty() or el.visibility = #public
</code>*/
	operation makesVisible(el : NamedElement) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
class Enumeration inherits DataType
{
	/**ordered set of literals for this Enumeration. Subsets Element::ownedMember.*/
	attribute ownedLiteral : EnumerationLiteral[0..*]#~enumeration

}
class DataType inherits Classifier
{
	/**The Attributes owned by the DataType. Subsets Classifier::attribute and Element:: ownedMember.*/
	attribute ownedAttribute : Property[0..*]#datatype

	/**The Operations owned by the DataType. Subsets Classifier::feature and Element:: ownedMember.*/
	attribute ownedOperation : Operation[0..*]#datatype

}
class EnumerationLiteral inherits InstanceSpecification
{
	/**Enumeration that this EnumerationLiteral is a member of. Subsets NamedElement:: namespace.*/
	reference ~enumeration : Enumeration#ownedLiteral

}
class PrimitiveType inherits DataType
{
}
abstract class Classifier inherits Namespace, Type, RedefinableElement
{
	@overloadable "true"
	property feature : set Feature[0..*]#featuringClassifier
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**If true, the Classifier does not provide a complete declaration and can typically not be instantiated. An abstract classifier is intended to be used by other classifiers e.g. as the target of general metarelationships or generalization relationships. Default value is false.*/
	attribute isAbstract : Boolean

	@overloadable "true"
	property inheritedMember : set NamedElement[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property general : set Classifier[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	attribute generalization : set Generalization[0..*]#specific

	@overloadable "true"
	property ~attribute : set Property[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	reference redefinedClassifier : set Classifier[0..*]

	attribute substitution : set Substitution[0..*]#substitutingClassifier

	reference powertypeExtent : set GeneralizationSet[0..*]#powertype

	attribute ownedUseCase : set UseCase[0..*]

	reference useCase : set UseCase[0..*]#subject

	/**References a collaboration occurrence which indicates the collaboration that represents this classifier. (Subsets Classifier.occurrence.)*/
	reference representation : CollaborationOccurrence

	/**References the collaboration occurrences owned by the classifier. (Subsets Element. ownedElement.)*/
	attribute occurrence : set CollaborationOccurrence[0..*]

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
member->select(oclIsKindOf(Feature))
</code>*/
	operation allFeatures() : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
not self.allParents()->includes(self)
</code>*/
	operation no_cycles_in_generalization(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.parents()->forAll(c | self.maySpecializeType(c))
</code>*/
	operation specialize_type(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.inheritedMember->includesAll(self.inherit(self.parents()->collect(p | p.inheritableMembers(self)))
</code>*/
	operation inherited_member(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
self.inherit(self.parents()->collect(p | p.inheritableMembers(self))
</code>*/
	operation op_inheritedMember() : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
generalization.general
</code>*/
	operation parents() : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
self.parents()->union(self.parents()->collect(p | p.allParents())
</code>*/
	operation allParents() : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
member->select(m | c.hasVisibilityOf(m))
</code>*/
	operation inheritableMembers(c : Classifier) : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
true
</code>*/
	operation hasVisibilityOf(n : NamedElement) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
inhs
</code>*/
	operation inherit(inhs : Set) : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
self.oclIsKindOf(c.oclType)
</code>*/
	operation maySpecializeType(c : Classifier) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
self.parents()
</code>*/
	operation op_general() : Set is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
general = self.parents()
</code>*/
	operation general_equals_parents(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
(self=other) or (self.allParents()->includes(other))
</code>*/
	operation op_conformsTo(other : Classifier) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
abstract class Feature inherits RedefinableElement
{
	/**The Classifiers that have this Feature as a feature. This is a derived union.*/
@overloadable "true"
	property featuringClassifier : set Classifier[0..*]#feature
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies whether the feature is applied at the classifier-level (true) or the instance-level (false). Default value is false.*/
	attribute isStatic : Boolean

}
class Constraint inherits PackageableElement
{
	/**Specifies the Namespace that is the context for evaluating this constraint. This is a derived union.*/
@overloadable "true"
	property context : Namespace
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	reference namespace : Namespace#ownedRule

	/**A condition that must be true when evaluated in order for the constraint to be satisfied. Subsets Element::ownedElement.*/
	attribute specification : ValueSpecification[1..1]

	/**ordered set of Elements referenced by this Constraint.*/
	reference constrainedElement : Element[0..*]

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
not constrainedElement->includes(self)
</code>*/
	operation not_apply_to_self(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
enumeration VisibilityKind
{
	public;
	private;
	protected;
	~package;
}
class LiteralBoolean inherits LiteralSpecification
{
	/**The specified Boolean value.*/
	attribute ~value : Boolean

}
abstract class LiteralSpecification inherits ValueSpecification
{
}
class LiteralString inherits LiteralSpecification
{
	/**The specified String value.*/
	attribute ~value : String

}
class LiteralNull inherits LiteralSpecification
{
}
class LiteralInteger inherits LiteralSpecification
{
	/**The specified Integer value.*/
	attribute ~value : Integer

}
class LiteralUnlimitedNatural inherits LiteralSpecification
{
	/**The specified UnlimitedNatural value.*/
	attribute ~value : UnlimitedNatural

}
abstract class BehavioralFeature inherits Namespace, Feature
{
	/**Specifies the parameters of the BehavioralFeature. Subsets Namespace::member. This is a derived union and is ordered.*/
@overloadable "true"
	property parameter : Parameter[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies the ordered set of formal parameters of this BehavioralFeature. Subsets BehavioralFeature::parameter and Namespace::ownedMember.*/
	attribute formalParameter : set Parameter[0..*]

	/**Specifies the ordered set of return results of this BehavioralFeature. Subsets Behavioral- Feature::parameter and Namespace::ownedMember.*/
	attribute returnResult : Parameter[0..*]

	/**References the Types representing exceptions that may be raised during an invocation of this operation.*/
	reference raisedException : set Type[0..*]

	/**If true, then the behavioral feature does not have an implementation, and one must be supplied by a more specific element. If false, the behavioral feature must have an implementation in the classifier or one must be inherited from a more general element. Communications*/
	attribute isAbstract : Boolean

	/**A behavioral description that implements the behavioral feature. There may be at most one behavior for a particular pairing of a classifier (as owner of the behavior) and a behavioral feature (as specification of the behavior).*/
	reference ~method : set Behavior[0..*]#specification

	attribute concurrency : CallConcurrencyKind

}
abstract class StructuralFeature inherits Feature, TypedElement, MultiplicityElement
{
	/**States whether the feature’s value may be modified by a client. Default is false.*/
	attribute isReadOnly : Boolean

}
class InstanceSpecification inherits PackageableElement, DeploymentTarget, DeployedArtifact
{
	/**A slot giving the value or values of a structural feature of the instance. An instance specification can have one slot per structural feature of its classifiers, including inherited features. It is not necessary to model a slot for each structural feature, in which case the instance specification is a partial description. Subsets Element::ownedElement.*/
	attribute slot : set Slot[0..*]#owningInstance

	/**The classifier or classifiers of the represented instance. If multiple classifiers are specified, the instance is classified by all of them.*/
	reference classifier : set Classifier[0..*]

	/**A specification of how to compute, derive, or construct the instance. Subsets Element:: ownedElement.*/
	attribute specification : ValueSpecification

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
slot->forAll(s |
  classifier->exists(c | c.allFeatures()->includes(s.definingFeature))
</code>*/
	operation slots_are_defined(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
classifier->forAll(c |
	(c.allFeatures()->forAll(f | slot->select(s | s.definingFeature = f)->size() <= 1)
	)
</code>*/
	operation no_duplicate_slots(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
class Slot inherits Element
{
	/**The instance specification that owns this slot. Subsets Element::owner.*/
	reference owningInstance : InstanceSpecification[1..1]#slot

	attribute ~value : ValueSpecification[0..*]

	/**The structural feature that specifies the values that may be held by the slot.*/
	reference definingFeature : StructuralFeature[1..1]

}
class InstanceValue inherits ValueSpecification
{
	/**The instance that is the specified value.*/
	reference instance : InstanceSpecification[1..1]

}
abstract class RedefinableElement inherits NamedElement
{
	/**the contexts that this element may be redefined from. This is a derived union.*/
@overloadable "true"
	property redefinitionContext : Classifier[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Indicates whether it is possible to further specialize a RedefinableElement. If the value is true, then it is not possible to further specialize the RedefinableElement. Default value is false.*/
	attribute isLeaf : Boolean

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.redefinedElement->forAll(e | self.isRedefinitionContextValid(e))
</code>*/
	operation redefinition_context_valid(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.redefinedElement->forAll(re | re.isConsistentWith(self))
</code>*/
	operation redefinition_consistent(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
false
</code>*/
	operation isConsistentWith(redefinee : RedefinableElement) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
self.redefinitionContext->exists(c | redefinable.redefinitionContext->exists(r | c.allParents()->includes(r)))
</code>*/
	operation isRedefinitionContextValid(redefinable : RedefinableElement) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
class Generalization inherits DirectedRelationship
{
	/**References the specializing classifier in the Generalization relationship. Subsets DirectedRelationship::source and Element::owner. Package PowerTypes (“PowerTypes” on page 109) • generalizationSet Designates a set in which instances of Generalization is considered members.*/
	reference specific : Classifier[1..1]#generalization

	/**References the general classifier in the Generalization relationship. Subsets DirectedRelationship::target.*/
	reference general : Classifier[1..1]

	/**Indicates whether the specific classifier can be used whereever the general classifier can be used. If true, the execution traces of the specific classifier will be a superset of the execution traces of the general classifier.*/
	attribute isSubstitutable : Boolean

	reference generalizationSet : set GeneralizationSet[0..*]#generalization

}
abstract class PackageableElement inherits NamedElement, ParameterableElement
{
	/**Indicates that packageable elements must always have a visibility, i.e., visibility is not optional. Redefines NamedElement::visibility.*/
	attribute packageableElement_visibility : VisibilityKind

}
class ElementImport inherits DirectedRelationship
{
	/**Specifies the visibility of the imported PackageableElement within the importing Package. The default visibility is the same as that of the imported element. If the imported element does not have a visibility, it is possible to add visibility to the element import.*/
	attribute visibility : VisibilityKind

	/**Specifies the name that should be added to the namespace of the importing Pack-age in lieu of the name of the imported PackagableElement. The aliased name must not clash with any other member name in the importing Package. By default, no alias is used.*/
	attribute ~alias : String

	/**Specifies the PackageableElement whose name is to be added to a Namespace. Subsets DirectedRelationship::target.*/
	reference importedElement : PackageableElement[1..1]

	/**Specifies the Namespace that imports a PackageableElement from another Package. Subsets DirectedRelationship::source and Element::owner.*/
	reference importingNamespace : Namespace[1..1]#elementImport

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.visibility = #public or self.visibility = #private
</code>*/
	operation visibility_public_or_private(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.importedElement.visibility.notEmpty() implies self.importedElement.visibility = #public
</code>*/
	operation imported_element_is_public(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
/**A query based on the following OCL expression:
<code>
if self.alias->notEmpty() then 
    self.alias
else
    self.importedElement.name
endif
</code>*/
	operation getName() : String is
		raise kermeta::exceptions::NotImplementedException.new

}
class PackageImport inherits DirectedRelationship
{
	/**Specifies the visibility of the imported PackageableElements within the import-ing Namespace, i.e., whether imported elements will in turn be visible to other packages that use that importingPackage as an importedPackage. If the PackageImport is public, the imported elements will be visible outside the package, while if it is private they will not. By default, the value of visibility is public.*/
	attribute visibility : VisibilityKind

	/**Specifies the Package whose members are imported into a Namespace. Subsets DirectedRelationship::target.*/
	reference importedPackage : Package[1..1]

	/**Specifies the Namespace that imports the members from a Package. Subsets DirectedRelationship::source and Element::owner.*/
	reference importingNamespace : Namespace[1..1]#packageImport

	@overloadable "true"
/**An invariant constraint based on the following OCL expression:
<code>
self.visibility = #public or self.visibility = #private
</code>*/
	operation public_or_private(diagnostics : ecore::EDiagnosticChain, context : ecore::EMap) : Boolean is
		raise kermeta::exceptions::NotImplementedException.new

}
class Association inherits Classifier, Relationship
{
	/**Specifies whether the association is derived from other model elements such as other associations or constraints. The default value is false.*/
	attribute isDerived : Boolean

	/**The non-navigable ends that are owned by the association itself. This is an ordered association. Subsets Association::memberEnd, Classifier::feature, and Namespace::owned- Member.*/
	attribute ownedEnd : Property[0..*]#owningAssociation

	/**References the classifiers that are used as types of the ends of the association.*/
@overloadable "true"
	property endType : set Type[1..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Each end represents participation of instances of the classifier connected to the end in links of the association. This is an ordered association. Subsets Namespace::member.*/
	reference memberEnd : Property[2..*]#association

}
class PackageMerge inherits DirectedRelationship
{
	/**References the Package that is being extended with the contents of the target of the PackageMerge. Subsets Element::owner and DirectedRelationship::source.*/
	reference mergingPackage : Package[1..1]#packageMerge

	/**References the Package that is to be merged with the source of the PackageMerge. Subsets DirectedRelationship;;target.*/
	reference mergedPackage : Package[1..1]

}
class Stereotype inherits Class
{
}
class Profile inherits Package
{
	@overloadable "true"
	property ownedStereotype : set Stereotype[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	reference metaclassReference : set ElementImport[0..*]

	reference metamodelReference : set PackageImport[0..*]

}
class ProfileApplication inherits PackageImport
{
	reference importedProfile : Profile[1..1]

}
class Extension inherits Association
{
	@overloadable "true"
	property isRequired : Boolean
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property metaclass : Class[1..1]#extension
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

}
class ExtensionEnd inherits Property
{
}
enumeration ParameterDirectionKind
{
	in;
	inout;
	out;
	return;
}
enumeration AggregationKind
{
	none;
	shared;
	composite;
}
abstract class Behavior inherits Class
{
	/**Tells whether the behavior can be invoked while it is still executing from a previous invocation.*/
	attribute isReentrant : Boolean

	/**The classifier owning the behavior. The features of the context classifier as well as the elements visible to the context classifier are visible to the behavior.*/
	reference context : BehavioredClassifier#ownedBehavior

	reference redefinedBehavior : set Behavior[0..*]

	/**Designates a behavioral feature that the behavior implements. The behavioral feature must be owned by the classifier that owns the behavior or be inherited by it. The parameters of the behavioral feature and the implementing behavior must match. If a behavior does not have a specification, it is directly associated with a classifier (i.e., it is the behavior of the classifier as a whole).*/
	reference specification : BehavioralFeature#~method

	/**References a list of parameters to the behavior which describes the order and type of arguments that can be given when the behavior is invoked and of the values which will be returned when the behavior completes its execution. (Specializes Namespace.owned- Member.)*/
	attribute parameter : Parameter[0..*]

	@overloadable "true"
	property formalParameter : Parameter[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property returnResult : Parameter[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	reference precondition : set Constraint[0..*]

	reference postcondition : set Constraint[0..*]

	attribute ownedParameterSet : set ParameterSet[0..*]

}
abstract class BehavioredClassifier inherits Classifier
{
	/**References behavior specifications owned by a classifier. (Specializes Namespace.owned- Member.)*/
	attribute ownedBehavior : set Behavior[0..*]#context

	/**A behavior specification that specifies the behavior of the classifier itself. (Specializes BehavioredClassifier.ownedBehavior.)*/
	reference classifierBehavior : Behavior

	/**(Specializes Element.ownedElement and Realization.clientDependency.)*/
	attribute implementation : set Implementation[0..*]#implementingClassifier

	attribute ownedTrigger : set Trigger[0..*]

	attribute ownedStateMachine : set StateMachine[0..*]#stateMachine_redefinitionContext

}
class Activity inherits Behavior
{
	/**A textual representation of the computation in the surface language determined by the language attribute.*/
	attribute body : String

	/**Specifies the language in which the body of the activity is stated. The interpretation of the expression body depends on the language.*/
	attribute language : String

	attribute edge : set ActivityEdge[0..*]#activity

	attribute group : set ActivityGroup[0..*]#activityGroup_activity

	attribute node : set ActivityNode[0..*]#activity

	reference action : Action[0..*]

	@overloadable "true"
	property structuredNode : set StructuredActivityNode[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	attribute isSingleExecution : Boolean

	attribute isReadOnly : Boolean

}
class Permission inherits Dependency
{
}
class Dependency inherits PackageableElement, DirectedRelationship
{
	/**The element that is affected by the supplier element. In some cases (such as a Trace Abstraction) the direction is unimportant and serves only to distinguish the two elements.*/
	reference client : set NamedElement[1..*]#clientDependency

	/**Designates the element that is unaffected by a change. In a two-way relationship (such as some Refinement Abstractions) this would be the more general element. In an undirected situation, such as a Trace Abstraction, the choice of client and supplier is not relevant.*/
	reference supplier : set NamedElement[1..*]

}
class Usage inherits Dependency
{
}
class Abstraction inherits Dependency
{
	/**An composition of an Expression that states the abstraction relationship between the supplier and the client. In some cases, such as Derivation, it is usually formal and unidirectional; in other cases, such as Trace, it is usually informal and bidirectional. The mapping expression is optional and may be omitted if the precise relationship between the elements is not specified.*/
	attribute mapping : OpaqueExpression

}
class Realization inherits Abstraction
{
	reference abstraction : Component#realization

	reference realizingClassifier : Classifier[1..1]

}
class Substitution inherits Realization
{
	/**(Specializes Dependency.target.)*/
	reference contract : Classifier[1..1]

	/**(Specializes Dependency.client.)*/
	reference substitutingClassifier : Classifier[1..1]#substitution

}
class GeneralizationSet inherits PackageableElement
{
	/**Indicates (via the associated Generalizations) whether or not the set of specific Classifiers are covering for a particular general classifier. When isCovering is true, every instance of a particular general Classifier is also an instance of at least one of its specific Classifiers for the GeneralizationSet. When isCovering is false, there are one or more instances of the particular general Classifier that are not instances of at least one of its specific Classifiers defined for the GeneralizationSet. For example, Person could have two Generalization relationships each with a different specific Classifier: Male Person and Female Person. This GeneralizationSet would be covering because every instance of Person would be an instance of Male Person or Female Person. In contrast, Person could have a three Generalization relationships involving three specific Classifiers: North AmericanPerson, Asian Person, and European Person. This GeneralizationSet would not be covering because there are instances of Person for which these three specific Classifiers do not apply. The first example, then, could be read: any Person would be specialized as either being a Male Person or a Female Person—and nothing else; the second could be read: any Person would be specialized as being North American Person, Asian Person, European Person, or something else.*/
	attribute isCovering : Boolean

	/**Indicates whether or not the set of specific Classifiers in a Generalization relationship have instance in common. If isDisjoint is true, the specific Classifiers for a particular GeneralizationSet have no members in common; that is, their intersection is empty. If isDisjoint is false, the specific Classifiers in a particular GeneralizationSet have one or more members in common; that is, their intersection is not empty. For example, Person could have two Generalization relationships, each with the different specific Classifier: Manager or Staff. This would be disjoint because every instance of Person must either be a Manager or Staff. In contrast, Person could have two Generalization relationships involving two specific (and non-covering) Classifiers: Sales Person and Manager. This Generalization- Set would not be disjoint because there are instances of Person which can be a Sales Person and a Manager.*/
	attribute isDisjoint : Boolean

	reference powertype : Classifier#powertypeExtent

	reference generalization : set Generalization[0..*]#generalizationSet

}
class AssociationClass inherits Class, Association
{
}
class InformationItem inherits Classifier
{
	/**: Determines the classifiers that will specify the structure and nature of the information. An information item represents all its represented classifiers. Customer Company Employee product wage <<flow>> <<flow>>*/
	reference represented : set Classifier[0..*]

}
class InformationFlow inherits PackageableElement, DirectedRelationship
{
	/**: Determines which Relationship will realize the specified flow*/
	reference realization : set Relationship[0..*]

	/**: Specifies the information items that may circulate on this information flow.*/
	reference conveyed : set Classifier[1..*]

}
class Model inherits Package
{
	/**The name of the viewpoint that is expressed by a model (This name may refer to a profile definition).*/
	attribute viewpoint : String

}
class ConnectorEnd inherits MultiplicityElement
{
	@overloadable "true"
	property definingEnd : Property
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**The connectable element attached at this connector end. When an instance of the containing classifier is created, a link may (depending on the multiplicities) be created to an instance of the classifier that types this connectable element.*/
	reference role : ConnectableElement#~end

	reference partWithPort : Property

}
abstract class ConnectableElement inherits NamedElement, ParameterableElement
{
	/**Denotes a connector that attaches to this connectable element.*/
	reference ~end : set ConnectorEnd[0..*]#role

}
class Connector inherits Feature
{
	/**An optional association that specifies the link corresponding to this connector.*/
	reference type : Association

	/**connector may be redefined when its containing classifier is specialized. The redefining connector may have a type that specializes the type of the redefined connector. The types of the connector ends of the redefining connector may specialize the types of the connector ends of the redefined connector. The properties of the connector ends of the redefining connector may be replaced. (Subsets Element.redefinedElement.)*/
	reference redefinedConnector : set Connector[0..*]

	/**A connector consists of at two connector ends, each of which represents the participation of instances of the classifiers typing the connectable elements attached to this end. The set of connector ends is ordered. (Subsets Element.ownedElement.)*/
	attribute ~end : ConnectorEnd[2..*]

	attribute kind : ConnectorKind

	reference contract : set Behavior[0..*]

}
abstract class StructuredClassifier inherits Classifier
{
	/**References the properties owned by the classifier. (Subsets StructuredClassifier.role, Classifier. attribute,and Namespace.ownedMember)*/
	attribute ownedAttribute : Property[0..*]

	/**References the properties specifying instances that the classifier owns by composition. This association is derived, selecting those owned properties where isComposite is true.*/
@overloadable "true"
	property part : set Property[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**References the roles that instances may play in this classifier. (Abstract union; subsets Classifier.feature.)*/
@overloadable "true"
	property role : set ConnectableElement[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**References the connectors owned by the classifier. (Subsets Classifier.feature and Namespace.ownedMember)*/
	attribute ownedConnector : set Connector[0..*]

}
abstract class ActivityEdge inherits RedefinableElement
{
	reference activity : Activity#edge

	reference source : ActivityNode[1..1]#outgoing

	reference target : ActivityNode[1..1]#incoming

	@overloadable "true"
	property inGroup : set ActivityGroup[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	attribute guard : ValueSpecification[1..1]

	reference redefinedElement : set ActivityEdge[0..*]

	/**Structured activity node containing the edge.*/
	reference inStructuredNode : StructuredActivityNode#containedEdge

	reference inPartition : set ActivityPartition[0..*]#containedEdge

	attribute weight : ValueSpecification[1..1]

	reference interrupts : InterruptibleActivityRegion#interruptingEdge

}
abstract class ActivityGroup inherits Element
{
	@overloadable "true"
	property superGroup : ActivityGroup
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Activity containing the group.*/
	reference activityGroup_activity : Activity#group

}
abstract class ActivityNode inherits RedefinableElement
{
	reference outgoing : set ActivityEdge[0..*]#source

	reference incoming : set ActivityEdge[0..*]#target

	@overloadable "true"
	property inGroup : set ActivityGroup[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	reference activity : Activity#node

	reference redefinedElement : set ActivityNode[0..*]

	/**Structured activity node containing the node.*/
	reference inStructuredNode : StructuredActivityNode#containedNode

	reference inPartition : set ActivityPartition[0..*]#containedNode

	reference inInterruptibleRegion : set InterruptibleActivityRegion[0..*]#containedNode

}
class Action inherits ExecutableNode
{
	attribute effect : String

	@overloadable "true"
	property output : OutputPin[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property input : InputPin[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property context : Classifier
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Constraint that must be satisfied when execution is started.*/
	attribute localPrecondition : set Constraint[0..*]

	/**Constraint that must be satisfied when executed is completed.*/
	attribute localPostcondition : set Constraint[0..*]

}
abstract class ObjectNode inherits ActivityNode, TypedElement
{
	/**= FIFO Tells whether and how the tokens in the object node are ordered for selection to traverse edges outgoing from the object node.*/
	attribute ordering : ObjectNodeOrderingKind

	attribute upperBound : ValueSpecification[1..1]

	/**The required states of the object available at this point in the activity.*/
	reference inState : set State[0..*]

	reference selection : Behavior

}
abstract class ControlNode inherits ActivityNode
{
}
class ControlFlow inherits ActivityEdge
{
}
class ObjectFlow inherits ActivityEdge
{
	attribute isMulticast : Boolean

	attribute isMultireceive : Boolean

	/**Changes or replaces data tokens flowing along edge.*/
	reference transformation : Behavior

	/**Selects tokens from a source object node.*/
	reference selection : Behavior

}
class InitialNode inherits ControlNode
{
}
abstract class FinalNode inherits ControlNode
{
}
class ActivityFinalNode inherits FinalNode
{
}
class DecisionNode inherits ControlNode
{
	/**Provides input to guard specifications on edges outgoing from the decision node.*/
	reference decisionInput : Behavior

}
class MergeNode inherits ControlNode
{
}
abstract class ExecutableNode inherits ActivityNode
{
	/**A set of exception handlers that are examined if an uncaught exception propagates to the outer level of the executable node.*/
	attribute handler : set ExceptionHandler[0..*]#protectedNode

}
class OutputPin inherits Pin
{
}
class InputPin inherits Pin
{
}
abstract class Pin inherits ObjectNode, MultiplicityElement
{
}
class ActivityParameterNode inherits ObjectNode
{
	/**The parameter the object node will be accepting and providing values for.*/
	reference parameter : Parameter[1..1]

}
class ValuePin inherits InputPin
{
	/**Value that the pin will provide.*/
	attribute ~value : ValueSpecification[1..1]

}
class Interface inherits Classifier
{
	/**References the properties owned by the Interface. (Subsets Namespace.ownedMember and Classifier.feature.)*/
	attribute ownedAttribute : Property[0..*]

	/**References the operations owned by the Interface. (Subsets Namespace.ownedMember and Classifier.feature.)*/
	attribute ownedOperation : Operation[0..*]

	/**(Subsets Element.redefinedElement.)*/
	reference redefinedInterface : set Interface[0..*]

	attribute nestedClassifier : Classifier[0..*]

	/**Receptions that objects providing this interface are willing to accept. (Subsets Namespace.ownedMember and Classifier.feature.)*/
	attribute ownedReception : set Reception[0..*]

	/**References a protocol state machine specifying the legal sequences of the invocation of the behavioral features described in the interface.*/
	attribute protocol : ProtocolStateMachine

}
class Implementation inherits Realization
{
	/**References the Interface specifying the conformance contract. (Specializes Dependency. supplier and Relationship.target)*/
	reference contract : Interface[1..1]

	/**References the operations owned by the Interface. (Specializes Dependency.client and Relationship.source)*/
	reference implementingClassifier : BehavioredClassifier[1..1]#implementation

}
class Artifact inherits Classifier, DeployedArtifact
{
	attribute fileName : String

	attribute nestedArtifact : set Artifact[0..*]

	attribute manifestation : set Manifestation[0..*]

	attribute ownedOperation : Operation[0..*]

	attribute ownedAttribute : Property[0..*]

}
class Manifestation inherits Abstraction
{
	/**The model element that is utilized in the manifestation in an Artifact. This association specializes the supplier association.*/
	reference utilizedElement : PackageableElement[1..1]

}
class Actor inherits Classifier
{
}
class Extend inherits NamedElement, DirectedRelationship
{
	/**References the use case that is being extended. (Specializes DirectedRelationship.target.)*/
	reference extendedCase : UseCase[1..1]

	reference extension : UseCase[1..1]#extend

	attribute condition : Constraint

	reference extensionLocation : ExtensionPoint[1..*]

}
class UseCase inherits BehavioredClassifier
{
	attribute include : set Include[0..*]#includingCase

	attribute extend : set Extend[0..*]#extension

	attribute extensionPoint : set ExtensionPoint[0..*]#useCase

	reference subject : set Classifier[0..*]#useCase

}
class ExtensionPoint inherits RedefinableElement
{
	reference useCase : UseCase[1..1]#extensionPoint

}
class Include inherits NamedElement, DirectedRelationship
{
	/**References the use case which will include the addition and owns the include relationship. (Specializes DirectedRelationship.source.)*/
	reference includingCase : UseCase[1..1]#include

	/**References the use case that is to be included. (Specializes DirectedRelationship.target.)*/
	reference addition : UseCase[1..1]

}
class CollaborationOccurrence inherits NamedElement
{
	/**The collaboration which is used in this occurrence. The collaboration defines the cooperation between its roles which are mapped to properties of the classifier owning the collaboration occurrence.*/
	reference type : Collaboration[1..1]

	attribute roleBinding : set Dependency[0..*]

}
class Collaboration inherits BehavioredClassifier, StructuredClassifier
{
	reference collaborationRole : set ConnectableElement[0..*]

}
class Port inherits Property
{
	/**Specifies whether requests arriving at this port are sent to the classifier behavior of this classifier (see “BehavioredClassifier (from BasicBehaviors)” on page 387). Such ports are referred to as behavior port. Any invocation of a behavioral feature targeted at a behavior port will be handled by the instance of the owning classifier itself, rather than by any instances that this classifier may contain. The default value is false.*/
	attribute isBehavior : Boolean

	/**If true indicates that this port is used to provide the published functionality of a classifier; if false, this port is used to implement the classifier but is not part of the essential externally- visible functionality of the classifier and can, therefore, be altered or deleted along with the internal implementation of the classifier and other properties that are considered part of its implementation. The default value for this attribute is true.*/
	attribute isService : Boolean

	/**References the interfaces specifying the set of operations and receptions which the classifier expects its environment to handle. This association is derived as the set of interfaces required by the type of the port or its supertypes.*/
@overloadable "true"
	property required : set Interface[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**A port may be redefined when its containing classifier is specialized. The redefining port may have additional interfaces to those that are associated with the redefined port or it may replace an interface by one of its subtypes. (Subsets Element.redefinedElement.)*/
	reference redefinedPort : set Port[0..*]

	/**References the interfaces specifying the set of operations and receptions which the classifier offers to its environment, and which it will handle either directly or by forwarding it to a part of its internal structure. This association is derived from the interfaces realized by the type of the port or by the type of the port, if the port was typed by an interface.*/
@overloadable "true"
	property provided : set Interface[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**References an optional protocol state machine which describes valid interactions at this interaction point.*/
	reference protocol : ProtocolStateMachine

}
abstract class EncapsulatedClassifier inherits StructuredClassifier
{
	/**References a set of ports that an encapsulated classifier owns. (Subsets Classifier.feature and Namespace.ownedMember.)*/
	attribute ownedPort : set Port[0..*]

}
enumeration CallConcurrencyKind
{
	sequential;
	guarded;
	concurrent;
}
class CallTrigger inherits MessageTrigger
{
	/**Designates the operation whose invocation raised the call event that is specified by the call trigger.*/
	reference ~operation : Operation[1..1]

}
abstract class MessageTrigger inherits Trigger
{
}
class ChangeTrigger inherits Trigger
{
	/**A Boolean-valued expression that will result in a change event whenever its value changes from false to true.*/
	attribute changeExpression : ValueSpecification[1..1]

}
abstract class Trigger inherits NamedElement
{
	/**Specifies the ports at which a communication that caused an event may have arrived.*/
	reference port : set Port[0..*]

}
class Reception inherits BehavioralFeature
{
	/**The signal that this reception handles.*/
	reference signal : Signal

}
class Signal inherits Classifier
{
	attribute ownedAttribute : Property[0..*]

}
class SignalTrigger inherits MessageTrigger
{
	reference signal : Signal[0..*]

}
class TimeTrigger inherits Trigger
{
	/**Specifies whether it is relative or absolute time.*/
	attribute isRelative : Boolean

	/**Specifies the corresponding time deadline.*/
	attribute when : ValueSpecification[1..1]

}
class AnyTrigger inherits MessageTrigger
{
}
class Variable inherits ConnectableElement, TypedElement, MultiplicityElement
{
	reference scope : StructuredActivityNode[1..1]#variable

}
class StructuredActivityNode inherits Action, Namespace, ActivityGroup
{
	attribute variable : set Variable[0..*]#scope

	attribute containedNode : ActivityNode[0..*]#inStructuredNode

	attribute containedEdge : ActivityEdge[0..*]#inStructuredNode

	attribute mustIsolate : Boolean

}
class ConditionalNode inherits StructuredActivityNode
{
	attribute isDeterminate : Boolean

	attribute isAssured : Boolean

	attribute clause : set Clause[1..*]

	/**A list of output pins that constitute the data flow outputs of the conditional.*/
	attribute ~result : OutputPin[0..*]

}
class Clause inherits Element
{
	reference test : set ActivityNode[0..*]

	reference body : set ActivityNode[0..*]

	reference predecessorClause : set Clause[0..*]#successorClause

	reference successorClause : set Clause[0..*]#predecessorClause

	reference decider : OutputPin[1..1]

	/**A list of output pins within the body fragment whose values are copied to the result pins of the containing conditional node or conditional node after execution of the clause body.*/
	reference bodyOutput : set OutputPin[0..*]

}
class LoopNode inherits StructuredActivityNode
{
	attribute isTestedFirst : Boolean

	reference bodyPart : set ActivityNode[0..*]

	reference setupPart : set ActivityNode[0..*]

	reference decider : OutputPin[1..1]

	reference test : set ActivityNode[0..*]

	/**A list of output pins that constitute the data flow output of the entire loop.*/
	attribute ~result : OutputPin[0..*]

	/**A list of output pins owned by the loop that hold the values of the loop variables during an execution of the loop. When the test fails, the values are copied to the result pins of the loop.*/
	attribute loopVariable : OutputPin[0..*]

	/**A list of output pins within the body fragment the values of which are copied to the loop variable pins after completion of execution of the body, before the next iteration of the loop begins or before the loop exits.*/
	reference bodyOutput : set OutputPin[0..*]

	/**A list of values that are copied into the loop variable pins before the first iteration of the loop.*/
	attribute loopVariableInput : InputPin[0..*]

}
class Interaction inherits Behavior, InteractionFragment
{
	attribute lifeline : set Lifeline[0..*]#interaction

	attribute message : set Message[0..*]#interaction

	attribute fragment : InteractionFragment[0..*]#enclosingInteraction

	/**Specifies the gates that form the message interface between this Interaction and any InteractionOccurrences which reference it.*/
	attribute formalGate : set Gate[0..*]

}
abstract class InteractionFragment inherits NamedElement
{
	reference covered : Lifeline[0..*]#coveredBy

	attribute generalOrdering : set GeneralOrdering[0..*]

	reference enclosingInteraction : Interaction#fragment

	/**operand enclosing this InteractionFragment (they may nest recursively)*/
	reference enclosingOperand : InteractionOperand#fragment

}
class Lifeline inherits NamedElement
{
	reference coveredBy : set InteractionFragment[0..*]#covered

	/**the ConnectableElement within the classifier that contains the enclosing interaction.*/
	reference represents : ConnectableElement[1..1]

	/**References the Interaction enclosing this Lifeline.*/
	reference interaction : Interaction[1..1]#lifeline

	/**If the referenced ConnectableElement is multivalued, then this specifies the specific individual part within that set.*/
	attribute selector : OpaqueExpression

	reference decomposedAs : PartDecomposition

}
class Message inherits NamedElement
{
	/**The derived kind of the Message (complete, lost, found or unknown) complete = sendEvent and receiveEvent are present lost = sendEvent present and receiveEvent absent found = sendEvent absent and receiveEvent present unknown = sendEvent and receiveEvent absent (should not appear)*/
@overloadable "true"
	property messageKind : MessageKind
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	attribute messageSort : MessageSort

	/**the Receiving of the Message*/
	reference receiveEvent : MessageEnd#receiveMessage

	/**References the Sending of the Message.*/
	reference sendEvent : MessageEnd#sendMessage

	/**The Connector on which this Message is sent.*/
	reference connector : Connector

	/**The enclosing Interaction owning the Message*/
	reference interaction : Interaction[1..1]#message

	/**The definition of the type or signature of the Message (depending on its kind)*/
	reference signature : NamedElement

	/**arguments of the Message*/
	attribute argument : set ValueSpecification[0..*]

}
class GeneralOrdering inherits NamedElement
{
	/**The Eventoccurrence referred comes before the Eventoccurrence referred by after*/
	reference before : EventOccurrence[1..1]#toAfter

	/**The Eventoccurrence referred comes after the Eventoccurrence referred by before*/
	reference after : EventOccurrence[1..1]#toBefore

}
enumeration MessageKind
{
	complete;
	lost;
	found;
	unknown;
}
enumeration MessageSort
{
	synchCall;
	synchSignal;
	asynchCall;
	asynchSignal;
}
abstract class MessageEnd inherits NamedElement
{
	/**the Message that contains the information of a receiveEvent*/
	reference receiveMessage : Message#receiveEvent

	/**References the Message that contains the information of a sendEvent*/
	reference sendMessage : Message#sendEvent

}
class EventOccurrence inherits InteractionFragment, MessageEnd
{
	reference startExec : set ExecutionOccurrence[0..*]#start

	reference finishExec : set ExecutionOccurrence[0..*]#finish

	reference toAfter : set GeneralOrdering[0..*]#before

	reference toBefore : set GeneralOrdering[0..*]#after

}
class ExecutionOccurrence inherits InteractionFragment
{
	/**References the Eventoccurrence that designates the start of the Action*/
	reference start : EventOccurrence[1..1]#startExec

	/**References the Eventoccurrence that designates the finish of the Action.*/
	reference finish : EventOccurrence[1..1]#finishExec

	/**References the associated behavior*/
	reference behavior : Behavior[0..*]

}
class StateInvariant inherits InteractionFragment
{
	/**A Constraint that should hold at runtime for this StateInvariant*/
	attribute invariant : Constraint[1..1]

}
class Stop inherits EventOccurrence
{
}
class TemplateSignature inherits Element
{
	/**The complete set of formal template parameters for this template signature.*/
	reference parameter : set TemplateParameter[1..*]

	/**The formal template parameters that are owned by this template signature. Subsets parameter and Element::ownedElement.*/
	attribute ownedParameter : set TemplateParameter[0..*]#signature

	reference nestedSignature : set TemplateSignature[0..*]#nestingSignature

	reference nestingSignature : TemplateSignature#nestedSignature

	/**element that owns this template signature. Subsets Element::owner.*/
	reference template : TemplateableElement[1..1]#ownedTemplateSignature

}
class TemplateParameter inherits Element
{
	reference signature : TemplateSignature[1..1]#ownedParameter

	reference parameteredElement : ParameterableElement[1..1]#templateParameter

	attribute ownedParameteredElement : ParameterableElement#owningParameter

	/**element that is the default for this formal template parameter.*/
	reference default : ParameterableElement

	attribute ownedDefault : ParameterableElement

}
abstract class TemplateableElement inherits Element
{
	/**optional bindings from this element to templates.*/
	attribute templateBinding : set TemplateBinding[0..*]#boundElement

	attribute ownedTemplateSignature : TemplateSignature#template

	@overloadable "true"
	operation parameterableElements() : Set is
		raise kermeta::exceptions::NotImplementedException.new

}
class StringExpression inherits TemplateableElement
{
	attribute subExpression : set StringExpression[0..*]#owningExpression

	reference owningExpression : StringExpression#subExpression

}
abstract class ParameterableElement inherits Element
{
	reference templateParameter : TemplateParameter#parameteredElement

	reference owningParameter : TemplateParameter#ownedParameteredElement

}
class TemplateBinding inherits DirectedRelationship
{
	/**element that is bound by this binding. Subsets DirectedRelationship::source.*/
	reference boundElement : TemplateableElement[1..1]#templateBinding

	reference signature : TemplateSignature[1..1]

	/**parameter substitutions owned by this template binding. Subsets Element::ownedElement.*/
	attribute parameterSubstitution : set TemplateParameterSubstitution[0..*]#templateBinding

}
class TemplateParameterSubstitution inherits Element
{
	/**The formal template parameter that is associated with this substitution.*/
	reference formal : TemplateParameter[1..1]

	reference templateBinding : TemplateBinding[1..1]#parameterSubstitution

	/**elements that are the actual parameters for this substitution.*/
	reference actual : set ParameterableElement[1..*]

	/**The actual parameters that are owned by this substitution. Subsets Element:: ownedElement and actual.*/
	attribute ownedActual : set ParameterableElement[0..*]

}
class OperationTemplateParameter inherits TemplateParameter
{
}
class ClassifierTemplateParameter inherits TemplateParameter
{
	/**the required relationship between an actual parameter and the parameteredElement for this formal parameter. Default is true.*/
	attribute allowSubstitutable : Boolean

}
abstract class ParameterableClassifier inherits Classifier
{
}
class RedefinableTemplateSignature inherits RedefinableElement, TemplateSignature
{
}
abstract class TemplateableClassifier inherits Classifier
{
}
class ConnectableElementTemplateParameter inherits TemplateParameter
{
}
class ForkNode inherits ControlNode
{
}
class JoinNode inherits ControlNode
{
	/**Tells whether tokens having objects with the same identity are combined into one by the join. Default value is true.*/
	attribute isCombineDuplicate : Boolean

	/**A specification giving the conditions under which the join will emit a token. Default is “and”.*/
	attribute joinSpec : ValueSpecification[1..1]

}
class FlowFinalNode inherits FinalNode
{
}
class CentralBufferNode inherits ObjectNode
{
}
class ActivityPartition inherits NamedElement, ActivityGroup
{
	/**Tells whether the partition groups other partitions along a dimension.*/
	attribute isDimension : Boolean

	/**Tells whether the partition represents an entity to which the partitioning structure does not apply.*/
	attribute isExternal : Boolean

	reference containedEdge : ActivityEdge[0..*]#inPartition

	reference containedNode : ActivityNode[0..*]#inPartition

	attribute subgroup : set ActivityPartition[0..*]#superPartition

	reference superPartition : ActivityPartition#subgroup

	/**An element constraining behaviors invoked by nodes in the partition.*/
	reference represents : Element

}
class ExpansionNode inherits ObjectNode
{
	/**expansion region for which the node is an output.*/
	reference regionAsOutput : ExpansionRegion#outputElement

	/**expansion region for which the node is an input.*/
	reference regionAsInput : ExpansionRegion#inputElement

}
class ExpansionRegion inherits StructuredActivityNode
{
	/**The way in which the executions interact: parallel — all interactions are independent iterative — the interactions occur in order of the elements stream — a stream of values flows into a single execution*/
	attribute mode : ExpansionKind

	/**An object node that accepts a separate element of the output collection during each of the multiple executions of the region. The values are formed into a collection that is available when the execution of the region is complete.*/
	reference outputElement : set ExpansionNode[0..*]#regionAsOutput

	/**An object node that holds a separate element of the input collection during each of the multiple executions of the region.*/
	reference inputElement : set ExpansionNode[1..*]#regionAsInput

}
enumeration ExpansionKind
{
	parallel;
	iterative;
	stream;
}
class ExceptionHandler inherits Element
{
	/**The node protected by the handler. The handler is examined if an exception propagates to the outside of the node.*/
	reference protectedNode : ExecutableNode[1..1]#handler

	/**A node that is executed if the handler satisfies an uncaught exception.*/
	reference handlerBody : ExecutableNode[1..1]

	reference exceptionInput : ObjectNode[1..1]

	reference exceptionType : set Classifier[1..*]

}
class InteractionOccurrence inherits InteractionFragment
{
	/**Refers to the Interaction that defines its meaning*/
	reference refersTo : Interaction[1..1]

	/**The actual gates of the InteractionOccurrence*/
	attribute actualGate : set Gate[0..*]

	/**The actual arguments of the Interaction*/
	attribute argument : set InputPin[0..*]

}
class Gate inherits MessageEnd
{
}
class PartDecomposition inherits InteractionOccurrence
{
}
class InteractionOperand inherits Namespace, InteractionFragment
{
	/**of the operand*/
	attribute guard : InteractionConstraint

	/**fragments of the operand.*/
	attribute fragment : set InteractionFragment[0..*]#enclosingOperand

}
class InteractionConstraint inherits Constraint
{
	/**minimum number of iterations of a loop*/
	attribute minint : ValueSpecification

	/**maximum number of iterations of a loop*/
	attribute maxint : ValueSpecification

}
enumeration InteractionOperator
{
	~seq;
	alt;
	opt;
	break;
	par;
	strict;
	~loop;
	critical;
	neg;
	assert;
	ignore;
	consider;
}
class CombinedFragment inherits InteractionFragment
{
	/**Specifies the operation which defines the semantics of this combination of InteractionFragments.*/
	attribute interactionOperator : InteractionOperator

	/**set of operands of the combined fragment.*/
	attribute operand : set InteractionOperand[1..*]

	/**Specifies the gates that form the interface between this CombinedFragment and its surroundings*/
	attribute cfragmentGate : set Gate[0..*]

}
class Continuation inherits InteractionFragment
{
	/**True: when the Continuation is at the end of the enclosing InteractionFragment and False when it is in the beginning.*/
	attribute setting : Boolean

}
class StateMachine inherits Behavior
{
	attribute region : set Region[1..*]#stateMachine

	attribute connectionPoint : set Pseudostate[0..*]

	reference extendedStateMachine : StateMachine

	reference stateMachine_redefinitionContext : BehavioredClassifier#ownedStateMachine

}
class Region inherits Namespace, RedefinableElement
{
	attribute subvertex : set Vertex[0..*]#container

	attribute transition : set Transition[0..*]#container

	reference stateMachine : StateMachine#region

	reference state : State#region

	reference extendedRegion : Region

}
class Pseudostate inherits Vertex
{
	attribute kind : PseudostateKind

}
class State inherits Namespace, RedefinableElement, Vertex
{
	@overloadable "true"
	property isComposite : Boolean
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property isOrthogonal : Boolean
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property isSimple : Boolean
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property isSubmachineState : Boolean
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	reference submachine : StateMachine

	attribute connection : set ConnectionPointReference[0..*]

	reference redefinedState : State

	reference deferrableTrigger : set Trigger[0..*]

	attribute region : set Region[0..*]#state

	attribute entry : Activity

	attribute exit : Activity

	attribute doActivity : Activity

	attribute stateInvariant : Constraint

}
abstract class Vertex inherits NamedElement
{
	/**The region that contains this vertex.*/
	reference container : Region#subvertex

	/**Specifies the transitions departing from this vertex.*/
	reference outgoing : set Transition[0..*]#source

	/**Specifies the transitions entering this vertex.*/
	reference incoming : set Transition[0..*]#target

}
class ConnectionPointReference inherits Vertex
{
	/**The entryPoint kind pseudo states corresponding to this connection point.*/
	reference entry : set Pseudostate[0..*]

	/**The exitPoints kind pseudo states corresponding to this connection point.*/
	reference exit : set Pseudostate[0..*]

}
class Transition inherits RedefinableElement
{
	/**See definition of TransitionKind.*/
	attribute kind : TransitionKind

	reference container : Region[1..1]#transition

	/**Designates the originating vertex (state or pseudostate) of the transition.*/
	reference source : Vertex[1..1]#outgoing

	/**Designates the target vertex that is reached when the transition is taken.*/
	reference target : Vertex[1..1]#incoming

	reference redefinedTransition : Transition

	/**Specifies the triggers that may fire the transition.*/
	reference trigger : set Trigger[0..*]

	/**A guard is a constraint that provides a fine-grained control over the firing of the transition. The guard is evaluated when an event is dispatched by the state machine. If the guard is true at that time, the transition may be enabled, otherwise, it is disabled. Guards should be pure expressions without side effects. Guard expressions with side effects are ill formed.*/
	attribute guard : Constraint

	/**Specifies an optional activity to be performed when the transition fires.*/
	attribute effect : Activity

}
enumeration TransitionKind
{
	internal;
	local;
	external;
}
enumeration PseudostateKind
{
	initial;
	deepHistory;
	shallowHistory;
	join;
	fork;
	junction;
	choice;
	entryPoint;
	exitPoint;
	terminate;
}
class FinalState inherits State
{
}
class CreateObjectAction inherits Action
{
	/**Classifier to be instantiated.*/
	reference classifier : Classifier[1..1]

	/**(Specialized from Action:output) Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

}
class DestroyObjectAction inherits Action
{
	attribute isDestroyLinks : Boolean

	attribute isDestroyOwnedObjects : Boolean

	/**(Specialized from Action:input) The input pin providing the object to be destroyed.*/
	attribute target : InputPin[1..1]

}
class TestIdentityAction inherits Action
{
	/**. (Specialized from Action:input) Gives the pin on which an object is placed.*/
	attribute first : InputPin[1..1]

	/**(Specialized from Action:input) Gives the pin on which an object is placed.*/
	attribute second : InputPin[1..1]

	/**(Specialized from Action:output) Tells whether the two input objects are identical.*/
	attribute ~result : OutputPin[1..1]

}
class ReadSelfAction inherits Action
{
	/**(Specialized from Action:output) Gives the output pin on which the hosting object is placed.*/
	attribute ~result : OutputPin[1..1]

}
abstract class StructuralFeatureAction inherits Action
{
	/**Structural feature to be read.*/
	reference structuralFeature : StructuralFeature[1..1]

	/**(Specialized from Action:input) Gives the input pin from which the object whose structural feature is to be read or written is obtained.*/
	attribute object : InputPin[1..1]

}
class ReadStructuralFeatureAction inherits StructuralFeatureAction
{
	/**(Specialized from Action:output) Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

}
abstract class WriteStructuralFeatureAction inherits StructuralFeatureAction
{
	/**(Specialized from Action:input) Value to be added or removed from the structural feature.*/
	attribute ~value : InputPin[1..1]

}
class ClearStructuralFeatureAction inherits StructuralFeatureAction
{
}
class RemoveStructuralFeatureValueAction inherits WriteStructuralFeatureAction
{
}
class AddStructuralFeatureValueAction inherits WriteStructuralFeatureAction
{
	/**Specifies whether existing values of the structural feature of the object should be removed before adding the new value.*/
	attribute isReplaceAll : Boolean

	/**(Specialized from Action:input) Gives the position at which to insert a new value or move an existing value in ordered structural features. The type of the pin is UnlimitedNatural, but the value cannot be zero. This pin is omitted for unordered structural features.*/
	attribute insertAt : InputPin

}
abstract class LinkAction inherits Action
{
	/**Data identifying one end of a link by the objects on its ends and qualifiers.*/
	attribute endData : set LinkEndData[2..*]

}
class LinkEndData inherits Element
{
	/**Input pin that provides the specified object for the given end. This pin is omitted if the link-end data specifies an “open” end for reading.*/
	reference ~value : InputPin

	/**Association end for which this link-end data specifies values.*/
	reference ~end : Property[1..1]

	/**Attribute representing the qualifier for which the value is to be specified.*/
	attribute qualifier : QualifierValue[0..*]

}
class ReadLinkAction inherits LinkAction
{
	/**(Specialized from Action:output) The pin on which are put the objects participating in the association at the end not specified by the inputs.*/
	attribute ~result : OutputPin[1..1]

}
class LinkEndCreationData inherits LinkEndData
{
	/**= falseSpecifies whether the existing links emanating from the object on this end should be destroyed before creating a new link.*/
	attribute isReplaceAll : Boolean

	/**Specifies where the new link should be inserted for ordered association ends, or where an existing link should be moved to. The type of the input is UnlimitedNatural, but the input cannot be zero. This pin is omitted for association ends that are not ordered.*/
	reference insertAt : InputPin

}
class CreateLinkAction inherits WriteLinkAction
{
}
abstract class WriteLinkAction inherits LinkAction
{
}
class DestroyLinkAction inherits WriteLinkAction
{
}
class ClearAssociationAction inherits Action
{
	/**(Specialized from Action:input) Gives the input pin from which is obtained the object whose participation in the association is to be cleared.*/
	attribute object : InputPin[1..1]

	/**Association to be cleared.*/
	reference association : Association[1..1]

}
abstract class VariableAction inherits Action
{
	/**Variable to be read.*/
	reference variable : Variable[1..1]

}
class ReadVariableAction inherits VariableAction
{
	/**(Specialized from Action:output) Gives the output pin on which the result is put.*/
	attribute ~result : OutputPin[1..1]

}
abstract class WriteVariableAction inherits VariableAction
{
	/**(Specialized from Action:input) Value to be added or removed from the variable.*/
	attribute ~value : InputPin[1..1]

}
class ClearVariableAction inherits VariableAction
{
}
class AddVariableValueAction inherits WriteVariableAction
{
	/**Specifies whether existing values of the variable should be removed before adding the new value.*/
	attribute isReplaceAll : Boolean

	/**(Specialized from Action:input) Gives the position at which to insert a new value or move an existing value in ordered variables. The types is UnlimitedINatural, but the value cannot be zero. This pin is omitted for unordered variables.*/
	attribute insertAt : InputPin

}
class RemoveVariableValueAction inherits WriteVariableAction
{
}
class ApplyFunctionAction inherits Action
{
	/**The primitive function to be invoked.*/
	reference ~function : PrimitiveFunction[1..1]

	/**The pins that provide inputs to the function. (Specializes Action.input.)*/
	attribute argument : set InputPin[0..*]

	/**The pins on which the results of invoking the function are returned. (Specializes Action.output.)*/
	attribute ~result : OutputPin[0..*]

}
class PrimitiveFunction inherits PackageableElement
{
	/**A textual representation of the function in the named surface language.*/
	attribute body : String

	/**Specifies the language in which the body of the primitive function is stated. The interpretation of the body depends on the language. If the language is unspecified, it might be implicit from the body or the context.*/
	attribute language : String

}
abstract class CallAction inherits InvocationAction
{
	/**If true, the call is synchronous and the caller waits for completion of the invoked behavior. If false, the call is asynchronous and the caller proceeds immediately and does not expect a return values.*/
	attribute isSynchronous : Boolean

	/**A list of output pins where the results of performing the invocation are placed.*/
	attribute ~result : OutputPin[0..*]

}
abstract class InvocationAction inherits Action
{
	/**Specification of an argument value that appears during execution.*/
	attribute argument : InputPin[0..*]

	reference onPort : Port

}
class SendSignalAction inherits InvocationAction
{
	/**The target object to which the signal is sent.*/
	attribute target : InputPin[1..1]

	/**The type of signal transmitted to the target object.*/
	reference signal : Signal[1..1]

}
class BroadcastSignalAction inherits InvocationAction
{
	/**The specification of signal object transmitted to the target objects.*/
	reference signal : Signal[1..1]

}
class SendObjectAction inherits InvocationAction
{
	attribute target : InputPin[1..1]

	attribute request : InputPin[1..1]

}
class CallOperationAction inherits CallAction
{
	/**The operation to be invoked by the action execution*/
	reference ~operation : Operation[1..1]

	/**The target object to which the request is sent. The classifier of the target object is used to dynamically determine a behavior to invoke. This object constitutes the context of the execution of the operation.*/
	attribute target : InputPin[1..1]

}
class CallBehaviorAction inherits CallAction
{
	/**The invoked behavior. It must be capable of accepting and returning control.*/
	reference behavior : Behavior[1..1]

}
class TimeExpression inherits ValueSpecification
{
	/**True if the TimeExpression describes the first point in time of the NamedElement referenced by event, in cases where the NamedElement describes something which extends in time. False if the TimeExpression describes the last point in time for the referenced NamedElement.*/
	attribute firstTime : Boolean

	/**Refers to the specification of the event occurrence that the TimeExpression describes*/
	reference event : NamedElement

}
class Duration inherits ValueSpecification
{
	/**If the duration is between times of two NamedElements, there are two Boolean attributes, one for the start of the duration and one for the end of the duration. For each of these it holds that firstTime is true if the time information is associated with the first point in time of the NamedElement referenced by event, and false if it represents the last point in time of the NamedElement. If there is only one NamedElement referenced by event, then this attribute is irrelevant. The default value is true.*/
	attribute firstTime : Boolean

	/**Refers to the specification(s) that describes the starting TimeExpression and the ending TimeExpression of the Duration. If only one NamedElement is referenced, the duration is from the first point in time of that NamedElement until the last point in time of that NamedElement.*/
	reference event : set NamedElement[0..2]

}
class TimeObservationAction inherits WriteStructuralFeatureAction
{
	/**Represents the current point in time.*/
	attribute now : TimeExpression[0..*]

}
class DurationInterval inherits Interval
{
}
class Interval inherits ValueSpecification
{
	/**Refers to the ValueSpecification denoting the minimum value of the range.*/
	reference min : ValueSpecification[0..*]

	/**Refers to the ValueSpecification denoting the maximum value of the range.*/
	reference max : ValueSpecification[0..*]

}
class TimeConstraint inherits IntervalConstraint
{
}
class IntervalConstraint inherits Constraint
{
}
class TimeInterval inherits Interval
{
}
class DurationObservationAction inherits WriteStructuralFeatureAction
{
	/**represent the measured Duration*/
	attribute duration : Duration[0..*]

}
class DurationConstraint inherits IntervalConstraint
{
}
class DataStoreNode inherits CentralBufferNode
{
}
enumeration ParameterEffectKind
{
	create;
	read;
	update;
	delete;
}
class InterruptibleActivityRegion inherits ActivityGroup
{
	/**.The edges leaving the region that will abort other tokens flowing in the region.*/
	reference interruptingEdge : set ActivityEdge[0..*]#interrupts

	reference containedNode : ActivityNode[0..*]#inInterruptibleRegion

}
enumeration ObjectNodeOrderingKind
{
	unordered;
	ordered;
	LIFO;
	FIFO;
}
class ParameterSet inherits NamedElement
{
	reference parameter : set Parameter[1..*]#parameterSet

	attribute condition : set Constraint[0..*]

}
class Component inherits Class
{
	/**{default = true} The kind of instantiation that applies to a Component. If false, the component is instantiated as an addressable object. If true, the Component is defined at design-time, but at runtime (or execution-time) an object specified by the Component does not exist, that is, the component is instantiated indirectly, through the instantiation of its realizing classifiers or parts. Several standard stereotypes use this meta attribute, e.g. «specification, «focus», «subsystem ».*/
	attribute isIndirectlyInstantiated : Boolean

	@overloadable "true"
	property required : set Interface[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	@overloadable "true"
	property provided : set Interface[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	attribute realization : set Realization[0..*]#abstraction

	attribute ownedMember : set PackageableElement[0..*]

}
enumeration ConnectorKind
{
	assembly;
	delegation;
}
class Deployment inherits Dependency
{
	reference deployedArtifact : set DeployedArtifact[0..*]

	reference location : DeploymentTarget[1..1]#deployment

	attribute configuration : set DeploymentSpecification[0..*]

}
abstract class DeployedArtifact inherits NamedElement
{
}
abstract class DeploymentTarget inherits NamedElement
{
	attribute deployment : set Deployment[0..*]#location

	@overloadable "true"
	property deployedElement : set PackageableElement[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

}
class Node inherits Class, DeploymentTarget
{
	attribute nestedNode : set Node[0..*]

}
class Device inherits Node
{
}
class ExecutionEnvironment inherits Node
{
}
class CommunicationPath inherits Association
{
}
class ProtocolConformance inherits DirectedRelationship
{
	/**: Specifies the state machine which conforms to the general state machine.*/
	reference specificMachine : ProtocolStateMachine[1..1]#conformance

	/**: Specifies the protocol state machine to which the specific state machine conforms.*/
	reference generalMachine : ProtocolStateMachine[1..1]

}
class ProtocolStateMachine inherits StateMachine
{
	/**: Conformance between protocol state machines.*/
	attribute conformance : set ProtocolConformance[0..*]#specificMachine

}
class ProtocolTransition inherits Transition
{
	/**Specifies the post condition of the transition which is the condition that should be obtained once the transition is triggered. This post condition is part of the post condition of the operation connected to the transition.*/
	attribute postCondition : Constraint

	@overloadable "true"
	property referred : set Operation[0..*]
		getter is raise kermeta::exceptions::NotImplementedException.new
		setter is raise kermeta::exceptions::NotImplementedException.new

	/**Specifies the precondition of the transition. It specifies the condition that should be verified before triggering the transition. This guard condition added to the source state will be evaluated as part of the precondition of the operation refered by the transition if any.*/
	reference preCondition : Constraint

}
class ReadExtentAction inherits Action
{
	/**The runtime instances of the classifier.*/
	attribute ~result : OutputPin[1..1]

	/**The classifier whose instances are to be retrieved.*/
	reference classifier : Classifier[1..1]

}
class ReclassifyObjectAction inherits Action
{
	/**Specifies whether existing classifiers should be removed before adding the new classifiers. The default value is false.*/
	attribute isReplaceAll : Boolean

	/**A set of classifiers to be removed from the classifiers of the object.*/
	reference oldClassifier : set Classifier[0..*]

	/**A set of classifiers to be added to the classifiers of the object.*/
	reference newClassifier : set Classifier[0..*]

	/**Holds the object to be reclassified. (Specializes Action.input.)*/
	attribute object : InputPin[1..1]

}
class ReadIsClassifiedObjectAction inherits Action
{
	/**Indicates whether the classifier must directly classify the input object. The default value is false.*/
	attribute isDirect : Boolean

	/**The classifier against which the classification of the input object is tested.*/
	reference classifier : Classifier[1..1]

	/**After termination of the action, will hold the result of the test. (Specializes Action.output.)*/
	attribute ~result : OutputPin[1..1]

	/**Holds the object whose classification is to be tested. (Specializes Action.input.)*/
	attribute object : InputPin[1..1]

}
class StartOwnedBehaviorAction inherits Action
{
	/**Holds the object on which to start the owned behavior. (Specializes Action.input.)*/
	attribute object : InputPin[1..1]

}
class QualifierValue inherits Element
{
	reference qualifier : Property[1..1]

	/**Input pin from which the specified value for the qualifier is taken.*/
	reference ~value : InputPin[1..1]

}
class ReadLinkObjectEndAction inherits Action
{
	attribute object : InputPin[1..1]

	/**Link end to be read.*/
	reference ~end : Property[1..1]

	attribute ~result : OutputPin[1..1]

}
class ReadLinkObjectEndQualifierAction inherits Action
{
	/**(Specialized from Action:input) Gives the input pin from which the link object is obtained.*/
	attribute object : InputPin[1..1]

	/**Pin where the result value is placed*/
	attribute ~result : OutputPin[1..1]

	/**The attribute representing the qualifier to be read.*/
	reference qualifier : Property[1..1]

}
class CreateLinkObjectAction inherits CreateLinkAction
{
	attribute ~result : OutputPin[1..1]

}
class AcceptEventAction inherits Action
{
	/**The type of event accepted by the action, as specified by a trigger. If it is a signal trigger, a signal of any subtype of the specified signal type is accepted.*/
	reference trigger : Trigger[0..*]

	/**Pin holding the event object that has been received. Event objects may be copied in transmission, so identity might not be preserved.*/
	reference ~result : set OutputPin[0..*]

}
class AcceptCallAction inherits AcceptEventAction
{
	/**Pin where a token is placed containing sufficient information to perform a subsequent reply and return control to the caller. The value in this token is opaque. It can be passed and copied but it cannot be manipulated by the model.*/
	reference returnInformation : OutputPin[1..1]

}
class ReplyAction inherits Action
{
	/**The operation call trigger being replied to.*/
	reference replyToCall : CallTrigger[1..1]

	/**A list of pins containing the reply values of the operation. These values are returned to the caller.*/
	reference replyValue : set InputPin[0..*]

	/**A pin containing the return information token produced by an earlier AcceptCallAction.*/
	reference returnInformation : InputPin[1..1]

}
class RaiseExceptionAction inherits Action
{
	/**An input pin whose value becomes an exception object.*/
	reference exception : InputPin[1..1]

}
class DeploymentSpecification inherits Artifact
{
	attribute deploymentLocation : String

	attribute executionLocation : String

}
