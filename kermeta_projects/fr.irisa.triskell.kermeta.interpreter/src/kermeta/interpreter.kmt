package kermeta::interpreter;

require "../../../fr.irisa.triskell.kermeta.framework/src/kermeta/kermeta.kmt"

using kermeta::language::behavior
using kermeta::language::structure
using kermeta::standard
using kermeta::utils

/***************************************************
 * Franck FLEUREY - 23/02/2005
 * Triskell Research Group
 * IRISA / University of Rennes 1 (France)
 * Distributed under the terms of the GPL licence
 *
 * Implementation of the Kermeta Interpreter.
 *************************************************** */


/**
 * The interpreter
 */
class Interpreter inherits KMExpressionVisitor<InterpreterContext, Object>
{
	method visitCallVariable(node : CallVariable, context : InterpreterContext) : Object is do
		result := context.getVariable(node.name).value
	end
	
	method visitCallFeature(node : CallFeature, context : InterpreterContext) : Object is do
	
	end
	
	method visitCallSuperOperation(node : CallSuperOperation, context : InterpreterContext) : Object is do
	
	end
	
	method visitCallResult(node : CallResult, context : InterpreterContext) : Object is do
		result := context.current_frame.operation_result
	end
	
	method visitAssignement(node : Assignement, context : InterpreterContext) : Object is do
	
	end
	
	method visitBlock(node : Block, context : InterpreterContext) : Object is do
	
	end
	
	method visitConditionnal(node : Conditionnal, context : InterpreterContext) : Object is do
	
	end
	
	method visitEmptyExpression(node : EmptyExpression, context : InterpreterContext) : Object is do
		result := void
	end
	
	method visitIntegerLiteral(node : IntegerLiteral, context : InterpreterContext) : Object is do
		result := node.value
	end
	
	method visitStringLiteral(node : StringLiteral, context : InterpreterContext) : Object is do
		result := node.value
	end
	
	method visitBooleanLiteral(node : BooleanLiteral, context : InterpreterContext) : Object is do
		result := node.value
	end
	
	method visitTypeLiteral(node : TypeLiteral, context : InterpreterContext) : Object is do
		result := node.typeref.type
	end
	
	method visitVoidLiteral(node : VoidLiteral, context : InterpreterContext) : Object is do
		result := void
	end
	
	method visitLoop(node : Loop, context : InterpreterContext) : Object is do
		// push the context of the loop
		context.current_frame.pushNewContext(node)
		var stop : Boolean
		// execute the initialization
		node.initiatization.acceptKMExpressionVisitor(self, context)
		// execute body until stop
		from stop ?= node.stopCondition.acceptKMExpressionVisitor(self, context)
		until stop
		loop
			result := node.body.acceptKMExpressionVisitor(self, context)
			stop ?= node.stopCondition.acceptKMExpressionVisitor(self, context)
		end
		// pop the context of the loop
		context.current_frame.popContext(node)
	end
	
	method visitSelfExpression(node : SelfExpression, context : InterpreterContext) : Object is do
		result := context.current_frame.self_object
	end
	
	method visitVariableDecl(node : VariableDecl, context : InterpreterContext) : Object is do
		// compute the initial value
		var init_value : Object
		if node.initialization != void then
			init_value := node.initialization.acceptKMExpressionVisitor(self, context)
		else
			// void by default
			init_value := void 
		end
		// create the variable (and adds it in the context)
		var variable : Variable init context.current_frame.current_context.defineVariable(node)
		// set the initial value
		variable.value := init_value
	end
	
	method visitRaise(node : Raise, context : InterpreterContext) : Object is do
	
	end
	
	method visitJavaStaticCall(node : JavaStaticCall, context : InterpreterContext) : Object is do
	
	end
	
	method visitLambdaExpression(node : LambdaExpression, context : InterpreterContext) : Object is do
		
	end
	
	method visitLambdaParameter(node : LambdaParameter, context : InterpreterContext) : Object is do
	
	end	
}

/**
* The context of the interpreter
*/
class InterpreterContext {
	
	// The call stack 
	attribut call_stack : Stack<CallFrame>
	
	// The current frame
	property readonly current_frame : CallFrame
		getter is do
			result := call_stack.peek
		end
	
	// returns the a Variable from its name in current_frame
	operation getVariableFromCurrentFrame(variable_name : String) : Variable is do
		result := getVariableFromFrame(variable_name, current_frame)
	end

	//	returns a Variable from its name in frame
	operation getVariableFromFrame(variable_name : String , frame : CallFrame) : Variable is do
		var expr_context : ExpressionContext
		from var it : Iterator<ExpressionContext> init frame.context_stack.iterator
		until it.isOff or result != void
		loop
			expr_context := it.next
			if expr_context.variables.containsKey(variable_name) then 
				result := expr_context.variables.get(variable_name)
			end
		end
	end	
	
	// find and returns a variable from its name in the entire InterpreterContext
	operation getVariable(variable_name : String) : Variable is do
		var frame : CallFrame
		from var i : Integer init call_stack.size
		until i.equals(0) or result != void
		loop
			result := getVariableFromFrame(variable_name, call_stack.elementAt(i))
			i := i - 1
		end
	end
	
}

/**
 * The class CallFrame represents a frame in the call stack of the
 * interpreter
 */
class CallFrame {

	// The "self" object
	reference self_object : Object
	
	// The result of the call
	reference operation_result : Object
	
	// The current context
	attribut context_stack : Stack<ExpressionContext>
	
	property readonly current_context : ExpressionContext 
		getter is do
			result := context_stack.peek
		end
		
	// push a new context
	operation pushNewContext(root : Expression) : Void is do
		var new_context : ExpressionContext init ExpressionContext.new
		new_context.root := root
		new_context.variables := Hashtable<String, Variable>.new
		context_stack.push(new_context)
	end
	
	// Pop the current_context
	operation popContext() : Void is do
		context_stack.pop
	end
}

/**
 * The class BlockContext encapsulate the variables
 * defined in a block
 */
class ExpressionContext {

	// The expression associated with this context
	reference root : Expression

	// The set of variable defines in this block
	attribut variables : Hashtable<String, Variable>
	
	// Add a new variable in the context
	operation defineVariable(declaration : VariableDecl) : Variable is do
		result := Variable.new
		result.declaration := declaration
		variables.put(result.name, result)
	end

}

/**
 * Represents a variable in the interpreter
 */
class Variable {
	
	// The declaration of the variable
	reference declaration : VariableDecl
	
	// The value of the variable
	reference value : Object
	
	// An accessor to the name of the variable
	property readonly name : String 
		getter is do
			result := declaration.identifier
		end
}

