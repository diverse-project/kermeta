@mainClass "testSaveEcoreSplittedXRefModel::Main"
@mainOperation "testmain"

/** test that we can save a model containing cross dependencies into several resources*/
package testSaveEcoreSplittedXRefModel;


require kermeta
require "platform:/plugin/fr.irisa.triskell.kermeta/lib/ecore.kmt"
using kermeta::persistence
using kermeta::standard
using ecore

class Main inherits kermeta::kunit::TestCase
{
	attribute filename1 : String
	attribute filename2 : String
	attribute metamodelname : String
	
    operation testmain() : Void is do 
        
        stdio.write("Begin\n")
        filename1 :="platform:/resource/fr.irisa.triskell.kermeta.interpreter/test/emf_testcases/output/051_file1_out.ecore"
        filename2 := "platform:/resource/fr.irisa.triskell.kermeta.interpreter/test/emf_testcases/output/051_file2_out.ecore"
        metamodelname := "platform:/resource/fr.irisa.triskell.kermeta.interpreter/test/emf_testcases/instances/Ecore.ecore"
		saveSplittedModel
        stdio.write("   model saved\n")
		
        checkSavedModel
        stdio.write("   reloaded model checked\n")
        
        
        stdio.write("End\n")
        
      
    end
    
    operation saveSplittedModel() is do
	    var repository : EMFRepository init EMFRepository.new
        
        
        // create 2 packages
        var aPackage1 : EPackage init EPackage.new
        var aPackage2 : EPackage init EPackage.new
        aPackage1.name := "P1"
        aPackage2.name := "P2"

        // create a class in each of them
        var aClass1 : EClass init EClass.new
        var aClass2 : EClass init EClass.new
        aClass1.name := "C1"
        aClass2.name := "C2"
        aPackage1.eClassifiers.add(aClass1)
        aPackage2.eClassifiers.add(aClass2)
        
        
        // put attributes in each of them that point to the second
        var eReference1 : EReference init EReference.new
        var eReference2 : EReference init EReference.new
        eReference1.name := "ref1"
        eReference2.name := "ref2"
        aClass1.eStructuralFeatures.add(eReference1) 
        aClass2.eStructuralFeatures.add(eReference2)
        
        eReference1.eType := aClass2
        eReference2.eType := aClass1
        eReference1.eOpposite := eReference2
        
        // each of the package is saved in different ressource
        var res1 : Resource init repository.createResource(
   			filename1,
   			metamodelname)
        var res2 : Resource init repository.createResource(
   			filename2,
   			metamodelname)
        
        res1.instances.add(aPackage1)
        res2.instances.add(aPackage2)
        
        res1.save
        res2.save
    end
    
    operation checkSavedModel() is do
    
        // reload the file that was saved verify
        // that the types of the references are correctly loaded
        
    	var repository : EMFRepository init EMFRepository.new
    	// we can reload everything just from this resource because there is a crossdependency
    	var res1 : Resource init repository.createResource(
   			filename1,
   			metamodelname)
   		res1.load
   		var aPackage1 : EPackage 
   		aPackage1 ?= res1.instances.one
   		assertTrueWithMsg(aPackage1.name == "P1", "aPackage1.name == \"P1\"")
   		var aClass1 : EClass
   		aClass1 ?= aPackage1.eClassifiers.one
   		assertTrueWithMsg(aClass1.name == "C1", "aClass1.name == \"C1\"")
   		
   		var eReference1 : EReference
   		eReference1 ?= aClass1.eStructuralFeatures.one
   		assertTrueWithMsg(eReference1.name == "ref1", "eReference1.name == \"ref1\"")
   		assertTrueWithMsg(not (eReference1.eType.isVoid) , "not (eReference1.eType.isVoid)")
   		assertTrueWithMsg(eReference1.eType.name == "C2", "eReference1.eType.name == \"C2\"")
   		
    end
}