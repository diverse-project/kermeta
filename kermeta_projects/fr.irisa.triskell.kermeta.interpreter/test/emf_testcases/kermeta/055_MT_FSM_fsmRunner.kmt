
package fsm;

require "055_MT_FSM_basic_fsm_type.kmt"
using kermeta::standard
using kermeta::utils
using kermeta::exceptions

class Runner<MT : basic_fsm> {

	reference currentState : Hashtable<MT::FSM, MT::State>
	
	operation run(machine : MT::FSM) : Void raises FSMException is
	do
		currentState := Hashtable<MT::FSM, MT::State>.new
		// reset if there is no current state
		if currentState.getValue(machine) == void
		then
			self.currentState.put(machine, machine.initialState)
		end
		from var str : String init "init"
		until str == "quit"
		loop
			stdio.writeln("Current state : " + currentState.getValue(machine).name)
			str := stdio.read("give me a letter : ")
			if str == "quit" then
				stdio.writeln("")
				stdio.writeln("quitting ...")
			else 
				if str == "print" then
					stdio.writeln("")
					//serializer.printFSM(self)
				else	
					stdio.writeln(str)			
					stdio.writeln("stepping...")
					do
						var textRes : String
						textRes := step(currentState.getValue(machine), str)
						if( textRes == void or textRes == "" )
						then
							textRes := "NC"
						end
						
						stdio.writeln("string produced : " + textRes)
					
						rescue (err : ConstraintViolatedPre)
		            		stdio.writeln(err.toString)
		            		stdio.writeln(err.message)
		            		str := "quit"
		            	rescue (err : ConstraintViolatedPost)
	            			stdio.writeln(err.toString)
	            			stdio.writeln(err.message)
	            			str := "quit"
	            		
						rescue(err : NonDeterminism)
							stdio.writeln(err.toString)
							str := "quit"	
						rescue(err : NoTransition)
							stdio.writeln(err.toString)
							str := "quit"
	            	end
				end
			end
		end
	end

	// Go to the next state
	operation step(s : MT::State, c : String) : String raises FSMException is
	
	// Declaration of the pre-condition
	pre notVoidInput is
		c != void and c != ""
		
	do
		// Get the valid transitions
		var validTransitions : Collection<MT::Transition> 
		validTransitions := s.outgoingTransition.select { t | t.input.equals(c) }
		stdio.writeln("Found " + validTransitions.size.toString + " valid transitions for " + s.name)
		// Check if there is one and only one valid transition
		if validTransitions.empty then raise NoTransition.new end
		if validTransitions.size > 1 then raise NonDeterminism.new end
		
		// Fire the transition
		result := fire(validTransitions.one)
	end
		
	// Declaration of the post-condition
	post notVoidOutput is
		result != void and result != ""
	
	// Create a new state from self state
	operation fire(transition : MT::Transition) : String is
	do
		// update FSM current state
		currentState.put(transition.source.owningFSM, transition.target)
		result := transition.output
	end

	operation printFSM(fsm : MT::FSM) is do
		fsm.ownedState.each 
		{ s | 
			stdio.writeln("State : " + s.name)
			s.outgoingTransition.each { t | 
				var outputText : String
				if( t.output != void and t.output != "" )
					then outputText := t.output
					else outputText := "NC"
				end
				stdio.writeln("  Transition : " + t.source.name + "-(" + t.input + "/" + outputText + ")->" + t.target.name)
			}
		}
	end


}