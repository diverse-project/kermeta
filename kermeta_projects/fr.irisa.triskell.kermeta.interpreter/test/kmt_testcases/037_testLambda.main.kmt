/*****************************************************************************
 * $Id: 037_testLambda.main.kmt,v 1.10 2005-05-16 13:42:24 zdrey Exp $
 * Project : Kermeta (First iteration)
 * Creation date :  
 * File : testLambda.kmt
 * 		
 * License : GPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * Creation date : Apr 18 11:13:50 2005
 * Author : zdrey
 * Description : 
 *		test for Lambda
 * 		test all the possible maneers to use a lambda expression
 ***************************************************************************
 */

@testOperation "yes"
@mainClass "testLambda::TestLambda"
@mainOperation "testNoLambda"

package testLambda;

require kermeta

alias Integer : kermeta::standard::Integer;
alias String : kermeta::standard::String;
alias Character : kermeta::standard::Character;
//alias FunctionType : kermeta::language::structure::FunctionType;

class TestLambda inherits kermeta::kunit::TestSuite
{

	operation testNoLambda() : kermeta::standard::Integer is do
		stdio.write("toto")
	end
	/** test a simple lambda expression call with one argument 
	 *  A call of a lambda expression is "interpreted" as a callvariable with parameters
	 *    <fParameters xsi:type="kermeta_behavior:FCallVariable" fName="lf1">
            <fParameters xsi:type="kermeta_behavior:FIntegerLiteral" fValue="3"/>
          </fParameters>
	*/
	operation testLambda1() : Void is do
		var lf1 : <Integer->Integer>
		var res : Integer
		lf1 := function { i : Integer | result:=i.plus(1) }
		res := lf1(3)
		assert(res == 4)
	end

	/** test an operation call with a lambda expression */
	operation testLambdaWithDef() : Void is do
		var lf1 : <Integer->Integer>
		lf1 := function { i : Integer | result:=i.plus(1) }
		assert(lf1(3).equals(4))
	end
	
	/** test a lambda exp. with 2 parameters */
	operation testLambdaWithTwoParams() : Void is do
		var lf1 : <[Integer, Integer]->Integer>
		lf1 := function { i : Integer, j : Integer | result:=i.plus(j) }
		assert(lf1(3, 4) == 7)
		stdio.writeln(lf1(3,4))
	end

	/** Test with a lambda exp. with 2 parameters, and a wrong call of it */
	operation testFailLambdaWithTwoParams() : Void is do
		var lfa1 : <[Integer, Integer]->Integer>
		lfa1 := function { i : Integer, j : Integer | result:= i.plus(j) }
		assert(lfa1(3, 4, 5) == 6)
	end

	/** test a lambda exp. with a String */
	operation testLambdaWithString() : Void is do
		var lfs : <String->String>
//		lfs := function { str : String | str.substring(0,1) }
		lfs := function { str : String | result:=str.indexOf("o") }
		assert(lfs("pof")==1)
		
	end

	/** test a lambda exp. with 3 parameters */
	operation testLambdaWithThreeParams() : Void is do
		var lfs : <[Integer, Integer, String]->Integer>
		lfs := function { i : Integer, j : Integer, k : String | result:=k.indexOf("f") }
		stdio.writeln("stringOfMoreThanSevenChars".indexOf("f"))
		assert(lfs(3, 4, "stringOfMoreThanSevenChars")==7)
	end


	operation testLambdaWithThreeParams2() : Void is do
		var lft2 : <[Integer, Integer, String]->String>
		lft2 := function { i : Integer, j : Integer, k : String | result:=k.substring(i.plus(j), i.plus(j)+2) }
		assert(lft2(3, 4, "stringOfMoreThanSevenChars")=="fM")
	end


	// todo : { i : Integer | i }?

	// test a nested lambda exp. 
	operation testNestedLambda() : Void is do
		var lf1 : <[Integer, Integer, String]->String>
		var lf2 : <[String, String]->String>
		lf1 := function { i : Integer, j : Integer, k : String | result:=k.substring(i.plus(j), 7) }
		lf2 := function { s1 : String, s2 : String | lf1(1, 2, s1+s2) }
		assert(lf2("abcde", "fghi")=="defg")
	end
	
	// test a lambda expression using an extern variable
	operation testLambdaWithExtVar() : Void is do
		var lf1 : <Integer->Integer>
		var extern_var : kermeta::standard::Integer
		lf1 := function { i : kermeta::standard::Integer | result:=i.plus(extern_var)}
		extern_var := 5
		assert(lf1(4)==9)
	end
	
	// test a lambda expression using in its params 
	// a variable of same name as an extern variable
	operation testLambdaVarPriority() : Void is do
		var lf1 : <[Integer, Integer]->Integer>
		var a_var : kermeta::standard::Integer
		lf1 := function { i : Integer, a_var : Integer |  result:=i.plus(a_var)}
		a_var := 4
		assert(lf1(1,2)==3)
		assert(a_var == 4)
	end
	
	// lambda exp. as parameter of an operation?
	operation testLambdaInOperation() : Void is do
		var lf1 : <[Integer, Integer]->Integer>
		lf1 := function { i : Integer, j : Integer | result:=i.plus(j) }
		// 3 * 2 * 5
		assert(3.times(lf1(2, 5))==21)
	end
	
	operation testOpWithLambdaAsParam() : Void is do
		var lf1 : <Integer->Integer>
		lf1 := function { i : Integer | result:=i.plus(54) }
		assert(opWithLambdaAsParam(lf1, 3)==57)
	end
	// TODO : lambda exp. as a parameter binding of a parametric class? 


	/** an operation that takes a lambda exp. as param and simply executes it*/
	operation opWithLambdaAsParam(lambda : <Integer->Integer>, a : kermeta::standard::Integer) : Integer is do
		result := lambda(a)
	end
}