/* $Id: Ocl2DroolsVisitor.kmt,v 1.22 2010-02-25 14:15:06 dvojtise Exp $
 * Creation date: February 25, 2010
 * License: EPL
 * Copyright: IRISA/INRIA
 * Authors: 
 *			Antonio de Almeida Souza Neto
 */

  
package ocl2DROOLS;
require kermeta

require "oclcstvisitor.kmt" 
require "../helpers/QualifiedName.kmt"
require "IOMixin.kmt" 

 
require "../helpers/QualifiedName.kmt"

require "KermetaHelper.kmt" 

require "StructType.kmt"
require "TreeRules.kmt"
require "VariableType.kmt"
    
using kermeta::standard
using kermeta::exceptions
using ocl::cst 
using ocl::cst::visitors 
using kermeta::utils
using qualifiedNames



 
/** This started out life as a pretty-printer from the parsed OCL Concrete Syntax Tree
 ** to Kermeta source code. Of course this is not a simple case ore pretty-printing
 ** because OCL has some oddities like the meaning of a.b.c depends on whether
 ** a.b refers to a single object or a collection (or "association", it's helpful to think
 ** about these as multiple associations, not as the collections that implement them
 ** in a programming language like kermeta). So the TypeSystemMixin adds facilities
 ** to keep track of the features (attributes and associations) and operations that
 ** appear in these expressions, and what their returned types are. These are
 ** called from within the visit methods here to set and, where necessary, obtain
 ** the necessary additional type information.
 **/
 class Ocl2DroolsVisitor inherits Visitor {

		attribute counterVar : Integer
		
		reference stackStructType : Stack<StructType>
		
		reference treeRules: TreeRules
		
		reference contextName: String
		
		reference listVariableType: Sequence<VariableType>
		
		operation initializeAttributes() : Void is
			do
				counterVar := 1
				
				stackStructType :=  Stack<StructType>.new
				
				listVariableType := Sequence<VariableType>.new
			end
			
		operation isOCLOperation(operationName: String) : Boolean is
			do
				var listOCLOperation : Set<String> init Set<String>.new
				
				//definition of the OCL operations
				listOCLOperation.add("oclIsNew")
				listOCLOperation.add("oclIsUndefined")
				listOCLOperation.add("oclIsInvalid")
				listOCLOperation.add("oclIsTypeOf")
				listOCLOperation.add("oclIsKindOf")
				listOCLOperation.add("oclIsInState")
				listOCLOperation.add("hasReturned")
				listOCLOperation.add("isSignalSent")
				listOCLOperation.add("isOperationCall")
				
				listOCLOperation.add("oclAsType")
				
				if (listOCLOperation.exists{s| s == operationName}) then
					result := true
				else
					result := false
				end
				
			end
			
		operation writeRules(ruleName: SimpleNameCS, contextName: String ) is
			do
				var structType : StructType init  StructType.new
				var listRules : Sequence<Stack<StructType>> init Sequence<Stack<StructType>>.new
				var ruleNameStr : String init ""
				
				//if is a stack top, we don't write the next type
				//The last element can't reference another
				var stackTop: Boolean init true
				
			
				treeRules.getListChildRules(listRules)
				
				from var i : Integer init 0
				until i == listRules.size()
				loop
					stdio.write("rule \"")
					if ( not ruleName.isVoid() ) then
						ruleNameStr := ruleName.~value.toString()
					else
						ruleNameStr := "0" 
					end
					if ( i != 0 ) then
						ruleNameStr := ruleNameStr + i.toString()
					end
					
					stdio.writeln(ruleNameStr + "\"")
					stdio.writeln("when")
					stackStructType := listRules.at(i)

					stackTop := true
				
					//print the statements
					from stackStructType.size()
					until stackStructType.size() == 0
					loop
						structType := stackStructType.pop()
						
						stdio.write("	$var" + counterVar.toString() + ": ")
						//stdio.write("org.eclipse.emf.ecore.")
						stdio.write(structType.typeElement + "(")
						
						if ( not structType.nameElement.isVoid() ) then
							stdio.write("name == \"")
							if ( stackStructType.size() == 0 and structType.nameElement == "self") then
								stdio.write(contextName)
								stdio.write("\"")
							else	
								stdio.write(structType.nameElement + "\"")
							end
	
							
							
							if ( not structType.nextElement.isVoid() and not stackTop ) then
								stdio.write(", ")
							end
	
						end
						
						
	
						if ( not structType.nextElement.isVoid() and not stackTop ) then
							stdio.write( structType.nextElement + " " + structType.relation + " $var" + (counterVar - 1).toString() )
						end
	
						stdio.writeln(")")
						
						
						counterVar := counterVar + 1
						
						stackTop := false
					end
					
					stdio.writeln("	EPackage(EClassifiers contains " + "$var" + (counterVar - 1).toString() + ")")
					
					stdio.writeln("then")
					stdio.write("	System.out.println(\"")
					
					stdio.write(ruleNameStr)
					stdio.writeln(" is applicable\");")
					stdio.writeln("	insertLogical(new IntConstraintOccurrence(\""+  ruleNameStr +"\", 10));")
					stdio.writeln("end")
					stdio.writeln("")
				
				
					i := i + 1
				end
			end
		

		operation writePrimitiveVariable(typeVar: String) is
			do
				var structType1 : StructType init StructType.new
				var structType2 : StructType init StructType.new
				
				
				if ( not treeRules.parentNode.isVoid() ) then
					//if it's a primitive variable, it's not a true child
					// then we remove the current child and use the brother
					treeRules := treeRules.parentNode
					treeRules.childNode.removeAt(treeRules.childNode.size() - 1)
					if ( treeRules.childNode.size() > 0 ) then
						treeRules := treeRules.childNode.at(treeRules.childNode.size() - 1)
					end
				end

				stackStructType := treeRules.stackStructType
				
				
				//stackStructType := treeRules.parentNode.childNode.at(treeRules.childNode.size() - 1).stackStructType
				if ( stackStructType.size() > 0 ) then
					structType1 := stackStructType.pop()
				
					if ( stackStructType.size()> 0 ) then
						structType2 := stackStructType.pop()
					end
			
					
					if ( structType1.typeElement == "EOperation" ) then
					
						structType1.nextElement := "EType"
						structType1.relation := "=="
							
						structType2.nextElement := "EAllOperations"
						structType2.relation := "contains"
						
					else
						structType1.typeElement := "EAttribute"
						structType1.nextElement := "EAttributeType"
						structType1.relation := "=="
							
						structType2.nextElement := "EAllAttributes"
						structType2.relation := "contains"
					end
					
					if ( structType2.typeElement.isVoid() ) then
						structType2.typeElement := "EClass"
					end
	
					stackStructType.push(structType2)
					stackStructType.push(structType1)
					
					//stacks the statement "EDataType"
					structType1 := StructType.new
					structType1.typeElement := "EDataType"
					structType1.nameElement := typeVar
					
					stackStructType.push(structType1)
				
				end
			end 


	    operation visit(visitable : Visitable) : Void is
			do
			
			end

		method visitCSTNode(visitable : CSTNode) : Void is
			do
			
			end
			
		method visitTypeCS(visitable : TypeCS) : kermeta::standard::~Void is
			do
    			
			end
		 
		method visitPackageDeclarationCS(visitable : PackageDeclarationCS) : Void is
			do
				stdio.writeln("import org.drools.solver.core.score.calculator.SimpleScoreCalculator;")
				stdio.writeln("import org.drools.solver.core.score.constraint.UnweightedConstraintOccurrence;")
				stdio.writeln("import org.drools.solver.core.score.constraint.ConstraintType;")
				
				stdio.writeln("import org.drools.solver.core.score.constraint.IntConstraintOccurrence;")
				
				stdio.writeln("import org.eclipse.emf.ecore.*;\n")
				
				stdio.writeln("global SimpleScoreCalculator scoreCalculator;\n")
			
			
  			 	visitable.contextDecls.each{e|e.accept(self)}
   			end
		
		method visitContextDeclCS(visitable : ContextDeclCS) : Void is
			do

			end

		method visitPropertyContextCS(visitable : PropertyContextCS) : Void is
			do

			end

		method visitClassifierContextDeclCS(visitable : ClassifierContextDeclCS) : Void is
			do
				stackStructType := Stack<StructType>.new
			
				treeRules := TreeRules.new
				treeRules.stackStructType := stackStructType
				visitable.invOrDefCS.accept(self)
				
				//(ruleName, contextName)
				writeRules(visitable.invOrDefCS.simpleNameCS, visitable.pathNameCS.sequenceOfNames.elementAt(visitable.pathNameCS.sequenceOfNames.size() - 1) )

			end
			
		attribute currentContextClassifier : ecore::EClassifier

		method visitOperationContextDeclCS(visitable : OperationContextDeclCS) : Void is
			do
				stackStructType := Stack<StructType>.new
			
				treeRules := TreeRules.new
				treeRules.stackStructType := stackStructType
			
				visitable.operationCS.accept(self)
				
				visitable.prePostOrBodyDecls.each{e|e.accept(self)}
			end
  
  
		method visitPrePostOrBodyDeclCS(visitable : PrePostOrBodyDeclCS) : Void is
			do
				stackStructType := Stack<StructType>.new
			
				treeRules := TreeRules.new
				treeRules.stackStructType := stackStructType
			
				visitable.expressionCS.accept(self)
				
				//(ruleName, contextName)
				writeRules( visitable.simpleNameCS, contextName )
				
			end

		

		method visitOperationCS(visitable : OperationCS) : Void is
			do
				var structType : StructType init StructType.new
				
			
				structType.nameElement := visitable.pathNameCS.sequenceOfNames.at( visitable.pathNameCS.sequenceOfNames.size() - 1 )
				structType.typeElement := "EClass"
				structType.nextElement := "EAllOperations"
				structType.relation := "contains"
				stackStructType.push(structType)

				structType := StructType.new
				
				structType.nameElement := visitable.simpleNameCS.~value
				structType.typeElement := "EOperation"
				structType.nextElement := "EType"
				structType.relation := "=="
				
				stackStructType.push(structType)
				
				visitable.parameters.each{e| e.accept(self)}
				
				visitable.typeCS.accept(self)
				
				contextName := visitable.pathNameCS.sequenceOfNames.at( visitable.pathNameCS.sequenceOfNames.size() - 1 )
				
				//(ruleName, contextName)
				writeRules(visitable.simpleNameCS, contextName )
			end

		method visitInitOrDerValueCS(visitable : InitOrDerValueCS) : Void is
			do
			
			end

		method visitDerValueCS(visitable : DerValueCS) : Void is
			do
				
			end

		method visitInitValueCS(visitable : InitValueCS) : Void is
			do
				
			end

		method visitInvOrDefCS(visitable : InvOrDefCS) : Void is
			do
			
			end

		method visitInvCS(visitable : InvCS) : Void is
			do
				visitable.expressionCS.accept(self)
			end

		method visitDefCS(visitable : DefCS) : Void is
			do
				
			end

		method visitDefExpressionCS(visitable : DefExpressionCS) : Void is
			do
			
			end

		method visitPathNameCS(visitable : PathNameCS) : Void is
			do
				var structType : StructType init StructType.new

			
				if ( stackStructType.size()>=1 ) then
					structType := stackStructType.pop()
				end
				
				
				if ( structType.typeElement == "EOperation" ) then
				
					structType.nextElement := "EType"
					structType.relation := "=="
					
					stackStructType.push(structType)
					
					structType := StructType.new
					
					structType.nameElement := visitable.sequenceOfNames.at( visitable.sequenceOfNames.size() - 1 )
					structType.typeElement := "EClass"
					
					stackStructType.push(structType)
				end
			end
          
		method visitSimpleNameCS(visitable : SimpleNameCS) : Void is
			do
		    	
			end

		reference qualifiedTypeName: QualifiedName
		
		method visitPrimitiveTypeCS(visitable : PrimitiveTypeCS) : Void is
			do
				if ( visitable.~value == "Integer" ) then
					writePrimitiveVariable("EInt")
				else if ( visitable.~value == "String" ) then
					writePrimitiveVariable("EString")
				else if ( visitable.~value == "Boolean" ) then
					writePrimitiveVariable("EBoolean")
				else if ( visitable.~value == "Real" ) then
					writePrimitiveVariable("EFloat")
				end
				end
				end
				end

			end

		method visitTupleTypeCS(visitable : TupleTypeCS) : Void is
			do
			
			end

		method visitCollectionTypeCS(visitable : CollectionTypeCS) : Void is
			do
				
			end

		method visitOCLExpressionCS(visitable : OCLExpressionCS) : Void is
			do
			
			end
			 
		method visitVariableCS(visitable : VariableCS) : Void is
			do
    			var variableType : VariableType init VariableType.new
    			
    			if ( visitable.typeCS.isKindOf(PathNameCS) ) then
					variableType.variable := visitable.name
					variableType.type := visitable.typeCS.asType(PathNameCS).sequenceOfNames.at(visitable.typeCS.asType(PathNameCS).sequenceOfNames.size() - 1)
				
					listVariableType.add(variableType)
				end
    			
			end

		method visitLetExpCS(visitable : LetExpCS) : Void is
			do
				
			end

		method visitIfExpCS(visitable : IfExpCS) : Void is
			do
				
			end

		method visitMessageExpCS(visitable : MessageExpCS) : Void is
			do
				
			end

		method visitOCLMessageArgCS(visitable : OCLMessageArgCS) : Void is
			do
				
			end

		method visitLiteralExpCS(visitable : LiteralExpCS) : Void is
			do
							
			end

		operation visitEnumLiteral(visitable : EnumLiteralExpCS) : Void is
			do
    			
			end
			
		operation visitEnumLiteralAsType(visitable : EnumLiteralExpCS) : Void is
			do
				
			end
			
		method visitEnumLiteralExpCS(visitable : EnumLiteralExpCS) : Void is
			do
			
			end

		method visitCollectionLiteralExpCS(visitable : CollectionLiteralExpCS) : Void is
			do
			
			end

		method visitTupleLiteralExpCS(visitable : TupleLiteralExpCS) : Void is
			do
					
			end

		method visitPrimitiveLiteralExpCS(visitable : PrimitiveLiteralExpCS) : Void is
			do

			end

		method visitIntegerLiteralExpCS(visitable : IntegerLiteralExpCS) : Void is
			do
				writePrimitiveVariable("EInt")
			end

		method visitRealLiteralExpCS(visitable : RealLiteralExpCS) : Void is
			do
				writePrimitiveVariable("EFloat")
			end

		method visitStringLiteralExpCS(visitable : StringLiteralExpCS) : Void is
			do
				writePrimitiveVariable("EString")
			end

		method visitBooleanLiteralExpCS(visitable : BooleanLiteralExpCS) : Void is
			do
				writePrimitiveVariable("EBoolean")
			end

		method visitNullLiteralExpCS(visitable : NullLiteralExpCS) : Void is
			do

			end

		method visitInvalidLiteralExpCS(visitable : InvalidLiteralExpCS) : Void is
			do
						
			end

		method visitCollectionLiteralPartCS(visitable : CollectionLiteralPartCS) : Void is
			do
				
			end

		method visitCollectionRangeCS(visitable : CollectionRangeCS) : Void is
			do
				
			end

		method visitCallExpCS(visitable : CallExpCS) : Void is
			do
			
			end

		method visitLoopExpCS(visitable : LoopExpCS) : Void is
			do
				
			end
 
	
		method visitIteratorExpCS(visitable : IteratorExpCS) : Void is
			do
				visitable.source.accept(self)
				visitable.body.accept(self)
			end

		method visitIterateExpCS(visitable : IterateExpCS) : Void is
			do
			end
			
		operation handleVariableExpression(featureName: String): Void is
			do
			
			end
			
		operation handleStringLiteral(content: String) : Void is
			do
			
			end
			
		/**  You have thee choices here:
		 ** - could be a string literal (there seems to be a bug in the parser that makes them look like this
		 ** - it could be a variable expression, call the handler above
		 ** - it coul dbe the name of a type, but only if we are expecting one because the function
		 ** is one of those special ones that takes a type name as a parameter such as oclAsType(...)
		 **/
		method visitVariableExpCS(visitable : VariableExpCS) : Void is
			do
				var structType : StructType init StructType.new
				var typeVariable : String init ""
			
				
				if ( visitable.simpleNameCS.~value == "self" ) then
					structType.nameElement := visitable.simpleNameCS.~value
					structType.typeElement := "EClass"
					structType.nextElement := "EStructuralFeatures"
					structType.relation := "contains"
					
					if ( stackStructType.size() > 0 ) then
						stackStructType.clear()
					end
					
					stackStructType.push(structType)

				else
				
					listVariableType.each{ e |  
							if ( e.variable == visitable.simpleNameCS.~value ) then
								typeVariable := e.type
							end
						}
					if ( typeVariable != "" ) then
						structType.nameElement := typeVariable
						structType.typeElement := "EClass"
						structType.nextElement := "EStructuralFeatures"
						structType.relation := "contains"
			
						stackStructType.push(structType)
					end
				end

			end
		
		operation visitActualParameters(visitable : FeatureCallExpCS) : Void is
			do
				
			end
		
		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				var structType : StructType init StructType.new
				
				visitable.source.accept(self)
								
				//The "EClass" like context is already stacked in this case
				if ( stackStructType.size() > 1 ) then
					structType.typeElement := "EClass"
					structType.nextElement := "EStructuralFeatures"
					structType.relation := "contains"
				
					stackStructType.push(structType)
					
					structType := StructType.new
				end

				structType.nameElement := visitable.simpleNameCS.~value
				structType.typeElement := "EReference"
				structType.nextElement := "EType"
				structType.relation := "=="
				
				stackStructType.push(structType)
			end

		
		method visitOperationCallExpCS(visitable : OperationCallExpCS) : Void is
			do
				var structType : StructType init StructType.new
				var canAccesArguments: Boolean init true

				
				treeRules.childNode := Sequence<TreeRules>.new
				
				
				if ( (visitable.simpleNameCS.~value != "self") and (not visitable.source.isVoid())) then
					
					treeRules.childNode.add( TreeRules.new )
					
					//fills the parent node in the child node
					treeRules.childNode.at(0).parentNode := treeRules
					
					//navigate to down the tree of expressions
					treeRules := treeRules.childNode.at(0)
					
					treeRules.stackStructType := Stack<StructType>.new
					treeRules.stackStructType.addAll(stackStructType)
					stackStructType := treeRules.stackStructType
					
					visitable.source.accept(self)
					
					
					//To not print the comparison symbols like >, <= etc. and operations from OCL collection
					if ( visitable.simpleNameCS.type == SimpleTypeEnum.identifier and 
						visitable.accessor != DotOrArrowEnum.arrow and
						not isOCLOperation(visitable.simpleNameCS.~value)) then
						//If the last is not Class, it use the new
						if ( stackStructType.size() == 1 ) then
							structType := stackStructType.pop()
						end
						
						structType.typeElement := "EClass"
						structType.nextElement := "EAllOperations"
						structType.relation := "contains"
					
						stackStructType.push(structType)
						
						structType := StructType.new
	
						structType.nameElement := visitable.simpleNameCS.~value
						structType.typeElement := "EOperation"
						structType.nextElement := "EType"
						structType.relation := "=="
						
						stackStructType.push(structType)
					end
					
					
					//navigate to up, returning
					if ( not treeRules.parentNode.isVoid() ) then
						treeRules := treeRules.parentNode
					
						
						//Remove the last element if no childs and its stack is void
						if  (stackStructType.size() == 0) then
							if (treeRules.childNode.at(treeRules.childNode.size() - 1).childNode.isVoid()) then
								treeRules.childNode.removeAt(treeRules.childNode.size() - 1)
							else
								if (treeRules.childNode.at(treeRules.childNode.size() - 1).childNode.size() == 0) then
									treeRules.childNode.removeAt(treeRules.childNode.size() - 1)
								end
							end
							
						end
					
					end
					
					
					stackStructType := treeRules.stackStructType
				end
				
				//When it's a operation of collection (like ...->size() == 0 )
				// we can't acces the right side of operation
				if ( visitable.simpleNameCS.type != SimpleTypeEnum.identifier) then
					if ( visitable.source.isKindOf(OperationCallExpCS) ) then
						if ( visitable.source.asType(OperationCallExpCS).accessor == DotOrArrowEnum.arrow ) then
							canAccesArguments := false
						end
					end
				end

				
				if ( canAccesArguments ) then

					from var i : Integer init 0
					until i== visitable.arguments.size()
					loop
	
						treeRules.childNode.add( TreeRules.new )
						
						//fills the parent node
						treeRules.childNode.at(treeRules.childNode.size() - 1).parentNode := treeRules
						
						//navigate to down the tree of expressions
						treeRules := treeRules.childNode.at(treeRules.childNode.size() - 1)
						
						treeRules.stackStructType := Stack<StructType>.new
						treeRules.stackStructType.addAll(stackStructType)
						stackStructType := treeRules.stackStructType
						
						visitable.arguments.at(i).accept(self)
						
						//navigate to up, returning
						if ( not treeRules.parentNode.isVoid() ) then
							treeRules := treeRules.parentNode
	
						
							//Remove the last element if no childs and its stack is void
							if  (stackStructType.size() == 0) then
								if (treeRules.childNode.at(treeRules.childNode.size() - 1).childNode.isVoid()) then
									treeRules.childNode.removeAt(treeRules.childNode.size() - 1)
								else
									if (treeRules.childNode.at(treeRules.childNode.size() - 1).childNode.size() == 0) then
										treeRules.childNode.removeAt(treeRules.childNode.size() - 1)
									end
								end
								
							end
						
						end
						
						stackStructType := treeRules.stackStructType
						
						i := i + 1
					end
					
				end
				
				//If not exists a rule expression for this node, and it has just one or zero child, this node is cut
				if ( treeRules.stackStructType.size() == 0 ) then
					if (treeRules.childNode.size() == 1 ) then
						if ( not treeRules.parentNode.isVoid() ) then
							treeRules.childNode.at(0).parentNode := treeRules.parentNode
							treeRules.parentNode.childNode.removeAt(treeRules.parentNode.childNode.size() - 1)
							treeRules.parentNode.childNode.add(treeRules.childNode.at(0))
						end
						treeRules := treeRules.childNode.at(0)
						stackStructType := treeRules.stackStructType
					end
				
				
				end
				
				if ( visitable.simpleNameCS.~value == "oclAsType" ) then
					if ( treeRules.childNode.isVoid() ) then
						treeRules := treeRules.parentNode
					end
					
					treeRules.childNode.add(TreeRules.new)
					
					//fills the parent node
					treeRules.childNode.at(treeRules.childNode.size() - 1).parentNode := treeRules
					
					//navigate to down the tree of expressions
					treeRules := treeRules.childNode.at(treeRules.childNode.size() - 1)
					
					treeRules.stackStructType := Stack<StructType>.new
					
					stackStructType := treeRules.stackStructType
					
					structType := StructType.new
					
					structType.nameElement := visitable.arguments.at(visitable.arguments.size() - 1).asType(EnumLiteralExpCS).simpleNameCS.~value
					structType.typeElement := "EClass"
					structType.nextElement := "EStructuralFeatures"
					structType.relation := "contains"
					
					stackStructType.push(structType)
				end

			end

		method visitIsMarkedPreCS(visitable : IsMarkedPreCS) : Void is
			do
					
			end

		method visitStateExpCS(visitable : StateExpCS) : Void is
			do
						
			end

	}
	
