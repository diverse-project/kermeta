/* $Id: OperatorPolicies.kmt,v 1.4 2007-05-28 08:25:59 barais Exp $
 * Creation date: February 23, 2007
 * License:
 * Copyright:
 * Authors: Mark Skipper
 */


package ocl2kmt;

require kermeta
require "../../mmodel/oclcstvisitor.kmt"
require "ocl2kmtVisitor.kmt"
 
using kermeta::standard
using kermeta::exceptions
using ocl::cst
using ocl::cst::visitors
 
 
class OperatorPolicy  {

	attribute name: String
	
	operation withName(opName: String): OperatorPolicy is
		do
			name := opName
			result := self
		end
		
	attribute suffix: String
	
    operation withSuffix(theSuffix: String): OperatorPolicy is
	    do
	    	suffix := theSuffix
	    	result := self
	    end
	    
		
	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
	  do
		 	var e : Exception  init Exception.new
		 	e.message := "Unimplemented policy: " + oclOp.simpleNameCS.~value.toString
		 	raise e
	  end
	  
	operation getPrefix():String is
	  do
  		 	result := ""
	  end
	  
 	operation getSuffix(): String is
   	  do
   	  		if suffix != void then
   	  			result := suffix 
   	  		else
   	  			result := ""
   	  		end
   	  end

}

class SimpleOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 		visitor.write("(")
				oclOp.source.accept(visitor)		
				visitor.write(" ")
				if name != void then
					visitor.write(name)
				else
					oclOp.simpleNameCS.accept(visitor)
				end
				visitor.write(" ")
				// TODO: assert: visitable.arguments.size == 1 ??? 
				oclOp.arguments.each{ arg |
						arg.accept(visitor)
			  	}
		 		visitor.write(")")
		 end
}


class MinusSignOp inherits OperatorPolicy {
 
	/**
	 * When you get a minus sign, you have several choices:
	 *  - negative numbers
	 *  - numeric subtraction
	 *  - set subtraction
	 */ 
	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			if oclOp.arguments.empty  then
				// unary minus
				oclOp.source.accept(visitor)
			  	 visitor.write(".uminus")
			else
				// infix minus
				// we really need to know the type of the 
				oclOp.source.accept(visitor)
				visitor.write(".minus")
	  			visitor.write("(")
				oclOp.arguments.each{ arg |
					arg.accept(visitor)
			  	}
	  			visitor.write(")")
		  	end
		 end

}


class ImpliesOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			oclOp.source.accept(visitor)
			visitor.write(".~not.~or(")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
  			visitor.writeln(")")
		 end
}

class UnimplementedOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			var e: Exception init Exception.new
			e.message := "Unimplemented Operation type: " + oclOp.simpleNameCS.~value.toString
			raise e
		 end
}

class CastOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			visitor.write("do")
			visitor.write(" var ")
			var localVarName : String init visitor.nextName("variable")
			visitor.write(localVarName)			
			visitor.write(" : ")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			// TODO: assert: the unique parameter is a type name ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
		  	visitor.write(" init ")
			oclOp.source.accept(visitor)			
			visitor.write( "  ")
			visitor.write(localVarName)			
  			visitor.write( " end ")
		 end
	
}

class NotNullOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		do
			oclOp.source.accept(visitor)
			visitor.write (" == void")
		end
		
}

class PrefixOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		do
			visitor.write(name)
			visitor.write(" (")
			oclOp.source.accept(visitor)			
			visitor.write(")")
		end
		
}



class FunctionCallOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 // TODO: only if the accessor type is 'arrow', 
		// if its not arrow, should treat is as a normal operation call if thats possible from here
		    visitor.write(getPrefix)
			oclOp.source.accept(visitor)
			visitor.write(".")
			if name != void then
				visitor.write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			if not oclOp.arguments.empty then
				visitor.write("(")
				from
					var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
				until
					it.isOff
				loop
	//				visitor.write(" ")
					it.next.accept(visitor)
					if  it.hasNext then
						visitor.write(",") 
					else
	//					visitor.write(" ")
					end
				end
	  			visitor.write(")")
	  		end
  			visitor.write(getSuffix)
		 end
}
class EmptyCallOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 // TODO: only if the accessor type is 'arrow', 
		// if its not arrow, should treat is as a normal operation call if thats possible from here
		    visitor.write(getPrefix)
			oclOp.source.accept(visitor)
			visitor.write(".")
			if name != void then
				visitor.write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			if not oclOp.arguments.empty then
				visitor.write("(")
				from
					var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
				until
					it.isOff
				loop
	//				visitor.write(" ")
					it.next.accept(visitor)
					if  it.hasNext then
						visitor.write(",") 
					else
	//					visitor.write(" ")
					end
				end
	  			visitor.write(")")
	  		end
  			visitor.write(getSuffix)
		 end
}

