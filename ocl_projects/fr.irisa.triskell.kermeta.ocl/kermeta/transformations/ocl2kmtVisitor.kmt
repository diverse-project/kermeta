/* $Id: ocl2kmtVisitor.kmt,v 1.11 2007-05-25 18:11:24 bitterjug Exp $
 * Creation date: February 5, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "::"
@mainOperation ""


package ocl2kmt;

require kermeta
require "../../mmodel/oclcstvisitor.kmt"
require "OperatorPolicies.kmt"  
require "platform:/resource/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
 
using kermeta::standard
using kermeta::exceptions
using ocl::cst
using ocl::cst::visitors
using kermeta::utils
using kermeta::io

class StringWriter inherits StdIO
{

	reference s: String

	method write(object: String) is
		do
			if s == void then
				s := object
			else
				s := s + object
			end
		end
		
	method writeln(object: String) is
		do
			self.write(object)
			self.write(" ")
		end
		
	method read(prompt: String): String is
		do
			var e: Exception init Exception.new
			e.message := "Sorry, you can't read from a writer"
			raise e
		end
}

 class Ocl2kmtVisitor inherits ocl::cst::visitors::Visitor {

 
		reference __ecoreHelper : EcoreHelpers::EcoreHelper
		
		operation setMetamodelURI(metamodelURI: String) is
			do
				__ecoreHelper := EcoreHelpers::EcoreHelper.new
				__ecoreHelper.loadMetamodel(metamodelURI) 
			end
			
		operation ecoreHelper(): EcoreHelpers::EcoreHelper is
			do
				if __ecoreHelper == void then
					var e : Exception init Exception.new
					e.message := "Metamodel URI must be set before visiting"
					raise e
				else
					result := __ecoreHelper
				end
			end
					
		reference  __io: StdIO 
		
		operation getIo(): StdIO is
			do
				if __io == void then
					__io := stdio
				end
				result := __io
			end
		
		/**
		 * Use this to set a string writer to get the generated source as a string
		 */
		operation setIo(newio: StdIO) is
			do
				self.__io := newio
			end
		
	    operation write(s: String) : Void is
		    do
		    	getIo.write(s)
		    end
    
	    operation writeln(s: String): Void is
		    do
		    	getIo.writeln(s)
		    end

  
  		attribute __name : Integer
  		
		operation nextName(root: String) : String is
			do
				if __name == void then
					__name := 0
				end
				__name := __name + 1
				result := root + __name.toString
			end     

	    operation visit(visitable : Visitable) : Void is
			do
				write( visitable.toString)
			end

		method visitCSTNode(visitable : CSTNode) : Void is
			do
				visit(visitable)
			end

		method visitPackageDeclarationCS(visitable : PackageDeclarationCS) : Void is
			do
			
				self.pathExpression := String.new
				self.previousIsMultiple := false
				pathContextCounter :=0
				currentPackagename :=""
				visitable.pathNameCS.sequenceOfNames.each{ e | currentPackagename := currentPackagename + "::"+e}
				currentPackagename:=currentPackagename.substring(2,currentPackagename.size)
				write("package ")
				visitable.pathNameCS.accept(self)
				writeln(";\n")
				write("require kermeta \n")
				write("require \"")
				visitable.pathNameCS.accept(self)
				write(".ecore\"\n")
				
				write("using kermeta::standard \n")
				
				visitable.contextDecls.each{ c |
						c.accept(self)
					}
			end

		reference currentPackagename : String
		reference currentClassifiername : String
		reference currentOperationname : String
		
		method visitContextDeclCS(visitable : ContextDeclCS) : Void is
			do
				visit(visitable)
			end

		method visitPropertyContextCS(visitable : PropertyContextCS) : Void is
			do
				visit(visitable)
			end

		method visitClassifierContextDeclCS(visitable : ClassifierContextDeclCS) : Void is
			do
				currentClassifiername :=""
				visitable.pathNameCS.sequenceOfNames.each{ e | currentClassifiername := currentClassifiername + "::"+e}
				currentClassifiername:=currentClassifiername.substring(2,currentClassifiername.size)
				//writeln(currentClassifiername )
				writeln("@aspect \"true\"")
				write("class ")
				visitable.pathNameCS.accept(self)
				writeln("{")
				visitable.invOrDefCS.accept(self)
		      	writeln("}")
			end
			attribute currentContextClassifier : ecore::EClassifier

		method visitOperationContextDeclCS(visitable : OperationContextDeclCS) : Void is
			do
			
				currentClassifiername :=""
				currentOperationname :=""
				visitable.operationCS.pathNameCS.sequenceOfNames.each{ e | currentClassifiername := currentClassifiername + "::"+e}
				currentClassifiername:=currentClassifiername.substring(2,currentClassifiername.size)
				
				writeln("@aspect \"true\"")
				write("class ")
				visitable.operationCS.pathNameCS.accept(self)
				writeln("{")
				writeln("@overloadable \"true\"")
				visitable.operationCS.accept(self)
				writeln("")
				visitable.prePostOrBodyDecls.each{ ppbd |
					ppbd.accept(self)
				}
				writeln("is")
				writeln("do")
				writeln("var e: Exception init NotImplementedException.new")
				write("e.message := \"OCL pre/post/body: " )
				visitable.operationCS.pathNameCS.accept(self)
				write(".")
				visitable.operationCS.simpleNameCS.accept(self)
				writeln("\"")
				writeln("raise e")
				writeln("end")
				writeln("}")
			end
  
		method visitPrePostOrBodyDeclCS(visitable : PrePostOrBodyDeclCS) : Void is
			do
				write(visitable.kind.name.toString)
				writeln(" " + nextName(visitable.kind.name.toString ))
				writeln("is do")
				visitable.expressionCS.accept(self)
				writeln(" end")
			end

		
		method visitOperationCS(visitable : OperationCS) : Void is
			do
				currentOperationname := visitable.simpleNameCS.~value
				
				write("operation ")
				visitable.simpleNameCS.accept(self)
				write("(")
				visitable.parameters.each{ p |
						p.accept(self)
					}
				write("):")
				visitable.typeCS.accept(self)
			end

		method visitInitOrDerValueCS(visitable : InitOrDerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitDerValueCS(visitable : DerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInitValueCS(visitable : InitValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInvOrDefCS(visitable : InvOrDefCS) : Void is
			do
				visit(visitable)
			end

		method visitInvCS(visitable : InvCS) : Void is
			do
				writeln("inv  " + nextName("invariant") + " is ")
				writeln("do" )
				visitable.expressionCS.accept(self)
				writeln("")
				writeln("end" )
			end

		method visitDefCS(visitable : DefCS) : Void is
			do
				 visitable.defExpressionCS.accept(self)
			end

		method visitDefExpressionCS(visitable : DefExpressionCS) : Void is
			do
				visitable.operationCS.accept(self)
				writeln(" is")
				writeln("do")
				write("result := ")
				visitable.expressionCS.accept(self)
				writeln("")
				write("end")
			end

		method visitPathNameCS(visitable : PathNameCS) : Void is
			do
				visitable.sequenceOfNames.each{o| 
					if o != void then
						write( o.toString)
					else
						write("[void path name]")
					end
				    //o.accept(self) 
				    }
			end

		method visitVariableExpCS(visitable : VariableExpCS) : Void is
			do
				pathExpression := pathExpression + visitable.simpleNameCS.~value+"."
				
				//self.currentPackagename + "::" + self.currentClassifiername
				//writeln(self.currentPackagename + "::" + self.currentClassifiername)
				//writeln(pathExpression.substring(0, pathExpression.size -1))

				var isMultiple : Boolean init self.ecoreHelper.isMultiple(self.currentPackagename + "::" + self.currentClassifiername, pathExpression.substring(0, pathExpression.size -1),".")
				//writeln(isMultiple.toString)
				
				if (previousIsMultiple) then
					write("collect{e | e.")
					write( visitable.simpleNameCS.~value)
					write("}")					
				else
					write( visitable.simpleNameCS.~value)
				end
				
				previousIsMultiple:=isMultiple
				//visitable.simpleNameCS.accept(self)
			end

       
          
		method visitSimpleNameCS(visitable : SimpleNameCS) : Void is
			do
			    var name : String init visitable.~value.toString
			    if isKermetaKeyword(name) then
			    	write("~")
			    end
				write(name)
			end

		method visitTypeCS(visitable : TypeCS) : Void is
			do
				visit(visitable)
			end

		method visitPrimitiveTypeCS(visitable : PrimitiveTypeCS) : Void is
			do
				if visitable.~value.toString.equals("OclAny") then
					write("Object")
				else
					visitSimpleNameCS(visitable)
				end
			end

		method visitTupleTypeCS(visitable : TupleTypeCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionTypeCS(visitable : CollectionTypeCS) : Void is
			do
				write(visitable.collectionTypeIdentifier.name)
				write("<")
				visitable.typeCS.accept(self)
				write(">")
			end

		method visitOCLExpressionCS(visitable : OCLExpressionCS) : Void is
			do
				visit(visitable)
			end

		method visitLetExpCS(visitable : LetExpCS) : Void is
			do
				write("do")
				//variables
				visitable.variables.each{ v |
						writeln("")
						write("var " )
						v.accept(self)
					}
				writeln("")
				//body
				visitable.inExpression.accept(self)
				writeln("")
				write("end")
			end

		method visitIfExpCS(visitable : IfExpCS) : Void is
			do
				write("if ")
				visitable.condition.accept(self)
				write(" then ")
				visitable.thenExpression.accept(self)
				write(" else ")
				visitable.elseExpression.accept(self)
				write(" endif")
			end

		method visitMessageExpCS(visitable : MessageExpCS) : Void is
			do
				visit(visitable)
			end

		method visitOCLMessageArgCS(visitable : OCLMessageArgCS) : Void is
			do
				visit(visitable)
			end

		method visitVariableCS(visitable : VariableCS) : Void is
			do
				write(visitable.name.toString)
				//visitable.name.accept(self)
				if visitable.typeCS != void then
					write(" : ")
					visitable.typeCS.accept(self)
				end
				if visitable.initExpression != void then
					write(" init ")
					visitable.initExpression.accept(self)
				end
			end

		method visitLiteralExpCS(visitable : LiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitEnumLiteralExpCS(visitable : EnumLiteralExpCS) : Void is
			do
				visitable.pathNameCS.accept(self)
				write(".")
				visitable.simpleNameCS.accept(self)
			end

		method visitCollectionLiteralExpCS(visitable : CollectionLiteralExpCS) : Void is
			do
				var varName :  String init nextName("variable")
				//TODO: do we have to infer the element type here?
				var type : String init visitable.collectionType.name +"<" + "????????" +">"
				writeln("do")
				write("var " + varName + " : " + type)
				writeln("init " + type + ".new")
				visitable.collectionLiteralParts.each{ clp |
						write(varName + ".add(")
						clp.accept(self)
						writeln(")")
					}
				writeln(varName)
			    write("end")
			end

		method visitTupleLiteralExpCS(visitable : TupleLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitPrimitiveLiteralExpCS(visitable : PrimitiveLiteralExpCS) : Void is
			do
  	 	 	    write(visitable.symbol)
			end

		method visitIntegerLiteralExpCS(visitable : IntegerLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitRealLiteralExpCS(visitable : RealLiteralExpCS) : Void is
			do
				write(visitable.symbol.toString)	
			end

		method visitStringLiteralExpCS(visitable : StringLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitBooleanLiteralExpCS(visitable : BooleanLiteralExpCS) : Void is
			do
				visitPrimitiveLiteralExpCS(visitable)
			end

		method visitNullLiteralExpCS(visitable : NullLiteralExpCS) : Void is
			do
				write("void")		
			end

		method visitInvalidLiteralExpCS(visitable : InvalidLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionLiteralPartCS(visitable : CollectionLiteralPartCS) : Void is
			do
				visitable.expressionCS.accept(self)
			end

		method visitCollectionRangeCS(visitable : CollectionRangeCS) : Void is
			do
				visit(visitable)
			end

		method visitCallExpCS(visitable : CallExpCS) : Void is
			do
				visit(visitable)
			end

		method visitLoopExpCS(visitable : LoopExpCS) : Void is
			do
				visit(visitable)			
			end

        attribute __iterators : Hashtable<String, IteratorPolicy>
        
        operation addIterator(oclIteratorName: String, policy: IteratorPolicy) : Void is 
        do
        	__iterators.put(oclIteratorName, policy)
        end
        
        property readonly iterators : Hashtable<String, IteratorPolicy>
        	getter is
        		do
        			if __iterators == void then
        				__iterators := Hashtable<String, IteratorPolicy>.new
        				var doNothing : IteratorPolicy init IteratorPolicy.new
        				var sameName: IteratorPolicy init SimpleIteratorIP.new
        				var functionWithSameName : IteratorPolicy init FunctionIP.new
        				addIterator("exists", sameName)
        				addIterator("forAll", sameName)
        				addIterator("isUnique", UniqueIP.new)
        				addIterator("any", SimpleIteratorIP.new.withName("detect"))
        				addIterator("one", SimpleIteratorIP.new.withName("select").withSuffix(".size.equals(1)"))
        				addIterator("select", SimpleIteratorIP.new.withName("select"))
        				addIterator("collect", sameName)
        				addIterator("collectNested", doNothing)
        				addIterator("sortedBy", sameName)
        				addIterator("reject", sameName)
        			end
        			result := __iterators
        		end
        		
		method visitIteratorExpCS(visitable : IteratorExpCS) : Void is
			do
				// <source> <accessor> <simpleNameCS>( <body> )
				// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
				// why can't I compare the enumerations normally
				// i.e. visitable.simpleNameCS.~type.equals(SimpleTypeEnum.keyword)
				//  <<<<<<<<<<<<<<<<<<<<<<<<
				if visitable.simpleNameCS.~type.name.equals(SimpleTypeEnum.keyword.name) then
				    // check which keyword type and act accordingly
				    // TODO: this won't work in cases where the inner expression defines its own variables
					var policy: IteratorPolicy init iterators.getValue(visitable.simpleNameCS.~value.toString)
					if policy != void then
						// TODO: assert that the accessor was an arrow
						policy.generate(visitable, self)
					else
						writeln("Unknown keyword type " +visitable.simpleNameCS.~value.toString )
					end
				end
			end

		method visitIterateExpCS(visitable : IterateExpCS) : Void is
			do
				visit(visitable)			
			end

		attribute pathExpression : String

		attribute previousIsMultiple : Boolean 
		
		attribute pathContextCounter : Integer 

		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				pathContextCounter := pathContextCounter+1
				if visitable.source != void then
					visitable.source.accept(self)		
					if visitable.accessor.name == "dot" then
					   write(".")
					end
					if visitable.accessor.name == "arrow" then
					   write(".")
					end
				//else
				//	last := true					
				end
				//visitable.simpleNameCS.accept(self)
				pathExpression := pathExpression + visitable.simpleNameCS.~value+"."
				
				//self.currentPackagename + "::" + self.currentClassifiername
				//writeln(self.currentPackagename + "::" + self.currentClassifiername)
				//writeln(pathExpression.substring(0, pathExpression.size -1))
				
				var isMultiple : Boolean init self.ecoreHelper.isMultiple(self.currentPackagename + "::" + self.currentClassifiername, pathExpression.substring(0, pathExpression.size -1),".")
				
				if (previousIsMultiple) then
					write("collect{e | e.")
					write( visitable.simpleNameCS.~value)
					write("}")					
				else
					write( visitable.simpleNameCS.~value)
				end
				
				previousIsMultiple:=isMultiple
				
				//writeln(isMultiple.toString)
				
				if visitable.arguments.size > 0 then
					write("(")
					from
						var it : Iterator<OCLExpressionCS> init visitable.arguments.iterator
					until
						it.isOff
					loop
						it.next.accept(self)
						if  it.hasNext then
							write(", ") 
						end
					end
					write(")")
			  	end
			  	
			  	pathContextCounter := pathContextCounter-1
			  	
			  	
			  	if (pathContextCounter==0) then
			  		previousIsMultiple:=false
			  		pathExpression := ""
			  	end
			  	
			end


/*
	  operation featureCall(visitable: FeatureCallExpCS): Void is
			do
				visitable.simpleNameCS.accept(self)
				if visitable.arguments.size > 0 then
					write("(")
					from
						var it : Iterator<OCLExpressionCS> init visitable.arguments.iterator
					until
						it.isOff
					loop
						it.next.accept(self)
						if  it.hasNext the
							write(", ") 
						end
					end
					write(")")
			  	end
			end
		
		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				if visitable.source != void then
					visitable.source.accept(self)		
					if visitable.accessor.name == "dot" then
						var variableName : String init nextName("variable")
					  write(".collect{" + variableName + " | ")
						write(variableName + ".")
						featureCall(visitable)
						write("}")
					end
					if visitable.accessor.name == "arrow" then
					   write(".")
						 featureCall(visitable)
					end
				end
			end
			*/

	   attribute __operators: Hashtable<String, OperatorPolicy>
        property readonly operators: Hashtable<String, OperatorPolicy>
			getter is 
				do
          			if __operators == void then
          			    var functionCall : OperatorPolicy init FunctionCallOp.new
          			    var simpleOp : OperatorPolicy init SimpleOP.new
          				__operators := Hashtable<String, OperatorPolicy>.new
          				__operators.put("implies", ImpliesOP.new)
          				__operators.put("and", functionCall)
          				__operators.put("or", functionCall)
          				__operators.put("xor", functionCall)
          				__operators.put("=", FunctionCallOp.new.withName("equals"))
          				__operators.put("<", FunctionCallOp.new.withName("isLower"))
          				__operators.put("<=", FunctionCallOp.new.withName("isLowerOrEqual"))
          				__operators.put(">",  FunctionCallOp.new.withName("isGreater"))
          				__operators.put(">=",  FunctionCallOp.new.withName("isGreaterOrEqual"))
          				__operators.put("<>",  FunctionCallOp.new.withName("equals").withSuffix(".~not"))
          				__operators.put("+",  FunctionCallOp.new.withName("plus"))
          				__operators.put("-", MinusSignOp.new)
          				__operators.put("*",  FunctionCallOp.new.withName("mult"))
          				__operators.put("/",  FunctionCallOp.new.withName("div"))
          				__operators.put("includes", FunctionCallOp.new.withName("contains"))
           				__operators.put("includesAll", FunctionCallOp.new.withName("containsAll"))
          				__operators.put("size", FunctionCallOp.new)
          				__operators.put("at", FunctionCallOp.new.withName("elementAt"))
          				__operators.put("indexOf", FunctionCallOp.new)
          				__operators.put("oclAsType", CastOp.new)   
          				__operators.put("oclIsUndefined", NotNullOp.new)          				
          				__operators.put("not", functionCall)  
          				__operators.put("notEmpty", EmptyCallOp.new.withName("empty").withSuffix(".~not"))
          				__operators.put("isEmpty", EmptyCallOp.new.withName("empty"))
           				__operators.put("oclIsTypeOf", FunctionCallOp.new.withName("isKindOf"))
           				__operators.put("oclIsKindOf", FunctionCallOp.new.withName("isInstanceOf"))
           				__operators.put("union", FunctionCallOp.new)
           				__operators.put("intersection", FunctionCallOp.new) 
           				__operators.put("including", functionCall)  
           				__operators.put("excluding", functionCall)  
          				__operators.put("symmetricDifference", functionCall)
          			end
          			result := __operators
				end


		method visitOperationCallExpCS(visitable : OperationCallExpCS) : Void is
			do
				//visit(visitable)		
				var policy: OperatorPolicy init operators.getValue(visitable.simpleNameCS.~value.toString)
				if policy != void then
					policy.generate(visitable, self)
				else
					visitFeatureCallExpCS(visitable)
				end
			end

		method visitIsMarkedPreCS(visitable : IsMarkedPreCS) : Void is
			do
				visit(visitable)			
			end

		method visitStateExpCS(visitable : StateExpCS) : Void is
			do
				visit(visitable)			
			end

 operation isKermetaKeyword(word: String): Boolean is
          do
          		result :=	word.equals("package") or
							word.equals("require") or
							word.equals("includeFilter") or
							word.equals("excludeFilter") or
							word.equals("using") or
							word.equals("inherits") or
							word.equals("class") or
							//word.equals("@pre" ) or
							word.equals("pre") or
							word.equals("post") or
							word.equals("inv") or
							word.equals("abstract") or
							word.equals("Self") or
							word.equals("Void") or
							word.equals("attribute") or
							word.equals("reference") or
							word.equals("property") or
							word.equals("readonly") or
							word.equals("getter") or
							word.equals("is") or
							word.equals("setter") or
							word.equals("raises") or
							word.equals("select") or
							word.equals("operation") or
							word.equals("method") or
							word.equals("bag") or
							word.equals("set") or
							word.equals("seq") or
							word.equals("oset") or
							word.equals("alias") or
							word.equals("enumeration") or
							word.equals("and") or
							word.equals("or") or
							word.equals("not") or
							//word.equals("self") or
							word.equals("super") or
							word.equals("do") or
							word.equals("end") or
							word.equals("function") or
							word.equals("rescue") or
							word.equals("from") or
							word.equals("until") or
							word.equals("loop") or
							word.equals("if") or
							word.equals("then") or
							word.equals("else") or
							word.equals("raise") or
							word.equals("var") or
							word.equals("init") or
							word.equals("extern") or
							word.equals("true") or
							word.equals("false") or
							word.equals("void") or
							word.equals("result") or
							word.equals("value") 
          end

	}
	

class IteratorPolicy {
	attribute name: String
	
    operation withName(functionName: String): IteratorPolicy is
	    do
	    	name := functionName
	    	result := self
	    end
	    
   	attribute suffix: String
	
    operation withSuffix(theSuffix: String): IteratorPolicy is
	    do
	    	suffix := theSuffix
	    	result := self
	    end
	    
	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	var e : Exception init Exception.new
		 	e.message := " Unimplemented policy: " + oclIterator.simpleNameCS.~value.toString
		 	raise e
		 end
}

class SimpleIteratorIP inherits IteratorPolicy {

	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			oclIterator.source.accept(visitor)
			visitor.write(".")
			if name == void then
				visitor.write(oclIterator.simpleNameCS.~value.toString )
			else
				visitor.write(name)
			end
			visitor.write("{ ")
			if (oclIterator.variable1 != void) then
				oclIterator.variable1.accept(visitor)
			else
				visitor.write(" e ")
				//TODO Check that mark
			end
			visitor.write(" | ")
			oclIterator.body.accept(visitor)
			visitor.write("}")
			if suffix != void then
				visitor.write(suffix)
			end
		 end
}

class UniqueIP inherits SimpleIteratorIP {

	method generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			name := "select"
			super(oclIterator, visitor)
			visitor.write(".asSet.size.equals(")
			oclIterator.source.accept(visitor)
			visitor.write(".size)")			
		 end
}

class FunctionIP inherits IteratorPolicy {
    
	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	if name == void then
				visitor.write(oclIterator.simpleNameCS.~value.toString )
			else
				visitor.writeln(name)
			end
			visitor.write("( ")
			oclIterator.source.accept(visitor)
			visitor.write(", \"")
			oclIterator.body.accept(visitor)
			visitor.write("\")")
		 end
}					
