/* $Id: ocl2kmtVisitor.kmt,v 1.2 2007-02-14 19:16:25 bitterjug Exp $
 * Creation date: February 5, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "::"
@mainOperation ""


package ocl2kmt;

require kermeta
require "../../mmodel/oclcstvisitor.kmt"
require "../../mmodel/Ecore.ecore"

using kermeta::standard
using ocl::cst
using ocl::cst::visitors
using kermeta::utils

class Writer {
    operation write(s: String) : Void is
	    do
	    	stdio.write(s)
	    end
    
    operation writeln(s: String): Void is
	    do
	    	stdio.writeln(s)
	    end
}

 class Ocl2kmtVisitor inherits ocl::cst::visitors::Visitor, Writer{
  
  		attribute __varName : Integer
  		attribute __invariantName : Integer
  		
		operation nextVarName() : String is
			do
				if __varName == void then
					__varName := 0
				end
				__varName := __varName + 1
				result := "variable" + __varName.toString
			end     

		operation nextInvariantName() : String is
			do
				if __invariantName == void then
					__invariantName := 0
				end
				__invariantName := __invariantName + 1
				result := "inv" + __invariantName.toString
			end     

  
	    operation visit(visitable : Visitable) : Void is
			do
				write( visitable.toString)
			end

		method visitCSTNode(visitable : CSTNode) : Void is
			do
				visit(visitable)
			end

		method visitPackageDeclarationCS(visitable : PackageDeclarationCS) : Void is
			do
				write("package ")
				visitable.pathNameCS.accept(self)
				write(";\n\n")
				visitable.contextDecls.each{ c |
						c.accept(self)
					}
			end

		method visitContextDeclCS(visitable : ContextDeclCS) : Void is
			do
				visit(visitable)
			end

		method visitPropertyContextCS(visitable : PropertyContextCS) : Void is
			do
				visit(visitable)
			end

		method visitClassifierContextDeclCS(visitable : ClassifierContextDeclCS) : Void is
			do
				write("@aspect \"true\" \n")
				write("class ")
				visitable.pathNameCS.accept(self)
				writeln("\n{")
				visitable.invOrDefCS.accept(self)
		      	writeln("\n} ")
			end

		method visitOperationContextDeclCS(visitable : OperationContextDeclCS) : Void is
			do
				visit(visitable)
			end
  
		method visitPrePostOrBodyDeclCS(visitable : PrePostOrBodyDeclCS) : Void is
			do
				visit(visitable)
			end

		method visitOperationCS(visitable : OperationCS) : Void is
			do
				write("operation ")
				visitable.simpleNameCS.accept(self)
				write("(")
				visitable.parameters.each{ p |
						p.accept(self)
					}
				write("):")
				visitable.typeCS.accept(self)
			end

		method visitInitOrDerValueCS(visitable : InitOrDerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitDerValueCS(visitable : DerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInitValueCS(visitable : InitValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInvOrDefCS(visitable : InvOrDefCS) : Void is
			do
				visit(visitable)
			end

		method visitInvCS(visitable : InvCS) : Void is
			do
				write("inv  " + nextInvariantName + " is \n do\n " )
				visitable.expressionCS.accept(self)
				write("\nend \n" )
			end

		method visitDefCS(visitable : DefCS) : Void is
			do
				 visitable.defExpressionCS.accept(self)
			end

		method visitDefExpressionCS(visitable : DefExpressionCS) : Void is
			do
				visitable.operationCS.accept(self)
				write(" is\ndo\n")
				write("  result := ")
				visitable.expressionCS.accept(self)
				write("\nend")
			end

		method visitPathNameCS(visitable : PathNameCS) : Void is
			do
				visitable.sequenceOfNames.each{o| 
					if o != void then
						write( o.toString)
					else
						write("[void path name]")
					end
				    //o.accept(self) 
				    }
			end

		method visitVariableExpCS(visitable : VariableExpCS) : Void is
			do
				visitable.simpleNameCS.accept(self)
			end

		method visitSimpleNameCS(visitable : SimpleNameCS) : Void is
			do
				write(visitable.~value.toString)
			end

		method visitTypeCS(visitable : TypeCS) : Void is
			do
				visit(visitable)
			end

		method visitPrimitiveTypeCS(visitable : PrimitiveTypeCS) : Void is
			do
				if visitable.~value.toString.equals("OclAny") then
					write("Object")
				else
					visitSimpleNameCS(visitable)
				end
			end

		method visitTupleTypeCS(visitable : TupleTypeCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionTypeCS(visitable : CollectionTypeCS) : Void is
			do
				write(visitable.collectionTypeIdentifier.name)
				write("<")
				visitable.typeCS.accept(self)
				write(">")
			end

		method visitOCLExpressionCS(visitable : OCLExpressionCS) : Void is
			do
				visit(visitable)
			end

		method visitLetExpCS(visitable : LetExpCS) : Void is
			do
				write(" do ")
				//variables
				visitable.variables.each{ v |
						write("\n var " )
						v.accept(self)
					}
				write("\n")
				//body
				visitable.inExpression.accept(self)
				write("\nend ")
			end

		method visitIfExpCS(visitable : IfExpCS) : Void is
			do
				visit(visitable)
			end

		method visitMessageExpCS(visitable : MessageExpCS) : Void is
			do
				visit(visitable)
			end

		method visitOCLMessageArgCS(visitable : OCLMessageArgCS) : Void is
			do
				visit(visitable)
			end

		method visitVariableCS(visitable : VariableCS) : Void is
			do
				write(visitable.name.toString)
				//visitable.name.accept(self)
				if visitable.typeCS != void then
					write(" : ")
					visitable.typeCS.accept(self)
				end
				if visitable.initExpression != void then
					write(" init ")
					visitable.initExpression.accept(self)
				end
			end

		method visitLiteralExpCS(visitable : LiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitEnumLiteralExpCS(visitable : EnumLiteralExpCS) : Void is
			do
				visitable.pathNameCS.accept(self)
				write("::")
				visitable.simpleNameCS.accept(self)
			end

		method visitCollectionLiteralExpCS(visitable : CollectionLiteralExpCS) : Void is
			do
				var varName :  String init nextVarName
				//TODO: do we have to infer the element type here?
				var type : String init visitable.collectionType.name +"<" + "????????" +">"
				write("do\n")
				write("var " + varName + " : " + type)
				write("init " + type + ".new\n")
				visitable.collectionLiteralParts.each{ clp |
						write(varName + ".add(")
						clp.accept(self)
						write(")\n")
					}
				write(varName)
			    write("\nend")
			end

		method visitTupleLiteralExpCS(visitable : TupleLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitPrimitiveLiteralExpCS(visitable : PrimitiveLiteralExpCS) : Void is
			do
  	 	 	    write(visitable.symbol)
			end

		method visitIntegerLiteralExpCS(visitable : IntegerLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitRealLiteralExpCS(visitable : RealLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitStringLiteralExpCS(visitable : StringLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitBooleanLiteralExpCS(visitable : BooleanLiteralExpCS) : Void is
			do
				visitPrimitiveLiteralExpCS(visitable)
			end

		method visitNullLiteralExpCS(visitable : NullLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitInvalidLiteralExpCS(visitable : InvalidLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionLiteralPartCS(visitable : CollectionLiteralPartCS) : Void is
			do
				visitable.expressionCS.accept(self)
			end

		method visitCollectionRangeCS(visitable : CollectionRangeCS) : Void is
			do
				visit(visitable)
			end

		method visitCallExpCS(visitable : CallExpCS) : Void is
			do
				visit(visitable)
			end

		method visitLoopExpCS(visitable : LoopExpCS) : Void is
			do
				visit(visitable)			
			end

        attribute __iterators : Hashtable<String, IteratorPolicy>
        
        operation addIterator(oclIteratorName: String, policy: IteratorPolicy) : Void is 
        do
        	__iterators.put(oclIteratorName, policy)
        end
        
        property readonly iterators : Hashtable<String, IteratorPolicy>
        	getter is
        		do
        			if __iterators == void then
        				__iterators := Hashtable<String, IteratorPolicy>.new
        				var doNothing : IteratorPolicy init IteratorPolicy.new
        				var sameName: IteratorPolicy init SimpleIteratorIP.new
        				var functionWithSameName : IteratorPolicy init FunctionIP.new
        				addIterator("exists", sameName)
        				addIterator("forAll", SimpleIteratorIP.new.withName("forAll"))
        				addIterator("isUnique", functionWithSameName)
        				addIterator("any", FunctionIP.new.withName("detect"))
        				addIterator("one", SimpleIteratorIP.new.withName("select").withSuffix(".size == 1"))
        				addIterator("collect", doNothing)
        				addIterator("collectNested", doNothing)
        				addIterator("sortedBy", doNothing)
        				addIterator("reject", doNothing)
        			end
        			result := __iterators
        		end
        		
		method visitIteratorExpCS(visitable : IteratorExpCS) : Void is
			do
				// <source> <accessor> <simpleNameCS>( <body> )
				// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
				// why can't I compare the enumerations normally
				// i.e. visitable.simpleNameCS.~type.equals(SimpleTypeEnum.keyword)
				//  <<<<<<<<<<<<<<<<<<<<<<<<
				if visitable.simpleNameCS.~type.name.equals(SimpleTypeEnum.keyword.name) then
				    // check which keyword type and act accordingly
				    // TODO: this won't work in cases where the inner expression defines its own variables
					var policy: IteratorPolicy init iterators.getValue(visitable.simpleNameCS.~value.toString)
					if policy != void then
						// TODO: assert that the accessor was an arrow
						policy.generate(visitable, self)
					else
						writeln("Unknown keyword type " +visitable.simpleNameCS.~value.toString )
					end
				end
			end

		method visitIterateExpCS(visitable : IterateExpCS) : Void is
			do
				visit(visitable)			
			end


		
		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				//visit(visitable)	
				if visitable.source != void then
					visitable.source.accept(self)		
					if visitable.accessor.name == "dot" then
					   write(".")
					end
				end
				visitable.simpleNameCS.accept(self)
				if visitable.arguments.size > 0 then
					write("(")
					from
						var it : Iterator<OCLExpressionCS> init visitable.arguments.iterator
					until
						it.isOff
					loop
						it.next.accept(self)
						if  it.hasNext then
							write(", ") 
						end
					end
					write(")")
			  	end
			  	
			end

	   attribute __operators: Hashtable<String, OperatorPolicy>
        property readonly operators: Hashtable<String, OperatorPolicy>
			getter is 
				do
          			if __operators == void then
          			    var impliesOp : OperatorPolicy init ImpliesOP.new
          			    var simpleOp : OperatorPolicy init SimpleOP.new
          				__operators := Hashtable<String, OperatorPolicy>.new
          				__operators.put("implies", impliesOp)
          				__operators.put("and", simpleOp)
          				__operators.put("or", simpleOp)
          				__operators.put("xor", simpleOp)
          				__operators.put("=", SimpleOP.new.withName("=="))
          				__operators.put("<", simpleOp)
          				__operators.put("<=", simpleOp)
          				__operators.put(">", simpleOp)
          				__operators.put(">=", simpleOp)
          				__operators.put("<>", SimpleOP.new.withName("!="))
          				__operators.put("+", simpleOp)
          				__operators.put("-", simpleOp)
          				__operators.put("*", simpleOp)
          				__operators.put("/", simpleOp)
          				__operators.put("includes", FunctionCallOp.new.withName("contains"))
          				__operators.put("size", FunctionCallOp.new)
          				__operators.put("at", FunctionCallOp.new.withName("elementAt"))
          				__operators.put("indexOf", FunctionCallOp.new)
          				__operators.put("oclAsType", CastOp.new)          				
          				__operators.put("oclIsUndefined", NotNullOp.new)          				
          				__operators.put("not", PrefixOp.new.withName("not"))          				
          			end
          			result := __operators
				end


		method visitOperationCallExpCS(visitable : OperationCallExpCS) : Void is
			do
				//visit(visitable)		
				var policy: OperatorPolicy init operators.getValue(visitable.simpleNameCS.~value.toString)
				if policy != void then
					policy.generate(visitable, self)
				else
					visitFeatureCallExpCS(visitable)
				end
			end

		method visitIsMarkedPreCS(visitable : IsMarkedPreCS) : Void is
			do
				visit(visitable)			
			end

		method visitStateExpCS(visitable : StateExpCS) : Void is
			do
				visit(visitable)			
			end

	}
	


class OperatorPolicy inherits Writer {

	attribute name: String
	
	operation withName(opName: String): OperatorPolicy is
		do
			name := opName
			result := self
		end
		
	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
	 do
	 	writeln("\n Unimplemented policy: " + oclOp.simpleNameCS.~value.toString)
	 end

}

class SimpleOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
				oclOp.source.accept(visitor)		
				write(" ")
				if name != void then
					write(name)
				else
					oclOp.simpleNameCS.accept(visitor)
				end
				write(" ")
				// TODO: assert: visitable.arguments.size == 1 ??? 
				oclOp.arguments.each{ arg |
						arg.accept(visitor)
			  	}
		 end
}

class ImpliesOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			write("not (")
			oclOp.source.accept(visitor)
			write(") or ( ")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
  			writeln(")")
		 end
}

class CastOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			write("do")
			write(" var ")
			var localVarName : String init visitor.nextVarName
			write(localVarName)			
			write(" : ")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			// TODO: assert: the unique parameter is a type name ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
		  	write(" init ")
			oclOp.source.accept(visitor)			
			write( "  ")
			write(localVarName)			
  			write( " end ")
		 end
	
}

class NotNullOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		do
			oclOp.source.accept(visitor)
			write (" == void")
		end
		
}

class PrefixOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		do
			write(name)
			write(" (")
			oclOp.source.accept(visitor)			
			write(")")
		end
		
}



class FunctionCallOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 // TODO: only if the accessor type is 'arrow', 
		// if its not arrow, should treat is as a normal operation call if thats possible from here
			oclOp.source.accept(visitor)
			write(".")
			if name != void then
				write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			write("(")
			from
				var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
			until
				it.isOff
			loop
				write(" ")
				it.next.accept(visitor)
				if  it.hasNext then
					write(",") 
				else
					write(" ")
				end
			end
  			write(")")
		 end
}

class IteratorPolicy inherits Writer {
	attribute name: String
	
    operation withName(functionName: String): IteratorPolicy is
	    do
	    	name := functionName
	    	result := self
	    end
	    
   	attribute suffix: String
	
    operation withSuffix(theSuffix: String): IteratorPolicy is
	    do
	    	suffix := theSuffix
	    	result := self
	    end
	    
	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	writeln("\n Unimplemented policy: " + oclIterator.simpleNameCS.~value.toString)
		 end
}

class SimpleIteratorIP inherits IteratorPolicy {

	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			oclIterator.source.accept(visitor)
			write(".")
			if name == void then
				write(oclIterator.simpleNameCS.~value.toString )
			else
				write(name)
			end
			write("{ ")
			oclIterator.variable1.accept(visitor)
			write(" | ")
			oclIterator.body.accept(visitor)
			write("}")
			if suffix != void then
				write(suffix)
			end
		 end
}



class FunctionIP inherits IteratorPolicy {
    
	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	if name == void then
				write(oclIterator.simpleNameCS.~value.toString )
			else
				writeln(name)
			end
			write("( ")
			oclIterator.source.accept(visitor)
			write(", \"")
			oclIterator.body.accept(visitor)
			write("\")")
		 end
}					
