/* $Id: ocl2kmtVisitor.kmt,v 1.3 2007-02-22 18:56:10 bitterjug Exp $
 * Creation date: February 5, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "::"
@mainOperation ""


package ocl2kmt;

require kermeta
require "../../mmodel/oclcstvisitor.kmt"
require "../../mmodel/Ecore.ecore"

using kermeta::standard
using kermeta::exceptions
using ocl::cst
using ocl::cst::visitors
using kermeta::utils
using kermeta::io

class StringWriter inherits StdIO
{

	reference s: String

	method write(object: String) is
		do
			if s == void then
				s := object
			else
				s := s + object
			end
		end
		
	method writeln(object: String) is
		do
			self.write(object)
			self.write(" ")
		end
		
	method read(prompt: String): String is
		do
			var e: Exception init Exception.new
			e.message := "Sorry, you can't read from a writer"
			raise e
		end
}

 class Ocl2kmtVisitor inherits ocl::cst::visitors::Visitor {

		reference  __io: StdIO 
		
		operation getIo(): StdIO is
			do
				if __io == void then
					__io := stdio
				end
				result := __io
			end
		
		/**
		 * Use this to set a string writer to get the generated source as a string
		 */
		operation setIo(newio: StdIO) is
			do
				self.__io := newio
			end
		
	    operation write(s: String) : Void is
		    do
		    	getIo.write(s)
		    end
    
	    operation writeln(s: String): Void is
		    do
		    	getIo.writeln(s)
		    end

  
  		attribute __varName : Integer
  		attribute __invariantName : Integer
  		
		operation nextVarName() : String is
			do
				if __varName == void then
					__varName := 0
				end
				__varName := __varName + 1
				result := "variable" + __varName.toString
			end     

		operation nextInvariantName() : String is
			do
				if __invariantName == void then
					__invariantName := 0
				end
				__invariantName := __invariantName + 1
				result := "inv" + __invariantName.toString
			end     

  
	    operation visit(visitable : Visitable) : Void is
			do
				write( visitable.toString)
			end

		method visitCSTNode(visitable : CSTNode) : Void is
			do
				visit(visitable)
			end

		method visitPackageDeclarationCS(visitable : PackageDeclarationCS) : Void is
			do
				write("package ")
				visitable.pathNameCS.accept(self)
				writeln("")
				writeln("")
				visitable.contextDecls.each{ c |
						c.accept(self)
					}
			end

		method visitContextDeclCS(visitable : ContextDeclCS) : Void is
			do
				visit(visitable)
			end

		method visitPropertyContextCS(visitable : PropertyContextCS) : Void is
			do
				visit(visitable)
			end

		method visitClassifierContextDeclCS(visitable : ClassifierContextDeclCS) : Void is
			do
				writeln("@aspect \"true\"")
				write("class ")
				visitable.pathNameCS.accept(self)
				writeln("{")
				visitable.invOrDefCS.accept(self)
		      	writeln("} ")
			end

		method visitOperationContextDeclCS(visitable : OperationContextDeclCS) : Void is
			do
				visit(visitable)
			end
  
		method visitPrePostOrBodyDeclCS(visitable : PrePostOrBodyDeclCS) : Void is
			do
				visit(visitable)
			end

		method visitOperationCS(visitable : OperationCS) : Void is
			do
				write("operation ")
				visitable.simpleNameCS.accept(self)
				write("(")
				visitable.parameters.each{ p |
						p.accept(self)
					}
				write("):")
				visitable.typeCS.accept(self)
			end

		method visitInitOrDerValueCS(visitable : InitOrDerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitDerValueCS(visitable : DerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInitValueCS(visitable : InitValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInvOrDefCS(visitable : InvOrDefCS) : Void is
			do
				visit(visitable)
			end

		method visitInvCS(visitable : InvCS) : Void is
			do
				writeln("inv  " + nextInvariantName + " is ")
				writeln("do" )
				visitable.expressionCS.accept(self)
				writeln("")
				writeln("end" )
			end

		method visitDefCS(visitable : DefCS) : Void is
			do
				 visitable.defExpressionCS.accept(self)
			end

		method visitDefExpressionCS(visitable : DefExpressionCS) : Void is
			do
				visitable.operationCS.accept(self)
				writeln(" is")
				writeln("do")
				write("  result := ")
				visitable.expressionCS.accept(self)
				writeln("")
				write("end")
			end

		method visitPathNameCS(visitable : PathNameCS) : Void is
			do
				visitable.sequenceOfNames.each{o| 
					if o != void then
						write( o.toString)
					else
						write("[void path name]")
					end
				    //o.accept(self) 
				    }
			end

		method visitVariableExpCS(visitable : VariableExpCS) : Void is
			do
				visitable.simpleNameCS.accept(self)
			end

       
          
		method visitSimpleNameCS(visitable : SimpleNameCS) : Void is
			do
			    var name : String init visitable.~value.toString
			    if isKermetaKeyword(name) then
			    	write("~")
			    end
				write(name)
			end

		method visitTypeCS(visitable : TypeCS) : Void is
			do
				visit(visitable)
			end

		method visitPrimitiveTypeCS(visitable : PrimitiveTypeCS) : Void is
			do
				if visitable.~value.toString.equals("OclAny") then
					write("Object")
				else
					visitSimpleNameCS(visitable)
				end
			end

		method visitTupleTypeCS(visitable : TupleTypeCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionTypeCS(visitable : CollectionTypeCS) : Void is
			do
				write(visitable.collectionTypeIdentifier.name)
				write("<")
				visitable.typeCS.accept(self)
				write(">")
			end

		method visitOCLExpressionCS(visitable : OCLExpressionCS) : Void is
			do
				visit(visitable)
			end

		method visitLetExpCS(visitable : LetExpCS) : Void is
			do
				write(" do ")
				//variables
				visitable.variables.each{ v |
						writeln("")
						write("var " )
						v.accept(self)
					}
				writeln("")
				//body
				visitable.inExpression.accept(self)
				writeln("")
				writeln("end")
			end

		method visitIfExpCS(visitable : IfExpCS) : Void is
			do
				visit(visitable)
			end

		method visitMessageExpCS(visitable : MessageExpCS) : Void is
			do
				visit(visitable)
			end

		method visitOCLMessageArgCS(visitable : OCLMessageArgCS) : Void is
			do
				visit(visitable)
			end

		method visitVariableCS(visitable : VariableCS) : Void is
			do
				write(visitable.name.toString)
				//visitable.name.accept(self)
				if visitable.typeCS != void then
					write(" : ")
					visitable.typeCS.accept(self)
				end
				if visitable.initExpression != void then
					write(" init ")
					visitable.initExpression.accept(self)
				end
			end

		method visitLiteralExpCS(visitable : LiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitEnumLiteralExpCS(visitable : EnumLiteralExpCS) : Void is
			do
				visitable.pathNameCS.accept(self)
				write("::")
				visitable.simpleNameCS.accept(self)
			end

		method visitCollectionLiteralExpCS(visitable : CollectionLiteralExpCS) : Void is
			do
				var varName :  String init nextVarName
				//TODO: do we have to infer the element type here?
				var type : String init visitable.collectionType.name +"<" + "????????" +">"
				writeln("do")
				write("var " + varName + " : " + type)
				writeln("init " + type + ".new")
				visitable.collectionLiteralParts.each{ clp |
						write(varName + ".add(")
						clp.accept(self)
						writeln(")")
					}
				writeln(varName)
			    write("end")
			end

		method visitTupleLiteralExpCS(visitable : TupleLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitPrimitiveLiteralExpCS(visitable : PrimitiveLiteralExpCS) : Void is
			do
  	 	 	    write(visitable.symbol)
			end

		method visitIntegerLiteralExpCS(visitable : IntegerLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitRealLiteralExpCS(visitable : RealLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitStringLiteralExpCS(visitable : StringLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitBooleanLiteralExpCS(visitable : BooleanLiteralExpCS) : Void is
			do
				visitPrimitiveLiteralExpCS(visitable)
			end

		method visitNullLiteralExpCS(visitable : NullLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitInvalidLiteralExpCS(visitable : InvalidLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionLiteralPartCS(visitable : CollectionLiteralPartCS) : Void is
			do
				visitable.expressionCS.accept(self)
			end

		method visitCollectionRangeCS(visitable : CollectionRangeCS) : Void is
			do
				visit(visitable)
			end

		method visitCallExpCS(visitable : CallExpCS) : Void is
			do
				visit(visitable)
			end

		method visitLoopExpCS(visitable : LoopExpCS) : Void is
			do
				visit(visitable)			
			end

        attribute __iterators : Hashtable<String, IteratorPolicy>
        
        operation addIterator(oclIteratorName: String, policy: IteratorPolicy) : Void is 
        do
        	__iterators.put(oclIteratorName, policy)
        end
        
        property readonly iterators : Hashtable<String, IteratorPolicy>
        	getter is
        		do
        			if __iterators == void then
        				__iterators := Hashtable<String, IteratorPolicy>.new
        				var doNothing : IteratorPolicy init IteratorPolicy.new
        				var sameName: IteratorPolicy init SimpleIteratorIP.new
        				var functionWithSameName : IteratorPolicy init FunctionIP.new
        				addIterator("exists", sameName)
        				addIterator("forAll", SimpleIteratorIP.new.withName("forAll"))
        				addIterator("isUnique", functionWithSameName)
        				addIterator("any", FunctionIP.new.withName("detect"))
        				addIterator("one", SimpleIteratorIP.new.withName("select").withSuffix(".size == 1"))
        				addIterator("select", SimpleIteratorIP.new.withName("select"))
        				addIterator("collect", doNothing)
        				addIterator("collectNested", doNothing)
        				addIterator("sortedBy", doNothing)
        				addIterator("reject", doNothing)
        			end
        			result := __iterators
        		end
        		
		method visitIteratorExpCS(visitable : IteratorExpCS) : Void is
			do
				// <source> <accessor> <simpleNameCS>( <body> )
				// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
				// why can't I compare the enumerations normally
				// i.e. visitable.simpleNameCS.~type.equals(SimpleTypeEnum.keyword)
				//  <<<<<<<<<<<<<<<<<<<<<<<<
				if visitable.simpleNameCS.~type.name.equals(SimpleTypeEnum.keyword.name) then
				    // check which keyword type and act accordingly
				    // TODO: this won't work in cases where the inner expression defines its own variables
					var policy: IteratorPolicy init iterators.getValue(visitable.simpleNameCS.~value.toString)
					if policy != void then
						// TODO: assert that the accessor was an arrow
						policy.generate(visitable, self)
					else
						writeln("Unknown keyword type " +visitable.simpleNameCS.~value.toString )
					end
				end
			end

		method visitIterateExpCS(visitable : IterateExpCS) : Void is
			do
				visit(visitable)			
			end


		
		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				//visit(visitable)	
				if visitable.source != void then
					visitable.source.accept(self)		
					if visitable.accessor.name == "dot" then
					   write(".")
					end
				end
				visitable.simpleNameCS.accept(self)
				if visitable.arguments.size > 0 then
					write("(")
					from
						var it : Iterator<OCLExpressionCS> init visitable.arguments.iterator
					until
						it.isOff
					loop
						it.next.accept(self)
						if  it.hasNext then
							write(", ") 
						end
					end
					write(")")
			  	end
			  	
			end

	   attribute __operators: Hashtable<String, OperatorPolicy>
        property readonly operators: Hashtable<String, OperatorPolicy>
			getter is 
				do
          			if __operators == void then
          			    var impliesOp : OperatorPolicy init ImpliesOP.new
          			    var simpleOp : OperatorPolicy init SimpleOP.new
          				__operators := Hashtable<String, OperatorPolicy>.new
          				__operators.put("implies", impliesOp)
          				__operators.put("and", simpleOp)
          				__operators.put("or", simpleOp)
          				__operators.put("xor", simpleOp)
          				__operators.put("=", SimpleOP.new.withName("=="))
          				__operators.put("<", simpleOp)
          				__operators.put("<=", simpleOp)
          				__operators.put(">", simpleOp)
          				__operators.put(">=", simpleOp)
          				__operators.put("<>", SimpleOP.new.withName("!="))
          				__operators.put("+", simpleOp)
          				__operators.put("-", simpleOp)
          				__operators.put("*", simpleOp)
          				__operators.put("/", simpleOp)
          				__operators.put("includes", FunctionCallOp.new.withName("contains"))
          				__operators.put("size", FunctionCallOp.new)
          				__operators.put("at", FunctionCallOp.new.withName("elementAt"))
          				__operators.put("indexOf", FunctionCallOp.new)
          				__operators.put("oclAsType", CastOp.new)          				
          				__operators.put("oclIsUndefined", NotNullOp.new)          				
          				__operators.put("not", PrefixOp.new.withName("not"))          				
          				__operators.put("notEmpty", FunctionCallOp.new.withName("size").withSuffix(" > 0"))          		
          				__operators.put("isEmpty", FunctionCallOp.new.withName("size").withSuffix(" = 0"))          		          				
           				__operators.put("includesAll", FunctionCallOp.new.withName("size").withSuffix(" = 0"))          		          				
           				__operators.put("union", FunctionCallOp.new)          		          				
           				__operators.put("intersection", FunctionCallOp.new)          		          				
           				__operators.put("incluiding", UnimplementedOp.new)  // these need type inference
           				__operators.put("excluding", UnimplementedOp.new)  // or something clever with types
           				// TODO: set difference in OCL is "-", this might take some detecting
          				__operators.put("symmetricDifference", UnimplementedOp.new)
          			end
          			result := __operators
				end


		method visitOperationCallExpCS(visitable : OperationCallExpCS) : Void is
			do
				//visit(visitable)		
				var policy: OperatorPolicy init operators.getValue(visitable.simpleNameCS.~value.toString)
				if policy != void then
					policy.generate(visitable, self)
				else
					visitFeatureCallExpCS(visitable)
				end
			end

		method visitIsMarkedPreCS(visitable : IsMarkedPreCS) : Void is
			do
				visit(visitable)			
			end

		method visitStateExpCS(visitable : StateExpCS) : Void is
			do
				visit(visitable)			
			end

 operation isKermetaKeyword(word: String): Boolean is
          do
          		result :=	word.equals("package") or
							word.equals("require") or
							word.equals("includeFilter") or
							word.equals("excludeFilter") or
							word.equals("using") or
							word.equals("inherits") or
							word.equals("class") or
							//word.equals("@pre" ) or
							word.equals("pre") or
							word.equals("post") or
							word.equals("inv") or
							word.equals("abstract") or
							word.equals("Self") or
							word.equals("Void") or
							word.equals("attribute") or
							word.equals("reference") or
							word.equals("property") or
							word.equals("readonly") or
							word.equals("getter") or
							word.equals("is") or
							word.equals("setter") or
							word.equals("raises") or
							word.equals("select") or
							word.equals("operation") or
							word.equals("method") or
							word.equals("bag") or
							word.equals("set") or
							word.equals("seq") or
							word.equals("oset") or
							word.equals("alias") or
							word.equals("enumeration") or
							word.equals("and") or
							word.equals("or") or
							word.equals("not") or
							//word.equals("self") or
							word.equals("super") or
							word.equals("do") or
							word.equals("end") or
							word.equals("function") or
							word.equals("rescue") or
							word.equals("from") or
							word.equals("until") or
							word.equals("loop") or
							word.equals("if") or
							word.equals("then") or
							word.equals("else") or
							word.equals("raise") or
							word.equals("var") or
							word.equals("init") or
							word.equals("extern") or
							word.equals("true") or
							word.equals("false") or
							word.equals("void") or
							word.equals("result") or
							word.equals("value") 
          end

	}
	


class OperatorPolicy  {

	attribute name: String
	
	operation withName(opName: String): OperatorPolicy is
		do
			name := opName
			result := self
		end
		
	attribute suffix: String
	
    operation withSuffix(theSuffix: String): OperatorPolicy is
	    do
	    	suffix := theSuffix
	    	result := self
	    end
	    
		
	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
	  do
		 	var e : Exception  init Exception.new
		 	e.message := "Unimplemented policy: " + oclOp.simpleNameCS.~value.toString
		 	raise e
	  end
	  
	operation getPrefix():String is
	  do
	  		if suffix != void then
	  		  	result := "("
	  		 else
	  		 	result := ""
	  		end
	  end
	  
 	operation getSuffix(): String is
   	  do
   	  		if suffix != void then
   	  			result := suffix + ")"
   	  		else
   	  			result := ""
   	  		end
   	  end

}

class SimpleOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
				oclOp.source.accept(visitor)		
				visitor.write(" ")
				if name != void then
					visitor.write(name)
				else
					oclOp.simpleNameCS.accept(visitor)
				end
				visitor.write(" ")
				// TODO: assert: visitable.arguments.size == 1 ??? 
				oclOp.arguments.each{ arg |
						arg.accept(visitor)
			  	}
		 end
}

class ImpliesOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			visitor.write("not (")
			oclOp.source.accept(visitor)
			visitor.write(") or ( ")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
  			visitor.writeln(")")
		 end
}

class UnimplementedOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			var e: Exception init Exception.new
			e.message := "Unimplemented Operation type: " + oclOp.simpleNameCS.~value.toString
			raise e
		 end
}

class CastOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			visitor.write("do")
			visitor.write(" var ")
			var localVarName : String init visitor.nextVarName
			visitor.write(localVarName)			
			visitor.write(" : ")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			// TODO: assert: the unique parameter is a type name ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
		  	visitor.write(" init ")
			oclOp.source.accept(visitor)			
			visitor.write( "  ")
			visitor.write(localVarName)			
  			visitor.write( " end ")
		 end
	
}

class NotNullOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		do
			oclOp.source.accept(visitor)
			visitor.write (" == void")
		end
		
}

class PrefixOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		do
			visitor.write(name)
			visitor.write(" (")
			oclOp.source.accept(visitor)			
			visitor.write(")")
		end
		
}



class FunctionCallOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 // TODO: only if the accessor type is 'arrow', 
		// if its not arrow, should treat is as a normal operation call if thats possible from here
		    visitor.write(getPrefix)
			oclOp.source.accept(visitor)
			visitor.write(".")
			if name != void then
				visitor.write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			visitor.write("(")
			from
				var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
			until
				it.isOff
			loop
				visitor.write(" ")
				it.next.accept(visitor)
				if  it.hasNext then
					visitor.write(",") 
				else
					visitor.write(" ")
				end
			end
  			visitor.write(")")
  			visitor.write(getSuffix)
		 end
}

class IteratorPolicy {
	attribute name: String
	
    operation withName(functionName: String): IteratorPolicy is
	    do
	    	name := functionName
	    	result := self
	    end
	    
   	attribute suffix: String
	
    operation withSuffix(theSuffix: String): IteratorPolicy is
	    do
	    	suffix := theSuffix
	    	result := self
	    end
	    
	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	var e : Exception init Exception.new
		 	e.message := " Unimplemented policy: " + oclIterator.simpleNameCS.~value.toString
		 	raise e
		 end
}

class SimpleIteratorIP inherits IteratorPolicy {

	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			oclIterator.source.accept(visitor)
			visitor.write(".")
			if name == void then
				visitor.write(oclIterator.simpleNameCS.~value.toString )
			else
				visitor.write(name)
			end
			visitor.write("{ ")
			oclIterator.variable1.accept(visitor)
			visitor.write(" | ")
			oclIterator.body.accept(visitor)
			visitor.write("}")
			if suffix != void then
				visitor.write(suffix)
			end
		 end
}



class FunctionIP inherits IteratorPolicy {
    
	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	if name == void then
				visitor.write(oclIterator.simpleNameCS.~value.toString )
			else
				visitor.writeln(name)
			end
			visitor.write("( ")
			oclIterator.source.accept(visitor)
			visitor.write(", \"")
			oclIterator.body.accept(visitor)
			visitor.write("\")")
		 end
}					
