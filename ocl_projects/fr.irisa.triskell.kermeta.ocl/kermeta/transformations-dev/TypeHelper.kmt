/* $Id: TypeHelper.kmt,v 1.2 2007-08-13 17:21:25 bitterjug Exp $
 * Creation date: July 25, 2007
 * License:
 * Copyright:
 * Authors: Mark Skipper
 */
@mainClass "ocl2kmt::TypeHelper"
@mainOperation "main"

package ocl2kmt;
require kermeta
require "EcoreHelper.kmt" 
require "oclcstvisitor.kmt"
require "../helpers/QualifiedName.kmt"


using kermeta::standard
using ocl::cst
using kermeta::standard
using kermeta::utils
using kermeta::exceptions
using qualifiedNames

class StackFrame {

	reference __visibleVariable : Hashtable<String,ecore::ETypedElement>
	reference next: StackFrame
	
	operation visibleVariable(): Hashtable<String,ecore::ETypedElement> is
		do
			if __visibleVariable == void then
				__visibleVariable := Hashtable<String,ecore::ETypedElement>.new
			end
			result := __visibleVariable
		end

	operation xclear() is
		do
			visibleVariable.clear
		end
		
	operation addByName(name: String, feature:ecore::ETypedElement) is
		do
			visibleVariable.put(name, feature)
		end

	operation xaddAll(features: Collection<ecore::ETypedElement>) is
		do
		  features.each{ parameter |  add(parameter) }
		end
		
	operation add(variable: ecore::ETypedElement) is
		do
			visibleVariable.put(variable.name.toString, variable)
		end
		
	operation lookup(varName: String) : ecore::ETypedElement is
		do
			result := visibleVariable.getValue(varName)
			if result == void and next != void then
				result := next.lookup(varName)
			end
		end
		
	operation setNext(newNext: StackFrame): StackFrame is
		do
			next := newNext
			result := self
		end
}

class VarStack {

	reference top: StackFrame
	
	operation push(): Void is
		do
			top := StackFrame.new.setNext(self.top)
		end
		
	operation pop(): Void is
		do
			if top == void then
				stdio.writeln("Warning: pop on empty stack")
			else
    			top := top.next
			end
		end
		
	operation lookup(varName: String) : ecore::ETypedElement is
		do
			if top != void then
				result := top.lookup(varName)
			end
		end
	
}

class TypeHelper 
{
	reference contextPackageName : String
	reference contextClassifierName : String
	reference localFeature: ecore::ETypedElement
	
	attribute __primitiveTypes: Hashtable<String, ecore::EDataType>
	attribute __primitiveOperations : Hashtable<String, ecore::ETypedElement> 
	
	operation isDefined(s: String): Boolean is
		do
			result := (s != void) and (s != "")
		end

	operation assertIsDefined(s: String, err: String) is
		do
			if  not isDefined(s) then
				var e: Exception init Exception.new
				e.message := err
				raise e
			end
		end

		reference __context: VarStack
		
		operation context(): VarStack is
			do
				if __context == void then
					__context := VarStack.new
				end
				result := __context
			end

		reference __ecoreHelper : EcoreHelpers::EcoreHelper
		
		operation setMetamodelURI(metamodelURI: String) is
			do
				stdio.writeln("Creating ecoreHelper for metamodel: " + metamodelURI)
				__ecoreHelper := EcoreHelpers::EcoreHelper.new
				__ecoreHelper.initialize
				__ecoreHelper.loadMetamodel(metamodelURI)  
			end
			
		operation ecoreHelper(): EcoreHelpers::EcoreHelper is
			do
				if __ecoreHelper == void then
					var e : Exception init Exception.new
					e.message := "Metamodel URI must be set before visiting"
					raise e
				else
					result := __ecoreHelper
				end
			end

	operation primitiveTypes(): Hashtable<String, ecore::EDataType> is
		do
			if __primitiveTypes == void then
				__primitiveTypes := Hashtable<String, ecore::EDataType>.new 
    			result := __primitiveTypes
    			result.put("Integer", newType("Integer"))
    			result.put("Real", newType("Real"))
    			result.put("String", newType("String"))
    			result.put("Boolean", newType("Boolean"))
			end
			result := __primitiveTypes
		end
		
	operation isPrimitiveType(typeName: String) : Boolean is
		do
			result := primitiveTypes.containsKey(typeName)
			if result then
				stdio.writeln("[" + typeName +"] is a primitive type")
			else
				stdio.writeln("[" + typeName +"] is NOT a primitive type")
			end
		end
		
	operation primitiveOperations(): Hashtable<String, ecore::ETypedElement> is
		do
			if __primitiveOperations == void then
				__primitiveOperations :=  Hashtable<String, ecore::ETypedElement> .new
				__primitiveOperations.put("String.size", createAttribute("String.size", lookupPrimitiveType("String"), 1,1,false))
				__primitiveOperations.put("String.concat", createAttribute("String.size", lookupPrimitiveType("Integer"), 1,1,false))
				__primitiveOperations.put("String.substring",createAttribute("String.substring", lookupPrimitiveType("String"), 1,1,false) )
				__primitiveOperations.put("String.toInteger",createAttribute("String.size", lookupPrimitiveType("Integer"), 1,1,false) )
				__primitiveOperations.put("String.toReal", createAttribute("String.size", lookupPrimitiveType("Real"), 1,1,false))
			end
			result  := __primitiveOperations
		end
		
	operation getPrimitiveOperation(typeName: String, operationName: String ): ecore::ETypedElement is
		do
			result := primitiveOperations.getValue(typeName+"."+operationName)
		end
		
	operation lookupPrimitiveType(typeName: String) : ecore::EDataType is
		do
			result := primitiveTypes.getValue(typeName)
		end
		
	operation getLocalFeature() : ecore::ETypedElement is
		do
			if localFeature == void then
				stdio.writeln("Attempt to get lcoal feature before it has been set, reurning 'self' as default value")
				setLocalFeature(getLocalVariable("self"))
			end
			result := localFeature
		end
		
	operation getLocalFeatureIsMultiple(): Boolean is
		do
			result := getLocalFeature().many
			stdio.writeln("Local feature [" +getLocalFeature.name +"] is multiple  is :" + result.toString)
    	end
    	
	operation getLocalFeatureIsOrdered(): Boolean is
		do
			result := getLocalFeature().ordered
    	end
    	
	operation setLocalFeature(feature: ecore::ETypedElement) is
		do
			stdio.writeln("Setting local feature to [" +feature.name + "] of type [" +  feature.eType.name + "]")
			localFeature := feature
		end
	
	operation stringLiteral(): ecore::ETypedElement is
		do
			result := simpleValue("String")
		end
		
	operation simpleValue(typeName: String): ecore::ETypedElement is
		do
			//TODO, could make this a singleton or hash on type names like primitive types
			result := createAttribute("simple value", lookupPrimitiveType(typeName), 1,1,false)
		end
		
	operation getContextFeature(type: ecore::EClassifier, name: String): ecore::ETypedElement is
		do
			stdio.writeln("Looking up feature ["+ name +"] in context [" +type.name + "]")
			var localClass : ecore::EClass 
			localClass ?= type
			if localClass != void then
    			result := ecoreHelper.getETypedElement(localClass, name)
			else
				if isPrimitiveType(type.name) then
					result := getPrimitiveOperation(type.name, name)
				else
    				raise TypeError.new.setMessage("Can't look for feature '"+ name+"' in type: " + type.name +  type.toString + " which is not a class")
				end
			end
		end
	
	operation getLocalFeatureTypeName(): String is
		do
			result := getLocalFeatureType().name
		end
		
	operation getLocalFeatureType(): ecore::EClassifier is
		do
			result := getLocalFeature.eType
		end
		
	operation setContextClassifierName(qualifiedName: String) is
		do
			stdio.writeln("Setting context classifier name [" + qualifiedName + "]")
			contextClassifierName := qualifiedName
		end
		
	operation  setContextPackageName(qualifiedName: String) is
		do
			stdio.writeln("Setting context package name [" + qualifiedName + "]")
			contextPackageName := qualifiedName
		end
		
	operation getContextClassifier(): ecore::EClass is
		do
		//pre:
			assertIsDefined(contextPackageName, "Package name not defined, cannot perform lookup")
			assertIsDefined(contextClassifierName, "Classifier name not defined, cannot perform lookup")
		//body:
			var classifierFQN : String init contextPackageName + "::" + contextClassifierName
			stdio.writeln("Looking up context classifier [" + classifierFQN + "]")
			var classifier : ecore::EClass 
			result ?= ecoreHelper.getEcoreClassifierByQualifiedName(classifierFQN)
		//post:
			if result == void then
				var e : Exception init Exception.new
				e.message := "Can't find cass " + classifierFQN + " in the ecore metamodel"
				raise e
			end
			stdio.writeln("Found classifier [" + result.name + "]")
		end
		
			
	operation pushNewStackFrame() is
		do
			context.push()
			context.top.add( createAttribute("self", getContextClassifier, 1, 1, false))
		end
		
	operation popStackFrame() is
		do
			context.pop()
		end
		
	operation findTypeInMetamodel(typeName: String) : ecore::EClassifier is
		do
			stdio.writeln("Looking for type [" + typeName + "] in metamodel")
			from
    			var prefix : QualifiedName init QualifiedName.new.appendString( contextPackageName).appendString( contextClassifierName).packageName
			until
				result != void 
			loop
				var qualifiedName : QualifiedName init prefix.appendString(typeName)
    			stdio.writeln("   Trying:  ["+ qualifiedName.toString + "] in the metamodel...")
				result := ecoreHelper.getClassifierByFQN(prefix.appendString(typeName))
				prefix := prefix.packageName
			end
			if result == void then
    			raise TypeError.new.setMessage("FindTypeInMetamodel: Unknown type: " +  typeName)
		    end
		end
	
	operation findType(typeName: String): ecore::EClassifier is
		do
			stdio.writeln("Resolving type [" + typeName+ "]")
			if isPrimitiveType(typeName) then
				result := lookupPrimitiveType(typeName)
    			stdio.writeln("Type [" + typeName+ "] is a primitive type")
			else
				result := findTypeInMetamodel(typeName)
				if result != void then
        			stdio.writeln("Type [" + typeName+ "] found in metamodel")
				else
					raise TypeError.new.setMessage("Unrecognised type: " + typeName)
				end
			end
		end
		
	operation addLocalTypedVariable(name: String, type: ecore::EClassifier, lowerBound: Integer, upperBound: Integer, ordered: Boolean) is
		do
			context.top.add( createAttribute(name, type, lowerBound, upperBound, ordered))
		end
		
	operation addLocalVariable(name: String, typeName: String, lowerBound: Integer, upperBound: Integer, ordered: Boolean) is
		do
			assertIsDefined(name, "local variable name must be defined")
			assertIsDefined(typeName, "local variable's type name must be defined")
			stdio.writeln("Adding variable [" + name + "] with a type called  [" + typeName +"] lower bound: ["+lowerBound.toString+"] upper bound: ["+upperBound.toString+"]")
			addLocalTypedVariable( name, findType(typeName), lowerBound, upperBound, ordered )
		end
		
	operation createAttribute(name: String, type: ecore::EClassifier, lowerBound: Integer, upperBound: Integer, ordered: Boolean) :ecore::EAttribute is
		do
			result := ecore::EAttribute.new
			result.name := name
			result.eType:= type
			result.ordered := false
			result.lowerBound:= lowerBound
			result.upperBound:=upperBound
			result.ordered := ordered
		end
			
	operation newType(typeName: String): ecore::EDataType is
		do
			stdio.writeln("Creating new data type called: " + typeName )
			result :=  ecore::EDataType.new 
			result.name := typeName
		end
		
	operation contextDefinesFeature(featureName: String): Boolean is
		do
			result := (ecoreHelper.getETypedElement(getContextClassifier(), featureName) != void)
		end
		
	operation featureIsLocalVariable(featureName: String): Boolean is
		do
			result := (getLocalVariable(featureName) != void)
		end
		
	operation getLocalVariable(featureName: String): ecore::ETypedElement is
		do
			stdio.writeln("looking for variable ["+featureName+"] in stack frame")
			if context.top != void then
    			result := context.top.lookup(featureName)
    		else
    			stdio.writeln("===> Warning: Trying to look for variable ["+featureName+"] in uninitialised stack frame")
			end
			if result == void then
    			stdio.writeln("["+featureName+"] not found in local variables")
			else
    			stdio.writeln("["+featureName+"] is local variable of type ["+result.eType.name.toString+"]")
			end
		end
		
 	operation joinNames(ss: Sequence<String>):String is
 		do
 			result := ""
			from
				var it: Iterator<String> init ss.iterator
			until
				it.isOff
			loop
				result.append(it.next)
				if it.hasNext then
					result.append("::")
				end
			end
 		end

	operation getEcoreFileName() : String is
		do
		stdio.writeln(ecoreHelper.getEcoreFileName().toString)
			result := ecoreHelper.getEcoreFileName().replace("\\", "\\\\")  
		end
}


class TypeError inherits Exception {
	operation initialize(typename: String, featureName: String): TypeError is
		do
			if message == void then
				message := ""
			end
			message.append(" Cant find [" + featureName + "] in [" + typename + "]")
			result := self
		end
		
	operation setMessage(s: String) :TypeError is
		do
			if message == void then
				message := ""
			end
			message := s + message
			result := self
		end
}

class Main{
	attribute test : seq String [0..*]
	
	operation main(): Void is
		do
			var th: TypeHelper init TypeHelper.new
			test.add("a")		
			test.add("b")		
			test.add("c")		
			stdio.writeln(test.size.toString + "...:" + th.joinNames(test))
			
		end
}
