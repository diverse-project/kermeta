/* $Id: ocl2kmtVisitor.kmt,v 1.8 2007-08-10 09:45:57 bitterjug Exp $
/* $Id: ocl2kmtVisitor.kmt,v 1.8 2007-08-10 09:45:57 bitterjug Exp $
 * Creation date: February 5, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "::"
@mainOperation ""

 
package ocl2kmt;
require kermeta
require "TypeHelper.kmt"
require "IOHelper.kmt"
require "EcoreHelper.kmt"
require "./oclcstvisitor.kmt"
require "OperatorPolicies.kmt" 
require "IteratorPolicies.kmt" 
require "KermetaHelper.kmt"
  
using kermeta::standard
using kermeta::exceptions
using ocl::cst
using ocl::cst::visitors 
using kermeta::utils

 class Ocl2kmtVisitor inherits ocl::cst::visitors::Visitor, KermetaHelper, IOHelper, IteratorPolicies, OperatorPolicies, TypeHelper {

  		attribute __name : Integer
  		
		operation nextName(root: String) : String is
			do
				if __name == void then
					__name := 0
				end
				__name := __name + 1
				result := root + __name.toString
			end     

	    operation visit(visitable : Visitable) : Void is
			do
				write( visitable.toString)
			end

		method visitCSTNode(visitable : CSTNode) : Void is
			do
				visit(visitable)
			end
		
		method visitPackageDeclarationCS(visitable : PackageDeclarationCS) : Void is
			/**
			 ** Sets global context package name and generates enclosing package
			 **/
			do
			// set type context:
  			    setContextPackageName(joinNames(visitable.pathNameCS.sequenceOfNames))
			// generate code:
				write("package ")
				visitable.pathNameCS.accept(self)
				writeln(";")
				writeln("require kermeta")
				write("require \"") //" 
				write(getEcoreFileName) 
				writeln("\"") //"
				writeln("using kermeta::standard")
				visitable.contextDecls.each{ c |	c.accept(self)	}
			end
		
		method visitContextDeclCS(visitable : ContextDeclCS) : Void is
			do
				visit(visitable)
			end

		method visitPropertyContextCS(visitable : PropertyContextCS) : Void is
			do
				visit(visitable)
			end

		method visitClassifierContextDeclCS(visitable : ClassifierContextDeclCS) : Void is
			do
			// set type context
				setContextClassifierName(joinNames(visitable.pathNameCS.sequenceOfNames))
				//setContextForCurrentClassifier()
			// generate code
				var packsName : Stack<String> init  Stack<String>.new // for package names in reverse order
				visitable.pathNameCS.sequenceOfNames.each{ e | packsName.push(e)}
				packsName.pop // not counting the default one for the file
				packsName.each{ e | writeln("package " + e +" {")}
				writeln("@aspect \"true\"")
				write("class ")
				write(getContextClassifier.name)
				//visitable.pathNameCS.accept(self)
				writeln("{")
				visitable.invOrDefCS.accept(self)
	      		writeln("}")
	      		packsName.each{ e | writeln("}")}
			end
			
		attribute currentContextClassifier : ecore::EClassifier

		method visitOperationContextDeclCS(visitable : OperationContextDeclCS) : Void is
		/**
		 ** where it isays something like: context C::foo(x:X, y:Y):Z pre: ....
		 **/
			do
				setContextClassifierName(joinNames(visitable.operationCS.pathNameCS.sequenceOfNames))
				var packageNames : Stack<String> init  Stack<String>.new
				visitable.operationCS.pathNameCS.sequenceOfNames.each{ e | packageNames.push(e)}
				var className: String init packageNames.pop
				packageNames.each{ e | writeln("package " + e +" {")}
				writeln("@aspect \"true\"")
				write("class ")
				write(className)
				writeln("{")
				writeln("@overloadable \"true\"")
				pushNewStackFrame()
				visitable.operationCS.accept(self)
				//TODO: add 'result' to scope for post: conditions-- mark
				writeln("")
				var body: PrePostOrBodyDeclCS
				visitable.prePostOrBodyDecls.each{ ppbd |
					if  ppbd.kind.name.toString.indexOf("def") >= 0 then
						body := ppbd
					else
    					ppbd.accept(self)
					end
				}
				writeln("is")
				if body == void then
    				writeln("abstract") 
    			else
    				writeln("do")
    				body.accept(self)
    				writeln("end")
    			end
				writeln("}")
				packageNames.each{ e | writeln("}")}
				popStackFrame()
			end
  
		method visitPrePostOrBodyDeclCS(visitable : PrePostOrBodyDeclCS) : Void is
    		/**
    		 ** a precondition or postcondition.
    		 **/
			do
				write(visitable.kind.name.toString)
				writeln(" " + nextName(visitable.kind.name.toString ))
				writeln("is do")
				visitable.expressionCS.accept(self)
				writeln(" end")
			end

		
	 	/**
	 	 ** Just the method header
	 	 **/
		method visitOperationCS(visitable : OperationCS) : Void is
			do
				write("operation ")
				visitable.simpleNameCS.accept(self)
				write("(")
				from
    				var it : Iterator<VariableCS> init visitable.parameters.iterator
    			until
    				it.isOff
    			loop
						it.next.accept(self)
						if it.hasNext then
							write(", ")
						end 
    			end
				write(") :")
				visitable.typeCS.accept(self)
			end

		method visitInitOrDerValueCS(visitable : InitOrDerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitDerValueCS(visitable : DerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInitValueCS(visitable : InitValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInvOrDefCS(visitable : InvOrDefCS) : Void is
			do
				visit(visitable)
			end

		method visitInvCS(visitable : InvCS) : Void is
			do
				var id: String 
				if visitable.simpleNameCS == void then
				 	id := nextName("invariant")
					stdio.writeln("Invariant has no identifier, will be called["+ id+"]")
				else
					id := visitable.simpleNameCS.~value.toString
				end
				pushNewStackFrame()
				writeln("inv " +  id + " is")
				writeln("do" )
				visitable.expressionCS.accept(self)
				writeln("")
				writeln("end" )
				popStackFrame()
			end

		method visitDefCS(visitable : DefCS) : Void is
			do
				 visitable.defExpressionCS.accept(self)
			end

		method visitDefExpressionCS(visitable : DefExpressionCS) : Void is
			do
				pushNewStackFrame()
				visitable.operationCS.accept(self)
				writeln(" is")
				writeln("do")
				write("result := ")
				visitable.expressionCS.accept(self)
				writeln("")
				write("end")
				popStackFrame()
			end

		method visitPathNameCS(visitable : PathNameCS) : Void is
			do
				expandedTypeName := joinNames(visitable.sequenceOfNames)
				write(expandedTypeName)
			end
          
		method visitSimpleNameCS(visitable : SimpleNameCS) : Void is
			do
		    	write(escape(visitable.~value.toString))
			end

		reference expandedTypeName: String
		
		/* abstract class
		method visitTypeCS(visitable : TypeCS) : Void is
			do
				visit(visitable)
			end */

		method visitPrimitiveTypeCS(visitable : PrimitiveTypeCS) : Void is
			do
				if visitable.~value.toString.equals("OclAny") then
					expandedTypeName := "Object"
				else
    		    	expandedTypeName :=escape(visitable.~value.toString)
				end
				write(expandedTypeName)
			end

		method visitTupleTypeCS(visitable : TupleTypeCS) : Void is
			do
				stdio.writeln("Error: Tuple types are not yet supported")
				raise Exception.new
			end

		method visitCollectionTypeCS(visitable : CollectionTypeCS) : Void is
			do
				stdio.writeln("***Warning: not yet dealing properly with collection types")
				write(visitable.collectionTypeIdentifier.name)
				write("<")
				visitable.typeCS.accept(self)
				write(">")
			end

		method visitOCLExpressionCS(visitable : OCLExpressionCS) : Void is
			do
				visit(visitable)
			end
			
		method visitVariableCS(visitable : VariableCS) : Void is
			do
    			var variableName: String init visitable.name.toString
    			stdio.writeln("Processing Variable [" + variableName + "]")
				write(escape(variableName))
				if visitable.typeCS != void then // type specified?
					write(" : ")
					visitable.typeCS.accept(self)
					addLocalVariable(variableName, expandedTypeName, 0, 1, false)
				else
					stdio.writeln("Warning: Can't handle variables implicit types: ["+variableName+"]")
				end
				if visitable.initExpression != void then
					write(" init ")
					visitable.initExpression.accept(self)
				end
			end

		method visitLetExpCS(visitable : LetExpCS) : Void is
			do
				pushNewStackFrame()
				write("do")
				visitable.variables.each{ v |
						writeln("")
						write("var " )
						v.accept(self)
					}
				writeln("")
				visitable.inExpression.accept(self)
				writeln("")
				write("end")
				popStackFrame()
			end

		method visitIfExpCS(visitable : IfExpCS) : Void is
			do
				write("if ")
				visitable.condition.accept(self)
				write(" then ")
				visitable.thenExpression.accept(self)
				write(" else ")
				visitable.elseExpression.accept(self)
				write(" end")
			end

		method visitMessageExpCS(visitable : MessageExpCS) : Void is
			do
				visit(visitable)
			end

		method visitOCLMessageArgCS(visitable : OCLMessageArgCS) : Void is
			do
				visit(visitable)
			end

		method visitLiteralExpCS(visitable : LiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitEnumLiteralExpCS(visitable : EnumLiteralExpCS) : Void is
			do
				visitable.pathNameCS.accept(self)
				write(".")
				visitable.simpleNameCS.accept(self)
			end

		method visitCollectionLiteralExpCS(visitable : CollectionLiteralExpCS) : Void is
			do
				var varName :  String init nextName("variable")
				//TODO: do we have to infer the element type here?
				var type : String init visitable.collectionType.name +"<" + "????????" +">"
				writeln("do")
				write("var " + varName + " : " + type)
				writeln("init " + type + ".new")
				visitable.collectionLiteralParts.each{ clp |
						write(varName + ".add(")
						clp.accept(self)
						writeln(")")
					}
				writeln(varName)
			    write("end")
			end

		method visitTupleLiteralExpCS(visitable : TupleLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitPrimitiveLiteralExpCS(visitable : PrimitiveLiteralExpCS) : Void is
			do
  	 	 	    write(visitable.symbol)
			end

		method visitIntegerLiteralExpCS(visitable : IntegerLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitRealLiteralExpCS(visitable : RealLiteralExpCS) : Void is
			do
				write(visitable.symbol.toString)	
			end

		method visitStringLiteralExpCS(visitable : StringLiteralExpCS) : Void is
			do
				write("\"" + visitable.symbol + "\"")
			end

		method visitBooleanLiteralExpCS(visitable : BooleanLiteralExpCS) : Void is
			do
				visitPrimitiveLiteralExpCS(visitable)
			end

		method visitNullLiteralExpCS(visitable : NullLiteralExpCS) : Void is
			do
				write("void")		
			end

		method visitInvalidLiteralExpCS(visitable : InvalidLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionLiteralPartCS(visitable : CollectionLiteralPartCS) : Void is
			do
				visitable.expressionCS.accept(self)
			end

		method visitCollectionRangeCS(visitable : CollectionRangeCS) : Void is
			do
				visit(visitable)
			end

		method visitCallExpCS(visitable : CallExpCS) : Void is
			do
				visit(visitable)
			end

		method visitLoopExpCS(visitable : LoopExpCS) : Void is
			do
				visit(visitable)			
			end

		operation isKeywordIterator(visitable:   IteratorExpCS): Boolean is
			do
				result:= visitable.simpleNameCS.~type.name.equals(SimpleTypeEnum.keyword.name)
			end
			
		method visitIteratorExpCS(visitable : IteratorExpCS) : Void is
			do
				// <source> <accessor> <simpleNameCS>( [<variable1>] | <body> )
				var operationName : String init visitable.simpleNameCS.~value.toString 
				if isKeywordIterator(visitable) then
				    // check which keyword type and act accordingly
					var policy: IteratorPolicy init iterators.getValue(visitable.simpleNameCS.~value.toString)
					if policy != void then
						policy.generate(visitable, self)
					else
						raise TypeError.new.initialize(getLocalFeatureTypeName(), operationName).setMessage("Unknown keyword")
					end
				else
					stdio.writeln("*** Warning: unknown iterator kind:" + operationName)
				end
			end

		method visitIterateExpCS(visitable : IterateExpCS) : Void is
			do
				visit(visitable)			
			end
			
		operation handleVariableExpression(featureName: String): Void is
			do
				write(escape( featureName))
				if featureIsLocalVariable(featureName) then
					stdio.writeln("[" + featureName + "] is a local variable")
    				setLocalFeature(getLocalVariable(featureName))
				else 
					 if contextDefinesFeature(featureName) then
        				setLocalFeature(getContextFeature(getContextClassifier, featureName) )
					 else 
    					raise TypeError.new.initialize(getContextClassifier.name, featureName)
					end
				end
			end
			
		operation handleStringLiteral(content: String) : Void is
			do
				write("\"" +  content +"\"")
        		setLocalFeature(stringLiteral)
			end
			
		method visitVariableExpCS(visitable : VariableExpCS) : Void is
			do
				// OCL Missing strin quote hack:
				var  content: String init visitable.simpleNameCS.~value
				stdio.write("[" + content +"].size=" +content.size.toString)
				stdio.write( "   end =" + visitable.simpleNameCS.endOffset.toString)
				stdio.writeln( "  start= "+ visitable.simpleNameCS.startOffset.toString)
				if (content.size == visitable.simpleNameCS.endOffset - visitable.simpleNameCS.startOffset +1 ) then
					stdio.writeln("[" + content+ "] is a variable expression")
					handleVariableExpression(content)
				else
					stdio.writeln("[" + content+ "] is a string literal")
					handleStringLiteral(content)
				end
			end
		
		operation implicitCollect(featureName: String):Void is
			do
				var variableName : String init nextName("variable")
				write(".collect{ " + variableName + " | " + variableName + "." + featureName + " }")
			end
			
		operation visitActualParameters(visitable : FeatureCallExpCS) : Void is
			do
				if visitable.arguments.size > 0 then
					write("(")
					from var it: Iterator<OCLExpressionCS> init visitable.arguments.iterator
					until it.isOff
					loop
						it.next.accept(self)
						if  it.hasNext then
							write(", ") 
						end
					end
					write(")")
				end
			end
		
		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				var featureName : String init  visitable.simpleNameCS.~value
				stdio.writeln("Visiting feature call [" + featureName+"]")
				if visitable.source != void then
					visitable.source.accept(self)		
    				if getLocalFeatureIsMultiple() then
    			    	implicitCollect(featureName)
    				else
    					write("." + featureName)
    				end
    		  		setLocalFeature(getContextFeature(getLocalFeatureType, featureName))
    				visitActualParameters(visitable)
				else
					if contextDefinesFeature(featureName) then
        		  		setLocalFeature(getContextFeature(getLocalFeatureType, featureName))
    					write(featureName)
        				visitActualParameters(visitable)
        			else
        				raise TypeError.new.initialize(getContextClassifier.name, featureName)
        			end
				end
			end

		
		method visitOperationCallExpCS(visitable : OperationCallExpCS) : Void is
			do
				var operationName : String init visitable.simpleNameCS.~value.toString
				var accessor: String init visitable.accessor.name
				stdio.writeln("Visiting operation call [" + accessor+"][" +operationName+ "]")
				if accessor.equals(DotOrArrowEnum.arrow.name) then // collection operation
					getCollectionOperationPolicy(operationName).generate(visitable, self)
				else
					if isOperator(operationName) then //  operator or OCL operation
    					getOperatorPolicy(operationName).generate(visitable, self)
    				else
    					visitFeatureCallExpCS(visitable) // model operation
    				end
				end
			end

		method visitIsMarkedPreCS(visitable : IsMarkedPreCS) : Void is
			do
				visit(visitable)			
			end

		method visitStateExpCS(visitable : StateExpCS) : Void is
			do
				visit(visitable)			
			end

	}
	
