/* $Id: ocl2kmtVisitor.kmt,v 1.10 2007-09-05 17:40:24 bitterjug Exp $
/* $Id: ocl2kmtVisitor.kmt,v 1.10 2007-09-05 17:40:24 bitterjug Exp $
 * Creation date: February 5, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "::"
@mainOperation ""

package ocl2kmt;
require kermeta
require "TypeSystemMixin.kmt"
require "IOMixin.kmt"
require "./oclcstvisitor.kmt"
require "../helpers/QualifiedName.kmt"
require "OperatorPolicies.kmt" 
require "IteratorPolicies.kmt" 
require "KermetaHelper.kmt"

using kermeta::standard
using kermeta::exceptions
using ocl::cst
using ocl::cst::visitors 
using kermeta::utils
using qualifiedNames


/** This started out life as a pretty-printer from the parsed OCL Concrete Syntax Tree
 ** to Kermeta source code. Of course this is not a simple case ore pretty-printing
 ** because OCL has some oddities like the meaning of a.b.c depends on whether
 ** a.b refers to a single object or a collection (or "association", it's helpful to think
 ** about these as multiple associations, not as the collections that implement them
 ** in a programming language like kermeta). So the TypeSystemMixin adds facilities
 ** to keep track of the features (attributes and associations) and operations that
 ** appear in these expressions, and what their returned types are. These are
 ** called from within the visit methods here to set and, where necessary, obtain
 ** the necessary additional type information.
 **/
 class Ocl2kmtVisitor inherits ocl::cst::visitors::Visitor,  IOMixin,  TypeSystemMixin {

		attribute __kermeta : KermetaHelper // I should be able to put [1] after this and have it initialised
		
		property readonly kermeta : KermetaHelper 
			getter is
				do
					if __kermeta == void then
						__kermeta := KermetaHelper.new
					end
					result := __kermeta
				end

		attribute __iterators: Iterators
		
		property readonly iteratorList: Iterators 
			getter is
				do
					if __iterators == void then
						__iterators := Iterators.new
					end
					result := __iterators
				end
				
		attribute __operators: Operators
		
		property readonly operatorList: Operators 
			getter is
				do
					if __operators == void then
						__operators := Operators.new
					end
					result := __operators
				end
				
  		attribute __name : Integer
  		
		operation nextName(root: String) : String is
			do
				if __name == void then
					__name := 0
				end
				__name := __name + 1
				result := root + __name.toString
			end     
			
		attribute __expectingType: Boolean
		
		operation expectingType(): Boolean is
			do
				result := __expectingType == true
				// void or false --> false
			end
		
		/** called when the operation being executed is something like
		 ** .oclAsType(Type) where the parameter is expected to be the
		 ** the name of a type rather than a normal expression
		 **/
		operation expectType(): Void is
			do
				__expectingType := true
			end
			
		/** undoes the effect of expectType() **/
		operation expectExpression(): Void is
			do
				__expectingType := false
			end

	    operation visit(visitable : Visitable) : Void is
			do
				write( visitable.toString)
			end

		method visitCSTNode(visitable : CSTNode) : Void is
			do
				visit(visitable)
			end
			
		method visitTypeCS(visitable : TypeCS) : kermeta::standard::~Void is
			do
    			visit(visitable)
			end
		 
		method visitPackageDeclarationCS(visitable : PackageDeclarationCS) : Void is
			do
  			    setContextPackageName(visitable.pathNameCS.sequenceOfNames)
				write("package ")
				visitable.pathNameCS.accept(self)
				writeln(";")
				writeln("require kermeta")
				write("require \"") //" 
				write(getEcoreFileName) 
				writeln("\"") //"
				writeln("using kermeta::standard")
				visitable.contextDecls.each{ c |	c.accept(self)	}
			end
		
		method visitContextDeclCS(visitable : ContextDeclCS) : Void is
			do
				visit(visitable)
			end

		method visitPropertyContextCS(visitable : PropertyContextCS) : Void is
			do
				visit(visitable)
			end

		method visitClassifierContextDeclCS(visitable : ClassifierContextDeclCS) : Void is
			do
				setContextClassifierName(visitable.pathNameCS.sequenceOfNames)
				var packsName : Stack<String> init  Stack<String>.new // for package names in reverse order
				visitable.pathNameCS.sequenceOfNames.each{ e | packsName.push(e)}
				packsName.pop // not counting the default one for the file
				packsName.each{ e | writeln("package " + e +" {")}
				writeln("@aspect \"true\"")
				write("class ")
				write(getContextClassifier.name)
				writeln("{")
				visitable.invOrDefCS.accept(self)
	      		writeln("}")
	      		packsName.each{ e | writeln("}")}
			end
			
		attribute currentContextClassifier : ecore::EClassifier

		method visitOperationContextDeclCS(visitable : OperationContextDeclCS) : Void is
			do
				setContextClassifierName(visitable.operationCS.pathNameCS.sequenceOfNames)
				var packageNames : Stack<String> init  Stack<String>.new
				visitable.operationCS.pathNameCS.sequenceOfNames.each{ e | packageNames.push(e)}
				var className: String init packageNames.pop
				packageNames.each{ e | writeln("package " + e +" {")}
				writeln("@aspect \"true\"")
				write("class ")
				write(className)
				writeln("{")
				writeln("@overloadable \"true\"")
				pushNewStackFrame()
				visitable.operationCS.accept(self)
				//TODO: add 'result' to scope for post: conditions-- mark
				writeln("")
				var body: PrePostOrBodyDeclCS
				visitable.prePostOrBodyDecls.each{ ppbd |
					if  ppbd.kind.name.toString.indexOf("def") >= 0 then
						body := ppbd
					else
    					ppbd.accept(self)
					end
				}
				writeln("is")
				if body == void then
    				writeln("abstract") 
    			else
    				writeln("do")
    				body.accept(self)
    				writeln("end")
    			end
				writeln("}")
				packageNames.each{ e | writeln("}")}
				popStackFrame()
			end
  
		method visitPrePostOrBodyDeclCS(visitable : PrePostOrBodyDeclCS) : Void is

			do
				write(visitable.kind.name.toString)
				writeln(" " + nextName(visitable.kind.name.toString ))
				writeln("is do")
				visitable.expressionCS.accept(self)
				writeln(" end")
			end

		

		method visitOperationCS(visitable : OperationCS) : Void is
			do
				write("operation ")
				visitable.simpleNameCS.accept(self)
				write("(")
				from
    				var it : Iterator<VariableCS> init visitable.parameters.iterator
    			until
    				it.isOff
    			loop
						it.next.accept(self)
						if it.hasNext then
							write(", ")
						end 
    			end
				write(") :")
				visitable.typeCS.accept(self)
			end

		method visitInitOrDerValueCS(visitable : InitOrDerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitDerValueCS(visitable : DerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInitValueCS(visitable : InitValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInvOrDefCS(visitable : InvOrDefCS) : Void is
			do
				visit(visitable)
			end

		method visitInvCS(visitable : InvCS) : Void is
			do
				var id: String 
				if visitable.simpleNameCS == void then
				 	id := nextName("invariant")
					stdio.writeln("Invariant has no identifier, will be called["+ id+"]")
				else
					id := visitable.simpleNameCS.~value.toString
				end
				pushNewStackFrame()
				writeln("inv " +  id + " is")
				writeln("do" )
				visitable.expressionCS.accept(self)
				writeln("")
				writeln("end" )
				popStackFrame()
			end

		method visitDefCS(visitable : DefCS) : Void is
			do
				 visitable.defExpressionCS.accept(self)
			end

		method visitDefExpressionCS(visitable : DefExpressionCS) : Void is
			do
				pushNewStackFrame()
				visitable.operationCS.accept(self)
				writeln(" is")
				writeln("do")
				write("result := ")
				visitable.expressionCS.accept(self)
				writeln("")
				write("end")
				popStackFrame()
			end

		method visitPathNameCS(visitable : PathNameCS) : Void is
			do
				qualifiedTypeName := QualifiedName.new.fromSequence(visitable.sequenceOfNames)
				write(qualifiedTypeName.toString)
			end
          
		method visitSimpleNameCS(visitable : SimpleNameCS) : Void is
			do
		    	write(kermeta.escape(visitable.~value.toString))
			end

		reference qualifiedTypeName: QualifiedName
		
		method visitPrimitiveTypeCS(visitable : PrimitiveTypeCS) : Void is
			do
				if visitable.~value.toString.equals("OclAny") then
					qualifiedTypeName := QualifiedName.new.fromString("Object")
				else
					qualifiedTypeName := QualifiedName.new.fromString( kermeta.escape(visitable.~value.toString))
				end
				write(qualifiedTypeName.toString)
			end

		method visitTupleTypeCS(visitable : TupleTypeCS) : Void is
			do
				stdio.writeln("Error: Tuple types are not yet supported")
				raise Exception.new
			end

		method visitCollectionTypeCS(visitable : CollectionTypeCS) : Void is
			do
				stdio.writeln("***Warning: not yet dealing properly with collection types")
				write(visitable.collectionTypeIdentifier.name)
				write("<")
				visitable.typeCS.accept(self)
				write(">")
			end

		method visitOCLExpressionCS(visitable : OCLExpressionCS) : Void is
			do
				visit(visitable)
			end
			
		method visitVariableCS(visitable : VariableCS) : Void is
			do
    			var variableName: String init visitable.name.toString
    			stdio.writeln("Processing Variable [" + variableName + "]")
				write(kermeta.escape(variableName))
				if visitable.typeCS != void then // type specified?
					write(" : ")
					visitable.typeCS.accept(self)
					addLocalVariable(variableName, qualifiedTypeName, 0, 1, false)
				else
					stdio.writeln("Warning: Can't handle variables implicit types: ["+variableName+"]")
				end
				if visitable.initExpression != void then
					write(" init ")
					visitable.initExpression.accept(self)
				end
			end

		method visitLetExpCS(visitable : LetExpCS) : Void is
			do
				pushNewStackFrame()
				write("do")
				visitable.variables.each{ v |
						writeln("")
						write("var " )
						v.accept(self)
					}
				writeln("")
				visitable.inExpression.accept(self)
				writeln("")
				write("end")
				popStackFrame()
			end

		method visitIfExpCS(visitable : IfExpCS) : Void is
			do
				write("if ")
				visitable.condition.accept(self)
				write(" then ")
				visitable.thenExpression.accept(self)
				write(" else ")
				visitable.elseExpression.accept(self)
				write(" end")
			end

		method visitMessageExpCS(visitable : MessageExpCS) : Void is
			do
				visit(visitable)
			end

		method visitOCLMessageArgCS(visitable : OCLMessageArgCS) : Void is
			do
				visit(visitable)
			end

		method visitLiteralExpCS(visitable : LiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitEnumLiteral(visitable : EnumLiteralExpCS) : Void is
			do
    			visitable.pathNameCS.accept(self)
    			write(".")
    			visitable.simpleNameCS.accept(self)
			end
			
		operation visitEnumLiteralAsType(visitable : EnumLiteralExpCS) : Void is
			do
				qualifiedTypeName := QualifiedName.new.fromSequence( visitable.pathNameCS.sequenceOfNames)
				qualifiedTypeName.add(visitable.simpleNameCS.~value.toString)
				write(qualifiedTypeName.toString)
			end
			
		method visitEnumLiteralExpCS(visitable : EnumLiteralExpCS) : Void is
			do
				if expectingType then
					// We are being called from a context where a type has been parsed as a enumeration such as a.asType(sample::B)
					visitEnumLiteralAsType(visitable)
				else
    				visitEnumLiteral(visitable)
				end
			end

		method visitCollectionLiteralExpCS(visitable : CollectionLiteralExpCS) : Void is
			do
				var varName :  String init nextName("variable")
				//TODO: do we have to infer the element type here?
				var type : String init visitable.collectionType.name +"<" + "????????" +">"
				writeln("do")
				write("var " + varName + " : " + type)
				writeln("init " + type + ".new")
				visitable.collectionLiteralParts.each{ clp |
						write(varName + ".add(")
						clp.accept(self)
						writeln(")")
					}
				writeln(varName)
			    write("end")
			end

		method visitTupleLiteralExpCS(visitable : TupleLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitPrimitiveLiteralExpCS(visitable : PrimitiveLiteralExpCS) : Void is
			do
  	 	 	    write(visitable.symbol)
			end

		method visitIntegerLiteralExpCS(visitable : IntegerLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitRealLiteralExpCS(visitable : RealLiteralExpCS) : Void is
			do
				write(visitable.symbol.toString)	
			end

		method visitStringLiteralExpCS(visitable : StringLiteralExpCS) : Void is
			do
				write("\"" + visitable.symbol + "\"")
			end

		method visitBooleanLiteralExpCS(visitable : BooleanLiteralExpCS) : Void is
			do
				visitPrimitiveLiteralExpCS(visitable)
			end

		method visitNullLiteralExpCS(visitable : NullLiteralExpCS) : Void is
			do
				write("void")		
			end

		method visitInvalidLiteralExpCS(visitable : InvalidLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionLiteralPartCS(visitable : CollectionLiteralPartCS) : Void is
			do
				visitable.expressionCS.accept(self)
			end

		method visitCollectionRangeCS(visitable : CollectionRangeCS) : Void is
			do
				visit(visitable)
			end

		method visitCallExpCS(visitable : CallExpCS) : Void is
			do
				visit(visitable)
			end

		method visitLoopExpCS(visitable : LoopExpCS) : Void is
			do
				visit(visitable)			
			end
 
		operation isKeywordIterator(visitable:   IteratorExpCS): Boolean is
			do
				result:= visitable.simpleNameCS.~type.name.equals(SimpleTypeEnum.keyword.name)
			end
			
		method visitIteratorExpCS(visitable : IteratorExpCS) : Void is
			do
				// <source> <accessor> <simpleNameCS>( [<variable1>] | <body> )
				var operationName : String init visitable.simpleNameCS.~value.toString 
				if isKeywordIterator(visitable) then
				    // check which keyword type and act accordingly
					var policy: IteratorPolicy init iteratorList.iterators.getValue(visitable.simpleNameCS.~value.toString)
					if policy != void then
						policy.generate(visitable, self)
					else
						raise TypeError.new.initialize(getLocalFeatureTypeName(), operationName).setMessage("Unknown keyword")
					end
				else
					stdio.writeln("*** Warning: unknown iterator kind:" + operationName)
				end
			end

		method visitIterateExpCS(visitable : IterateExpCS) : Void is
			do
				visit(visitable)			
			end
			
		operation handleVariableExpression(featureName: String): Void is
			do
				write(kermeta.escape( featureName))
				if featureIsLocalVariable(featureName) then
					stdio.writeln("[" + featureName + "] is a local variable")
    				setLocalFeature(getLocalVariable(featureName))
				else 
					 if contextDefinesFeature(featureName) then
        				setLocalFeature(getContextFeature(getContextClassifier, featureName) )
					 else 
    					raise TypeError.new.initialize(getContextClassifier.name, featureName)
					end
				end
			end
			
		operation handleStringLiteral(content: String) : Void is
			do
				write("\"" +  content +"\"")
        		setLocalFeature(stringLiteral)
			end
			
		/**  You have thee choices here:
		 ** - could be a string literal (there seems to be a bug in the parser that makes them look like this
		 ** - it could be a variable expression, call the handler above
		 ** - it coul dbe the name of a type, but only if we are expecting one because the function
		 ** is one of those special ones that takes a type name as a parameter such as oclAsType(...)
		 **/
		method visitVariableExpCS(visitable : VariableExpCS) : Void is
			do
				var  content: String init visitable.simpleNameCS.~value
				if expectingType then
					// we were called from a place where a type was expected as a parameter, such as b.oclAsType(A)
					qualifiedTypeName := QualifiedName.new.fromString(content)
					write(qualifiedTypeName.toString)
				else
    				// OCL Missing string-quote hack:
    				if (content.size == visitable.simpleNameCS.endOffset - visitable.simpleNameCS.startOffset +1 ) then
    					stdio.writeln("[" + content+ "] is a variable expression")
    					handleVariableExpression(content)
    				else // It's a string, d'oh!
    					stdio.writeln("[" + content+ "] is a string literal")
    					handleStringLiteral(content)
    				end
				end
			end
		
		operation implicitCollect(featureName: String):Void is
			do
				var variableName : String init nextName("variable")
				write(".collect{ " + variableName + " | " + variableName + "." + featureName + " }")
			end
			
		operation visitActualParameters(visitable : FeatureCallExpCS) : Void is
			do
				if visitable.arguments.size > 0 then
					write("(")
					from var it: Iterator<OCLExpressionCS> init visitable.arguments.iterator
					until it.isOff
					loop
						it.next.accept(self)
						if  it.hasNext then
							write(", ") 
						end
					end
					write(")")
				end
			end
		
		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				var featureName : String init  visitable.simpleNameCS.~value
				stdio.writeln("Visiting feature call [" + featureName+"]")
				if visitable.source != void then
					visitable.source.accept(self)		
					// This is where we decide whether or not to use an explicit collect
    				if getLocalFeatureIsMultiple() then
    			    	implicitCollect(featureName)
    				else
    					write("." + featureName)
    				end
    		  		setLocalFeature(getContextFeature(getLocalFeatureType, featureName))
    				visitActualParameters(visitable)
				else
					if contextDefinesFeature(featureName) then
        		  		setLocalFeature(getContextFeature(getLocalFeatureType, featureName))
    					write(featureName)
        				visitActualParameters(visitable)
        			else
        				raise TypeError.new.initialize(getContextClassifier.name, featureName)
        			end
				end
			end

		
		method visitOperationCallExpCS(visitable : OperationCallExpCS) : Void is
			do
				var operationName : String init visitable.simpleNameCS.~value.toString
				var accessor: String init visitable.accessor.name
				stdio.writeln("Visiting operation call [" + accessor+"][" +operationName+ "]")
				if accessor.equals(DotOrArrowEnum.arrow.name) then // collection operation
					operatorList.getCollectionOperationPolicy(operationName).generate(visitable, self)
				else
					if operatorList.isOperator(operationName) then //  operator or OCL operation
    					operatorList.getOperatorPolicy(operationName).generate(visitable, self)
    				else
    					visitFeatureCallExpCS(visitable) // model operation
    				end
				end
			end

		method visitIsMarkedPreCS(visitable : IsMarkedPreCS) : Void is
			do
				visit(visitable)			
			end

		method visitStateExpCS(visitable : StateExpCS) : Void is
			do
				visit(visitable)			
			end

	}
	
