/* $Id: ocl2kmtVisitor.kmt,v 1.1 2007-06-01 15:00:34 barais Exp $
/* $Id: ocl2kmtVisitor.kmt,v 1.1 2007-06-01 15:00:34 barais Exp $
 * Creation date: February 5, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "::"
@mainOperation ""
 

package ocl2kmt;

require kermeta
require "../../mmodel/oclcstvisitor.kmt"
require "OperatorPolicies.kmt"    
require "../../../fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"

using kermeta::standard
using kermeta::exceptions
using ocl::cst
using ocl::cst::visitors 
using kermeta::utils
using kermeta::io

class StringWriter inherits StdIO
{

	reference s: String

	method write(object: String) is
		do
			if s == void then
				s := object
			else
				s.append(object)
			end
		end
		
	method writeln(object: String) is
		do
			self.write(object)
			self.write("\n")
		end
		
	method read(prompt: String): String is
		do
			var e: Exception init Exception.new
			e.message := "Sorry, you can't read from a writer"
			raise e
		end
}

class FileWriter inherits StdIO
{

	reference f: kermeta::io::FileIO
	reference filename :String
	method write(object: String) is
		do
			if f == void then
				f := kermeta::io::FileIO.new
			end
			if filename != void then
					
				f.writeTextFile(filename, object)
			else
				var e: Exception init Exception.new
				e.message := "Sorry, filename is not set"
				
				raise e
			end
			
		end
		
	method writeln(object: String) is
		do
			self.write(object)
			self.write(" ")
		end
		
	method read(prompt: String): String is
		do
			var e: Exception init Exception.new
			e.message := "Sorry, you can't read from a writer"
			raise e
		end
}



 class Ocl2kmtVisitor inherits ocl::cst::visitors::Visitor {

 		operation initialize() : Void is do
 			self.pathExpression := ""
			self.previousIsMultiple := false
			pathContextCounter :=0
			currentPackagename :=""
			visibleVariable := kermeta::utils::Hashtable<String,ecore::ETypedElement>.new
			//visibleVariableMultiplicities := kermeta::utils::Hashtable<String,Boolean>.new
			self.pathExpressionStack := kermeta::utils::Stack<String>.new
			iteratorVariable := false
  		end 
 
 		reference __ecoreHelper : EcoreHelpers::EcoreHelper
		
		operation setMetamodelURI(metamodelURI: String) is
			do
				__ecoreHelper := EcoreHelpers::EcoreHelper.new
				__ecoreHelper.loadMetamodel(metamodelURI)  
			end
			
		operation ecoreHelper(): EcoreHelpers::EcoreHelper is
			do
				if __ecoreHelper == void then
					var e : Exception init Exception.new
					e.message := "Metamodel URI must be set before visiting"
					raise e
				else
					result := __ecoreHelper
				end
			end
			
		reference  __io: StdIO 
		
		operation getIo(): StdIO is
			do
				if __io == void then
					//var f : FileWriter init FileWriter.new
					//f.filename := filename
					__io :=StringWriter.new
				end
				result := __io
			end
		reference  __ierr: StdIO 
		
		operation getIerr(): StdIO is
			do
				if __io == void then
					__io :=stdio
				end
				result := __io
			end
		/**
		 * Use this to set a string writer to get the generated source as a string
		 */
		operation setIo(newio: StdIO) is
			do
				self.__io := newio
			end
		
	    operation write(s: String) : Void is
		    do
		    	getIo.write(s)
		    end
    
	    operation writeln(s: String): Void is
		    do
		    	getIo.writeln(s)
		    end
		 operation writeerr(s: String) : Void is
		    do
		    	getIo.write(s)
		    end
    
	    operation writeerrln(s: String): Void is
		    do
		    	getIo.writeln(s)
		    end
  
  		attribute __name : Integer
  		
		operation nextName(root: String) : String is
			do
				if __name == void then
					__name := 0
				end
				__name := __name + 1
				result := root + __name.toString
			end     

	    operation visit(visitable : Visitable) : Void is
			do
				write( visitable.toString)
			end

		method visitCSTNode(visitable : CSTNode) : Void is
			do
				visit(visitable)
			end
		
		reference ecoreFileName : String
		
		method visitPackageDeclarationCS(visitable : PackageDeclarationCS) : Void is
			do
			
				visitable.pathNameCS.sequenceOfNames.each{ e | currentPackagename := currentPackagename + "::"+e}
				currentPackagename:=currentPackagename.substring(2,currentPackagename.size)
				write("package ")
				visitable.pathNameCS.accept(self)
				writeln(";")
				writeln("require kermeta")
				write("require \"")
				//visitable.pathNameCS.accept(self)
				write(ecoreFileName)
				writeln("\"")
				
				writeln("using kermeta::standard")
				
				visitable.contextDecls.each{ c |
						c.accept(self)
					}
				
			end

		reference currentPackagename : String
		reference currentClassifiername : String
		reference currentOperationname : String
		
		method visitContextDeclCS(visitable : ContextDeclCS) : Void is
			do
				visit(visitable)
			end

		method visitPropertyContextCS(visitable : PropertyContextCS) : Void is
			do
				visit(visitable)
			end

		method visitClassifierContextDeclCS(visitable : ClassifierContextDeclCS) : Void is
			do
				currentClassifiername :=""
				visitable.pathNameCS.sequenceOfNames.each{ e | currentClassifiername := currentClassifiername + "::"+e}
				currentClassifiername:=currentClassifiername.substring(2,currentClassifiername.size)
				//var classifier : ecore::EClassifier init self.ecoreHelper.getClassifierFromPath(self.currentPackagename + "::" + self.currentClassifiername, pathExpression.substring(0, pathExpression.size -1),".")
				
				
				visibleVariable.clear
				var classifier : ecore::EClass
				classifier ?= self.ecoreHelper.getEcoreClassifierByQualifiedName(self.currentPackagename + "::" + self.currentClassifiername)
				
				if (classifier!= void) then
					classifier.eAllStructuralFeatures.each{ e |  visibleVariable.put(e.name.toString,e)}
					var tmp : ecore::EAttribute init ecore::EAttribute.new
					tmp.eType:=classifier
					tmp.name := "self"
					tmp.ordered := false
					tmp.lowerBound:=0
					tmp.upperBound:=1
					visibleVariable.put(tmp.name.toString,tmp)
				else
					writeln("no cache for allAttributes of  " + currentClassifiername)
				end
				
				//writeln(currentClassifiername )
				writeln("@aspect \"true\"")
				write("class ")
				visitable.pathNameCS.accept(self)
				writeln("{")
				visitable.invOrDefCS.accept(self)
		      	writeln("}")
			end
			attribute currentContextClassifier : ecore::EClassifier

		method visitOperationContextDeclCS(visitable : OperationContextDeclCS) : Void is
			do
			
				currentClassifiername :=""
				currentOperationname :=""
				visitable.operationCS.pathNameCS.sequenceOfNames.each{ e | currentClassifiername := currentClassifiername + "::"+e}
				currentClassifiername:=currentClassifiername.substring(2,currentClassifiername.size)
				
				
				
				writeln("@aspect \"true\"")
				write("class ")
				visitable.operationCS.pathNameCS.accept(self)
				writeln("{")
				writeln("@overloadable \"true\"")
				visitable.operationCS.accept(self)
				writeln("")
				visitable.prePostOrBodyDecls.each{ ppbd |
					ppbd.accept(self)
				}
				writeln("is")
				writeln("do")
				writeln("var e: Exception init NotImplementedException.new")
				write("e.message := \"OCL pre/post/body: " )
				visitable.operationCS.pathNameCS.accept(self)
				write(".")
				visitable.operationCS.simpleNameCS.accept(self)
				writeln("\"")
				writeln("raise e")
				writeln("end")
				writeln("}")
			end
  
		method visitPrePostOrBodyDeclCS(visitable : PrePostOrBodyDeclCS) : Void is
			do
				write(visitable.kind.name.toString)
				writeln(" " + nextName(visitable.kind.name.toString ))
				writeln("is do")
				visitable.expressionCS.accept(self)
				writeln(" end")
			end

		
		method visitOperationCS(visitable : OperationCS) : Void is
			do
				currentOperationname := visitable.simpleNameCS.~value
				
				visibleVariable.clear
				var classifier : ecore::EClass
				 classifier ?= self.ecoreHelper.getEcoreClassifierByQualifiedName(self.currentPackagename + "::" + self.currentClassifiername)
				
				if (classifier!= void) then
					classifier.eAllStructuralFeatures.each{ e |  visibleVariable.put(e.name.toString,e)}
					var tmp : ecore::EAttribute init ecore::EAttribute.new
					tmp.eType:=classifier
					tmp.name := "self"
					tmp.ordered := false
					tmp.lowerBound:=0
					tmp.upperBound:=1
					visibleVariable.put(tmp.name.toString,tmp)
					var currops : ecore::EOperation init classifier.eAllOperations.select{e| e.name == currentOperationname}.one
					currops.eParameters.each{ e |  visibleVariable.put(e.name.toString,e)
					/*if (e.upperBound >1 or e.upperBound == -1 ) then
		 				visibleVariableMultiplicities.put(e.name.toString,true)
		 			else
		 				visibleVariableMultiplicities.put(e.name.toString,false)
			 		end*/	
					
					
					}
				else
					writeln("no cache for allAttributes of  " + currentClassifiername)
				end
				
				write("operation ")
				visitable.simpleNameCS.accept(self)
				write("(")
				visitable.parameters.each{ p |
						p.accept(self)
					}
				write("):")
				visitable.typeCS.accept(self)
			end

		method visitInitOrDerValueCS(visitable : InitOrDerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitDerValueCS(visitable : DerValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInitValueCS(visitable : InitValueCS) : Void is
			do
				visit(visitable)
			end

		method visitInvOrDefCS(visitable : InvOrDefCS) : Void is
			do
				visit(visitable)
			end

		method visitInvCS(visitable : InvCS) : Void is
			do
				writeln("inv " + nextName("invariant") + " is")
				writeln("do" )
				visitable.expressionCS.accept(self)
				writeln("")
				writeln("end" )
			end

		method visitDefCS(visitable : DefCS) : Void is
			do
				 visitable.defExpressionCS.accept(self)
			end

		method visitDefExpressionCS(visitable : DefExpressionCS) : Void is
			do
				visitable.operationCS.accept(self)
				writeln(" is")
				writeln("do")
				write("result := ")
				visitable.expressionCS.accept(self)
				writeln("")
				write("end")
			end

		method visitPathNameCS(visitable : PathNameCS) : Void is
			do
				var v : Integer init 0
				visitable.sequenceOfNames.each{o| 
					if o != void then
						v:= v+1
						write( o.toString)
						if (visitable.sequenceOfNames.size != v) then
							write("::")
						end
						
					else
						write("[void path name]")
					end
				    //o.accept(self) 
				    }
			end

		

       
          
		method visitSimpleNameCS(visitable : SimpleNameCS) : Void is
			do
			    var name : String init visitable.~value.toString
			    if isKermetaKeyword(name) then
			    	write("~")
			    end
				write(name)
			end

		method visitTypeCS(visitable : TypeCS) : Void is
			do
				visit(visitable)
			end

		method visitPrimitiveTypeCS(visitable : PrimitiveTypeCS) : Void is
			do
				if visitable.~value.toString.equals("OclAny") then
					write("Object")
				else
					visitSimpleNameCS(visitable)
				end
			end

		method visitTupleTypeCS(visitable : TupleTypeCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionTypeCS(visitable : CollectionTypeCS) : Void is
			do
				write(visitable.collectionTypeIdentifier.name)
				write("<")
				visitable.typeCS.accept(self)
				write(">")
			end

		method visitOCLExpressionCS(visitable : OCLExpressionCS) : Void is
			do
				visit(visitable)
			end

		method visitLetExpCS(visitable : LetExpCS) : Void is
			do
				write("do")
				//variables
				visitable.variables.each{ v |
						writeln("")
						write("var " )
						v.accept(self)
					}
				writeln("")
				//body
				visitable.inExpression.accept(self)
				writeln("")
				write("end")
				visitable.variables.each{ v |
						//writeln("")
						//write("var " )
						//v.accept(self)
						visibleVariable.remove(v.name.toString)
					}
				
			end

		method visitIfExpCS(visitable : IfExpCS) : Void is
			do
				write("if ")
				visitable.condition.accept(self)
				write(" then ")
				visitable.thenExpression.accept(self)
				write(" else ")
				visitable.elseExpression.accept(self)
				write(" end")
			end

		method visitMessageExpCS(visitable : MessageExpCS) : Void is
			do
				visit(visitable)
			end

		method visitOCLMessageArgCS(visitable : OCLMessageArgCS) : Void is
			do
				visit(visitable)
			end

		//reference contextPathExpression : String
		//reference contextVariable : String

		
		method visitLiteralExpCS(visitable : LiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitEnumLiteralExpCS(visitable : EnumLiteralExpCS) : Void is
			do
				visitable.pathNameCS.accept(self)
				write(".")
				visitable.simpleNameCS.accept(self)
			end

		method visitCollectionLiteralExpCS(visitable : CollectionLiteralExpCS) : Void is
			do
				var varName :  String init nextName("variable")
				//TODO: do we have to infer the element type here?
				var type : String init visitable.collectionType.name +"<" + "????????" +">"
				writeln("do")
				write("var " + varName + " : " + type)
				writeln("init " + type + ".new")
				visitable.collectionLiteralParts.each{ clp |
						write(varName + ".add(")
						clp.accept(self)
						writeln(")")
					}
				writeln(varName)
			    write("end")
			end

		method visitTupleLiteralExpCS(visitable : TupleLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitPrimitiveLiteralExpCS(visitable : PrimitiveLiteralExpCS) : Void is
			do
  	 	 	    write(visitable.symbol)
			end

		method visitIntegerLiteralExpCS(visitable : IntegerLiteralExpCS) : Void is
			do
				write(visitable.symbol)
			end

		method visitRealLiteralExpCS(visitable : RealLiteralExpCS) : Void is
			do
				write(visitable.symbol.toString)	
			end

		method visitStringLiteralExpCS(visitable : StringLiteralExpCS) : Void is
			do
				write("\"" + visitable.symbol + "\"")
			end

		method visitBooleanLiteralExpCS(visitable : BooleanLiteralExpCS) : Void is
			do
				visitPrimitiveLiteralExpCS(visitable)
			end

		method visitNullLiteralExpCS(visitable : NullLiteralExpCS) : Void is
			do
				write("void")		
			end

		method visitInvalidLiteralExpCS(visitable : InvalidLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		method visitCollectionLiteralPartCS(visitable : CollectionLiteralPartCS) : Void is
			do
				visitable.expressionCS.accept(self)
			end

		method visitCollectionRangeCS(visitable : CollectionRangeCS) : Void is
			do
				visit(visitable)
			end

		method visitCallExpCS(visitable : CallExpCS) : Void is
			do
				visit(visitable)
			end

		method visitLoopExpCS(visitable : LoopExpCS) : Void is
			do
				visit(visitable)			
			end

        attribute __iterators : Hashtable<String, IteratorPolicy>
        
        operation addIterator(oclIteratorName: String, policy: IteratorPolicy) : Void is 
        do
        	__iterators.put(oclIteratorName, policy)
        end
        
        		
		method visitIteratorExpCS(visitable : IteratorExpCS) : Void is
			do
				// <source> <accessor> <simpleNameCS>( <body> )
				// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
				// why can't I compare the enumerations normally
				// i.e. visitable.simpleNameCS.~type.equals(SimpleTypeEnum.keyword)
				//  <<<<<<<<<<<<<<<<<<<<<<<<
				if visitable.simpleNameCS.~type.name.equals(SimpleTypeEnum.keyword.name) then
				    // check which keyword type and act accordingly
				    // TODO: this won't work in cases where the inner expression defines its own variables
					var policy: IteratorPolicy init iterators.getValue(visitable.simpleNameCS.~value.toString)
					if policy != void then
						// TODO: assert that the accessor was an arrow
						policy.generate(visitable, self)
					else
						writeln("Unknown keyword type " +visitable.simpleNameCS.~value.toString )
					end
				end
			end

		method visitIterateExpCS(visitable : IterateExpCS) : Void is
			do
				visit(visitable)			
			end

		attribute pathExpression : String
		attribute pathExpressionStack : kermeta::utils::Stack<String>
		attribute previousIsMultiple : Boolean 
		attribute pathContextCounter : Integer 
		reference visibleVariable : kermeta::utils::Hashtable<String,ecore::ETypedElement>
		//reference visibleVariableMultiplicities : kermeta::utils::Hashtable<String,Boolean>
		reference currentClassifier : ecore::ETypedElement
		reference currentVariableName : String
		method visitVariableExpCS(visitable : VariableExpCS) : Void is
			do
				var isNotAccessible:Boolean init false
				currentClassifier := self.visibleVariable.getValue( visitable.simpleNameCS.~value)
				
				pathExpressionStack.push(pathExpression)
				pathExpression := ""//pathExpression + visitable.simpleNameCS.~value+"."
				pathContextCounter := 0
				//var isMultiple : Boolean
				do 
					previousIsMultiple :=  self.visibleVariable.getValue( visitable.simpleNameCS.~value).many
					//writeln("variable name "+visitable.simpleNameCS.~value)
				 
				rescue (e: kermeta::exceptions::CallOnVoidTarget)
					isNotAccessible := true
					getIerr.writeln("/*Variable "+  visitable.simpleNameCS.~value + " is not accessible*/")
					previousIsMultiple := false
				end 
				if (visitable.simpleNameCS.~value.size == visitable.simpleNameCS.endOffset - visitable.simpleNameCS.startOffset +1 ) then
					if (isNotAccessible) then
						getIerr.writeln("/*Variable "+  visitable.simpleNameCS.~value + " is not accessible*/")
					end
					write( visitable.simpleNameCS.~value)
				else
					write("\"" +  visitable.simpleNameCS.~value+"\"")
				end
				
				
			end
		
		reference iteratorVariable :Boolean
		
		method visitVariableCS(visitable : VariableCS) : Void is
			do
				var classifier : ecore::ETypedElement 
				if (pathExpression.size == 0) then
					//writeln("passe pas la")
					classifier :=  currentClassifier
					if (classifier!= void  and iteratorVariable.~not) then							
						visibleVariable.put(visitable.name.toString,classifier)
						//visibleVariableMultiplicities.put(visitable.name.toString,false)
					else 
						if (classifier!= void) then
							var tmp : ecore::EAttribute init ecore::EAttribute.new
							tmp.name := visitable.name.toString
							tmp.eType := classifier.eType
							tmp.upperBound := 1
							visibleVariable.put(tmp.name,tmp)
							iteratorVariable:=false
						else
							//writeln("no cache for variable " + visitable.name)
							
						end
						
					end
						
				else
					classifier := self.ecoreHelper.getETypedElementFromPath(
						self.currentPackagename + "::" + self.currentClassifiername,
						 pathExpression.substring(0, pathExpression.size -1),".")
					
					if (classifier!= void) then
						if (iteratorVariable.~not) then
							var tmp : ecore::EAttribute init ecore::EAttribute.new
							tmp.name := visitable.name.toString
							tmp.eType := classifier.eType
							tmp.upperBound := 1
							visibleVariable.put(tmp.name,tmp)
							iteratorVariable:=false
						else
							visibleVariable.put(visitable.name.toString,classifier)
						end
					//visibleVariableMultiplicities.put(visitable.name.toString, self.ecoreHelper.isMultiple(self.currentPackagename + "::" + self.currentClassifiername, pathExpression.substring(0, pathExpression.size -1),"."))
					else
						//writeln("no cache for variable " + visitable.name)
					end
				end
				write(visitable.name.toString)
				//contextPathExpression := pathExpression
				currentVariableName := visitable.name.toString
				//writeln("toto" + pathExpression)
				//visitable.name.accept(self)
				if visitable.typeCS != void then
					write(" : ")
					visitable.typeCS.accept(self)
					var tmp : ecore::EAttribute init ecore::EAttribute.new
					tmp.name := visitable.name.toString
					var type :ecore::EDataType init ecore::EDataType.new 
					type.name:=visitable.typeCS.toString
					tmp.eType := type
					tmp.upperBound := 1
					visibleVariable.put(tmp.name,tmp)
							
				end
				if visitable.initExpression != void then
					write(" init ")
					visitable.initExpression.accept(self)
				end
			end
		
		
		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				pathContextCounter := pathContextCounter+1
				if visitable.source != void then
					visitable.source.accept(self)		
					if visitable.accessor.name == "dot" then
					   write(".")
					end
					if visitable.accessor.name == "arrow" then
					   write(".")
					end
				//else
				//	last := true					
				end
				//visitable.simpleNameCS.accept(self)
				pathExpression := pathExpression + visitable.simpleNameCS.~value+"."
				
				//self.currentPackagename + "::" + self.currentClassifiername
				//writeln(self.currentPackagename + "::" + self.currentClassifiername)
				//writeln(pathExpression.substring(0, pathExpression.size -1))
				var isMultiple : Boolean 
				do 	
		 			if (self.currentClassifier == void) then 
		 				isMultiple :=false
		 			else
		 				isMultiple := self.ecoreHelper.getETypedElementFromPath(ecoreHelper.getClassifierQualifiedName(self.currentClassifier.eType) , pathExpression.substring(0, pathExpression.size -1),".").many
					end
				if (previousIsMultiple) then
					var variableName : String init nextName("variable")
					write("collect{ " + variableName + " | " + variableName + ".")
					write( visitable.simpleNameCS.~value)
					write("}")
				else
					write( visitable.simpleNameCS.~value)
				end
				previousIsMultiple:=isMultiple
				
				rescue (errPre : EcoreHelpers::InvalidPathName)  
					isMultiple:= false
					getIerr.writeln("/*INVALIDPATH"+ pathExpression.substring(0, pathExpression.size -1) + " " + currentClassifier.eType.name +"*/"+ visitable.simpleNameCS.~value )
				
				end
				
				previousIsMultiple:=isMultiple
				
				//writeln(isMultiple.toString)
					if visitable.arguments.size > 0 then
						write("(")
						from
							var it : Iterator<OCLExpressionCS> init visitable.arguments.iterator
						until
							it.isOff
						loop
							it.next.accept(self)
							if  it.hasNext then
								write(", ") 
							end
						end
						write(")")
			  		end				
			  	
			  
			  	pathContextCounter := pathContextCounter-1
					
				if (pathContextCounter==0) then
			  		previousIsMultiple:=false
			  		pathExpression := ""
			  		pathExpression:=pathExpressionStack.pop
			  		
			  		visibleVariable.remove(currentVariableName)
			  		//visibleVariableMultiplicities.remove(currentVariableName)
			  		
			  	end
			  	
			end


/*
	  operation featureCall(visitable: FeatureCallExpCS): Void is
			do
				visitable.simpleNameCS.accept(self)
				if visitable.arguments.size > 0 then
					write("(")
					from
						var it : Iterator<OCLExpressionCS> init visitable.arguments.iterator
					until
						it.isOff
					loop
						it.next.accept(self)
						if  it.hasNext the
							write(", ") 
						end
					end
					write(")")
			  	end
			end
		
		method visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				if visitable.source != void then
					visitable.source.accept(self)		
					if visitable.accessor.name == "dot" then
						var variableName : String init nextName("variable")
					  write(".collect{" + variableName + " | ")
						write(variableName + ".")
						featureCall(visitable)
						write("}")
					end
					if visitable.accessor.name == "arrow" then
					   write(".")
						 featureCall(visitable)
					end
				end
			end
			*/

	   attribute __operators: Hashtable<String, OperatorPolicy>
        property readonly operators: Hashtable<String, OperatorPolicy>
			getter is 
				do
          			if __operators == void then
          			    var functionCall : OperatorPolicy init FunctionCallOp.new
          			    var simpleOp : OperatorPolicy init SimpleOP.new
          				__operators := Hashtable<String, OperatorPolicy>.new
          				__operators.put("implies", ImpliesOP.new)
          				__operators.put("and", functionCall)
          				__operators.put("or", functionCall)
          				__operators.put("xor", functionCall)
          				__operators.put("<", FunctionCallOp.new.withName("isLower"))
          				__operators.put("<=", FunctionCallOp.new.withName("isLowerOrEqual"))
          				__operators.put(">",  FunctionCallOp.new.withName("isGreater"))
          				__operators.put(">=",  FunctionCallOp.new.withName("isGreaterOrEqual"))
          				__operators.put("<>",  FunctionCallOp.new.withName("equals").withSuffix(".~not"))
          				__operators.put("+",  FunctionCallOp.new.withName("plus"))
          				__operators.put("-", MinusSignOp.new)
          				__operators.put("*",  FunctionCallOp.new.withName("mult"))
          				__operators.put("/",  FunctionCallOp.new.withName("div"))
          				__operators.put("includes", functionCollectionCall.new)
           				__operators.put("includesAll", functionCollectionCall.new)
          				__operators.put("excludes", functionCollectionCall.new)
           				__operators.put("excludesAll", functionCollectionCall.new)
          				
          				__operators.put("size", FunctionCallOp.new)
          				__operators.put("at", functionCollectionCall.new.withName("elementAt"))
          				__operators.put("indexOf", functionCollectionCall.new)
          				__operators.put("includes", functionCollectionCall.new)
           				__operators.put("includesAll", functionCollectionCall.new)
          				__operators.put("excludes", functionCollectionCall.new)
           				__operators.put("excludesAll", functionCollectionCall.new)
          				
          				__operators.put("size", functionCollectionCall.new)
          				__operators.put("at", functionCollectionCall.new.withName("elementAt"))
          				__operators.put("indexOf", functionCollectionCall.new)
          				__operators.put("oclAsType", CastOp.new)   
          				__operators.put("oclIsUndefined", NotNullOp.new)          				
          				__operators.put("not", functionCall)  
          				__operators.put("oclIsTypeOf", FunctionCallOp.new.withName("isKindOf"))
           				__operators.put("oclIsKindOf", FunctionCallOp.new.withName("isInstanceOf"))
          				
          				__operators.put("size", FunctionCallOp.new)
          				
          				
          				//Standard library : Colllection operation
          				__operators.put("includes", functionCollectionCall.new)
           				__operators.put("excludes", functionCollectionCall.new)
           				__operators.put("count", functionCollectionCall.new)  
           				__operators.put("includesAll", functionCollectionCall.new)
          				__operators.put("excludesAll", functionCollectionCall.new)
          				__operators.put("notEmpty", EmptyCallOp.new.withName("empty").withSuffix(".~not"))
          				__operators.put("isEmpty", EmptyCallOp.new.withName("empty"))
           				__operators.put("oclIsTypeOf", FunctionCallOp.new.withName("isKindOf"))
           				__operators.put("oclIsKindOf", FunctionCallOp.new.withName("isInstanceOf"))
           				__operators.put("union", FunctionCallOp.new)
           				__operators.put("intersection", FunctionCallOp.new) 
           				__operators.put("including", functionCall)  
           				__operators.put("excluding", functionCall)  
           				__operators.put("last", functionCall)  
           				__operators.put("first", functionCall)  
           				__operators.put("count", functionCall)             				
           				__operators.put("union", functionCollectionCall.new)
           				__operators.put("intersection", functionCollectionCall.new) 
           				__operators.put("including", functionCollectionCall.new)   
           				__operators.put("excluding", functionCollectionCall.new)  
           				__operators.put("last", functionOrderedCollectionCall.new)  
           				__operators.put("first", functionOrderedCollectionCall.new)  
           				__operators.put("count", functionCollectionCall.new)  
           				__operators.put("asBag", functionCollectionCall.new)  
           				__operators.put("asSet", functionCollectionCall.new)  
           				__operators.put("asOrderedSet", functionCollectionCall.new)  
           				__operators.put("asSequence", functionCollectionCall.new)  
           				__operators.put("subSequence", functionCollectionCall.new)  
           				__operators.put("prepend", functionCollectionCall.new)  
           				__operators.put("insertAt", functionCollectionCall.new)  
           				__operators.put("append", functionCollectionCall.new)  
           				__operators.put("flatten", functionCollectionCall.new)  
           				__operators.put("union", functionCollectionCall.new)
           				__operators.put("intersection", functionCollectionCall.new) 
           				__operators.put("including", functionCollectionCall.new)   
           				__operators.put("excluding", functionCollectionCall.new)  
           				__operators.put("last", functionOrderedCollectionCall.new)  
           				__operators.put("first", functionOrderedCollectionCall.new)  
           				__operators.put("count", functionCollectionCall.new)  
           				__operators.put("asBag", functionCollectionCall.new)  
           				__operators.put("asSet", functionCollectionCall.new)  
           				__operators.put("asOrderedSet", functionCollectionCall.new)  
           				__operators.put("asSequence", functionCollectionCall.new)  
           				__operators.put("subSequence", functionCollectionCall.new)  
           				__operators.put("prepend", functionCollectionCall.new)  
           				__operators.put("insertAt", functionCollectionCall.new)  
           				__operators.put("append", functionCollectionCall.new)  
           				__operators.put("flatten", functionCollectionCall.new)  
           				__operators.put("union", functionCollectionCall.new)
           				__operators.put("intersection", functionCollectionCall.new) 
           				__operators.put("including", functionCollectionCall.new)   
           				__operators.put("excluding", functionCollectionCall.new)  
           				__operators.put("last", functionOrderedCollectionCall.new)  
           				__operators.put("first", functionOrderedCollectionCall.new)  
           				__operators.put("count", functionCollectionCall.new)  
           				__operators.put("asBag", functionCollectionCall.new)  
           				__operators.put("asSet", functionCollectionCall.new)  
           				__operators.put("asOrderedSet", functionCollectionCall.new)  
           				__operators.put("asSequence", functionCollectionCall.new)  
           				__operators.put("subSequence", functionCollectionCall.new)  
           				__operators.put("prepend", functionCollectionCall.new)  
           				__operators.put("insertAt", functionCollectionCall.new)  
           				__operators.put("append", functionCollectionCall.new)  
           				__operators.put("flatten", functionCollectionCall.new)  
           				__operators.put("sum", functionCollectionCall.new)
           				__operators.put("product", EmptyCallOp.new.withName("empty"))
           				
           				//Standard library : Set operation
          				__operators.put("union", functionCollectionCall.new)
           				__operators.put("=", FunctionCallOp.new.withName("equals"))
          				__operators.put("intersection", functionCollectionCall.new) 
           				__operators.put("including", functionCollectionCall.new)   
           				__operators.put("excluding", functionCollectionCall.new)  
           				__operators.put("flatten", functionCollectionCall.new)  
           				__operators.put("symmetricDifference", functionCall)
           				__operators.put("asBag", functionCollectionCall.new)  
           				__operators.put("asSet", functionCollectionCall.new)  
           				__operators.put("asOrderedSet", functionCollectionCall.new)  
           				__operators.put("asSequence", functionCollectionCall.new)  
           				
           				//Standard library : OrderedSet operation
          				__operators.put("prepend", functionCollectionCall.new)  
           				__operators.put("insertAt", functionCollectionCall.new)  
           				__operators.put("append", functionCollectionCall.new)  
           				__operators.put("subOrderedSet", functionCollectionCall.new) 
           				__operators.put("at", functionCollectionCall.new.withName("elementAt"))
          				__operators.put("indexOf", functionCollectionCall.new)
          				__operators.put("last", functionOrderedCollectionCall.new)  
           				__operators.put("first", functionOrderedCollectionCall.new)  
           				
						//Standard library : Bag operation
          				__operators.put("subSequence", functionCollectionCall.new)  
          				
          				

           				

          			end
          			result := __operators
				end


		method visitOperationCallExpCS(visitable : OperationCallExpCS) : Void is
			do
				//visit(visitable)		
				var policy: OperatorPolicy init operators.getValue(visitable.simpleNameCS.~value.toString)
				if policy != void then
					policy.generate(visitable, self)
				else
					//write("Manage Operation Call")

					
					visitFeatureCallExpCS(visitable)
				end
				
			end

		method visitIsMarkedPreCS(visitable : IsMarkedPreCS) : Void is
			do
				visit(visitable)			
			end

		method visitStateExpCS(visitable : StateExpCS) : Void is
			do
				visit(visitable)			
			end

        property readonly iterators : Hashtable<String, IteratorPolicy>
        	getter is
        		do
        			if __iterators == void then
        				__iterators := Hashtable<String, IteratorPolicy>.new
        				var doNothing : IteratorPolicy init IteratorPolicy.new
        				var sameName: IteratorPolicy init SimpleIteratorIP.new
        				var functionWithSameName : IteratorPolicy init FunctionIP.new
        				addIterator("exists", sameName)
        				addIterator("forAll", sameName)
        				addIterator("isUnique", UniqueIP.new)
        				addIterator("any", sameName)//SimpleIteratorIP.new.withName("detect"))
        				addIterator("one", sameName)//SimpleIteratorIP.new.withName("select").withSuffix(".size.equals(1)"))
        				addIterator("select", SimpleIteratorIP.new.withName("select"))
        				addIterator("collect", sameName)
        				addIterator("collectNested", doNothing)
        				addIterator("sortedBy", sameName)
        				addIterator("reject", sameName)
        			end
        			result := __iterators
        		end


 operation isKermetaKeyword(word: String): Boolean is
          do
          		result :=	word.equals("package") or
							word.equals("require") or
							word.equals("includeFilter") or
							word.equals("excludeFilter") or
							word.equals("using") or
							word.equals("inherits") or
							word.equals("class") or
							//word.equals("@pre" ) or
							word.equals("pre") or
							word.equals("post") or
							word.equals("inv") or
							word.equals("abstract") or
							word.equals("Self") or
							word.equals("Void") or
							word.equals("attribute") or
							word.equals("reference") or
							word.equals("property") or
							word.equals("readonly") or
							word.equals("getter") or
							word.equals("is") or
							word.equals("setter") or
							word.equals("raises") or
							word.equals("select") or
							word.equals("operation") or
							word.equals("method") or
							word.equals("bag") or
							word.equals("set") or
							word.equals("seq") or
							word.equals("oset") or
							word.equals("alias") or
							word.equals("enumeration") or
							word.equals("and") or
							word.equals("or") or
							word.equals("not") or
							//word.equals("self") or
							word.equals("super") or
							word.equals("do") or
							word.equals("end") or
							word.equals("function") or
							word.equals("rescue") or
							word.equals("from") or
							word.equals("until") or
							word.equals("loop") or
							word.equals("if") or
							word.equals("then") or
							word.equals("else") or
							word.equals("raise") or
							word.equals("var") or
							word.equals("init") or
							word.equals("extern") or
							word.equals("true") or
							word.equals("false") or
							word.equals("void") or
							word.equals("result") or
							word.equals("value") 
          end

	}
	

class IteratorPolicy {
	attribute name: String
	
    operation withName(functionName: String): IteratorPolicy is
	    do
	    	name := functionName
	    	result := self
	    end
	    
   	attribute suffix: String
	
    operation withSuffix(theSuffix: String): IteratorPolicy is
	    do
	    	suffix := theSuffix
	    	result := self
	    end
	    
	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	var e : Exception init Exception.new
		 	e.message := " Unimplemented policy: " + oclIterator.simpleNameCS.~value.toString
		 	raise e
		 end
}

class SimpleIteratorIP inherits IteratorPolicy {

	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	
 			visitor.iteratorVariable := true 
		 	
			oclIterator.source.accept(visitor)
			visitor.write(".")
			if name == void then
				visitor.write(oclIterator.simpleNameCS.~value.toString )
			else
				visitor.write(name)
			end

			visitor.write("{ ")
			var variableName : String
			if (oclIterator.variable1 != void) then
				oclIterator.variable1.accept(visitor)
				variableName:= oclIterator.variable1.name
			else
			 variableName := visitor.nextName("variable")
				visitor.write(variableName)
				//TODO Check that mark
			end
			visitor.write(" | ")
			//visitor.write(oclIterator.body.getMetaClass.toString)
 					 	
			oclIterator.body.accept(visitor)
			visitor.write("}")
			if suffix != void then
				visitor.write(suffix)
			end
			visitor.visibleVariable.remove(variableName)
			
		 end
}

class UniqueIP inherits SimpleIteratorIP {

	method generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			name := "select"
			super(oclIterator, visitor)
			visitor.write(".asSet.size.equals(")
			oclIterator.source.accept(visitor)
			visitor.write(".size)")			
		 end
}

class FunctionIP inherits IteratorPolicy {
    
	operation generate(oclIterator: IteratorExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 	if name == void then
				visitor.write(oclIterator.simpleNameCS.~value.toString )
			else
				visitor.writeln(name)
			end
			visitor.write("( ")
			oclIterator.source.accept(visitor)
			visitor.write(", \"")
			oclIterator.body.accept(visitor)
			visitor.write("\")")
		 end
}					
