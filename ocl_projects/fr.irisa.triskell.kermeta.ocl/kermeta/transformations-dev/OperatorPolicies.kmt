/* $Id: OperatorPolicies.kmt,v 1.3 2007-06-12 10:52:31 barais Exp $
 * Creation date: February 23, 2007
 * License:
 * Copyright:
 * Authors: Mark Skipper
 */
 
 
package ocl2kmt;

require kermeta
require "../../mmodel/oclcstvisitor.kmt"
require "ocl2kmtVisitor.kmt"
     
using kermeta::standard
using kermeta::exceptions
using ocl::cst
using ocl::cst::visitors
 
 
class OperatorPolicy  {

	attribute name: String
	
	operation withName(opName: String): OperatorPolicy is
		do
			name := opName
			result := self
		end
		
	attribute suffix: String
	
    operation withSuffix(theSuffix: String): OperatorPolicy is
	    do
	    	suffix := theSuffix
	    	result := self
	    end
	    
		
	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
	  do
		 	var e : Exception  init Exception.new
		 	e.message := "Unimplemented policy: " + oclOp.simpleNameCS.~value.toString
		 	raise e
	  end
	  
	operation getPrefix():String is
	  do
  		 	result := ""
	  end
	  
 	operation getSuffix(): String is
   	  do
   	  		if suffix != void then
   	  			result := suffix 
   	  		else
   	  			result := ""
   	  		end
   	  end

   	  

}

class SimpleOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 		visitor.write("(")
				oclOp.source.accept(visitor)		
				visitor.write(" ")
				if name != void then
					visitor.write(name)
				else
					oclOp.simpleNameCS.accept(visitor)
				end
				visitor.write(" ")
				// TODO: assert: visitable.arguments.size == 1 ??? 
				oclOp.arguments.each{ arg |
						arg.accept(visitor)
			  	}
		 		visitor.write(")")
		 end
}


class MinusSignOp inherits OperatorPolicy {
 
	/**
	 * When you get a minus sign, you have several choices:
	 *  - negative numbers
	 *  - numeric subtraction
	 *  - set subtraction
	 */ 
	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			if oclOp.arguments.empty  then
				// unary minus
				oclOp.source.accept(visitor)
			  	 visitor.write(".uminus")
			else
				// infix minus
				// we really need to know the type of the 
				oclOp.source.accept(visitor)
				visitor.write(".minus")
	  			visitor.write("(")
				oclOp.arguments.each{ arg |
					arg.accept(visitor)
			  	}
	  			visitor.write(")")
		  	end
		 end

}


class ImpliesOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			oclOp.source.accept(visitor)
			visitor.write(".~not.~or(")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
  			visitor.writeln(")")
		 end
}

class UnimplementedOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			var e: Exception init Exception.new
			e.message := "Unimplemented Operation type: " + oclOp.simpleNameCS.~value.toString
			raise e
		 end
}

class CastOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
			visitor.write("do")
			visitor.write(" var ")
			var localVarName : String init visitor.nextName("variable")
			visitor.write(localVarName)			
			visitor.write(" : ")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			// TODO: assert: the unique parameter is a type name ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
		  	visitor.write(" init ")
			oclOp.source.accept(visitor)			
			visitor.write( "  ")
			visitor.write(localVarName)			
  			visitor.write( " end ")
		 end
	
}

class NotNullOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		do
			oclOp.source.accept(visitor)
			visitor.write (" == void")
		end
		
}

class PrefixOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		do
			visitor.write(name)
			visitor.write(" (")
			oclOp.source.accept(visitor)			
			visitor.write(")")
		end
		
}

class functionCollectionCall inherits FunctionCallOp{
	method generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is do
		    visitor.write(getPrefix)
			oclOp.source.accept(visitor)
			if (not visitor.currentClassifier.many) then
				visitor.getIerr.write("/*cannot call this operation in this context : "+ visitor.currentClassifier.eType.name+"*/")
			end 
			
			visitor.write(".")
			if name != void then
				visitor.write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			if not oclOp.arguments.empty then
				visitor.write("(")
				from
					var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
				until
					it.isOff
				loop
	//				visitor.write(" ")
					it.next.accept(visitor)
					if  it.hasNext then
						visitor.write(",") 
					else
	//					visitor.write(" ")
					end
				end
	  			visitor.write(")")
	  		end
  			visitor.write(getSuffix)
  			if (res != void and true == res) then
  			
  				visitor.previousIsMultiple := resMultiple
  				visitor.currentClassifier.ordered := resOrdered
  				if (resMultiple) then
  					visitor.currentClassifier.upperBound:=-1
  				else
  					visitor.currentClassifier.lowerBound:=0
  					visitor.currentClassifier.upperBound:=1
  				end
  			end 
  			
  			   	
//  			visitor.previousIsMultiple := false
	end
				reference resMultiple : Boolean
				reference resOrdered : Boolean
				reference res : Boolean
				

				operation setResult(manageResult : Boolean, multiple : Boolean, ordered : Boolean) : OperatorPolicy is do
					res := manageResult
					resMultiple := multiple 
					resOrdered := ordered
					
				result:=self
	
				end
	

}

class functionOrderedCollectionCall inherits FunctionCallOp{
	method generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is do
		    visitor.write(getPrefix)
			oclOp.source.accept(visitor)
			var currentType : ecore::ETypedElement init visitor.ecoreHelper.getETypedElementFromPath(visitor.ecoreHelper.getClassifierQualifiedName(visitor.currentClassifier.eType) , visitor.pathExpression.substring(0, visitor.pathExpression.size -1),".")
			if (not (currentType.ordered and currentType.many)) then
				visitor.getIerr.write("/*cannot call this operation in this context : "+ visitor.currentClassifier.name+"*/")
			end
			
			visitor.write(".")
			if name != void then
				visitor.write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			if not oclOp.arguments.empty then
				visitor.write("(")
				from
					var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
				until
					it.isOff
				loop
	//				visitor.write(" ")
					it.next.accept(visitor)
					if  it.hasNext then
						visitor.write(",") 
					else
	//					visitor.write(" ")
					end
				end
	  			visitor.write(")")
	  		end
  			visitor.write(getSuffix)
  			visitor.previousIsMultiple := false		
  			if (res != void and true == res) then
  			
  				visitor.previousIsMultiple := resMultiple
  				visitor.currentClassifier.ordered := resOrdered
  				if (resMultiple) then
  					visitor.currentClassifier.upperBound:=-1
  				else
  					visitor.currentClassifier.lowerBound:=0
  					visitor.currentClassifier.upperBound:=1
  				end
  			end 
  			
  			   	
//  			visitor.previousIsMultiple := false
	end
				reference resMultiple : Boolean
				reference resOrdered : Boolean
				reference res : Boolean
				

				operation setResult(manageResult : Boolean, multiple : Boolean, ordered : Boolean) : OperatorPolicy is do
					res := manageResult
					resMultiple := multiple 
					resOrdered := ordered
					
				result:=self
	
				end
	
}


class FunctionCallOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 // TODO: only if the accessor type is 'arrow', 
		// if its not arrow, should treat is as a normal operation call if thats possible from here
		    visitor.write(getPrefix)
			oclOp.source.accept(visitor)
			visitor.write(".")
			if name != void then
				visitor.write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			if not oclOp.arguments.empty then
				visitor.write("(")
				from
					var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
				until
					it.isOff
				loop
	//				visitor.write(" ")
					it.next.accept(visitor)
					if  it.hasNext then
						visitor.write(",") 
					else
	//					visitor.write(" ")
					end
				end
	  			visitor.write(")")
	  		end
  			visitor.write(getSuffix)
//  			visitor.previousIsMultiple := false
		 end

}
class EmptyCallOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: Ocl2kmtVisitor): Void is
		 do
		 // TODO: only if the accessor type is 'arrow', 
		// if its not arrow, should treat is as a normal operation call if thats possible from here
		    visitor.write(getPrefix)
			oclOp.source.accept(visitor)
			visitor.write(".")
			if name != void then
				visitor.write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			if not oclOp.arguments.empty then
				visitor.write("(")
				from
					var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
				until
					it.isOff
				loop
	//				visitor.write(" ")
					it.next.accept(visitor)
					if  it.hasNext then
						visitor.write(",") 
					else
	//					visitor.write(" ")
					end
				end
	  			visitor.write(")")
	  		end
  			visitor.write(getSuffix)
		 end
}

