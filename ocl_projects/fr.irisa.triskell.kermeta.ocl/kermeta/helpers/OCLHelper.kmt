/* $Id: OCLHelper.kmt,v 1.2 2007-01-24 12:55:21 bitterjug Exp $
 * File : EcoreHelper.kmt
 * License : EPL
 * Copyright : IRISA / INRIA / Universite de Rennes 1
 * ----------------------------------------------------------------------------
 * Creation date : Sep 08, 2005
 * Authors : 
 *  Didier Vojtisek <dvojtise@irisa.fr>
 *  Damien Pollet   <dpollet@irisa.fr>
 * 
 */
//@mainClass "OCLHelpers::OCLHelper"
//@mainOperation "main"


package OCLHelpers;

require kermeta
require "../../mmodel/oclcstvisitor.kmt"
require "../../mmodel/Ecore.ecore"

using kermeta::standard
using kermeta::persistence
using kermeta::exceptions
using kermeta::utils
//using ecore
using ocl::cst
using ocl::cst::visitors
using kermeta::standard

/** This class provides some helper methods to load/save Ecore models
    Plus some other useful navigation methods
 */
class OCLHelper
{
	attribute ecoreMetamodel : String
	attribute repository: EMFRepository
	attribute modelURI: String

	operation initialize() is 
	do
		ecoreMetamodel := "../../mmodel/OCLCST.ecore"
		modelURI :="../../speedsOCL1.xmi"
		modelURI :="../../speedsOCL2.xmi"
		modelURI :="../../speedsOCL3.xmi"
		modelURI :="../../speedsOCL4.xmi"
		modelURI :="../../speedsOCL5.xmi"
		repository := EMFRepository.new
	end
	
    operation main(): Void is
    do
		stdio.writeln("OCL -> Kermeta 'prettyprinter'")
		stdio.writeln("Can't easily be made to work for iterators with implicit variables.\n")		
     	initialize
     	var context: ocl::cst::ClassifierContextDeclCS
		context ?=   loadOCLModel(repository, modelURI).detect{o|
		     	   var classContext: ocl::cst::ClassifierContextDeclCS
		     	   classContext ?= o
		     	   classContext != void
		     	}
     	var visitor : OCLCSTvisitor init OCLCSTvisitor.new
     	context.accept(visitor)
    end
    
    operation loadOCLModel(repository : EMFRepository, modelUri : String) : Set<Object> is 
    do
    	var resource : Resource init repository.createResource(modelUri , ecoreMetamodel)
    	resource.load
    	var instances : Set<Object> init resource.instances
    	result := instances
    end
    
  }
  
  class OCLCSTvisitor inherits ocl::cst::visitors::Visitor {
  
  		attribute __varName : Integer
  		
		operation nextVarName() : String is
			do
				if __varName == void then
					__varName := 0
				end
				__varName := __varName + 1
				result := "variable" + __varName.toString
			end     
  
	    operation visit(visitable : Visitable) : Void is
			do
				stdio.write( visitable.toString)
			end

		operation visitCSTNode(visitable : CSTNode) : Void is
			do
				visit(visitable)
			end

		operation visitPackageDeclarationCS(visitable : PackageDeclarationCS) : Void is
			do
				visit(visitable)
			end

		operation visitContextDeclCS(visitable : ContextDeclCS) : Void is
			do
				visit(visitable)
			end

		operation visitPropertyContextCS(visitable : PropertyContextCS) : Void is
			do
				visit(visitable)
			end

		operation visitClassifierContextDeclCS(visitable : ClassifierContextDeclCS) : Void is
			do
				//visit(visitable)
				stdio.write("generating code for ")
				visitable.pathNameCS.accept(self)
				stdio.writeln("\n")
				visitable.invOrDefCS.accept(self)
		      	stdio.writeln("\ndone ")
			end

		operation visitOperationContextDeclCS(visitable : OperationContextDeclCS) : Void is
			do
				visit(visitable)
			end
  
		operation visitPrePostOrBodyDeclCS(visitable : PrePostOrBodyDeclCS) : Void is
			do
				visit(visitable)
			end

		operation visitOperationCS(visitable : OperationCS) : Void is
			do
				visit(visitable)
			end

		operation visitInitOrDerValueCS(visitable : InitOrDerValueCS) : Void is
			do
				visit(visitable)
			end

		operation visitDerValueCS(visitable : DerValueCS) : Void is
			do
				visit(visitable)
			end

		operation visitInitValueCS(visitable : InitValueCS) : Void is
			do
				visit(visitable)
			end

		operation visitInvOrDefCS(visitable : InvOrDefCS) : Void is
			do
				visit(visitable)
			end

		operation visitInvCS(visitable : InvCS) : Void is
			do
				//visit(visitable)			
				visitable.expressionCS.accept(self)
			end

		operation visitDefCS(visitable : DefCS) : Void is
			do
				 visit(visitable)
			end

		operation visitDefExpressionCS(visitable : DefExpressionCS) : Void is
			do
				visit(visitable)
			end

		operation visitPathNameCS(visitable : PathNameCS) : Void is
			do
				// visit(visitable)
				visitable.sequenceOfNames.each{o| 
					stdio.write("[pathName]" + o.toString)
 					// <<<<<<<<< Sequence of names contains a void item, how did that happen?
				    //o.accept(self) 
				    }
			end

		operation visitVariableExpCS(visitable : VariableExpCS) : Void is
			do
				//visit(visitable)			
				visitable.simpleNameCS.accept(self)
			end

		operation visitSimpleNameCS(visitable : SimpleNameCS) : Void is
			do
				//visit(visitable)			
				stdio.write(visitable.~value.toString)
			end

		operation visitTypeCS(visitable : TypeCS) : Void is
			do
				visit(visitable)
			end

		operation visitPrimitiveTypeCS(visitable : PrimitiveTypeCS) : Void is
			do
				visit(visitable)
			end

		operation visitTupleTypeCS(visitable : TupleTypeCS) : Void is
			do
				visit(visitable)			
			end

		operation visitCollectionTypeCS(visitable : CollectionTypeCS) : Void is
			do
				visit(visitable)
			end

		operation visitOCLExpressionCS(visitable : OCLExpressionCS) : Void is
			do
				visit(visitable)
			end

		operation visitLetExpCS(visitable : LetExpCS) : Void is
			do
				//visit(visitable)
				stdio.write(" do ")
				//variables
				visitable.variables.each{ v |
						stdio.write("\n var " )
						v.accept(self)
					}
				stdio.write("\n")
				//body
				visitable.inExpression.accept(self)
				stdio.write("\nend ")
			end

		operation visitIfExpCS(visitable : IfExpCS) : Void is
			do
				visit(visitable)
			end

		operation visitMessageExpCS(visitable : MessageExpCS) : Void is
			do
				visit(visitable)
			end

		operation visitOCLMessageArgCS(visitable : OCLMessageArgCS) : Void is
			do
				visit(visitable)
			end

		operation visitVariableCS(visitable : VariableCS) : Void is
			do
				//visit(visitable)
				stdio.write(visitable.name.toString)
				//visitable.name.accept(self)
				if visitable.typeCS != void then
					stdio.write(" : ")
					visitable.typeCS.accept(self)
				end
				if visitable.initExpression != void then
					stdio.write(" init ")
					visitable.initExpression.accept(self)
				end
			end

		operation visitLiteralExpCS(visitable : LiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitEnumLiteralExpCS(visitable : EnumLiteralExpCS) : Void is
			do
				visit(visitable)
			end

		operation visitCollectionLiteralExpCS(visitable : CollectionLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitTupleLiteralExpCS(visitable : TupleLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitPrimitiveLiteralExpCS(visitable : PrimitiveLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitIntegerLiteralExpCS(visitable : IntegerLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitRealLiteralExpCS(visitable : RealLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitStringLiteralExpCS(visitable : StringLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitBooleanLiteralExpCS(visitable : BooleanLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitNullLiteralExpCS(visitable : NullLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitInvalidLiteralExpCS(visitable : InvalidLiteralExpCS) : Void is
			do
				visit(visitable)			
			end

		operation visitCollectionLiteralPartCS(visitable : CollectionLiteralPartCS) : Void is
			do
				visit(visitable)			
			end

		operation visitCollectionRangeCS(visitable : CollectionRangeCS) : Void is
			do
				visit(visitable)
			end

		operation visitCallExpCS(visitable : CallExpCS) : Void is
			do
				visit(visitable)
			end

		operation visitLoopExpCS(visitable : LoopExpCS) : Void is
			do
				visit(visitable)			
			end

        attribute __iterators : Hashtable<String, IteratorPolicy>
        
        operation addIterator(oclIteratorName: String, policy: IteratorPolicy) : Void is 
        do
        	__iterators.put(oclIteratorName, policy)
        end
        
        property readonly iterators : Hashtable<String, IteratorPolicy>
        	getter is
        		do
        			if __iterators == void then
        				__iterators := Hashtable<String, IteratorPolicy>.new
        				var doNothing : IteratorPolicy init IteratorPolicy.new
        				var sameName: IteratorPolicy init SimpleIteratorIP.new
        				var functionWithSameName : IteratorPolicy init FunctionIP.new
        				addIterator("exists", sameName)
        				addIterator("forAll", SimpleIteratorIP.new.withName("forall"))
        				addIterator("isUnique", functionWithSameName)
        				addIterator("any", FunctionIP.new.withName("detect"))
        				addIterator("one", functionWithSameName)
        				addIterator("collect", doNothing)
        				addIterator("collectNested", doNothing)
        				addIterator("sortedBy", doNothing)
        				addIterator("reject", doNothing)
        			end
        			result := __iterators
        		end
        		
		operation visitIteratorExpCS(visitable : IteratorExpCS) : Void is
			do
				//visit(visitable)			
				// <source> <accessor> <simpleNameCS>( <body> )
				// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
				// why can't I compare the enumerations normally
				// i.e. visitable.simpleNameCS.~type.equals(SimpleTypeEnum.keyword)
				//  <<<<<<<<<<<<<<<<<<<<<<<<
				if visitable.simpleNameCS.~type.name.equals(SimpleTypeEnum.keyword.name) then
				    // check which keyword type and act accordingly
				    // TODO: this won't work in cases where the inner expression defines its own variables
					var policy: IteratorPolicy init iterators.getValue(visitable.simpleNameCS.~value.toString)
					if policy != void then
						// TODO: assert that the accessor was an arrow
						policy.generate(visitable, self)
					else
						stdio.writeln("Unknown keyword type " +visitable.simpleNameCS.~value.toString )
					end
				end
			end

		operation visitIterateExpCS(visitable : IterateExpCS) : Void is
			do
				visit(visitable)			
			end


		
		operation visitFeatureCallExpCS(visitable : FeatureCallExpCS) : Void is
			do
				//visit(visitable)	
				visitable.source.accept(self)		
				stdio.write(".")
				visitable.simpleNameCS.accept(self)
				if visitable.arguments.size > 0 then
					stdio.write("(")
					from
						var it : Iterator<OCLExpressionCS> init visitable.arguments.iterator
					until
						it.isOff
					loop
						it.next.accept(self)
						if  it.hasNext then
							stdio.write(", ") // TODO: dont put final comma
						end
					end
					stdio.write(")")
			  	end
			  	
			end

	   attribute __operators: Hashtable<String, OperatorPolicy>
        property readonly operators: Hashtable<String, OperatorPolicy>
			getter is 
				do
          			if __operators == void then
          			    var impliesOp : OperatorPolicy init ImpliesOP.new
          			    var simpleOp : OperatorPolicy init SimpleOP.new
          				__operators := Hashtable<String, OperatorPolicy>.new
          				__operators.put("implies", impliesOp)
          				__operators.put("and", simpleOp)
          				__operators.put("or", simpleOp)
          				__operators.put("xor", simpleOp)
          				__operators.put("=", SimpleOP.new.withName("=="))
          				__operators.put("<", simpleOp)
          				__operators.put("<=", simpleOp)
          				__operators.put(">", simpleOp)
          				__operators.put(">=", simpleOp)
          				__operators.put("<>", SimpleOP.new.withName("!="))
          				__operators.put("+", simpleOp)
          				__operators.put("-", simpleOp)
          				__operators.put("*", simpleOp)
          				__operators.put("/", simpleOp)
          				__operators.put("includes", FunctionCallOp.new.withName("contains"))
          				__operators.put("oclAsType", CastOp.new)          				
          			end
          			result := __operators
				end


		operation visitOperationCallExpCS(visitable : OperationCallExpCS) : Void is
			do
				//visit(visitable)		
				var policy: OperatorPolicy init operators.getValue(visitable.simpleNameCS.~value.toString)
				if policy != void then
					policy.generate(visitable, self)
				else
					visitFeatureCallExpCS(visitable)
				end
			end

		operation visitIsMarkedPreCS(visitable : IsMarkedPreCS) : Void is
			do
				visit(visitable)			
			end

		operation visitStateExpCS(visitable : StateExpCS) : Void is
			do
				visit(visitable)			
			end

	}
	


class OperatorPolicy {

	attribute name: String
	
	operation withName(opName: String): OperatorPolicy is
		do
			name := opName
			result := self
		end
		
	operation generate(oclOp: OperationCallExpCS, visitor: OCLCSTvisitor): Void is
	 do
	 	stdio.writeln("\n Unimplemented policy: " + oclOp.simpleNameCS.~value.toString)
	 end

}

class SimpleOP inherits OperatorPolicy {


	
	operation generate(oclOp: OperationCallExpCS, visitor: OCLCSTvisitor): Void is
		 do
				oclOp.source.accept(visitor)		
				stdio.write(" ")
				if name != void then
					stdio.write(name)
				else
					oclOp.simpleNameCS.accept(visitor)
				end
				stdio.write(" ")
				// TODO: assert: visitable.arguments.size == 1 ??? 
				oclOp.arguments.each{ arg |
						arg.accept(visitor)
			  	}
		 end
}

class ImpliesOP inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: OCLCSTvisitor): Void is
		 do
			stdio.write("not (")
			oclOp.source.accept(visitor)
			stdio.write(") or ( ")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
  			stdio.writeln(")")
		 end
}

class CastOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: OCLCSTvisitor): Void is
		 do
			stdio.write("do")
			stdio.write(" var ")
			var localVarName : String init visitor.nextVarName
			stdio.write(localVarName)			
			stdio.write(" : ")
			// TODO: assert: visitable.arguments.size == 1 ??? 
			// TODO: assert: the unique parameter is a type name ??? 
			oclOp.arguments.each{ arg |
				arg.accept(visitor)
		  	}
		  	stdio.write(" init ")
			oclOp.source.accept(visitor)			
			stdio.write( "  ")
			stdio.write(localVarName)			
  			stdio.write( " end ")
		 end
	
}

class FunctionCallOp inherits OperatorPolicy {

	operation generate(oclOp: OperationCallExpCS, visitor: OCLCSTvisitor): Void is
		 do
		 // TODO: only if the accessor type is 'arrow', 
		// if its not arrow, should treat is as a normal operation call if thats possible from here
			oclOp.source.accept(visitor)
			stdio.write(".")
			if name != void then
				stdio.write(name)
			else
				oclOp.simpleNameCS.accept(visitor)
			end
			stdio.write("(")
			from
				var it : Iterator<OCLExpressionCS> init oclOp.arguments.iterator
			until
				it.isOff
			loop
				it.next.accept(visitor)
				if  it.hasNext then
					stdio.write(", ") // TODO: dont put final comma
				end
			end
  			stdio.writeln(")")
		 end
}

class IteratorPolicy {
	attribute name: String
	
    operation withName(functionName: String): IteratorPolicy is
	    do
	    	name := functionName
	    	result := self
	    end

	operation generate(oclIterator: IteratorExpCS, visitor: OCLCSTvisitor): Void is
		 do
		 	stdio.writeln("\n Unimplemented policy: " + oclIterator.simpleNameCS.~value.toString)
		 end
}

class SimpleIteratorIP inherits IteratorPolicy {

	operation generate(oclIterator: IteratorExpCS, visitor: OCLCSTvisitor): Void is
		 do
			oclIterator.source.accept(visitor)
			stdio.write(".")
			if name == void then
				stdio.write(oclIterator.simpleNameCS.~value.toString )
			else
				stdio.write(name)
			end
			stdio.write("{ ")
			oclIterator.variable1.accept(visitor)
			stdio.write(" | ")
			oclIterator.body.accept(visitor)
			stdio.write("}")
		 end
}

class FunctionIP inherits IteratorPolicy {
    
	operation generate(oclIterator: IteratorExpCS, visitor: OCLCSTvisitor): Void is
		 do
		 	if name == void then
				stdio.write(oclIterator.simpleNameCS.~value.toString )
			else
				stdio.writeln(name)
			end
			stdio.write("( ")
			oclIterator.source.accept(visitor)
			stdio.write(", \"")
			oclIterator.body.accept(visitor)
			stdio.write("\")")
		 end
}					