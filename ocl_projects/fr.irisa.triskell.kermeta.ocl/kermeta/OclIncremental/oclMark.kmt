package ocl;

require "platform:/resource/fr.irisa.triskell.kermeta.ocl/mmodel/OCLCST.ecore" 
require "TypeSystemMixin.kmt"
require "oclTypeCheck.kmt"

 
using kermeta::standard   
using ocl2kmt
package cst
{
	enumeration MARKTYPE { UND; UPD; INC; DEC; }
	
	aspect
	abstract class CSTNode 
	{
		attribute marks : Set<MARKTYPE>
		operation mark() : Void is abstract 

	}
	aspect
	class PackageDeclarationCS 
	{ 
		method mark() : Void from ocl::cst::CSTNode is
		do
			self.contextDecls.each{e | e.marks := Set<MARKTYPE>.new}
			self.contextDecls.each{e | e.marks.addAll(self.marks)}
			self.contextDecls.each{e | e.mark()}
		end 
	}  
	aspect
	abstract class ContextDeclCS
	{
		method mark() : Void from ocl::cst::CSTNode is abstract 
	} 
	aspect
	class PropertyContextCS 
	{
		
		method mark() : Void from ocl::cst::ContextDeclCS is
		do

		end	}
	aspect
	class ClassifierContextDeclCS
	{

		method mark() : Void from ocl::cst::ContextDeclCS is
		do
			self.invOrDefCS.marks := Set<MARKTYPE>.new
			self.invOrDefCS.marks.addAll(self.marks)
			self.invOrDefCS.mark()
		end	}
	aspect
	class OperationContextDeclCS 
	{
		method mark() : Void from ocl::cst::ContextDeclCS is
			do end
	}
	aspect
	class PrePostOrBodyDeclCS
	{
		method mark() : Void from ocl::cst::CSTNode is
			do end
	}

	aspect
	class OperationCS 
	{
		method mark() : Void from ocl::cst::CSTNode is
			do end
	}
	aspect
	abstract class InitOrDerValueCS
{

		method mark() : Void from ocl::cst::CSTNode is
			abstract 
	}
	aspect
	class DerValueCS 
	{
		method mark() : Void from ocl::cst::InitOrDerValueCS is
			do 
			
			end
	}
	aspect
	class InitValueCS
	{
		method mark() : Void from ocl::cst::InitOrDerValueCS is
			do end
	}
	aspect
	abstract class InvOrDefCS
	{
		method mark() : Void from ocl::cst::CSTNode is abstract
	}
	aspect
	class InvCS 
	{
		method mark() : Void from ocl::cst::InvOrDefCS is
		do
			self.expressionCS.marks := Set<MARKTYPE>.new
			self.expressionCS.marks.addAll(self.marks)
			self.expressionCS.mark()
		end	
	}
	aspect
	class DefCS 
	{
		method mark() : Void from ocl::cst::InvOrDefCS is
		do 
			//TODO
		end
	}
	aspect class DefExpressionCS
	{

		method mark() : Void from ocl::cst::CSTNode is
			do end
	}
	aspect class PathNameCS
	{
	
/**    TODO
**/
		method mark() : Void from ocl::cst::TypeCS is
		do end
	}
	aspect class VariableExpCS
	{
		method mark() : Void from ocl::cst::OCLExpressionCS is do

		end
	}
	aspect class SimpleNameCS 
	{
		method mark() : Void from ocl::cst::OCLExpressionCS is
			do end
	}

	 aspect
	abstract class TypeCS
	{
		method mark() : Void from ocl::cst::OCLExpressionCS is abstract
	}
	aspect class PrimitiveTypeCS 
	{
		method mark() : Void from ocl::cst::SimpleNameCS is
		do end
	}
	aspect class TupleTypeCS 
	{

		method mark() : Void from ocl::cst::TypeCS is
		do end
	}
	aspect class CollectionTypeCS
	{

		method mark() : Void from ocl::cst::TypeCS is
		do end
	}

	aspect
	abstract  class OCLExpressionCS 
	{
		method mark() : Void from ocl::cst::CSTNode is
		abstract
	}
	aspect class LetExpCS
	{

		method mark() : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class IfExpCS 
	{

		method mark() : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class MessageExpCS
	{

		method mark() : Void from ocl::cst::OCLExpressionCS is
			do end
	}
	aspect class OCLMessageArgCS
	{

		method mark() : Void from ocl::cst::CSTNode is
			do end
	}
	aspect class VariableCS
	{

		method mark() : Void from ocl::cst::CSTNode is
			do end
	}
	aspect
	abstract  class LiteralExpCS
	{
		method mark() : Void from ocl::cst::OCLExpressionCS is
		abstract
	} 
	aspect class EnumLiteralExpCS 
	{
		method mark() : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class CollectionLiteralExpCS 
	{
		method mark() : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class TupleLiteralExpCS 
	{


		method mark() : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class PrimitiveLiteralExpCS
	{
		method mark() : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class IntegerLiteralExpCS
	{
		method mark() : Void from ocl::cst::PrimitiveLiteralExpCS is
		do 

		end
	}
	aspect class RealLiteralExpCS
	{
		method mark() : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class StringLiteralExpCS
	{
		method mark() : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class BooleanLiteralExpCS
	{
		method mark() : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class NullLiteralExpCS
	{
		method mark() : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class InvalidLiteralExpCS {


		method mark() : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class CollectionLiteralPartCS
	{


		method mark() : Void from ocl::cst::CSTNode is
		do end
	}
	aspect class CollectionRangeCS
	{
		method mark() : Void from ocl::cst::CollectionLiteralPartCS is
		do end
	}
	aspect class CallExpCS
	{
		method mark() : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class LoopExpCS
	{
		method mark() : Void from ocl::cst::CallExpCS is do

		 end
	}
	aspect class IteratorExpCS
	{
		method mark() : Void from ocl::cst::LoopExpCS is do
			self.source.marks := Set<MARKTYPE>.new
			self.body.marks := Set<MARKTYPE>.new
			if (self.simpleNameCS.~value == "forAll") then // und => +u, und
				if (self.marks.contains(MARKTYPE.UND)) then
					self.source.marks.add(MARKTYPE.UPD)
					self.source.marks.add(MARKTYPE.INC)
					self.body.marks.add(MARKTYPE.UND)
				end else
			if (self.simpleNameCS.~value == "select") then // + => +u, und // - => -u, und
				self.body.marks.add(MARKTYPE.UND)
				self.source.marks.add(MARKTYPE.UPD)
				if (self.marks.contains(MARKTYPE.DEC)) then
					self.source.marks.add(MARKTYPE.DEC)
				end
				if (self.marks.contains(MARKTYPE.INC)) then
					self.source.marks.add(MARKTYPE.INC)
				end else
			if (self.simpleNameCS.~value == "collect") then
				if (self.marks.contains(MARKTYPE.UPD)) then
					self.source.marks.add(MARKTYPE.UPD)
					self.body.marks.add(MARKTYPE.UPD)
				end 
				if (self.marks.contains(MARKTYPE.DEC)) then
					self.source.marks.add(MARKTYPE.DEC)
					self.body.marks.add(MARKTYPE.DEC)
				end
				if (self.marks.contains(MARKTYPE.INC)) then
					self.source.marks.add(MARKTYPE.INC)
					self.body.marks.add(MARKTYPE.INC)
				end else
			end
			end		
			end 
			self.source.mark()
			self.body.mark()
		end	
	}
	aspect class IterateExpCS
	{
		method mark() : Void from ocl::cst::LoopExpCS is do
			 
			 end

	}
	aspect class FeatureCallExpCS
	{
		method mark() : Void from ocl::cst::CallExpCS is do
    		  var featureName : String init  self.simpleNameCS.~value
    		  self.source.marks := Set<MARKTYPE>.new
    		  self.source.mark
    		  self.source.marks.addAll(self.marks)
    		  if not(isAtt) then self.source.marks.add(MARKTYPE.UPD) end
		 end
	}

	aspect class OperationCallExpCS 
	{
		method mark() : Void from ocl::cst::FeatureCallExpCS is do
			self.source.marks := Set<MARKTYPE>.new
			self.arguments.each{e | e.marks := Set<MARKTYPE>.new}
			if ((self.simpleNameCS.~value == "and") or (self.simpleNameCS.~value == "or")) then 
				self.source.marks.add(MARKTYPE.UND)
				self.arguments.each{e | e.marks.add(MARKTYPE.UND)} else
			if ((self.simpleNameCS.~value == ">") or (self.simpleNameCS.~value == ">="))  then		
				self.source.marks.add(MARKTYPE.DEC)
				self.arguments.each{e | e.marks.add(MARKTYPE.INC)} else
			if ((self.simpleNameCS.~value == "<") or (self.simpleNameCS.~value == "<="))  then		
				self.source.marks.add(MARKTYPE.DEC)
				self.arguments.each{e | e.marks.add(MARKTYPE.INC)} else
			if ((self.simpleNameCS.~value == "=") or (self.simpleNameCS.~value == "<>")) then 
				self.source.marks.add(MARKTYPE.DEC)
				self.source.marks.add(MARKTYPE.INC)
				self.source.marks.add(MARKTYPE.UPD)
				self.arguments.each{e | e.marks.add(MARKTYPE.UPD)}
				self.arguments.each{e | e.marks.add(MARKTYPE.DEC)}
				self.arguments.each{e | e.marks.add(MARKTYPE.INC)} else
			if ((self.simpleNameCS.~value == "+") or (self.simpleNameCS.~value == "-")) then 
				if (self.marks.contains(MARKTYPE.UPD)) then
					self.source.marks.add(MARKTYPE.UPD)
					self.arguments.each{e | e.marks.add(MARKTYPE.UPD)}
				end
				self.source.marks.add(MARKTYPE.DEC)
				self.source.marks.add(MARKTYPE.INC)
				self.arguments.each{e | e.marks.add(MARKTYPE.DEC)}
				self.arguments.each{e | e.marks.add(MARKTYPE.INC)} else
			if (self.simpleNameCS.~value == "size") then 
				if (self.marks.contains(MARKTYPE.DEC)) then
					self.source.marks.add(MARKTYPE.DEC)
				end
				if (self.marks.contains(MARKTYPE.INC)) then
					self.source.marks.add(MARKTYPE.INC)
				end else
			if (self.simpleNameCS.~value == "sum") then 
				if (self.marks.contains(MARKTYPE.DEC)) then
					self.source.marks.add(MARKTYPE.DEC)
					self.source.marks.add(MARKTYPE.UPD)
				end
				if (self.marks.contains(MARKTYPE.INC)) then
					self.source.marks.add(MARKTYPE.INC)
					self.source.marks.add(MARKTYPE.UPD)
				end else
			self.source.marks.addAll(self.mark)
			end
			end
			end
			end
			end
			end
			end
			//TODO other operations and, or, implies, <>, =, count,...etc
			self.source.mark
			self.arguments.each{e | e.mark}
		end
	}
	aspect class IsMarkedPreCS 
	{
		method mark() : Void from ocl::cst::CSTNode is do
			 
			 end
	}
	aspect class StateExpCS 
	{
		method mark() : Void  is do
			 
			 end
	}

}
}

