package ocl;

require "platform:/resource/fr.irisa.triskell.kermeta.ocl/mmodel/OCLCST.ecore" 
require "TypeSystemMixin.kmt"

 
using kermeta::standard   
using ocl2kmt
package cst
{
	enumeration MARKTYPE { UND; UPD; INC; DEC; }
	
	aspect
	abstract class CSTNode 
	{
		attribute marks : Set<MARKTYPE>
		operation mark(context:TypeSystemMixin) : Void is abstract 

	}
	aspect
	class PackageDeclarationCS 
	{ 
		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
		do
			stdio.write(">>> The current Package : " )
			self.pathNameCS.sequenceOfNames.each{e|stdio.write(e)}
			stdio.writeln("")
			context.setContextPackageName(self.pathNameCS.sequenceOfNames)
			self.contextDecls.each{e | e.marks := Set<MARKTYPE>.new}
			self.contextDecls.each{e | e.marks.addAll(self.marks)}
			self.contextDecls.each{e | e.mark(context)}
		end 
	}  
	aspect
	abstract class ContextDeclCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is abstract 
	} 
	aspect
	class PropertyContextCS 
	{
		
		method mark(context:TypeSystemMixin) : Void from ocl::cst::ContextDeclCS is
		do

		end	}
	aspect
	class ClassifierContextDeclCS
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::ContextDeclCS is
		do
			stdio.write(">>> Context : " )
			self.pathNameCS.sequenceOfNames.each{e|stdio.write(e+".")}
			stdio.writeln("")
			context.setContextClassifierName(self.pathNameCS.sequenceOfNames)
			context.pushNewStackFrame()
			self.invOrDefCS.marks := Set<MARKTYPE>.new
			self.invOrDefCS.marks.addAll(self.marks)
			self.invOrDefCS.mark(context)
			context.popStackFrame()

		end	}
	aspect
	class OperationContextDeclCS 
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::ContextDeclCS is
			do end
	}
	aspect
	class PrePostOrBodyDeclCS
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
			do end
	}

	aspect
	class OperationCS 
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
			do end
	}
	aspect
	abstract class InitOrDerValueCS
{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
			abstract 
	}
	aspect
	class DerValueCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::InitOrDerValueCS is
			do 
			
			end
	}
	aspect
	class InitValueCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::InitOrDerValueCS is
			do end
	}
	aspect
	abstract class InvOrDefCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is abstract
	}
	aspect
	class InvCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::InvOrDefCS is
		do
			self.expressionCS.marks := Set<MARKTYPE>.new
			self.expressionCS.marks.addAll(self.marks)
			self.expressionCS.mark(context)
		end	
	}
	aspect
	class DefCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::InvOrDefCS is
		do 
			//TODO
		end
	}
	aspect class DefExpressionCS
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
			do end
	}
	aspect class PathNameCS
	{
	
/**    TODO
**/
		method mark(context:TypeSystemMixin) : Void from ocl::cst::TypeCS is
		do end
	}
	aspect class VariableExpCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::OCLExpressionCS is do

		end
	}
	aspect class SimpleNameCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::OCLExpressionCS is
			do end
	}

	 aspect
	abstract class TypeCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::OCLExpressionCS is abstract
	}
	aspect class PrimitiveTypeCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::SimpleNameCS is
		do end
	}
	aspect class TupleTypeCS 
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::TypeCS is
		do end
	}
	aspect class CollectionTypeCS
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::TypeCS is
		do end
	}

	aspect
	abstract  class OCLExpressionCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
		abstract
	}
	aspect class LetExpCS
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class IfExpCS 
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class MessageExpCS
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::OCLExpressionCS is
			do end
	}
	aspect class OCLMessageArgCS
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
			do end
	}
	aspect class VariableCS
	{

		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
			do end
	}
	aspect
	abstract  class LiteralExpCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::OCLExpressionCS is
		abstract
	} 
	aspect class EnumLiteralExpCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class CollectionLiteralExpCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class TupleLiteralExpCS 
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class PrimitiveLiteralExpCS
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class IntegerLiteralExpCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::PrimitiveLiteralExpCS is
		do 

		end
	}
	aspect class RealLiteralExpCS
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class StringLiteralExpCS
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class BooleanLiteralExpCS
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class NullLiteralExpCS
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class InvalidLiteralExpCS {


		method mark(context:TypeSystemMixin) : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class CollectionLiteralPartCS
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is
		do end
	}
	aspect class CollectionRangeCS
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::CollectionLiteralPartCS is
		do end
	}
	aspect class CallExpCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class LoopExpCS
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::CallExpCS is do

		 end

	}
	aspect class IteratorExpCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::LoopExpCS is do
			self.source.mark(context)
			self.body.mark(context)
		end	
	}
	aspect class IterateExpCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::LoopExpCS is do
			 
			 end

	}
	aspect class FeatureCallExpCS
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::CallExpCS is do
    		  var featureName : String init  self.simpleNameCS.~value
    		  context.setLocalFeature(context.getContextFeature(context.getLocalFeatureType, featureName))
    		  stdio.writeln(">>> Context : " + context.getLocalFeatureTypeName)
		end
	}

	aspect class OperationCallExpCS 
	{
		method mark(context:TypeSystemMixin) : Void from ocl::cst::FeatureCallExpCS is do
			self.source.mark(context)
			self.arguments.each{e|e.mark(context)}
			
		end
	}
	aspect class IsMarkedPreCS 
	{


		method mark(context:TypeSystemMixin) : Void from ocl::cst::CSTNode is do
			 
			 end

	}
	aspect class StateExpCS 
	{


		method mark(context:TypeSystemMixin) : Void  is do
			 
			 end

	}

}
}

