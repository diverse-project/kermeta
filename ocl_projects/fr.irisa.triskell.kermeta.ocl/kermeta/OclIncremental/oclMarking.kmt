package ocl;

require "platform:/resource/fr.irisa.triskell.kermeta.ocl/mmodel/OCLCST.ecore" 
require "EcoreHelper.kmt"
require "TypeSystemMixin.kmt"
//require "QualifiedName.kmt"
 
  
using kermeta::standard 
using kermeta::utils
using kermeta::persistence
using ecore
using EcoreHelpers
using ocl2kmt
using qualifiedNames
package cst
{
	enumeration MARKTYPE { UND; UPD; INC; DEC; }
	aspect
	abstract class CSTNode 
	{
		attribute mark : Set<MARKTYPE>
		operation getModel(context : Hashtable<String,Object>) : Resource is
		do
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
			result:=void
		end
/**
** I'll not spend my time in mapping the OCL epression to the ecore model
** I'll only check if an identifeir is an attribute or a reference
** without checking the existence
** i.e. we suppose that OCL expression contain no error.
** the best methoed is to genrate an OCL AST model and not OCL CST
** with this methode the code will be more lisible and each class will have
** only small code to write without complication of ifs.
**/

/**
** this methode is a temporary one, 
** because an attribute can appear with the same name in different classes
**/
		
		/*operation isAtt(name : String, context : Hashtable<String,Object>) : Boolean is
		do
			result := true		
		end*/
		
		operation marque(context :Hashtable<String,Object>) : Void is
			
		do end 
	}
	
	aspect
	class PackageDeclarationCS 
	{ 
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
		do
			/*var pname : String
			var i : Integer init 1
			self.pathNameCS.sequenceOfNames.each{e| if (i==1) then 
					pname := e.toString
				else
					pname := pname+ "."+e.toString
				end
				}
			stdio.writeln("packagename = " + pname)
			context.put("cur_packagename",pname)*/
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
			v.setContextPackageName(self.pathNameCS.sequenceOfNames)
			self.contextDecls.each{e | e.mark := Set<MARKTYPE>.new}
			self.contextDecls.each{e | e.mark.addAll(self.mark)}
			self.contextDecls.each{e | e.marque(context)}
			context.remove("cur_packagename")
			
		end
	}  
	aspect
	abstract class ContextDeclCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is abstract 
	} 
	aspect
	class PropertyContextCS 
	{
		
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::ContextDeclCS is
		do
			stdio.writeln(self.pathNameCS.sequenceOfNames.first.toString)
			//TODO
		end	}
	aspect
	class ClassifierContextDeclCS
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::ContextDeclCS is
		do
		
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
			v.setContextClassifierName(self.pathNameCS.sequenceOfNames)
			v.pushNewStackFrame()
			self.invOrDefCS.mark := Set<MARKTYPE>.new
			self.invOrDefCS.mark.addAll(self.mark)
			self.invOrDefCS.marque(context)
			v.popStackFrame()
		end	}
	aspect
	class OperationContextDeclCS 
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::ContextDeclCS is
			do
				var v : TypeSystemMixin 
				v?= context.getValue("typemixin")
				v.setContextClassifierName(self.operationCS.pathNameCS.sequenceOfNames) 
			end
	}
	aspect
	class PrePostOrBodyDeclCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
			do end
	}

	aspect
	class OperationCS 
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
			do end
	}
	aspect
	abstract class InitOrDerValueCS
{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
			abstract 
	}
	aspect
	class DerValueCS 
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::InitOrDerValueCS is
			do end
	}
	aspect
	class InitValueCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::InitOrDerValueCS is
			do end
	}
	aspect
	abstract class InvOrDefCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
			do end
	}
	aspect
	class InvCS 
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::InvOrDefCS is
		do
			self.expressionCS.mark := Set<MARKTYPE>.new
			self.expressionCS.mark.addAll(self.mark)
			self.expressionCS.marque(context)
		end	
	}
	aspect
	class DefCS 
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::InvOrDefCS is
			do 
			
			
			end
	}
	aspect class DefExpressionCS
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
			do
			var v : TypeSystemMixin 
				v?= context.getValue("typemixin")
			v.pushNewStackFrame()
				//TODO
			v.popStackFrame()
			 end
	}
	aspect class PathNameCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::TypeCS is
		do 
			var qualifiedTypeName : QualifiedName init  QualifiedName.new.fromSequence(self.sequenceOfNames.asSequence())
			context.put("qualifiedTypeName",qualifiedTypeName)
		end
	}
	aspect class VariableExpCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::OCLExpressionCS is do
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
		end
		
		operation canAccesTo(context :Hashtable<String,Object>, name : String) : Boolean is
		do
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
			v.getLocalVariable(self.simpleNameCS.~value)
			//result:=v.contextDefinesFeature(name)
			result := (v.ecoreHelper.getETypedElement(v.getLocalVariable(self.simpleNameCS.~value).eType.asType(EClass), name) != void)
			stdio.writeln(result.toString() + " ========>"+self.simpleNameCS.~value)
			//result:=(v.getLocalVariable(self.simpleNameCS.~value).eType.asType(EClass).eAllStructuralFeatures.select{e| e.name == name}.first.isInstanceOf(EAttribute))
			
		end
	}
	aspect class SimpleNameCS 
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::OCLExpressionCS is
			do end
	}

	 aspect
	abstract class TypeCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class PrimitiveTypeCS 
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::SimpleNameCS is
		do end
	}
	aspect class TupleTypeCS 
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::TypeCS is
		do end
	}
	aspect class CollectionTypeCS
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::TypeCS is
		do end
	}

	aspect
	abstract  class OCLExpressionCS 
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
		do end
	}
	aspect class LetExpCS
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class IfExpCS 
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class MessageExpCS
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::OCLExpressionCS is
			do end
	}
	aspect class OCLMessageArgCS
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
			do end
	}
	aspect class VariableCS
	{

		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
		do 
			self.typeCS.marque(context)
			var variableName: String init self.name.toString
    			
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
			var s : QualifiedName
			s?= context.getValue("qualifiedTypeName")
			stdio.writeln("_______pass par la " + variableName)
			v.addLocalVariable(variableName, s, 0, 1, false)// add to stack
		end
		
	}
	aspect
	abstract  class LiteralExpCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::OCLExpressionCS is
			do end
	} 
	aspect class EnumLiteralExpCS 
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class CollectionLiteralExpCS 
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class TupleLiteralExpCS 
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::LiteralExpCS is
			do end
	}
	aspect class PrimitiveLiteralExpCS
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class IntegerLiteralExpCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::PrimitiveLiteralExpCS is
		do 
		end
	}
	aspect class RealLiteralExpCS
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class StringLiteralExpCS
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class BooleanLiteralExpCS
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::PrimitiveLiteralExpCS is
		do end
	}
	aspect class NullLiteralExpCS
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class InvalidLiteralExpCS {


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::LiteralExpCS is
		do end
	}
	aspect class CollectionLiteralPartCS
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is
		do end
	}
	aspect class CollectionRangeCS
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CollectionLiteralPartCS is
		do end
	}
	aspect class CallExpCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::OCLExpressionCS is
		do end
	}
	aspect class LoopExpCS
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CallExpCS is do
			// Don't forget the other loop operations selcte, reject, ...etc
			self.source.mark := Set<MARKTYPE>.new
			self.body.mark := Set<MARKTYPE>.new
			if (self.simpleNameCS.~value == "forAll") then // und => +u, und
				if (self.mark.contains(MARKTYPE.UND)) then
					self.source.mark.add(MARKTYPE.UPD)
					self.source.mark.add(MARKTYPE.INC)
					self.body.mark.add(MARKTYPE.UND)
				end else
			if (self.simpleNameCS.~value == "select") then // + => +u, und // - => -u, und
				self.body.mark.add(MARKTYPE.UND)
				self.source.mark.add(MARKTYPE.UPD)
				if (self.mark.contains(MARKTYPE.DEC)) then
					self.source.mark.add(MARKTYPE.DEC)
				end
				if (self.mark.contains(MARKTYPE.INC)) then
					self.source.mark.add(MARKTYPE.INC)
				end else
			if (self.simpleNameCS.~value == "collect") then
				if (self.mark.contains(MARKTYPE.UPD)) then
					self.source.mark.add(MARKTYPE.UPD)
					self.body.mark.add(MARKTYPE.UPD)
				end 
				if (self.mark.contains(MARKTYPE.DEC)) then
					self.source.mark.add(MARKTYPE.DEC)
					self.body.mark.add(MARKTYPE.DEC)
				end
				if (self.mark.contains(MARKTYPE.INC)) then
					self.source.mark.add(MARKTYPE.INC)
					self.body.mark.add(MARKTYPE.INC)
				end else
			end
			end		
			end 
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
			stdio.writeln("______________________________")
			self.source.marque(context)
			
			stdio.writeln("_____"+v.getLocalFeatureTypeName.toString)

			self.variable1.marque(context)
		 	self.body.marque(context)
		end

	}
/*	aspect class IteratorExpCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::LoopExpCS is do
		end	
	}
	aspect class IterateExpCS
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::LoopExpCS is do
			 
			 end

	}
*/	
	/** cette methode sera mieux ecrite si il y a la commande select case??!!!
	**/
	aspect class FeatureCallExpCS
	
	{
		attribute isAtt : Boolean
		
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CallExpCS is do
			//self.source.marque(context)
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
			//stdio.writeln(self.source.toString)
				var varName :String init "" 
//			varName := 
			if (self.source.isInstanceOf(VariableExpCS)) 
			then 
				varName :=self.source.asType(VariableExpCS).simpleNameCS.~value
				stdio.writeln("+++++++++" + " Loking for " + self.simpleNameCS.~value + 
			" in " + self.source.asType(VariableExpCS).simpleNameCS.~value+ " -----> " + 
			self.source.asType(VariableExpCS).canAccesTo(context, self.simpleNameCS.~value).toString) 
				self.source.asType(VariableExpCS).simpleNameCS.~value
				self.isAtt:=v.getLocalVariable(varName).eType.asType(EClass).eAllStructuralFeatures.select{e| e.name == self.simpleNameCS.~value}.first.isInstanceOf(EAttribute)
			
			else 
			varName :=self.source.asType(FeatureCallExpCS).simpleNameCS.~value
				stdio.writeln("+++++++++" + " Loking for " + self.simpleNameCS.~value + 
			" in " + v.getContextFeature(v.getLocalFeatureType(),self.source.asType(FeatureCallExpCS).simpleNameCS.~value).eType.name+ " -----> " + 
			self.source.asType(FeatureCallExpCS).canAccesTo(context, self.simpleNameCS.~value).toString) 
				self.source.asType(FeatureCallExpCS).simpleNameCS.~value
				self.isAtt:=v.getContextFeature(v.getLocalFeatureType(),self.source.asType(FeatureCallExpCS).simpleNameCS.~value).eType.asType(EClass).eAllStructuralFeatures.select{e| e.name == self.simpleNameCS.~value}.first.isInstanceOf(EAttribute)
			
			end
			
		
			var featureName : String init  self.simpleNameCS.~value
	   		//v.setLocalFeature(v.getContextFeature(v.getLocalFeatureType, featureName))
			self.source.mark := Set<MARKTYPE>.new
			//self.isAtt:=false
			if (self.simpleNameCS.type == SimpleTypeEnum.identifier) then 
			  if (self.source.isInstanceOf(VariableExpCS)) then
				if (self.source.asType(VariableExpCS).canAccesTo(context, self.simpleNameCS.~value)) then	
					if (self.isAtt)
					then
						self.source.mark.add(MARKTYPE.UPD)
						self.source.mark.add(MARKTYPE.INC)
					else
						self.source.mark.addAll(self.mark)
					end
				end
			  else
			  	if (self.source.asType(FeatureCallExpCS).canAccesTo(context, self.simpleNameCS.~value)) then	
			    end
			  end
			end
			self.source.marque(context)
		end
		// TODO : the test of te cardinality, example e.ceo.age
		operation canAccesTo(context :Hashtable<String,Object>, name : String) : Boolean is
		do
			var v : TypeSystemMixin 
			v?= context.getValue("typemixin")
			//v.getLocalVariable(self.simpleNameCS.~value)
			if (self.source.isInstanceOf(VariableExpCS)) 
			then result:= self.source.asType(VariableExpCS).canAccesTo(context, self.simpleNameCS.~value)
			else result:= self.source.asType(FeatureCallExpCS).canAccesTo(context, self.simpleNameCS.~value)
			end
			
			result:=result and v.contextDefinesFeature(name)
			//result:=(v.getLocalVariable(self.simpleNameCS.~value).eType.asType(EClass).eAllStructuralFeatures.select{e| e.name == name}.first.isInstanceOf(EAttribute))
			
		end
		
	}

	aspect class OperationCallExpCS 
	{
		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::FeatureCallExpCS is do
			self.source.mark := Set<MARKTYPE>.new
			self.arguments.each{e | e.mark := Set<MARKTYPE>.new}
			if ((self.simpleNameCS.~value == "and") or (self.simpleNameCS.~value == "or")) then 
				self.source.mark.add(MARKTYPE.UND)
				self.arguments.each{e | e.mark.add(MARKTYPE.UND)} else
			if ((self.simpleNameCS.~value == ">") or (self.simpleNameCS.~value == ">="))  then		
				self.source.mark.add(MARKTYPE.DEC)
				self.arguments.each{e | e.mark.add(MARKTYPE.INC)} else
			if ((self.simpleNameCS.~value == "<") or (self.simpleNameCS.~value == "<="))  then		
				self.source.mark.add(MARKTYPE.DEC)
				self.arguments.each{e | e.mark.add(MARKTYPE.INC)} else
			if ((self.simpleNameCS.~value == "=") or (self.simpleNameCS.~value == "<>")) then 
				self.source.mark.add(MARKTYPE.DEC)
				self.source.mark.add(MARKTYPE.INC)
				self.source.mark.add(MARKTYPE.UPD)
				self.arguments.each{e | e.mark.add(MARKTYPE.UPD)}
				self.arguments.each{e | e.mark.add(MARKTYPE.DEC)}
				self.arguments.each{e | e.mark.add(MARKTYPE.INC)} else
			if ((self.simpleNameCS.~value == "+") or (self.simpleNameCS.~value == "-")) then 
				if (self.mark.contains(MARKTYPE.UPD)) then
					self.source.mark.add(MARKTYPE.UPD)
					self.arguments.each{e | e.mark.add(MARKTYPE.UPD)}
				end
				self.source.mark.add(MARKTYPE.DEC)
				self.source.mark.add(MARKTYPE.INC)
				self.arguments.each{e | e.mark.add(MARKTYPE.DEC)}
				self.arguments.each{e | e.mark.add(MARKTYPE.INC)} else
			if (self.simpleNameCS.~value == "size") then 
				if (self.mark.contains(MARKTYPE.DEC)) then
					self.source.mark.add(MARKTYPE.DEC)
				end
				if (self.mark.contains(MARKTYPE.INC)) then
					self.source.mark.add(MARKTYPE.INC)
				end else
			if (self.simpleNameCS.~value == "sum") then 
				if (self.mark.contains(MARKTYPE.DEC)) then
					self.source.mark.add(MARKTYPE.DEC)
					self.source.mark.add(MARKTYPE.UPD)
				end
				if (self.mark.contains(MARKTYPE.INC)) then
					self.source.mark.add(MARKTYPE.INC)
					self.source.mark.add(MARKTYPE.UPD)
				end else
			self.source.mark.addAll(self.mark)
			end
			end
			end
			end
			end
			end
			end

			//TODO other operations and, or, implies, <>, =, count,...etc
			self.source.marque(context)
			self.arguments.each{e | e.marque(context)}

		end

	}
	aspect class IsMarkedPreCS 
	{


		method marque(context :Hashtable<String,Object>) : Void from ocl::cst::CSTNode is do
			 
			 end

	}
	aspect class StateExpCS 
	{


		method marque(context :Hashtable<String,Object>) : Void  is do
			 
			 end

	}
}
}

