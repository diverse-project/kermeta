package ocl;

require "platform:/plugin/fr.irisa.triskell.kermeta/lib/ecore.kmt"
package cst
{
	abstract class CSTNode
	{
		attribute startOffset : ecore::EInt

		attribute endOffset : ecore::EInt

	}
	class PackageDeclarationCS inherits CSTNode
	{
		attribute pathNameCS : PathNameCS

		attribute contextDecls : ContextDeclCS[0..*]

		reference packageDeclarationCS : PackageDeclarationCS

	}
	class PathNameCS inherits TypeCS
	{
		attribute sequenceOfNames : seq ecore::EString[0..*]

	}
	abstract class TypeCS inherits OCLExpressionCS
	{
	}
	abstract class OCLExpressionCS inherits CSTNode
	{
	}
	abstract class ContextDeclCS inherits CSTNode
	{
	}
	class PropertyContextCS inherits ContextDeclCS
	{
		attribute pathNameCS : PathNameCS

		attribute simpleNameCS : SimpleNameCS

		attribute typeCS : TypeCS

		attribute initOrDerValueCS : InitOrDerValueCS

	}
	class SimpleNameCS inherits OCLExpressionCS
	{
		attribute ~value : ecore::EString

		attribute type : SimpleTypeEnum

	}
	enumeration SimpleTypeEnum
	{
		identifier;
		~self;
		Integer;
		String;
		Real;
		Boolean;
		OclAny;
		OclVoid;
		Invalid;
		OclMessage;
		keyword;
		UnlimitedNatural;
	}
	abstract class InitOrDerValueCS inherits CSTNode
	{
		reference initOrDerValueCS : InitOrDerValueCS

		attribute expressionCS : OCLExpressionCS

	}
	class ClassifierContextDeclCS inherits ContextDeclCS
	{
		attribute pathNameCS : PathNameCS

		attribute invOrDefCS : InvOrDefCS

	}
	abstract class InvOrDefCS inherits CSTNode
	{
		attribute simpleNameCS : SimpleNameCS

		reference invOrDefCS : InvOrDefCS

	}
	class OperationContextDeclCS inherits ContextDeclCS
	{
		attribute operationCS : OperationCS

		attribute prePostOrBodyDecls : PrePostOrBodyDeclCS[1..*]

	}
	class OperationCS inherits CSTNode
	{
		attribute pathNameCS : PathNameCS

		attribute simpleNameCS : SimpleNameCS

		attribute parameters : VariableCS[0..*]

		attribute typeCS : TypeCS

	}
	class VariableCS inherits CSTNode
	{
		attribute name : ecore::EString

		attribute typeCS : TypeCS

		attribute initExpression : OCLExpressionCS

	}
	class PrePostOrBodyDeclCS inherits CSTNode
	{
		attribute kind : PrePostOrBodyEnum

		attribute simpleNameCS : SimpleNameCS

		attribute expressionCS : OCLExpressionCS

	}
	enumeration PrePostOrBodyEnum
	{
		~pre;
		~post;
		body;
	}
	class DerValueCS inherits InitOrDerValueCS
	{
	}
	class InitValueCS inherits InitOrDerValueCS
	{
	}
	class InvCS inherits InvOrDefCS
	{
		attribute expressionCS : OCLExpressionCS

	}
	class DefCS inherits InvOrDefCS
	{
		attribute defExpressionCS : DefExpressionCS

	}
	class DefExpressionCS inherits CSTNode
	{
		attribute operationCS : OperationCS

		attribute variableCS : VariableCS

		attribute expressionCS : OCLExpressionCS

	}
	class VariableExpCS inherits OCLExpressionCS
	{
		attribute arguments : OCLExpressionCS[0..*]

		attribute simpleNameCS : SimpleNameCS

		attribute isMarkedPreCS : IsMarkedPreCS

	}
	class IsMarkedPreCS inherits CSTNode
	{
		attribute ~pre : ecore::EBoolean

	}
	class PrimitiveTypeCS inherits SimpleNameCS, TypeCS
	{
	}
	class TupleTypeCS inherits TypeCS
	{
		attribute variables : VariableCS[1..*]

	}
	class CollectionTypeCS inherits TypeCS
	{
		attribute collectionTypeIdentifier : CollectionTypeIdentifierEnum

		attribute typeCS : TypeCS

	}
	enumeration CollectionTypeIdentifierEnum
	{
		Set;
		Bag;
		Sequence;
		Collection;
		OrderedSet;
	}
	class LetExpCS inherits OCLExpressionCS
	{
		attribute variables : VariableCS[1..*]

		attribute inExpression : OCLExpressionCS

	}
	class IfExpCS inherits OCLExpressionCS
	{
		attribute thenExpression : OCLExpressionCS[1..1]

		attribute elseExpression : OCLExpressionCS[1..1]

		attribute condition : OCLExpressionCS[1..1]

	}
	class MessageExpCS inherits OCLExpressionCS
	{
		attribute target : OCLExpressionCS

		attribute kind : MessageExpKind

		attribute simpleNameCS : SimpleNameCS

		attribute arguments : OCLMessageArgCS[0..*]

	}
	enumeration MessageExpKind
	{
		hasSent;
		sent;
	}
	class OCLMessageArgCS inherits CSTNode
	{
		attribute typeCS : TypeCS

		attribute expression : OCLExpressionCS

	}
	abstract class LiteralExpCS inherits OCLExpressionCS
	{
	}
	class EnumLiteralExpCS inherits LiteralExpCS
	{
		attribute pathNameCS : PathNameCS

		attribute simpleNameCS : SimpleNameCS

	}
	class CollectionLiteralExpCS inherits LiteralExpCS
	{
		attribute collectionType : CollectionTypeIdentifierEnum

		attribute collectionLiteralParts : CollectionLiteralPartCS[0..*]

	}
	class CollectionLiteralPartCS inherits CSTNode
	{
		attribute expressionCS : OCLExpressionCS

	}
	class TupleLiteralExpCS inherits LiteralExpCS
	{
		attribute variables : VariableCS[0..*]

	}
	class PrimitiveLiteralExpCS inherits LiteralExpCS
	{
		attribute symbol : ecore::EString

	}
	class IntegerLiteralExpCS inherits PrimitiveLiteralExpCS
	{
		attribute integerSymbol : ecore::EIntegerObject

	}
	class UnlimitedNaturalLiteralExpCS inherits PrimitiveLiteralExpCS
	{
		attribute integerSymbol : ecore::EIntegerObject

	}
	class RealLiteralExpCS inherits PrimitiveLiteralExpCS
	{
		attribute realSymbol : ecore::EDoubleObject

	}
	class StringLiteralExpCS inherits PrimitiveLiteralExpCS
	{
		attribute stringSymbol : ecore::EString

	}
	class BooleanLiteralExpCS inherits PrimitiveLiteralExpCS
	{
		attribute booleanSymbol : ecore::EBooleanObject

	}
	class NullLiteralExpCS inherits LiteralExpCS
	{
		attribute symbol : ecore::EString

	}
	class InvalidLiteralExpCS inherits LiteralExpCS
	{
		attribute symbol : ecore::EString

	}
	class CollectionRangeCS inherits CollectionLiteralPartCS
	{
		attribute lastExpressionCS : OCLExpressionCS

	}
	class CallExpCS inherits OCLExpressionCS
	{
		attribute source : OCLExpressionCS

		attribute accessor : DotOrArrowEnum

		attribute simpleNameCS : SimpleNameCS

	}
	enumeration DotOrArrowEnum
	{
		none;
		dot;
		arrow;
	}
	class LoopExpCS inherits CallExpCS
	{
		attribute variable1 : VariableCS

		attribute variable2 : VariableCS

		attribute body : OCLExpressionCS

	}
	class IteratorExpCS inherits LoopExpCS
	{
	}
	class IterateExpCS inherits LoopExpCS
	{
	}
	class FeatureCallExpCS inherits CallExpCS
	{
		attribute arguments : OCLExpressionCS[0..*]

		attribute isMarkedPreCS : IsMarkedPreCS

	}
	class OperationCallExpCS inherits FeatureCallExpCS
	{
	}
	class StateExpCS inherits TypeCS
	{
		attribute sequenceOfNames : ecore::EString[0..*]

	}
}

