package ocl;

require "platform:/plugin/fr.irisa.triskell.kermeta/lib/ecore.kmt"
package cst
{
	abstract class CSTNode
	{
attribute startOffset : ecore::EInt

		attribute endOffset : ecore::EInt

	}
	class PackageDeclarationCS inherits CSTNode
	{
reference pathNameCS : PathNameCS

		reference contextDecls : ContextDeclCS[0..*]

	}
	abstract class ContextDeclCS inherits CSTNode
	{
	}
	class PropertyContextCS inherits ContextDeclCS
	{
reference pathNameCS : PathNameCS

		reference simpleNameCS : SimpleNameCS

		reference typeCS : TypeCS

		reference initOrDerValueCS : InitOrDerValueCS

	}
	class ClassifierContextDeclCS inherits ContextDeclCS
	{
reference pathNameCS : PathNameCS

		reference invOrDefCS : InvOrDefCS

	}
	class OperationContextDeclCS inherits ContextDeclCS
	{
reference operationCS : OperationCS

		reference prePostOrBodyDecls : PrePostOrBodyDeclCS[1..*]

	}
	class PrePostOrBodyDeclCS inherits CSTNode
	{
attribute kind : PrePostOrBodyEnum

		reference simpleNameCS : SimpleNameCS

		reference expressionCS : OCLExpressionCS

	}
	enumeration PrePostOrBodyEnum
	{
~pre;
		~post;
		body;
	}
	class OperationCS inherits CSTNode
	{
reference pathNameCS : PathNameCS

		reference simpleNameCS : SimpleNameCS

		reference parameters : VariableCS[0..*]

		reference typeCS : TypeCS

	}
	abstract class InitOrDerValueCS inherits CSTNode
	{
reference initOrDerValueCS : InitOrDerValueCS

		reference expressionCS : OCLExpressionCS

	}
	class DerValueCS inherits InitOrDerValueCS
	{
	}
	class InitValueCS inherits InitOrDerValueCS
	{
	}
	abstract class InvOrDefCS inherits CSTNode
	{
reference simpleNameCS : SimpleNameCS

		reference invOrDefCS : InvOrDefCS

	}
	class InvCS inherits InvOrDefCS
	{
reference expressionCS : OCLExpressionCS

	}
	class DefCS inherits InvOrDefCS
	{
reference defExpressionCS : DefExpressionCS

	}
	class DefExpressionCS inherits CSTNode
	{
reference operationCS : OperationCS

		reference variableCS : VariableCS

		reference expressionCS : OCLExpressionCS

	}
	class PathNameCS inherits TypeCS
	{
attribute sequenceOfNames : ecore::EString[0..*]

	}
	class VariableExpCS inherits OCLExpressionCS
	{
reference arguments : OCLExpressionCS[0..*]

		reference simpleNameCS : SimpleNameCS

		reference isMarkedPreCS : IsMarkedPreCS

	}
	class SimpleNameCS inherits OCLExpressionCS
	{
attribute ~value : ecore::EString

		attribute type : SimpleTypeEnum

	}
	enumeration SimpleTypeEnum
	{
identifier;
		~self;
		Integer;
		String;
		Real;
		Boolean;
		OclAny;
		OclVoid;
		Invalid;
		OclMessage;
		keyword;
	}
	abstract class TypeCS inherits OCLExpressionCS
	{
	}
	class PrimitiveTypeCS inherits SimpleNameCS, TypeCS
	{
	}
	class TupleTypeCS inherits TypeCS
	{
reference variables : VariableCS[1..*]

	}
	class CollectionTypeCS inherits TypeCS
	{
attribute collectionTypeIdentifier : CollectionTypeIdentifierEnum

		reference typeCS : TypeCS

	}
	enumeration CollectionTypeIdentifierEnum
	{
Set;
		Bag;
		Sequence;
		Collection;
		OrderedSet;
	}
	abstract class OCLExpressionCS inherits CSTNode
	{
	}
	class LetExpCS inherits OCLExpressionCS
	{
reference variables : VariableCS[1..*]

		reference inExpression : OCLExpressionCS

	}
	class IfExpCS inherits OCLExpressionCS
	{
attribute thenExpression : OCLExpressionCS[1..1]

		attribute elseExpression : OCLExpressionCS[1..1]

		attribute condition : OCLExpressionCS[1..1]

	}
	class MessageExpCS inherits OCLExpressionCS
	{
attribute target : OCLExpressionCS

		attribute kind : MessageExpKind

		reference simpleNameCS : SimpleNameCS

		attribute arguments : OCLMessageArgCS[0..*]

	}
	class OCLMessageArgCS inherits CSTNode
	{
reference typeCS : TypeCS

		reference expression : OCLExpressionCS

	}
	class VariableCS inherits CSTNode
	{
attribute name : ecore::EString

		reference typeCS : TypeCS

		reference initExpression : OCLExpressionCS

	}
	abstract class LiteralExpCS inherits OCLExpressionCS
	{
	}
	class EnumLiteralExpCS inherits LiteralExpCS
	{
reference pathNameCS : PathNameCS

		reference simpleNameCS : SimpleNameCS

	}
	class CollectionLiteralExpCS inherits LiteralExpCS
	{
attribute collectionType : CollectionTypeIdentifierEnum

		reference collectionLiteralParts : CollectionLiteralPartCS[0..*]

	}
	class TupleLiteralExpCS inherits LiteralExpCS
	{
reference variables : VariableCS[0..*]

	}
	class PrimitiveLiteralExpCS inherits LiteralExpCS
	{
attribute symbol : ecore::EString

	}
	class IntegerLiteralExpCS inherits PrimitiveLiteralExpCS
	{
attribute integerSymbol : ecore::EIntegerObject

	}
	class RealLiteralExpCS inherits PrimitiveLiteralExpCS
	{
attribute realSymbol : ecore::EDoubleObject

	}
	class StringLiteralExpCS inherits PrimitiveLiteralExpCS
	{
attribute stringSymbol : ecore::EString

	}
	class BooleanLiteralExpCS inherits PrimitiveLiteralExpCS
	{
attribute booleanSymbol : ecore::EBooleanObject

	}
	class NullLiteralExpCS inherits LiteralExpCS
	{
attribute symbol : ecore::EString

	}
	class InvalidLiteralExpCS inherits LiteralExpCS
	{
attribute symbol : ecore::EString

	}
	class CollectionLiteralPartCS inherits CSTNode
	{
reference expressionCS : OCLExpressionCS

	}
	class CollectionRangeCS inherits CollectionLiteralPartCS
	{
reference lastExpressionCS : OCLExpressionCS

	}
	class CallExpCS inherits OCLExpressionCS
	{
reference source : OCLExpressionCS

		attribute accessor : DotOrArrowEnum

		reference simpleNameCS : SimpleNameCS

	}
	class LoopExpCS inherits CallExpCS
	{
reference variable1 : VariableCS

		reference variable2 : VariableCS

		reference body : OCLExpressionCS

	}
	class IteratorExpCS inherits LoopExpCS
	{
	}
	class IterateExpCS inherits LoopExpCS
	{
	}
	class FeatureCallExpCS inherits CallExpCS
	{
reference arguments : OCLExpressionCS[0..*]

		reference isMarkedPreCS : IsMarkedPreCS

	}
	enumeration DotOrArrowEnum
	{
none;
		dot;
		arrow;
	}
	class OperationCallExpCS inherits FeatureCallExpCS
	{
	}
	class IsMarkedPreCS inherits CSTNode
	{
attribute ~pre : ecore::EBoolean

	}
	class StateExpCS inherits TypeCS
	{
attribute sequenceOfNames : ecore::EString[0..*]

	}
	enumeration MessageExpKind
	{
hasSent;
		sent;
	}
	package visitor
	{
class Visitor
		{
		}
	}

}

