/* $Id:$
 * Creation : 2010-01-15
 * Licence  : EPL 
 * Copyright: IRISA/INRIA
 * Authors  : 
 *            
 */
package kermeta::language::structure;

require kermeta
// require "http://www.kermeta.org/kermeta/1_2_0//kermeta"
// require "platform:/plugin/fr.irisa.triskell.kermeta.model/build/ecore/kermeta_java.ecore"
require "platform:/lookup/org.kermeta.language.scalacompiler.model/src/kmt/scalacompiler/ScalaCompilerContext.kmt"
require "platform:/resource/org.kermeta.language.scalacompiler.model/src/kmt/scalacompiler/kermeta/language/structure/GenericTypeDefinition.kmt"
require "platform:/resource/org.kermeta.language.scalacompiler.model/src/kmt/scalacompiler/kermeta/language/structure/TypeContainer.kmt"


using kermeta::standard
using kermeta::utils
using scalacompiler

aspect class ClassDefinition inherits GenericTypeDefinition, TypeContainer{
   /**
    * Generate Scala code
    */
   method generateScala(context : ScalaCompilerContext, buffer : kermeta::utils::StringBuffer) 
     from kermeta::language::structure::GenericTypeDefinition
     is do
      self.context := context
	   	
   end
    
      
     reference context : ScalaCompilerContext
     
   	operation pass1(context : ScalaCompilerContext, res : kermeta::utils::StringBuffer,ctxtp1 : ScalaCompilerContextPass1): Void is do
	   	self.context := context
	   	var par: ClassDefinition init self
	//	if(actualPackage == "org.eclipse.emf.ecore"  ) { //TODO REMOVE DEBUG MODE
			 
			var genpackageName : StringBuffer init StringBuffer.new
			var packageName : StringBuffer init  StringBuffer.new
			
			
			genpackageName.append(context.getPackageEquivalence(par.container.asType(Package).qualifiedName))
			packageName.append(genpackageName.toString)
			if (context.hasEcoreTag(par.container.asType(Package))) then
				packageName.append("ScalaAspect")
			end
			genpackageName.append(".")
			
			if (par.isAbstract) then
				ctxtp1.viewDef.append( " abstract")
			end
				
			
			var param : StringBuffer init StringBuffer.new
			par.generateParamerterClass(param)
			if (context.hasEcoreTag(par)) then				
				var  implName:String init context.getImplPackageSuffix(packageName.toString)
				ctxtp1.viewDef.append(" class Rich"+par.name+" extends "+ context.getTypeEquivalence(genpackageName.toString+implName.substring(1,implName.size) + par.name+"Impl")+" with "+packageName.toString +"."+par.name+"Aspect \n")
				ctxtp1.implicitDef.append(" implicit def richAspect(v : "+ context.getTypeEquivalence(genpackageName.toString+par.name)+") = v.asInstanceOf["+ packageName.toString+"."+ par.name+"Aspect]\n" )
				ctxtp1.implicitDef.append(" implicit def richAspect(v : "+ packageName.toString+"."+par.name+"Aspect) = v.asInstanceOf["+ par.container.asType(Object).getQualifiedNameCompilo+ context.getImplPackageSuffix(packageName.toString) + par.name+"Impl]\n")
			else
				ctxtp1.viewDef.append(" class Rich"+par.name+ param.toString +" extends org.eclipse.emf.ecore.impl.EObjectImpl with "+ context.getTypeEquivalence(packageName.toString +"."+ par.name)+ param.toString +" with "+packageName.toString +"."+par.name+"Aspect" + param.toString +" \n")
				ctxtp1.implicitDef.append(" implicit def richAspect" + param.toString + "(v : "+ context.getTypeEquivalence(packageName.toString+"."+par.name)+ param.toString +") = v.asInstanceOf["+ packageName.toString+"."+par.name+"Aspect"+ param.toString +"]\n") 
				ctxtp1.implicitDef.append(" implicit def richAspect" + param.toString +"(v : "+ packageName.toString+"."+par.name+"Aspect" + param.toString +") = v.asInstanceOf["+ packageName.toString+"."+par.name+ param.toString +"]\n")
			end
			 
			if (not par.isAbstract) then
				if (context.hasEcoreTag(par)) then
					ctxtp1.factoryDefClass.append(" override")
					ctxtp1.factoryDefClass.append(" def create"+par.name+ param.toString +" : "+ context.getTypeEquivalence(genpackageName.toString+par.name)+param.toString+" = { new "+ packageName.toString+".Rich"+par.name + param.toString +" }\n")
				
				else
					ctxtp1.factoryDefClass.append(" def create"+par.name+ param.toString +" : "+ context.getTypeEquivalence(packageName.toString+"."+par.name)+param.toString+" = { new "+ packageName.toString+".Rich"+par.name+ param.toString +" }\n")
				end
			end
	//}
	end
	
	method getQualifiedNameCompilo():String  is do
		result :=context.getTypeEquivalence(self.container.asType(Object).getQualifiedNameCompilo() + "."+ self.name)
	end
	
	operation generateParamerterClass(res1:StringBuffer) :Void is do
		if (self.typeParameter.size()>0) then
					var i :Integer init 0
					res1.append("[")
					self.typeParameter().each{param |
						if (i>0) then
							res1.append(",")
						end
						res1.append(param.getQualifiedNameCompilo())
						i:=i+1
					}
					res1.append("]")
				end
	end
   
   
}