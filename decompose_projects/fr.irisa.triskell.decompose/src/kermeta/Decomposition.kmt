/* $Id: Decomposition.kmt,v 1.10 2008-08-20 11:06:01 fmunoz Exp $ 
 * Creation : August 11, 2008
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            freddy
 */


package decomposition;

//require "platform:/resource/fr.irisa.triskell.decompose/src/kermeta/Mergeable.kmt"
require "http://www.kermeta.org/decomposer"
require "http://www.eclipse.org/emf/2002/Ecore"


using kermeta::language::structure
using kermeta::language
using kermeta::standard
using kermeta::utils 
using kermeta::persistence
using kompose
using decomposition

@aspect "true"
class Decomposer {

	
	attribute objectIndex:String[0..*]
	
	
	reference resource:kermeta::persistence::EMFResource 
	attribute numeral:Integer
	
	attribute decompositionPlans:DecompositionPlan[0..*]
	reference currentPlan:DecompositionPlan
	
	attribute procLKeys:String[0..*]
	attribute procRKeys:String[0..*]
	
	operation initialize(initial:Mergeable) is do
		self.original:=initial
		self.numeral:=0
	end
	
	operation start():Void is do
		self.indexate(self.original)
		self.createPlans()
		self.decompositionPlans.each{plan|
			self.currentPlan:=plan
			self.decompose(void,original,void,true)
		}
	end
	
	
	operation createPlans():Void is do
		var plan:DecompositionPlan plan:=DecompositionPlan.new
		plan.initialize()
		self.decompositionPlans.add(plan)
		initializePlans(plan,self.original,void,OperationType.CLONE,void)
		plan.keys.remove(self.original.toString)
		recurseCombinatorics(plan)
	end
	
	
	operation clonePlan(plan:DecompositionPlan): DecompositionPlan is do
		var newPlan:DecompositionPlan newPlan:=DecompositionPlan.new
		newPlan.initialize()
		plan.atomicPlans.values.each{aplan|
			var atomNew:AtomicPlanPart atomNew:=AtomicPlanPart.new
			atomNew.element:=aplan.element
			atomNew.operationType:=aplan.operationType
			atomNew.side:=aplan.side
			atomNew.inElement:=aplan.inElement
			aplan.dependantOn.each{dep|
				atomNew.dependantOn.add(dep)
			}
			newPlan.atomicPlans.put(atomNew.element,atomNew)
		}
		plan.keys.each{k|
			newPlan.keys.add(k)
		}
		result:=newPlan
	end
	
	operation recurseCombinatorics(plan:DecompositionPlan):Void is do
		plan.keys.each{key|
			if not self.procRKeys.contains(key) then
				self.procRKeys.add(key)
				var newPlanR:DecompositionPlan newPlanR:=self.clonePlan(plan)
				newPlanR.keys.remove(key)
				var atomNewR:AtomicPlanPart atomNewR:=newPlanR.atomicPlans.getValue(key)
				atomNewR.operationType:=OperationType.ONESIDE
				atomNewR.side:=true
				newPlanR.atomicPlans.put(key,atomNewR)
				recurseCombinatorics(newPlanR)
				if newPlanR.atomicPlans.getValue(atomNewR.inElement).side==true then
					if atomNewR.dependantOn.size > 0 then
						var onside:Boolean init true
						atomNewR.dependantOn.each{dep|
							stdio.writeln(dep)
							if  newPlanR.atomicPlans.keys.contains(dep) then
								if newPlanR.atomicPlans.getValue(dep).side==false then
									onside:=false
								end
							end
						}
						if onside then
							self.decompositionPlans.add(newPlanR)
						end
					else
						self.decompositionPlans.add(newPlanR)
					end
				end
			end
			if not self.procLKeys.contains(key) then
				self.procLKeys.add(key)
				var newPlanL:DecompositionPlan newPlanL:=self.clonePlan(plan)
				newPlanL.keys.remove(key)
				var atomNewL:AtomicPlanPart atomNewL:=newPlanL.atomicPlans.getValue(key)
				atomNewL.operationType:=OperationType.ONESIDE
				atomNewL.side:=false
				newPlanL.atomicPlans.put(key,atomNewL)
				recurseCombinatorics(newPlanL)
				self.decompositionPlans.add(newPlanL)	
				if newPlanL.atomicPlans.getValue(atomNewL.inElement).side==false then
					if atomNewL.dependantOn.size > 0 then
						var onside:Boolean init false
						atomNewL.dependantOn.each{dep|
							stdio.writeln(dep)
							if  newPlanL.atomicPlans.keys.contains(dep) then
								if newPlanL.atomicPlans.getValue(dep).side==true then
									onside:=false
								end
							end
						}
						if onside then
							self.decompositionPlans.add(newPlanL)
						end
					else
						self.decompositionPlans.add(newPlanL)
					end
				end
			end
		}
	
	end
	
	operation initializePlans(plan:DecompositionPlan,element:Mergeable,superElement:Mergeable,currentOp:OperationType,direction:Boolean):Void is do
		/*if element.getMetaClass().toString == "EClass" then
			var cl:ecore::EClass cl?=element
			stdio.writeln("classname: "+cl.name+"->"+element.toString)
		end*/
		var atomic:AtomicPlanPart atomic:=AtomicPlanPart.new
		atomic.element:=element.toString
		atomic.operationType:=OperationType.CLONE
		atomic.inElement:=superElement.toString
		plan.atomicPlans.put(element.toString,atomic)
		plan.keys.add(element.toString)
		var ppts : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
		var properties:Collection<Property> properties:=ppts.select{ p | Mergeable.isSuperTypeOf(p.type) }
		if properties.size >0 then				
			properties.each{ p |
				if p.upper != 1 then
					var objects : Collection<Object> objects?=element.~get(p)
					objects.each{obj|
						var mergeable:Mergeable mergeable?=obj
						if mergeable!=void and self.objectIndex.contains(mergeable.toString) then
							if not self.dependants.contains(element.getMetaClass().toString) then	
								if not plan.atomicPlans.containsKey(mergeable.toString) then					
									var container:Mergeable container?=mergeable.container
									self.initializePlans(plan,mergeable,container,OperationType.CLONE,void)				
								end
							else
								if plan.keys.contains(mergeable.toString) then
									atomic.dependantOn.add(mergeable.toString)
								else
									atomic.dependantOn.add(mergeable.toString)
									var container:Mergeable container?=mergeable.container					
									self.initializePlans(plan,mergeable,container,OperationType.CLONE,void)
								end
							end
						end
					}
				else
					var mergeable:Mergeable mergeable?=element.~get(p)
					if mergeable!=void and self.objectIndex.contains(mergeable.toString) then
						if not self.dependants.contains(element.getMetaClass().toString) then	
							if not plan.atomicPlans.containsKey(mergeable.toString) then
								var container:Mergeable container?=mergeable.container
								self.initializePlans(plan,mergeable,container,OperationType.CLONE,void)				
							end
						else
							if plan.keys.contains(mergeable.toString) then
								atomic.dependantOn.add(mergeable.toString)
							else
								atomic.dependantOn.add(mergeable.toString)
								var container:Mergeable container?=mergeable.container
								self.initializePlans(plan,mergeable,container,OperationType.CLONE,void)
							end
						end
					end
				end
			}
		end
	end
	
	operation setResource(resource:kermeta::persistence::EMFResource ): Void is do
		self.resource:=resource
	end
	
	operation resouceContains(element:Object):Boolean is do
		result:=false
		if element.containingResource()==self.resource then
			result:=true
		end
	end
	
	operation indexate(element:Object):Void is do
		if self.resouceContains(element) then
			if not self.objectIndex.contains(element.toString) then
				self.objectIndex.add(element.toString)
				var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
				properties.each{ p|
					if p.upper != 1 then
						var objects : Collection<Object> objects?=element.~get(p)
						objects.each{obj|self.indexate(obj)}
					else
						self.indexate(element.~get(p))
					end
				}
			end
		end
	
	end
	
	operation getPropertyByContainement(container:Mergeable,contained:Mergeable):Property is do
		var properties : Collection<Property> init container.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
		result:=void
		properties.each{p|
			if p.upper == 1 then
				if contained == container.~get(p) then
					result:=p
				end
			else
				var objects : Collection<Object> objects?=container.~get(p)
				objects.each{obj|
					if obj == contained then
						result:=p
					end
				}
			end
		}
	end
	
	operation decompose(parent:Mergeable[0..*],element:Mergeable,iproperty:Property[0..*],direction:Boolean):Void is do	
		
		self.currentPlan.print()
		
		stdio.writeln("processing element: "+element.toString)
		/*if element.getMetaClass().toString == "EClass" then
				var cl:ecore::EClass cl?=element
				stdio.writeln("cloning classname: "+cl.name+"->"+element.toString)
			end
			*/		
		if self.currentPlan.atomicPlans.getValue(element.toString).operationType==OperationType.ONESIDE then
			self.side(parent,element,iproperty,self.currentPlan.atomicPlans.getValue(element.toString).side)
		else
			self.clone(parent,element,iproperty)
		end
	end
	
	operation clone(parent:Mergeable[0..*],element:Mergeable,iproperty:Property[0..*]):Void is do
		if not self.currentPlan.processed.contains(element)  then
			var isDependable: Boolean init false
			/*if element.getMetaClass().toString == "EClass" then
				var cl:ecore::EClass cl?=element
				parent.each{p|
					stdio.writeln("cloning classname: "+cl.name+"->"+element.toString+" in: "+p.toString)
				}
			end*/
			if self.dependants.contains(element.getMetaClass.classDefinition.name) then
				stdio.writeln("dependable: "+element.getMetaClass.classDefinition.toString)
				isDependable:=true
			end
			
			var left:Mergeable left?=element.getMetaClass().new
			var right:Mergeable right?=element.getMetaClass().new
			
			var doAll:Boolean init true
			var direction:Boolean init false
			var sdirection:Boolean init false
			
			var trtmp:TriContainer init TriContainer.new
			
			trtmp.element:=element.toString
			trtmp.left:=left.toString
			trtmp.right:=right.toString
			trtmp.appliedOperation:=OperationType.CLONE
			
			self.currentPlan.newMapper.put(left.toString,left)
			self.currentPlan.newMapper.put(right.toString,right)
			self.currentPlan.mapper.put(element.toString,trtmp)
			self.currentPlan.processed.add(element)
		
			var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
			if isDependable then
				properties.each{ p |
					if Mergeable.isSuperTypeOf(p.type) then
						if p.upper == 1 then
							var mergeable:Mergeable mergeable?=element.~get(p)
							if self.objectIndex.contains(mergeable.toString) then
								if self.currentPlan.processed.contains(mergeable) then
									if self.currentPlan.mapper.getValue(mergeable.toString).appliedOperation==OperationType.ONESIDE then
										stdio.writeln("element: "+element.toString+" must be sided because of: "+mergeable.toString)
										self.currentPlan.newMapper.remove(left.toString)
										self.currentPlan.newMapper.remove(right.toString)
										self.currentPlan.mapper.remove(element.toString)
										self.currentPlan.processed.remove(element)
										sdirection:=self.currentPlan.mapper.getValue(mergeable.toString).side
										doAll:=false
									end
								end
							end
						else //p.upper > 1
							var objects : Collection<Object> objects?=element.~get(p)
							objects.each{obj|
								var mergeable:Mergeable mergeable?=obj
								if self.objectIndex.contains(mergeable.toString) then
									if self.currentPlan.processed.contains(mergeable) then
										if self.currentPlan.mapper.getValue(mergeable.toString).appliedOperation==OperationType.ONESIDE then
											stdio.writeln("element: "+element.toString+" must be sided because of: "+mergeable.toString)
											self.currentPlan.newMapper.remove(left.toString)
											self.currentPlan.newMapper.remove(right.toString)
											self.currentPlan.mapper.remove(element.toString)
											self.currentPlan.processed.remove(element)
											sdirection:=self.currentPlan.mapper.getValue(mergeable.toString).side
											doAll:=false
										end
									end
								end
							}
						end
					end
				}
			end
			if doAll then
				properties.each{ p |
					if not Mergeable.isSuperTypeOf(p.type) then
						if p.upper != 1 then
							var objects : Collection<Object> objects?=element.~get(p)
							var objectsL : Collection<Object> objects?=left.~get(p)
							var objectsR : Collection<Object> objects?=right.~get(p)
							objects.each{obj|
								if obj != void then
									objectsL.add(obj)
									objectsR.add(obj)
								end
							}
						else
							if element.~get(p)!= void then
								left.~set(p,element.~get(p))
								right.~set(p,element.~get(p))
							end
						end
					else
						if p.upper != 1 then
							var objects : Collection<Object> objects?=element.~get(p)
								objects.select{obj|obj!=void}.each{obj|
									var mergeable:Mergeable mergeable?=obj			
									var ctnr:Mergeable[0..*]
									var ctnr2:Mergeable ctnr2?=mergeable.container()
									var prpts:Property[0..*]
									ctnr:=OrderedSet<Mergeable>.new
									prpts:=OrderedSet<Property>.new
									if element!= ctnr2 then
										//bug::: what happens if ctnr2 is not processed yet?
										ctnr.add(element)
										ctnr.add(ctnr2)
										prpts.add(p)
										var prpt:Property prpt:=self.getPropertyByContainement(ctnr2,mergeable)
										prpts.add(prpt)
									else
										ctnr.add(element)
										prpts.add(p)
									end
									if not self.currentPlan.processed.contains(mergeable) then
										self.decompose(ctnr,mergeable,prpts,void)
									else
										var objectsL : Collection<Object> objectsL?=left.~get(p)
										var objectsR : Collection<Object> objectsR?=right.~get(p)
										if not objectsL.contains(self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).left))) then
											objectsL.add(self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).left)))
											objectsR.add(self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).right)))
										end
									end
								}
						else //p.upper == 1
							var mergeable:Mergeable mergeable?=element.~get(p)
							if mergeable != void then
									if self.objectIndex.contains(mergeable.toString) then
										var ctnr:Mergeable[0..*]
										var ctnr2:Mergeable ctnr2?=mergeable.container()
										var prpts:Property[0..*]
										ctnr:=OrderedSet<Mergeable>.new
										prpts:=OrderedSet<Property>.new
										if element!= ctnr2 then
											ctnr.add(element)
											ctnr.add(ctnr2)
											prpts.add(p)

											prpts.add(self.getPropertyByContainement(ctnr2,mergeable))
											
										else
											ctnr.add(element)
											prpts.add(p)
										end
										if not self.currentPlan.processed.contains(mergeable) then
											self.decompose(ctnr,mergeable,prpts,void)
										else
											left.~set(p,self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).left)))
											right.~set(p,self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).right)))
										end
										
									else
										if element.~get(p) !=void then
											left.~set(p,element.~get(p))
											right.~set(p,element.~get(p))
										end
									end
							end
						end
					end 
				}
				if parent==void then
					self.checkNonVoid(left,"clone left")
					self.checkNonVoid(right,"clone right")
					self.left.add(left)
					self.right.add(right)
				else
					iproperty.select{p|p!=void}.each{p|
						if p.upper == 1 then
							stdio.writeln("clone setting singleL : "+left.toString+" in "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.toString).left).toString+"for "+parent.one.toString+" original "+element.toString+ "on p: "+p.name)
							stdio.writeln("clone setting singleR : "+right.toString+" in "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.toString).right).toString+"for "+parent.one.toString+" original "+element.toString+ "on p: "+p.name)
							
							self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.toString).left).~set(p,left)
							self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.toString).right).~set(p,right)
						else
							stdio.writeln("clone setting multiple L : "+left.toString+" in "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.toString).left).toString+"for "+parent.one.toString+" original "+element.toString+ "on p: "+p.name)
							stdio.writeln("clone setting multiple R : "+right.toString+" in "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.toString).right).toString+"for "+parent.one.toString+" original "+element.toString+ "on p: "+p.name)
							var objectsL : Collection<Object> objectsL?=self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.toString).left).~get(p)
							var objectsR : Collection<Object> objectsR?=self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.toString).right).~get(p)
							objectsL.add(left)
							objectsR.add(right)
						end
						parent.remove(parent.one)
					}
				end
			else
				stdio.writeln(doAll.toString+ " siding element: "+element.toString)
				self.side(parent,element,iproperty,sdirection)
			end
		end
	end
	
	operation checkNonVoid(element:Object,op:String):Void is do
		var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
		properties.each{p|
			if p.upper!= 1 then
				var objects : Collection<Object>
				objects?=element.~get(p)
				var pos:Integer init 0
				objects.each{o|
					if o==void then
						stdio.errorln("problem in property "+p.name+" from "+op+" element "+element.toString)
						objects.remove(void)
					end
					pos:=pos+1
				}
			end
		}
		
	end

	//direction true=right left=false
	operation side(parent:Mergeable[0..*],element:Mergeable,iproperty:Property[0..*],direction:Boolean):Void is do
		if not self.currentPlan.processed.contains(element)  then
			stdio.writeln("siding element: "+element.toString)
			var newElement:Mergeable newElement?=element.getMetaClass().new
			/*if element.getMetaClass().toString == "EClass" then
				var cl:ecore::EClass cl?=element
				parent.each{p|
					stdio.writeln("siding classname: "+cl.name+"->"+element.toString+" in: "+p.toString+" nL: "+newElement.toString)
				}
			end*/
//			stdio.writeln("siding element: "+element.toString+" into "+newElement.toString)
			
			var trtmp:TriContainer init TriContainer.new
			
			trtmp.element:=element.toString
			if direction then
				trtmp.right:=newElement.toString
			else
				trtmp.left:=newElement.toString
			end
			trtmp.side:=direction
			trtmp.appliedOperation:=OperationType.ONESIDE
			self.currentPlan.newMapper.put(newElement.toString,newElement)
			self.currentPlan.mapper.put(element.toString,trtmp)
			self.currentPlan.processed.add(element)
			
			
			var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
			properties.each{ p |
				if not Mergeable.isSuperTypeOf(p.type) then
						if p.upper != 1 then
							var objects : Collection<Object> objects?=element.~get(p)
							var objectsN : Collection<Object> objectsN?=newElement.~get(p)
							objects.each{obj|
								if obj!=void then 
									objectsN.add(obj)
								end
							}
						else
							if element.~get(p)!=void then
								newElement.~set(p,element.~get(p))
							end
						end
				else
					if p.upper != 1 then
						var objects : Collection<Object> objects?=element.~get(p)
						objects.select{obj|obj!=void}.each{obj|
							var mergeable:Mergeable mergeable?=obj			
							var ctnr:Mergeable[0..*]
							var ctnr2:Mergeable ctnr2?=mergeable.container()
							var prpts:Property[0..*]
							ctnr:=OrderedSet<Mergeable>.new
							prpts:=OrderedSet<Property>.new
							if element!= ctnr2 then
								ctnr.add(element)
								ctnr.add(ctnr2)
								prpts.add(p)
								var prpt:Property prpt:=self.getPropertyByContainement(ctnr2,mergeable)
								prpts.add(prpt)
							else
								ctnr.add(element)
								prpts.add(p)
							end
							if not self.currentPlan.processed.contains(mergeable) then
								self.decompose(ctnr,mergeable,prpts,direction)
							else
								var objectsN : Collection<Object> objectsN?=newElement.~get(p)
								var mr:Mergeable 
								if direction then
									mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).right))
								else
									mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).left))
								end
								if not objectsN.contains(mr) then
									if mr!=void then
										objectsN.add(mr)
									end
								end
							end
						}
					else
						var mergeable:Mergeable mergeable?=element.~get(p)
						if mergeable != void then
							if self.objectIndex.contains(mergeable.toString) then
								var ctnr:Mergeable[0..*]
								var ctnr2:Mergeable ctnr2?=mergeable.container()
								var prpts:Property[0..*]
								ctnr:=OrderedSet<Mergeable>.new
								prpts:=OrderedSet<Property>.new
								if element!= ctnr2 then
									ctnr.add(element)
									ctnr.add(ctnr2)
									prpts.add(p)
									prpts.add(self.getPropertyByContainement(ctnr2,mergeable))		
								else
									ctnr.add(element)
									prpts.add(p)
								end
								if not self.currentPlan.processed.contains(mergeable) then
									self.decompose(ctnr,mergeable,prpts,direction)
								else
									var mr:Mergeable 
									if direction then
										mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).right))
									else
										mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.toString).left))
									end
									if mr!=void then
										newElement.~set(p,mr)
									end
								end	
							else
								if element.~get(p)!= void then
									newElement.~set(p,element.~get(p))
								end
							end
						end
					end	
				end
			}	
			if parent==void then
				self.checkNonVoid(newElement,"side")
				if direction then
					self.right.add(newElement)
				else
					self.left.add(newElement)
				end
			else
				iproperty.select{p|p!=void}.each{p|
					var mr:Mergeable 
					if direction then
						mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(parent.one.toString).right))
					else
						mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(parent.one.toString).left))
					end
					if p.upper == 1 then
						stdio.writeln("side setting single : "+newElement.toString+" in "+mr.toString+"for "+parent.one.toString+" original "+element.toString+ "on p: "+p.name)
						mr.~set(p,newElement)
					else
						stdio.writeln("side setting multiple : "+newElement.toString+" in "+mr.toString+"for "+parent.one.toString+" original "+element.toString+ "on p: "+p.name)
						var objectsN : Collection<Object> objectsN?=mr.~get(p)
						objectsN.add(newElement)
					end
					parent.remove(parent.one)
				}
			end
		end
	end
	
	operation rename(element:Named): Rule is do
		result:=void
	end
	
	operation renameBefore(element:Named): Rule is do
		result:=void
	end
}


class TriContainer{
	attribute element:String
	attribute left:String
	attribute right:String
	attribute appliedOperation:OperationType
	attribute side:Boolean
}

class DecompositionPlan{
	attribute atomicPlans:Hashtable<String,AtomicPlanPart>
	attribute keys:String[0..*]
	attribute mapper:Hashtable<String,TriContainer> 
	reference newMapper:Hashtable<String,Mergeable>
	reference processed:Mergeable[0..*]
	attribute procPlan:String [0..*]
	
	operation initialize(): Void is do
		self.atomicPlans:=Hashtable<String,AtomicPlanPart>.new
		self.mapper:=Hashtable<String,TriContainer>.new
		self.newMapper:=Hashtable<String,Mergeable>.new
	end
	
	operation print(): Void is do
		stdio.writeln("plan : ")
		self.atomicPlans.values().each{plan|
			stdio.writeln("  element: "+plan.element+" contained in :"+plan.inElement+"-> "+plan.operationType.name+" : "+plan.side.toString)
				if plan.dependantOn.size >0 then
					plan.dependantOn.each{dependant|
						stdio.writeln("   dependantOf: "+dependant)
					}
				end
		}
	end
}
class AtomicPlanPart{
	attribute element:String
	attribute operationType:OperationType
	attribute side:Boolean
	attribute dependantOn:String[0..*]
	attribute inElement:String
}
