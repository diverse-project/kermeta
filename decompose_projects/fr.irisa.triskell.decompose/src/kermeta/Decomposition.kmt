/* $Id: Decomposition.kmt,v 1.13 2008-10-13 20:05:47 fmunoz Exp $ 
 * Creation : August 11, 2008
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            freddy
 */


package decomposition;

require "http://www.kermeta.org/decomposer/plan"
//require "http://www.kermeta.org/decomposer"



using kermeta::language::structure
using kermeta::language
using kermeta::standard
using kermeta::utils 
using kermeta::persistence
using kompose
using plan
using decomposition

@aspect "true"
class Decomposer {

	
	attribute objectIndex:String[0..*]
	
	
	reference resource:kermeta::persistence::EMFResource 
	attribute numeral:Integer
	
	attribute decompositionPlans:DecompositionPlan[0..*]
	reference currentPlan:DecompositionPlan
	
	attribute procLKeys:String[0..*]
	attribute procRKeys:String[0..*]
	
	attribute recCount:Integer
	
	attribute planification:Planification
	
	operation initialize(initial:Mergeable) is do
		self.original:=initial
		self.numeral:=0
	end
	
	operation start():Void is do
		self.indexate(self.original)
		self.createPlans()
		var i:Integer init 0
		self.decompositionPlans.each{plan|
			self.currentPlan:=plan
			stdio.writeln("======================= > proc plan: "+i.toString)
			i:=i+1
			self.decompose(void,original,void,true)
		}
	end
	
	
	operation createPlans():Void is do
		var plan:DecompositionPlan plan:=DecompositionPlan.new
		self.planification:= Planification.new
		plan.initialize()
		self.decompositionPlans.add(plan)
		initializePlans(plan,self.original,void,OperationType.CLONE,void,void)
		plan.keys.remove(self.original.oid().toString())
		self.recCount:=0
		stdio.writeln("goin on RIGHT")
		recurseRight(plan)
		var i:Integer init 0
		self.decompositionPlans.each{plan|
			var pl:Plan init Plan.new
			pl.address:=i
			plan.atomicPlans.values().each{aplan|
				var atomNew:AtomicPlanPart atomNew:=AtomicPlanPart.new
				atomNew.element:=aplan.element
				atomNew.operationType:=aplan.operationType
				atomNew.side:=aplan.side
				atomNew.inElement:=aplan.inElement
				atomNew.restricted:=aplan.restricted
				if aplan.restricted then
					atomNew.restriction:=aplan.restriction
				end
				pl.atomicPlans.add(atomNew)
			}
			self.planification.plans.add(pl)
			i:=i+1
		}
	end
	
	
	operation clonePlan(plan:DecompositionPlan): DecompositionPlan is do
		var newPlan:DecompositionPlan newPlan:=DecompositionPlan.new
		newPlan.initialize()
		plan.atomicPlans.values.each{aplan|
			var atomNew:AtomicPlanPart atomNew:=AtomicPlanPart.new
			atomNew.element:=aplan.element
			atomNew.operationType:=aplan.operationType
			atomNew.side:=aplan.side
			atomNew.inElement:=aplan.inElement
			atomNew.eoid:=aplan.eoid
			atomNew.inoid:=aplan.inoid
			atomNew.restricted:=aplan.restricted
			atomNew.inversion:=aplan.inversion	
			if aplan.restricted then
				atomNew.restriction:=aplan.restriction
			end
			aplan.dependantOn.each{dep|
				atomNew.dependantOn.add(dep)
			}
			newPlan.atomicPlans.put(atomNew.eoid,atomNew)
		}
		plan.keys.each{k|
			newPlan.keys.add(k)
		}
		result:=newPlan
	end
	
	operation insDep(atomNew:AtomicPlanPart,newPlan:DecompositionPlan,side:Boolean,rest:Restriction):Void is do
		atomNew.dependantOn.each{dep|
					if newPlan.atomicPlans.getValue(dep).operationType!=OperationType.ONESIDE then
						//stablish a restriction on the related
						newPlan.atomicPlans.getValue(dep).restricted:=side
						newPlan.atomicPlans.getValue(dep).restriction:=rest
						//if aleaready processed
					//	if not newPlan.keys.contains(newPlan.atomicPlans.getValue(dep).inoid) then
						if not newPlan.atomicPlans.getValue(dep).inversion then
							newPlan.atomicPlans.getValue(dep).operationType:=OperationType.ONESIDE 
							newPlan.atomicPlans.getValue(dep).side:=side
						end
					end
				}
	end
	
	operation recurseRight(plan:DecompositionPlan):Void is do
		plan.keys.each{key|
			//check whether the restriction allows this side
			plan.keys.remove(key)
			var continue:Boolean init true
			if plan.atomicPlans.getValue(key).restricted then
				if plan.atomicPlans.getValue(key).restriction!=Restriction.RIGHT then
					continue:=false
				end
			end
			if continue then
				self.recCount:=self.recCount+1
				stdio.write(self.recCount.toString+") in right "+key+" "+plan.atomicPlans.getValue(key).element+"\n")
				var newPlan:DecompositionPlan init self.clonePlan(plan)
				newPlan.keys.remove(key)
				var atomNew:AtomicPlanPart init newPlan.atomicPlans.getValue(key)
				atomNew.operationType:=OperationType.ONESIDE
				atomNew.side:=true
				newPlan.atomicPlans.put(key,atomNew)
				var onside:Boolean init true
				var keys:OrderedSet<String> init OrderedSet<String>.new
				newPlan.keys.each{k|
					keys.add(k)
				}
				atomNew.dependantOn.each{dep|
					if newPlan.atomicPlans.getValue(dep).operationType==OperationType.ONESIDE then
						if not newPlan.atomicPlans.getValue(dep).side then
							onside:=false
						else
							keys.remove(dep)
						end
					else
						//stablish a restriction on the related
						newPlan.atomicPlans.getValue(dep).restricted:=true
						newPlan.atomicPlans.getValue(dep).restriction:=Restriction.RIGHT
						//if aleaready processed
					//	if not newPlan.keys.contains(newPlan.atomicPlans.getValue(dep).inoid) then
						if not newPlan.atomicPlans.getValue(dep).inversion then
							newPlan.atomicPlans.getValue(dep).operationType:=OperationType.ONESIDE 
							newPlan.atomicPlans.getValue(dep).side:=true
						end
						self.insDep(newPlan.atomicPlans.getValue(dep),newPlan,true,Restriction.RIGHT)
					//	end
					end
				}
				if newPlan.atomicPlans.containsKey(atomNew.inoid) then
					if newPlan.atomicPlans.getValue(atomNew.inoid).operationType==OperationType.ONESIDE  then
						if not newPlan.atomicPlans.getValue(atomNew.inoid).side then
							onside:=false
						else
							keys.remove(atomNew.inoid)
						end
					else
						//stablish a restriction on the parent
						newPlan.atomicPlans.getValue(atomNew.inoid).restricted:=true
						newPlan.atomicPlans.getValue(atomNew.inoid).restriction:=Restriction.RIGHT
					//	self.insDep(newPlan.atomicPlans.getValue(atomNew.inoid),newPlan,true,Restriction.RIGHT)
					end
				end
				if onside then
					keys.each{k|
						if newPlan.atomicPlans.getValue(k).inoid == atomNew.eoid then
							if newPlan.atomicPlans.getValue(k).operationType == OperationType.ONESIDE  then
								if not newPlan.atomicPlans.getValue(k).side then
									onside:=false
								end
							else
								//add a restriction, ewPlanR.atomicPlans.getValue(k) must be in the same side of atomNewR.
								newPlan.atomicPlans.getValue(k).restricted:=true
								newPlan.atomicPlans.getValue(k).restriction:=Restriction.RIGHT
						//		self.insDep(newPlan.atomicPlans.getValue(k),newPlan,true,Restriction.RIGHT)
							end
						end
						newPlan.atomicPlans.getValue(k).dependantOn.each{dep|
							if dep == atomNew.eoid then
								newPlan.atomicPlans.getValue(k).restricted:=true
								newPlan.atomicPlans.getValue(k).restriction:=Restriction.RIGHT
						//		self.insDep(newPlan.atomicPlans.getValue(k),newPlan,true,Restriction.RIGHT)
								onside:=false
							end
						}
					}
					
				end
				if onside then
					self.decompositionPlans.add(newPlan)
					recurseRight(newPlan)
					recurseLeft(newPlan)
				end
			/*else
				var atom:AtomicPlanPart
				atom:=plan.atomicPlans.getValue(key)
				atom.dependantOn.each{dep|
					if plan.atomicPlans.getValue(dep).operationType==OperationType.ONESIDE then
						if not plan.atomicPlans.getValue(dep).side then
							
						else
							
						end
					else
						//stablish a restriction on the related
						plan.atomicPlans.getValue(dep).restricted:=true
						plan.atomicPlans.getValue(dep).restriction:=Restriction.RIGHT
					end
				}*/
			end
		}
	end
	
	operation recurseLeft(plan:DecompositionPlan):Void is do
		plan.keys.each{key|
			//check whether the restriction allows this side
			plan.keys.remove(key)
			var continue:Boolean init true
			if plan.atomicPlans.getValue(key).restricted then
				if plan.atomicPlans.getValue(key).restriction!=Restriction.LEFT then
					continue:=false
				end
			end
			if continue then
				self.recCount:=self.recCount+1
				stdio.write(self.recCount.toString+") in left "+key+" "+plan.atomicPlans.getValue(key).element+"\n")
				var newPlan:DecompositionPlan init self.clonePlan(plan)
				newPlan.keys.remove(key)
				var atomNew:AtomicPlanPart init newPlan.atomicPlans.getValue(key)
				atomNew.operationType:=OperationType.ONESIDE
				atomNew.side:=false
				newPlan.atomicPlans.put(key,atomNew)
				var onside:Boolean init true
				var keys:OrderedSet<String> init OrderedSet<String>.new
				newPlan.keys.each{k|
					keys.add(k)
				}
				atomNew.dependantOn.each{dep|
					if newPlan.atomicPlans.getValue(dep).operationType==OperationType.ONESIDE then
						if newPlan.atomicPlans.getValue(dep).side then
							onside:=false
						else
							keys.remove(dep)
						end
					else
						//stablish a restriction on the related
						newPlan.atomicPlans.getValue(dep).restricted:=true
						newPlan.atomicPlans.getValue(dep).restriction:=Restriction.LEFT
						//	if not newPlan.keys.contains(newPlan.atomicPlans.getValue(dep).inoid) then
						if not newPlan.atomicPlans.getValue(dep).inversion then
							newPlan.atomicPlans.getValue(dep).operationType:=OperationType.ONESIDE 
							newPlan.atomicPlans.getValue(dep).side:=false
						end
						self.insDep(newPlan.atomicPlans.getValue(dep),newPlan,false,Restriction.LEFT)
					//	end
					end
				}
				if newPlan.atomicPlans.containsKey(atomNew.inoid) then
					if newPlan.atomicPlans.getValue(atomNew.inoid).operationType==OperationType.ONESIDE  then
						if newPlan.atomicPlans.getValue(atomNew.inoid).side then
							onside:=false
						else
							keys.remove(atomNew.inoid)
						end
					else
						//stablish a restriction on the parent
						newPlan.atomicPlans.getValue(atomNew.inoid).restricted:=true
						newPlan.atomicPlans.getValue(atomNew.inoid).restriction:=Restriction.LEFT
					//	self.insDep(newPlan.atomicPlans.getValue(atomNew.inoid),newPlan,false,Restriction.LEFT)
					end
				end
				if onside then
					keys.each{k|
						if newPlan.atomicPlans.getValue(k).inoid == atomNew.eoid then
							if newPlan.atomicPlans.getValue(k).operationType == OperationType.ONESIDE  then
								if newPlan.atomicPlans.getValue(k).side then
									onside:=false
								end
							else
								//add a restriction, ewPlanR.atomicPlans.getValue(k) must be in the same side of atomNewR.
								newPlan.atomicPlans.getValue(k).restricted:=true
								newPlan.atomicPlans.getValue(k).restriction:=Restriction.LEFT
	
					//			self.insDep(newPlan.atomicPlans.getValue(k),newPlan,false,Restriction.LEFT)
							end
						end
						
						newPlan.atomicPlans.getValue(k).dependantOn.each{dep|
							if dep == atomNew.eoid then
								newPlan.atomicPlans.getValue(k).restricted:=true
								newPlan.atomicPlans.getValue(k).restriction:=Restriction.LEFT

						//		self.insDep(newPlan.atomicPlans.getValue(k),newPlan,false,Restriction.LEFT)
								onside:=false
							end
						}
					}
				end
				if onside then
					self.decompositionPlans.add(newPlan)
					recurseRight(newPlan)
					recurseLeft(newPlan)
				end
			end
		}
	end
	
	operation initializePlans(plan:DecompositionPlan,element:Mergeable,superElement:Mergeable,currentOp:OperationType,direction:Boolean,odip:String):Void is do
		var atomic:AtomicPlanPart atomic:=AtomicPlanPart.new
		atomic.element:=element.toString
		atomic.operationType:=OperationType.CLONE
		atomic.inElement:=superElement.toString
		atomic.inoid:=superElement.oid().toString()
		atomic.eoid:=element.oid().toString()
		atomic.restricted:=false
		atomic.inversion:=false
		plan.atomicPlans.put(atomic.eoid,atomic)
		plan.keys.add(atomic.eoid)
		if odip!=void then
			atomic.dependantOn.add(odip)
			stdio.writeln("adding inverse dep "+odip+"  in "+atomic.element)
			atomic.inversion:=true
		end
		var ppts : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
		var properties:Collection<Property> properties:=ppts.select{ p | Mergeable.isSuperTypeOf(p.type) }
		if properties.size >0 then				
			properties.each{ p |
				if p.upper != 1 then
					var objects : Collection<Object> objects?=element.~get(p)
					objects.each{obj|
						var mergeable:Mergeable mergeable?=obj
						if mergeable!=void and self.objectIndex.contains(mergeable.oid().toString()) then
							if not self.dependants.contains(element.getMetaClass().toString()) then	
								if not plan.atomicPlans.containsKey(mergeable.oid().toString()) then					
									var container:Mergeable container?=mergeable.container
									self.initializePlans(plan,mergeable,container,OperationType.CLONE,void,void)				
								end
							else
								atomic.dependantOn.add(mergeable.oid().toString())
								if plan.keys.contains(mergeable.oid().toString()) then
								   plan.atomicPlans.getValue(mergeable.oid().toString()).dependantOn.add(atomic.eoid)
								else
								   var container:Mergeable container?=mergeable.container					
								   self.initializePlans(plan,mergeable,container,OperationType.CLONE,void,atomic.eoid)
								end
							end
						end
					}
				else
					var mergeable:Mergeable mergeable?=element.~get(p)
					if mergeable!=void and self.objectIndex.contains(mergeable.oid().toString()) then
						if not self.dependants.contains(element.getMetaClass().toString()) then	
							if not plan.atomicPlans.containsKey(mergeable.oid().toString()) then
								var container:Mergeable container?=mergeable.container
								self.initializePlans(plan,mergeable,container,OperationType.CLONE,void,void)				
							end
						else
							if plan.keys.contains(mergeable.oid().toString()) then
								atomic.dependantOn.add(mergeable.oid().toString())
								plan.atomicPlans.getValue(mergeable.oid().toString()).dependantOn.add(atomic.eoid)
							else
								atomic.dependantOn.add(mergeable.oid().toString())
								var container:Mergeable container?=mergeable.container
								self.initializePlans(plan,mergeable,container,OperationType.CLONE,void,atomic.eoid)
							end
						end
					end
				end
			}
		end
	end
	@EMF_renameAs "setResourceA"
	operation setResource(resource:kermeta::persistence::EMFResource ): Void is do
		self.resource:=resource
	end
	
	operation resouceContains(element:Object):Boolean is do
		result:=false
		if element.containingResource()==self.resource then
			result:=true
		end
	end
	
	operation indexate(element:Object):Void is do
		if self.resouceContains(element) then
			if not self.objectIndex.contains(element.oid().toString()) then
				self.objectIndex.add(element.oid().toString())
				var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
				properties.each{ p|
					if p.upper != 1 then
						var objects : Collection<Object> objects?=element.~get(p)
						objects.each{obj|self.indexate(obj)}
					else
						self.indexate(element.~get(p))
					end
				}
			end
		end
	
	end
	
	operation getPropertyByContainement(container:Mergeable,contained:Mergeable):Property is do
		var properties : Collection<Property> init container.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
		result:=void
		properties.each{p|
			if p.upper == 1 then
				if contained == container.~get(p) then
					result:=p
				end
			else
				var objects : Collection<Object> objects?=container.~get(p)
				objects.each{obj|
					if obj == contained then
						result:=p
					end
				}
			end
		}
	end
	
	operation decompose(parent:Mergeable[0..*],element:Mergeable,iproperty:Property[0..*],direction:Boolean):Void is do	
		
		self.currentPlan.print()
		stdio.writeln("processing element: "+element.toString+" oid: "+element.oid().toString())
		if self.currentPlan.atomicPlans.getValue(element.oid().toString()).operationType==OperationType.ONESIDE then
			self.side(parent,element,iproperty,self.currentPlan.atomicPlans.getValue(element.oid().toString()).side)
		else
			self.clone(parent,element,iproperty)
		end
	end
	
	operation clone(parent:Mergeable[0..*],element:Mergeable,iproperty:Property[0..*]):Void is do
		if not self.currentPlan.processed.contains(element)  then
			
			var isDependable: Boolean init false
			
			if self.dependants.contains(element.getMetaClass.classDefinition.name) then
				stdio.writeln("dependable: "+element.getMetaClass.classDefinition.toString+" in "+element.toString()+" oid: "+element.oid().toString())
				isDependable:=true
			end
			
			var left:Mergeable left?=element.getMetaClass().new
			var right:Mergeable right?=element.getMetaClass().new
			
			var doAll:Boolean init true
			var direction:Boolean init false
			var sdirection:Boolean init false
			
			var trtmp:TriContainer init TriContainer.new
			
			trtmp.element:=element.oid().toString()
			trtmp.left:=left.oid().toString()
			trtmp.right:=right.oid().toString()
			trtmp.appliedOperation:=OperationType.CLONE
			
			self.currentPlan.newMapper.put(left.oid().toString(),left)
			self.currentPlan.newMapper.put(right.oid().toString(),right)
			self.currentPlan.mapper.put(element.oid().toString(),trtmp)
			self.currentPlan.processed.add(element)
			
			
			var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
			if isDependable then
				properties.each{ p |
					if Mergeable.isSuperTypeOf(p.type) then
						if p.upper == 1 then
							var mergeable:Mergeable mergeable?=element.~get(p)
							if self.objectIndex.contains(mergeable.oid().toString()) then
								if self.currentPlan.processed.contains(mergeable) then
									if self.currentPlan.mapper.getValue(mergeable.oid().toString()).appliedOperation==OperationType.ONESIDE then
										stdio.writeln("1)element: "+element.toString+" must be sided because of: "+mergeable.toString+" in "+p.name)
										self.currentPlan.newMapper.remove(left.oid().toString())
										self.currentPlan.newMapper.remove(right.oid().toString())
										self.currentPlan.mapper.remove(element.oid().toString())
										self.currentPlan.processed.remove(element)
										sdirection:=self.currentPlan.mapper.getValue(mergeable.oid().toString()).side
										doAll:=false
									end
								end
							end
						else //p.upper > 1
							var objects : Collection<Object> objects?=element.~get(p)
							objects.each{obj|
								var mergeable:Mergeable mergeable?=obj
								if self.objectIndex.contains(mergeable.oid().toString()) then
									if self.currentPlan.processed.contains(mergeable) then
										if self.currentPlan.mapper.getValue(mergeable.oid().toString()).appliedOperation==OperationType.ONESIDE then
											stdio.writeln("*)element: "+element.toString+" must be sided because of: "+mergeable.oid().toString())
											self.currentPlan.newMapper.remove(left.oid().toString())
											self.currentPlan.newMapper.remove(right.oid().toString())
											self.currentPlan.mapper.remove(element.oid().toString())
											self.currentPlan.processed.remove(element)
											sdirection:=self.currentPlan.mapper.getValue(mergeable.oid().toString()).side
											doAll:=false
										end
									end
								end
							}
						end
					end
				}
			end
			if doAll then
				properties.each{ p |
					if not Mergeable.isSuperTypeOf(p.type) then
						if p.upper != 1 then
							var objects : Collection<Object> objects?=element.~get(p)
							var objectsL : Collection<Object> objects?=left.~get(p)
							var objectsR : Collection<Object> objects?=right.~get(p)
							objects.each{obj|
								if obj != void then
									objectsL.add(obj)
									objectsR.add(obj)
								end
							}
						else
							if element.~get(p)!= void then
								left.~set(p,element.~get(p))
								right.~set(p,element.~get(p))
							end
						end

					else
						if p.upper != 1 then
							var objects : Collection<Object> objects?=element.~get(p)
								objects.select{obj|obj!=void}.each{obj|
									var mergeable:Mergeable mergeable?=obj			
									var ctnr:Mergeable[0..*]
									var ctnr2:Mergeable ctnr2?=mergeable.container()
									var prpts:Property[0..*]
									ctnr:=OrderedSet<Mergeable>.new
									prpts:=OrderedSet<Property>.new
									if element!= ctnr2 then
										//bug::: what happens if ctnr2 is not processed yet?
										ctnr.add(element)
										ctnr.add(ctnr2)
										prpts.add(p)
										var prpt:Property prpt:=self.getPropertyByContainement(ctnr2,mergeable)
										prpts.add(prpt)
									else
										ctnr.add(element)
										prpts.add(p)
									end
									if not self.currentPlan.processed.contains(mergeable) then
										self.decompose(ctnr,mergeable,prpts,void)
									else
										var objectsL : Collection<Object> objectsL?=left.~get(p)
										var objectsR : Collection<Object> objectsR?=right.~get(p)
										if not objectsL.contains(self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).left))) then
											objectsL.add(self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).left)))
											objectsR.add(self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).right)))
										end
									end
								}
						else //p.upper == 1
							var mergeable:Mergeable mergeable?=element.~get(p)
							if mergeable != void then
									if self.objectIndex.contains(mergeable.oid().toString()) then
										var ctnr:Mergeable[0..*]
										var ctnr2:Mergeable ctnr2?=mergeable.container()
										var prpts:Property[0..*]
										ctnr:=OrderedSet<Mergeable>.new
										prpts:=OrderedSet<Property>.new
										if element!= ctnr2 then
											ctnr.add(element)
											ctnr.add(ctnr2)
											prpts.add(p)

											prpts.add(self.getPropertyByContainement(ctnr2,mergeable))
											
										else
											ctnr.add(element)
											prpts.add(p)
										end
										if not self.currentPlan.processed.contains(mergeable) then
											self.decompose(ctnr,mergeable,prpts,void)
										else
											left.~set(p,self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).left)))
											right.~set(p,self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).right)))
										end
										
									else
										if element.~get(p) !=void then
											left.~set(p,element.~get(p))
											right.~set(p,element.~get(p))
										end
									end
							end
						end
					end 
				}
				if parent==void then
					self.checkNonVoid(left,"clone left")
					self.checkNonVoid(right,"clone right")
					stdio.writeln("initializing clone with left: "+left.toString()+" oid: "+left.oid().toString())
					stdio.writeln("initializing clone with right: "+right.toString()+" oid: "+right.oid().toString())
					self.left.add(left)
					self.right.add(right)
				else
					iproperty.select{p|p!=void}.each{p|
						if p.upper == 1 then
							stdio.writeln("clone setting single L: "+left.toString+" oid:"+left.oid().toString()+" in "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).left).toString+" oid: "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).left).oid().toString()+" for "+parent.one.toString+" oid: "+parent.one.oid().toString()+" original "+element.toString+" oid: "+element.oid().toString()+" on p: "+p.name)
							stdio.writeln("clone setting single R: "+right.toString+" oid:"+right.oid().toString()+" in "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).right).toString+" oid: "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).right).oid().toString()+" for "+parent.one.toString+" oid: "+parent.one.oid().toString()+" original "+element.toString+" oid: "+element.oid().toString()+" on p: "+p.name)
							var leftStr:String  init self.currentPlan.mapper.getValue(parent.one.oid().toString()).left
							var rightStr:String init self.currentPlan.mapper.getValue(parent.one.oid().toString()).right
							var leftMrg:Mergeable init self.currentPlan.newMapper.getValue(leftStr)
							var rightMrg:Mergeable init self.currentPlan.newMapper.getValue(rightStr)
							leftMrg.~set(p,left)
							rightMrg.~set(p,right)
						else
							stdio.writeln("clone setting multiple L: "+left.toString+" oid:"+left.oid().toString()+" in "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).left).toString+" oid: "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).left).oid().toString()+" for "+parent.one.toString+" oid: "+parent.one.oid().toString()+" original "+element.toString+" oid: "+element.oid().toString()+" on p: "+p.name)
							stdio.writeln("clone setting multiple R: "+right.toString+" oid:"+right.oid().toString()+" in "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).right).toString+" oid: "+self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).right).oid().toString()+" for "+parent.one.toString+" oid: "+parent.one.oid().toString()+" original "+element.toString+" oid: "+element.oid().toString()+" on p: "+p.name)
							var objectsL : Collection<Object> objectsL?=self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).left).~get(p)
							var objectsR : Collection<Object> objectsR?=self.currentPlan.newMapper.getValue(self.currentPlan.mapper.getValue(parent.one.oid().toString()).right).~get(p)
							objectsL.add(left)
							objectsR.add(right)
						end
						parent.remove(parent.one)
					}
				end
			else
				stdio.writeln(doAll.toString+ "=> siding element: "+element.toString+" direction "+sdirection.toString)
				self.side(parent,element,iproperty,sdirection)
			end
		end
	end
	
	operation checkNonVoid(element:Object,op:String):Void is do
		var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
		properties.each{p|
			if p.upper!= 1 then
				var objects : Collection<Object>
				objects?=element.~get(p)
				var pos:Integer init 0
				objects.each{o|
					if o==void then
						stdio.errorln("problem in property "+p.name+" from "+op+" element "+element.toString)
						objects.remove(void)
					end
					pos:=pos+1
				}
			end
		}
		
	end

	operation side(parent:Mergeable[0..*],element:Mergeable,iproperty:Property[0..*],direction:Boolean):Void is do
		if not self.currentPlan.processed.contains(element)  then
			stdio.writeln("siding element: "+element.toString)
			var newElement:Mergeable newElement?=element.getMetaClass().new

			
			var trtmp:TriContainer init TriContainer.new
			
			trtmp.element:=element.oid().toString()
			if direction then
				trtmp.right:=newElement.oid().toString()
			else
				trtmp.left:=newElement.oid().toString()
			end
			trtmp.side:=direction
			trtmp.appliedOperation:=OperationType.ONESIDE
			self.currentPlan.newMapper.put(newElement.oid().toString(),newElement)
			self.currentPlan.mapper.put(element.oid().toString(),trtmp)
			self.currentPlan.processed.add(element)
			
			
			var properties : Collection<Property> init element.getMetaClass.classDefinition.allAttribute.select{p | not p.isDerived}
			properties.each{ p |
				if not Mergeable.isSuperTypeOf(p.type) then
						if p.upper != 1 then
							var objects : Collection<Object> objects?=element.~get(p)
							var objectsN : Collection<Object> objectsN?=newElement.~get(p)
							objects.each{obj|
								if obj!=void then 
									objectsN.add(obj)
								end
							}
						else
							if element.~get(p)!=void then
								newElement.~set(p,element.~get(p))
							end
						end
				else
					if p.upper != 1 then
						var objects : Collection<Object> objects?=element.~get(p)
						objects.select{obj|obj!=void}.each{obj|
							var mergeable:Mergeable mergeable?=obj			
							var ctnr:Mergeable[0..*]
							var ctnr2:Mergeable ctnr2?=mergeable.container()
							var prpts:Property[0..*]
							ctnr:=OrderedSet<Mergeable>.new
							prpts:=OrderedSet<Property>.new
							if element!= ctnr2 then
								ctnr.add(element)
								ctnr.add(ctnr2)
								prpts.add(p)
								var prpt:Property prpt:=self.getPropertyByContainement(ctnr2,mergeable)
								prpts.add(prpt)
							else
								ctnr.add(element)
								prpts.add(p)
							end
							if not self.currentPlan.processed.contains(mergeable) then
								self.decompose(ctnr,mergeable,prpts,direction)
							else
								var objectsN : Collection<Object> objectsN?=newElement.~get(p)
								var mr:Mergeable 
								if direction then
									mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).right))
								else
									mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).left))
								end
								if not objectsN.contains(mr) then
									if mr!=void then
										objectsN.add(mr)
									end
								end
							end
						}
					else
						var mergeable:Mergeable mergeable?=element.~get(p)
						if mergeable != void then
							if self.objectIndex.contains(mergeable.oid().toString()) then
								var ctnr:Mergeable[0..*]
								var ctnr2:Mergeable ctnr2?=mergeable.container()
								var prpts:Property[0..*]
								ctnr:=OrderedSet<Mergeable>.new
								prpts:=OrderedSet<Property>.new
								if element!= ctnr2 then
									ctnr.add(element)
									ctnr.add(ctnr2)
									prpts.add(p)
									prpts.add(self.getPropertyByContainement(ctnr2,mergeable))		
								else
									ctnr.add(element)
									prpts.add(p)
								end
								if not self.currentPlan.processed.contains(mergeable) then
									self.decompose(ctnr,mergeable,prpts,direction)
								else
									var mr:Mergeable 
									if direction then
										mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).right))
									else
										mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(mergeable.oid().toString()).left))
									end
									if mr!=void then
										newElement.~set(p,mr)
									end
								end	
							else
								if element.~get(p)!= void then
									newElement.~set(p,element.~get(p))
								end
							end
						end
					end	
				end
			}	
			if parent==void then
				self.checkNonVoid(newElement,"side")
				if direction then
					self.right.add(newElement)
				else
					self.left.add(newElement)
				end
			else
				iproperty.select{p|p!=void}.each{p|
					var mr:Mergeable 
					if direction then
						mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(parent.one.oid().toString()).right))
					else
						mr:=self.currentPlan.newMapper.getValue((self.currentPlan.mapper.getValue(parent.one.oid().toString()).left))
					end
					if p.upper == 1 then
						stdio.writeln("side setting single : "+newElement.toString+" oid:"+newElement.oid().toString()+" in "+mr.toString()+" oid: "+mr.oid().toString()+" for "+parent.one.toString+" oid: "+parent.one.oid().toString()+" original "+element.toString+" oid: "+element.oid().toString()+" on p: "+p.name)
						mr.~set(p,newElement)
					else
						stdio.writeln("side setting multiple : "+newElement.toString+" oid:"+newElement.oid().toString()+" in "+mr.toString()+" oid: "+mr.oid().toString()+" for "+parent.one.toString+" oid: "+parent.one.oid().toString()+" original "+element.toString+" oid: "+element.oid().toString()+" on p: "+p.name)
						var objectsN : Collection<Object> objectsN?=mr.~get(p)
						objectsN.add(newElement)
					end
					parent.remove(parent.one)
				}
			end
		end
	end
	
	operation rename(element:Named): Rule is do
		result:=void
	end
	
	operation renameBefore(element:Named): Rule is do
		result:=void
	end
}


class TriContainer{
	attribute element:String
	attribute left:String
	attribute right:String
	attribute appliedOperation:OperationType
	attribute side:Boolean
}

class DecompositionPlan{
	attribute atomicPlans:Hashtable<String,AtomicPlanPart>
	attribute keys:String[0..*]
	attribute mapper:Hashtable<String,TriContainer> 
	reference newMapper:Hashtable<String,Mergeable>
	reference processed:Mergeable[0..*]
	attribute procPlan:String [0..*]
	
	operation initialize(): Void is do
		self.atomicPlans:=Hashtable<String,AtomicPlanPart>.new
		self.mapper:=Hashtable<String,TriContainer>.new
		self.newMapper:=Hashtable<String,Mergeable>.new
	end
	
	operation print(): Void is do
	/*	stdio.writeln("plan : ")
		self.atomicPlans.values().each{plan|
			stdio.writeln("  element: "+plan.element+" contained in :"+plan.inElement+"-> "+plan.operationType.name+" : "+plan.side.toString)
				if plan.dependantOn.size >0 then
					plan.dependantOn.each{dependant|
						stdio.writeln("   dependantOf: "+dependant)
					}
				end
		}*/
	end
}
/*class AtomicPlanPart{
	attribute element:String
	attribute operationType:OperationType
	attribute side:Boolean
	attribute dependantOn:String[0..*]
	attribute inElement:String
}*/
