package org::kermeta::language::behavior;
using kermeta::standard
using org::kermeta::language::structure

aspect class Expression {
	method visitToAddClasses(theKermetaPruning : KermetaPruning) from TypeContainer is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) from TypeContainer is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
		end
	end
}

aspect class VariableDecl {
	method createFrom() : Object is do
		var theVariableDecl : VariableDecl init VariableDecl.new
		result := theVariableDecl
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~type.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~type.visitToAddRelations(theKermetaPruning)
			if(self.~type.sliced) then
				self.dup.asType(VariableDecl).type := self.~type.dup.asType(TypeReference)
				theKermetaPruning.addToRoot(self.~type.dup)
			end

		end
	end
}

aspect class CallTypeLiteral {
	method createFrom() : Object is do
		var theCallTypeLiteral : CallTypeLiteral init CallTypeLiteral.new
		result := theCallTypeLiteral
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~typeref.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~typeref.visitToAddRelations(theKermetaPruning)
			if(self.~typeref.sliced) then
				self.dup.asType(CallTypeLiteral).typeref := self.~typeref.dup.asType(TypeReference)
				theKermetaPruning.addToRoot(self.~typeref.dup)
			end

		end
	end
}

aspect class LambdaExpression {
	method createFrom() : Object is do
		var theLambdaExpression : LambdaExpression init LambdaExpression.new
		result := theLambdaExpression
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~parameters.each{theLambdaParameter | theLambdaParameter.visitToAddClasses(theKermetaPruning)}
			self.~body.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~parameters.each{theLambdaParameter | theLambdaParameter.visitToAddRelations(theKermetaPruning)
				if(not dup.isVoid and theLambdaParameter.sliced) then
					dup.asType(LambdaExpression).parameters.add(theLambdaParameter.dup.asType(LambdaParameter))
					theKermetaPruning.addToRoot(theLambdaParameter.dup)
				end
			}
			self.~body.visitToAddRelations(theKermetaPruning)
			if(self.~body.sliced) then
				self.dup.asType(LambdaExpression).body := self.~body.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~body.dup)
			end

		end
	end
}

aspect class LambdaParameter {
	method createFrom() : Object is do
		var theLambdaParameter : LambdaParameter init LambdaParameter.new
		result := theLambdaParameter
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~type.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~type.visitToAddRelations(theKermetaPruning)
			if(self.~type.sliced) then
				self.dup.asType(LambdaParameter).type := self.~type.dup.asType(TypeReference)
				theKermetaPruning.addToRoot(self.~type.dup)
			end

		end
	end
}

aspect class Conditional {
	method createFrom() : Object is do
		var theConditional : Conditional init Conditional.new
		result := theConditional
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~condition.visitToAddClasses(theKermetaPruning)
			if(not self.~elseBody.isVoid) then self.~elseBody.visitToAddClasses(theKermetaPruning) end
			self.~thenBody.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~condition.visitToAddRelations(theKermetaPruning)
			if(self.~condition.sliced) then
				self.dup.asType(Conditional).condition := self.~condition.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~condition.dup)
			end

			if(not self.~elseBody.isVoid) then self.~elseBody.visitToAddRelations(theKermetaPruning)
			if(self.~elseBody.sliced) then
				self.dup.asType(Conditional).elseBody := self.~elseBody.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~elseBody.dup)
			end
 end
			self.~thenBody.visitToAddRelations(theKermetaPruning)
			if(self.~thenBody.sliced) then
				self.dup.asType(Conditional).thenBody := self.~thenBody.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~thenBody.dup)
			end

		end
	end
}

aspect class Raise {
	method createFrom() : Object is do
		var theRaise : Raise init Raise.new
		result := theRaise
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~expression.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~expression.visitToAddRelations(theKermetaPruning)
			if(self.~expression.sliced) then
				self.dup.asType(Raise).expression := self.~expression.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~expression.dup)
			end

		end
	end
}

aspect class Loop {
	method createFrom() : Object is do
		var theLoop : Loop init Loop.new
		result := theLoop
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			if(not self.~initialization.isVoid) then self.~initialization.visitToAddClasses(theKermetaPruning) end
			if(not self.~body.isVoid) then self.~body.visitToAddClasses(theKermetaPruning) end
			self.~stopCondition.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			if(not self.~initialization.isVoid) then self.~initialization.visitToAddRelations(theKermetaPruning)
			if(self.~initialization.sliced) then
				self.dup.asType(Loop).initialization := self.~initialization.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~initialization.dup)
			end
 end
			if(not self.~body.isVoid) then self.~body.visitToAddRelations(theKermetaPruning)
			if(self.~body.sliced) then
				self.dup.asType(Loop).body := self.~body.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~body.dup)
			end
 end
			self.~stopCondition.visitToAddRelations(theKermetaPruning)
			if(self.~stopCondition.sliced) then
				self.dup.asType(Loop).stopCondition := self.~stopCondition.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~stopCondition.dup)
			end

		end
	end
}

aspect class Block {
	method createFrom() : Object is do
		var theBlock : Block init Block.new
		result := theBlock
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~statement.each{theExpression | theExpression.visitToAddClasses(theKermetaPruning)}
			self.~rescueBlock.each{theRescue | theRescue.visitToAddClasses(theKermetaPruning)}
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~statement.each{theExpression | theExpression.visitToAddRelations(theKermetaPruning)
				if(not dup.isVoid and theExpression.sliced) then
					dup.asType(Block).statement.add(theExpression.dup.asType(Expression))
					theKermetaPruning.addToRoot(theExpression.dup)
				end
			}
			self.~rescueBlock.each{theRescue | theRescue.visitToAddRelations(theKermetaPruning)
				if(not dup.isVoid and theRescue.sliced) then
					dup.asType(Block).rescueBlock.add(theRescue.dup.asType(Rescue))
					theKermetaPruning.addToRoot(theRescue.dup)
				end
			}
		end
	end
}

aspect class CallExpression {
	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~parameters.each{theExpression | theExpression.visitToAddClasses(theKermetaPruning)}
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~parameters.each{theExpression | theExpression.visitToAddRelations(theKermetaPruning)
				if(not dup.isVoid and theExpression.sliced) then
					dup.asType(CallExpression).parameters.add(theExpression.dup.asType(Expression))
					theKermetaPruning.addToRoot(theExpression.dup)
				end
			}
		end
	end
}

aspect class Assignment {
	method createFrom() : Object is do
		var theAssignment : Assignment init Assignment.new
		result := theAssignment
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~target.visitToAddClasses(theKermetaPruning)
			self.~value.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~target.visitToAddRelations(theKermetaPruning)
			if(self.~target.sliced) then
				self.dup.asType(Assignment).target := self.~target.dup.asType(CallExpression)
				theKermetaPruning.addToRoot(self.~target.dup)
			end

			self.~value.visitToAddRelations(theKermetaPruning)
			if(self.~value.sliced) then
				self.dup.asType(Assignment).~value := self.~value.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~value.dup)
			end

		end
	end
}

aspect class CallFeature {
	method createFrom() : Object is do
		var theCallFeature : CallFeature init CallFeature.new
		result := theCallFeature
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			if(not self.~target.isVoid) then self.~target.visitToAddClasses(theKermetaPruning) end
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			if(not self.~target.isVoid) then self.~target.visitToAddRelations(theKermetaPruning)
			if(self.~target.sliced) then
				self.dup.asType(CallFeature).target := self.~target.dup.asType(Expression)
				theKermetaPruning.addToRoot(self.~target.dup)
			end
 end
		end
	end
}

aspect class Rescue {
	method createFrom() : Object is do
		var theRescue : Rescue init Rescue.new
		result := theRescue
	end

	method visitToAddClasses(theKermetaPruning : KermetaPruning) is do
		checkInitialisation(theKermetaPruning.idPass)
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.~body.each{theExpression | theExpression.visitToAddClasses(theKermetaPruning)}
			self.~exceptionType.visitToAddClasses(theKermetaPruning)
		end
	end
	method visitToAddRelations(theKermetaPruning : KermetaPruning) is do
		if(not self.visitedPass) then
			super(theKermetaPruning)
			self.visitedPass := true
			self.visitedForRelations := true
			self.~body.each{theExpression | theExpression.visitToAddRelations(theKermetaPruning)
				if(not dup.isVoid and theExpression.sliced) then
					dup.asType(Rescue).body.add(theExpression.dup.asType(Expression))
					theKermetaPruning.addToRoot(theExpression.dup)
				end
			}
			self.~exceptionType.visitToAddRelations(theKermetaPruning)
			if(self.~exceptionType.sliced) then
				self.dup.asType(Rescue).exceptionType := self.~exceptionType.dup.asType(TypeReference)
				theKermetaPruning.addToRoot(self.~exceptionType.dup)
			end

		end
	end
}

