/* $Id:$ 
 * Creation : November 17, 2011
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            xdolques
 */


package org::kermeta::language;


require "StaticSetter_kermeta_aspect.kmt"
require kermeta
using kermeta::standard
using kermeta::utils
using org::kermeta::language::staticsetter
package behavior{
	aspect class CallOperation 
	{
		operation inferTypeVariableFromParameters(context : StaticSetterContext) is do 
			stdio.writeln("inferTypeVariableFromParameters for "+self.name)
			
			var typeVariableToSet : Hashtable<TypeVariable, Type> init Hashtable<TypeVariable, Type>.new
			
			
			//todo : check if type parameters are passed to the calloperation and if so bind them with typeParameters from the staticOperation
			//if there are typeParamaters and they are not filled by the call then put them in the variables to set
			if not staticOperation.typeParameter.isEmpty and self.staticTypeVariableBindings.isEmpty then 
				staticOperation.typeParameter.each{tv|typeVariableToSet.put(tv, tv)}
				
			end
			
			from var i : Integer init 0
			until i==self.parameters.size() loop
				
				if not self.parameters.elementAt(i).staticType.isVoid then
					self.parameters.elementAt(i).staticType.compareToDefinition(staticOperation.ownedParameter.elementAt(i).type,typeVariableToSet)
				end
				i:=i+1
			end
			if not staticOperation.typeParameter.isEmpty and self.staticTypeVariableBindings.isEmpty then 
				staticOperation.typeParameter.each{tv|
						self.staticTypeVariableBindings.add(typeVariableToSet.getValue(tv))
						stdio.writeln("binding found : "+tv.name+" - "+typeVariableToSet.getValue(tv).toString)
						//type should already be contained
						}
			end
			
		end
	}
}

package structure{

	
	
	aspect class Type
	{
		//if the current type from definition is a type variable, then add the binding
		//if not, it's only important if self is a class or a function type
		operation compareToDefinition(definition : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> ) is do
			stdio.writeln("compare a type with something")
			
			if definition.isInstanceOf(TypeVariable).andThen{x|typeVariableToSet.containsKey(definition.asType(TypeVariable))} then
				typeVariableToSet.put(definition.asType(TypeVariable), self)
			
			end
			
		end
		
		
	}
	
	aspect class Class
	{
		method compareToDefinition(definition : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> ) is do
			stdio.writeln("compare a class with something")
			if definition.isInstanceOf(TypeVariable).andThen{x|typeVariableToSet.containsKey(definition.asType(TypeVariable))} then
				typeVariableToSet.put(definition.asType(TypeVariable), self)
				
			else
				if definition.isInstanceOf(Class) then
					// they are both of type class with the same number of type parameters, then all type parameters should be checked
					// the resolver only try to find the bindings, but it's the checker which will have to tell if the type is different from the definition
					if	self.typeParamBinding.size==definition.asType(Class).typeParamBinding.size
					then
						from var i : Integer init 0
						until i==self.typeParamBinding.size
						loop
							 self.typeParamBinding.elementAt(i).type.compareToDefinition(definition.asType(Class).typeParamBinding.elementAt(i).type
																							,typeVariableToSet)
							i:=i+1
						end
					end			
				end
			end
			
		end
	}
	
	aspect class FunctionType
	{
		method compareToDefinition(definition : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> ) is do
			stdio.writeln("compare a FunctionType with something")
			if definition.isInstanceOf(TypeVariable).andThen{x|typeVariableToSet.containsKey(definition.asType(TypeVariable))} then
				typeVariableToSet.put(definition.asType(TypeVariable), self)
			else
				//only the right part may be used to infer a typeParameter
				if definition.isInstanceOf(FunctionType) and not self.right.isVoid and not definition.asType(FunctionType).right.isVoid then
					self.right.compareToDefinition(definition.asType(FunctionType).right, typeVariableToSet)
				end
			end	
		end
	}

}
