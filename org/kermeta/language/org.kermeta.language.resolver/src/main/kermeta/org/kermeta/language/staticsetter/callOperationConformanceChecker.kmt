/* $Id:$ 
 * Creation : November 17, 2011
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            xdolques
 */


package org::kermeta::language;


require "StaticSetter_kermeta_aspect.kmt"
require "../resolver/ResolverException.kmt"
require kermeta
using kermeta::standard
using kermeta::utils
using org::kermeta::language::staticsetter
using org::kermeta::language::resolver
package behavior{
	aspect class CallOperation 
	{
		operation inferTypeVariableFromParameters(context : StaticSetterContext) is do 
			stdio.writeln("inferTypeVariableFromParameters for "+self.name)
			
			var typeVariableToSet : Hashtable<TypeVariable, Type> init Hashtable<TypeVariable, Type>.new
			
			
			//todo : check if type parameters are passed to the calloperation and if so bind them with typeParameters from the staticOperation
			//if there are typeParamaters and they are not filled by the call then put them in the variables to set
			if not staticOperation.typeParameter.isEmpty and self.staticTypeVariableBindings.isEmpty then 
				staticOperation.typeParameter.each{tv|typeVariableToSet.put(tv, tv)}
				
			end
			
			from var i : Integer init 0
			until i==self.parameters.size() loop
				
				if not self.parameters.elementAt(i).staticType.isVoid and not self.parameters.elementAt(i).isInstanceOf(VoidLiteral) then
						self.parameters.elementAt(i).staticType.compareToExpectedType(staticOperation.ownedParameter.elementAt(i).type,typeVariableToSet, context)
				end
				i:=i+1
			end
			if not staticOperation.typeParameter.isEmpty and self.staticTypeVariableBindings.isEmpty then 
				staticOperation.typeParameter.each{tv|
						self.staticTypeVariableBindings.add(typeVariableToSet.getValue(tv))
						stdio.writeln("binding found : "+tv.name+" - "+typeVariableToSet.getValue(tv).toString)
						//type should already be contained
						}
			end
			
		end
	}
}

package structure{

	
	
	aspect class Type
	{
		//if the current type from expectedType is a type variable, then add the binding
		//if not, it's only important if self is a class or a function type
		operation compareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> , context : StaticSetterContext) is do
			stdio.writeln("compare a type with something")
			
			if expectedType.isInstanceOf(TypeVariable).andThen{x|typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} then
				typeVariableToSet.put(expectedType.asType(TypeVariable), self)
			
			end
			
		end
		
		//structural comparison is used when types are supposed to be equals
		
		operation structurallyCompareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> , context : StaticSetterContext) is do
			stdio.writeln("compare a type with something")
			
			if expectedType.isInstanceOf(TypeVariable).andThen{x|typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} then
				typeVariableToSet.put(expectedType.asType(TypeVariable), self)
			
			end
			
		end
		
		
	}
	
	aspect class Class
	{
		method compareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> , context : StaticSetterContext) is do
			stdio.writeln("compare a class with something")
			stdio.writeln("is it a typeVariable ? "+expectedType.isInstanceOf(TypeVariable).toString)
			
			if expectedType.isInstanceOf(TypeVariable).andThen{x| stdio.writeln("is it an operation typeVariable ? "+typeVariableToSet.containsKey(expectedType.asType(TypeVariable)).toString) typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} then
				typeVariableToSet.put(expectedType.asType(TypeVariable), self)
				
			else
				if expectedType.isInstanceOf(Class) then
					
					var comparableClass : Class init self.getComparableClass(expectedType.asType(Class), context)
					
					if not comparableClass.isVoid then
						// they are both of type class with the same number of type parameters, then all type parameters should be checked
						// the resolver only try to find the bindings, but it's the checker which will have to tell if the type is different from the expectedType
						if	comparableClass.typeParamBinding.size==expectedType.asType(Class).typeParamBinding.size
						then
							from var i : Integer init 0
							until i==comparableClass.typeParamBinding.size
							loop
								 comparableClass.typeParamBinding.elementAt(i).type.structurallyCompareToExpectedType(expectedType.asType(Class).typeParamBinding.elementAt(i).type
																								,typeVariableToSet
																								,context)
								i:=i+1
							end
						end
					end			
				end
			end
			
		end
		
		method structurallyCompareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> , context : StaticSetterContext) is do
			
			
			stdio.writeln("compare a class with something")
			stdio.writeln("is it a typeVariable ? "+expectedType.isInstanceOf(TypeVariable).toString)
			
			if expectedType.isInstanceOf(TypeVariable).andThen{x| stdio.writeln("is it an operation typeVariable ? "+typeVariableToSet.containsKey(expectedType.asType(TypeVariable)).toString) typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} then
				typeVariableToSet.put(expectedType.asType(TypeVariable), self)
				
			else
				if expectedType.isInstanceOf(Class) then
					
					// they are both of type class with the same number of type parameters, then all type parameters should be checked
					// the resolver only try to find the bindings, but it's the checker which will have to tell if the type is different from the expectedType
					if	self.typeParamBinding.size==expectedType.asType(Class).typeParamBinding.size
					then
						from var i : Integer init 0
						until i==self.typeParamBinding.size
						loop
							 self.typeParamBinding.elementAt(i).type.structurallyCompareToExpectedType(expectedType.asType(Class).typeParamBinding.elementAt(i).type
																							,typeVariableToSet
																							,context)
							i:=i+1
						end
					end
							
				end
			end
			
		end
		
		
		
		/**
			returns the sequence of typedefinition separing self to typeToSearch in the Type hierarchy
		*/
		operation findPathToType(typeToSearch : ClassDefinition, typeDefAlreadyVisited : Sequence<ClassDefinition>) : Sequence<Class> is do
			typeDefAlreadyVisited.add(self.typeDefinition.asType(ClassDefinition))
			result:=void
			if typeToSearch==self.typeDefinition then
				result:=Sequence<Class>.new
				result.add(self)
			else
				self.typeDefinition.superType.detect{t|
					if not typeDefAlreadyVisited.contains(t.asType(Class).typeDefinition.asType(ClassDefinition)) then
						result:= t.asType(Class).findPathToType(typeToSearch,typeDefAlreadyVisited)
						if not result.isVoid then
							result.addAt(0, self)
						end
					end
					//stop condition
					result.isVoid.~not()
					}
			end
		end
		
		/**
			returns a clone of the current class but with the type of the different bindings replaced according to the parameter bindings
		*/
		
		operation cloneWithBindings ( bindings : OrderedSet<TypeVariableBinding>) : Class is do
	
			result:= Class.new
			result.typeDefinition:=self.typeDefinition
			self.typeParamBinding.each{tvb|
				var newTVB : TypeVariableBinding init TypeVariableBinding.new
				newTVB.variable:=tvb.variable
				if tvb.type.isInstanceOf(TypeVariable) then
					var binding : TypeVariableBinding init bindings.detect{b|b.variable==tvb.type}
					if binding.isVoid.~not then
						newTVB.type:=binding.type
					end
				else 
					if tvb.type.isInstanceOf(Class) then
						newTVB.type:=tvb.type.asType(Class).cloneWithBindings(bindings)
					end
				end
				result.typeParamBinding.add(newTVB)
				}

		end
		
		
		
		
		/**
			return a class that is structurally comparable to typeExpected
		*/
		operation getComparableClass(typeExpected : Class, context : StaticSetterContext ) : Class is do 
			var inheritancePath : Sequence<Class>
			inheritancePath:=findPathToType(typeExpected.typeDefinition.asType(ClassDefinition), Sequence<ClassDefinition>.new)
			result:=void
			if inheritancePath.isVoid then
				
				context.errors.add(ResolverException.new.initialize("Parameter not of the expected type. Provided type : "+
				self.getQualifiedName + ", Expected type : "+typeExpected.getQualifiedName, self))
			else
				//the supertype of the current Class that is of the same level than typeExpected 
				var selfSuperType : Class init inheritancePath.elementAt(0)
				from var i : Integer init 0
				until i == inheritancePath.size - 1
				loop
					var superSuperType : Class 
					superSuperType:=inheritancePath.elementAt(i+1).cloneWithBindings(selfSuperType.typeParamBinding)
					
					selfSuperType:=superSuperType
					i:=i+1
				end
				result:=selfSuperType
			end
			
		end
	}
	
	aspect class FunctionType
	{
		method compareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> , context : StaticSetterContext) is do
			stdio.writeln("compare a FunctionType with something")
			if expectedType.isInstanceOf(TypeVariable).andThen{x|typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} then
				typeVariableToSet.put(expectedType.asType(TypeVariable), self)
			else
				//only the right part may be used to infer a typeParameter
				if expectedType.isInstanceOf(FunctionType) and not self.right.isVoid and not expectedType.asType(FunctionType).right.isVoid then
					self.right.compareToExpectedType(expectedType.asType(FunctionType).right, typeVariableToSet, context)
				end
			end	
		end
		
		method structurallyCompareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> , context : StaticSetterContext) is do
			stdio.writeln("compare a FunctionType with something")
			if expectedType.isInstanceOf(TypeVariable).andThen{x|typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} then
				typeVariableToSet.put(expectedType.asType(TypeVariable), self)
			else
				//only the right part may be used to infer a typeParameter
				if expectedType.isInstanceOf(FunctionType) and not self.right.isVoid and not expectedType.asType(FunctionType).right.isVoid then
					self.right.structurallyCompareToExpectedType(expectedType.asType(FunctionType).right, typeVariableToSet, context)
				end
			end	
		end
	}

}
