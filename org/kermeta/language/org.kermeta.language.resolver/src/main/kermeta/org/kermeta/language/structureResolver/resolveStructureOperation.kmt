package org::kermeta::language::structure;
require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/OperationSignatureEquivalence_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetCallableFeatures_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetQualifiedName_structure_aspect.kmt"
require "ResolverContext_Aspect.kmt"
using kermeta::standard
using org::kermeta::language::resolver

aspect class KermetaModelElement{

	operation resolveStructureOperation(context : LanguageVisitorContext) is do
		
	end
}
aspect class UnresolvedOperation inherits Unresolved, AbstractOperation, TypeContainer {

	reference correspondingOperation : Operation
	operation findCorrespondingOperation(context : LanguageVisitorContext) : Operation is do
		// type given in from 
		if context.verbose then 
			stdio.writeln("look for corresponding operation "+operationIdentifier)
		end
		
		var  classFrom: Class 
		
		if not ~from.isVoid then
			classFrom?= ~from
		end
		
		if context.verbose then 
			stdio.writeln("from "+~from.toString)
		end
		
		if not classFrom.isVoid then
			if context.verbose then 
				stdio.writeln("in typedef "+classFrom.typeDefinition.asType(ClassDefinition).name)
			end

			//we have a Class corresponding to the one indicated in the from statement
			//we have to check if this class is a direct class to the current class
			//TODO what do we do with generic class
			
			var isDirectSuperClass : Boolean 
			isDirectSuperClass := context.currentClassDef.superType.exists{c|
				if c.isInstanceOf(Class) then 
					c.asType(Class).typeDefinition.equals(classFrom.typeDefinition) 
				else 
					false 
				end }
			if isDirectSuperClass then
			
				var cdFrom : ClassDefinition init classFrom.typeDefinition.asType(ClassDefinition)
				var callableOperations : Set<Operation> init cdFrom.getAllCallableOperations()
															 .select{op|op.hasSameSignature(context.currentOperation)}.asSet()
				if callableOperations.size()==1 then
					correspondingOperation := callableOperations.one
				else
					if callableOperations.size()==0 then
						context.errors.add(ResolverException.new.initialize(
								"Super Operation "+operationIdentifier+" cannot be resolved in " + cdFrom.name, self))
					else
						context.errors.add(ResolverException.new.initialize(
								"The current operation in " + cdFrom.name + " have too many super definition to call", self))
					end
				end
		
			
				result:=correspondingOperation
			
			else
				context.errors.add(ResolverException.new.initialize(
								"'from' statement of "+operationIdentifier+ " is not a direct type of "+context.currentClassDef.name, self))
			end
		end
	end
	
	
}

aspect class Operation inherits MultiplicityElement, AbstractOperation {
	method resolveStructureOperation(context : LanguageVisitorContext) is do
		//if there is a super operation 
		if not superOperation.isVoid then
			if superOperation.isInstanceOf(UnresolvedOperation) then
				var unresolvedOp : UnresolvedOperation init superOperation.asType(UnresolvedOperation)
				// at this point superOperation
				unresolvedOp.findCorrespondingOperation(context)
				if not unresolvedOp.correspondingOperation.isVoid then
					superOperation:=unresolvedOp.correspondingOperation
					ownedUnresolvedOperations.remove(unresolvedOp)
				else
					
					stdio.writeln("operation "+ getQualifiedName+ " cannot be resolved")
				end
			end
		else
			//we should look for potentially existing superoperations			
			if context.verbose then
				stdio.writeln("currentOperation from is void")
			end
			var callableOps: Set<Operation> init Set<Operation>.new
			context.currentClassDef.superType.each{t|
				if t.isInstanceOf(Class) then
					if context.verbose then
						stdio.writeln("look into "+t.asType(Class).typeDefinition.name)
					end
					callableOps.addAll(t.asType(Class).typeDefinition.asType(ClassDefinition).getAllCallableOperations().select{op|
						op.hasSameSignature(context.currentOperation)})
						
				end
				}
			if callableOps.size()==1 then
					self.superOperation := callableOps.one
				else
					if callableOps.size()!=0 then
						context.errors.add(ResolverException.new.initialize(
							"The current operation in " + context.currentClassDef.name + " have too many super definition to call", self))
					end
				end	
				
		end
		
	end
}