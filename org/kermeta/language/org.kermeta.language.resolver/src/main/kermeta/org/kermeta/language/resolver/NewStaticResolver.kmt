/* $Id:$ 
 * Creation : December 30, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise
 */
@mainClass "org::kermeta::language::resolver::FullStaticResolver"
@mainOperation "testMain"


package org::kermeta::language::resolver;


require kermeta
//require "Resolver.kmt"
require "../staticsetter/StaticSetter_kermeta_aspect.kmt"
require "../staticsetter/StaticSetterContext.kmt"
require "ResolverException.kmt"
require "../structureResolver/structureResolver.kmt"
require "../typeawaremerger/TypeAwareMerger.kmt"
//require "../structureResolver/ResolverContext_Aspect.kmt"
using org::kermeta::language::staticsetter

using org::kermeta::language::resolver
using kermeta::persistence
using kermeta::standard

class FullStaticResolver
{
	attribute ctxt : LanguageVisitorContext

	operation testMain() : Void is do 
		var repository : EMFRepository init EMFRepository.new
		var folder : String init "platform:/resource/org.kermeta.language.resolver/src/tests/"
		var baseFileName : String init "beforeResolving"
		repository.registerEcoreFile("platform:/resource/org.kermeta.language.model/src/main/ecore/kermeta.ecore")
		var unresolvedModelResource : Resource init repository.getResource(folder+baseFileName+".km")
       	stdio.writeln("	********************* " + folder+baseFileName+".km" + " loaded ************************")
		       	
       	var unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit
       	var resolvedModelingUnit : org::kermeta::language::structure::ModelingUnit 
       	unresolvedModelingUnit ?= unresolvedModelResource.one
       	unresolvedModelingUnit.canUseCachedStructuralTypeDefinitions := true
       	//checkUnresolved(unresolvedModelingUnit)
        resolvedModelingUnit := doResolving(unresolvedModelingUnit)
        
        //workaround to remove cache before saving as it triggers errors in interpreted mode
       	var cache : org::kermeta::language::structure::internal::ModelingUnitCache init resolvedModelingUnit.cache
        resolvedModelingUnit.cache:=void
       	         
        stdio.writeln("	********** saving intermediate resolved but not set file "+ folder+"results/"+baseFileName+"Resolved.km")  	    	
       	unresolvedModelResource.saveWithNewURI(folder+"results/"+baseFileName+"Resolved.km")
       	
       	//workaround to remove cache before saving as it triggers errors in interpreted mode
       	resolvedModelingUnit.cache:=cache
       	
       	resolvedModelingUnit := unresolvedModelingUnit
       	checkUnresolved(resolvedModelingUnit)
       	resolvedModelingUnit := doStaticSetting(resolvedModelingUnit)
       	
       	//workaround to remove cache before saving as it triggers errors in interpreted mode
       	resolvedModelingUnit.cache:=void
       	unresolvedModelResource.saveWithNewURI(folder+"results/"+baseFileName+"StaticSetted.km")
       	
       	stdio.writeln("	********************* " + folder+"results/"+baseFileName+"StaticSetted.km" + " saved ************************")
       	if not getErrors.isEmpty then
       		stdio.writeln("	********************* Errors detected")
       		getErrors.each{e | stdio.writeln(e.message)}
       	end
	end
	
	operation getErrors() : OrderedSet<ResolverException> is do
		result := ctxt.errors
	end


	operation resolve(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		result := doStaticSetting(doStructureResolving(doTypeAwareMerging(doTypeResolving(unresolvedModelingUnit))))
	end

	operation doTypeResolving(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		//init of context
		ctxt:= LanguageVisitorContext.new.initialize(unresolvedModelingUnit)
		unresolvedModelingUnit.resolveStructureInheritance(ctxt)
		result:=unresolvedModelingUnit
	end
	
	operation doTypeAwareMerging(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		var mergeCtxt : TypeAwareMergerContext init TypeAwareMergerContext.new
		mergeCtxt.errors:=ctxt.errors
		unresolvedModelingUnit.typeAwareMerge( mergeCtxt)
		result:=unresolvedModelingUnit
	
	end
	
	operation doStructureResolving(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		//init of context
		unresolvedModelingUnit.resolveStructure(ctxt)
		result:=unresolvedModelingUnit
	end

	operation doResolving(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		stdio.writeln("	********************* Resolving " + unresolvedModelingUnit.toString() + " *********************")
       	/*var unresolvedFinder : ResolverUnresolvedFinderVisitor init ResolverUnresolvedFinderVisitor.new

		ctxt := LanguageVisitorContext.new.initialise()
	
   		unresolvedModelingUnit.accept(unresolvedFinder, ctxt)*/
   		
   		doStructureResolving(doTypeAwareMerging(doTypeResolving(unresolvedModelingUnit)))
       	stdio.writeln("	********************* " + unresolvedModelingUnit.toString() + " resolved *********************")
       	
       	//checkDangling(unresolvedModelingUnit.containingResource())       	
		//checkUnresolved(unresolvedModelingUnit)
       	
       	result := unresolvedModelingUnit
	end
	
	operation doStaticSetting(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do      	
		stdio.writeln("	********************* Static setting " + unresolvedModelingUnit.toString() + " *********************")
		var staticSetterContext : StaticSetterContext init StaticSetterContext.new.initialize(unresolvedModelingUnit)
		
		staticSetterContext.verbose := false
		staticSetterContext.errors  := ctxt.errors
		
		unresolvedModelingUnit.inferContainedExpressionStatic(staticSetterContext)
		
       	stdio.writeln("	********************* " + unresolvedModelingUnit.toString() + " statically set *********************")
       	result := unresolvedModelingUnit
	end
	
	operation checkUnresolved(aKermetaModelElement : org::kermeta::language::structure::KermetaModelElement) : Void is do
		aKermetaModelElement.eachOwnedElement{p |
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedType) then
				stdio.writeln("UNRESOLVED_TYPE -- typeIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedType).typeIdentifier.toString)
				p.asType(org::kermeta::language::structure::UnresolvedType).usings.each{ us |
					stdio.writeln("|-------------usings: " + us.toString)
				}
				p.asType(org::kermeta::language::structure::UnresolvedType).generics.each{g |
					if (g.isInstanceOf(org::kermeta::language::structure::UnresolvedType)) then
						stdio.writeln("UNRESOLVED_TYPE on GENERICS -- typeIdentifier: " + g.asType(org::kermeta::language::structure::UnresolvedType).typeIdentifier.toString)
						g.asType(org::kermeta::language::structure::UnresolvedType).usings.each{ us |
							stdio.writeln("|-------------usings: " + us.toString)
						}
					end
				}
			end
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedOperation) then
				stdio.writeln("UNRESOLVED_OPERATION -- operationIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedOperation).operationIdentifier.toString)
				stdio.writeln("|-------------from: " + p.asType(org::kermeta::language::structure::UnresolvedOperation).~from.toString)
			end
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedProperty) then
				stdio.writeln("UNRESOLVED_PROPERTY -- peropertyIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedProperty).propertyIdentifier.toString)
			end
			if p.isInstanceOf(org::kermeta::language::behavior::UnresolvedCall) then
				stdio.writeln("UNRESOLVED_CALL -- name: " + p.asType(org::kermeta::language::behavior::UnresolvedCall).name)
			end
			if p.isInstanceOf(org::kermeta::language::behavior::Expression) then
				if p.asType(org::kermeta::language::behavior::Expression).staticType.isVoid then
					stdio.writeln("-*-*-STATIC_TYPE VOID FOUND")
				end
			end
			if p.isInstanceOf(org::kermeta::language::structure::KermetaModelElement) then
				checkUnresolved(p.asType(org::kermeta::language::structure::KermetaModelElement))
			end
			p
		}
	end

	/*operation checkDangling(unresolvedModelResource : Resource) : Void is do
		var report : Set<org::kermeta::language::resolver::DanglingDiagnosticBIS>
	 	report := findDanglingModelElementsBIS(unresolvedModelResource)
	 	report.each{ diag |
	 		var danglingName : String init ""
	 		var referencingName : String init ""
	 		if diag.danglingElement.isInstanceOf(org::kermeta::language::structure::NamedElement) then
	 			danglingName := "(named " + diag.danglingElement.asType(org::kermeta::language::structure::NamedElement).name() + ")"
	 		else
	 			if diag.danglingElement.isInstanceOf(org::kermeta::language::structure::Class) then
	 				danglingName := "(named " + diag.danglingElement.asType(org::kermeta::language::structure::Class).name() + ")"
	 			end
	 		end
	 		if diag.referencingElement.isInstanceOf(org::kermeta::language::structure::NamedElement) then
	 			referencingName := "(named " + diag.referencingElement.asType(org::kermeta::language::structure::NamedElement).name() + ")"
	 		else
	 			if diag.referencingElement.isInstanceOf(org::kermeta::language::structure::Class) then
	 				referencingName := "(named " + diag.referencingElement.asType(org::kermeta::language::structure::Class).name() + ")"
	 			end
	 		end
			stdio.writeln(diag.danglingElement.toString() + danglingName + " referenced by " + diag.referencingElement.toString + "." +
			diag.referencingProperty.name + referencingName)
		}
	end*/	
}