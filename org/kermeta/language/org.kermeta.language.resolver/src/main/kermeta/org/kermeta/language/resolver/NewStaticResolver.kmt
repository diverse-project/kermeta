/* $Id:$ 
 * Creation : December 30, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise
 */
@mainClass "org::kermeta::language::resolver::FullStaticResolver"
@mainOperation "testMain"


package org::kermeta::language::resolver;


require kermeta

require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"

require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverException.kmt"

require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/behaviorResolver_inferedStaticType.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/callOperationConformanceChecker.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/StaticSetter_kermeta_aspect.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/StaticSetter_typevariableResolver.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/StaticSetterContext.kmt"

require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/primitiveType_aspect.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/ResolverContext_Aspect.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/resolveStructureOperation.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/resolveStructureProperty.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/resolveStructureType.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/structureResolver.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/unresolvedType_Aspect.kmt"

require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/typeawaremerger/TypeAwareMerger.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/typeawaremerger/TypeAwareMergerContext.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/typeawaremerger/TypeRebind.kmt"

require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/OperationSignatureEquivalence_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetCallableFeatures_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetQualifiedName_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/eachOwnedElement_kermeta_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetAllSuperTypes_TypeDefinition_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/MetamodelHelper_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/TypeEquality_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetRootContainer_object_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/CreationHelper.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/prettyprinters/PrettyPrinter_kermeta_aspect.kmt"

using org::kermeta::language::staticsetter
using org::kermeta::language::resolver
using kermeta::persistence
using kermeta::standard

class FullStaticResolver
{
	attribute ctxt : LanguageVisitorContext

	/* *
		this is the operation you will want to launch if you want to launch the 
		resolver with the interpreter of kermeta V1
		to do so you just have to put a unresolved but merged km file named beforeResolving.km
		in the folder "src/interperterTests"
		After launching you will see the results in the folder "results" (how surprising)
	*/
	operation testMain() : Void is do 
		var repository : EMFRepository init EMFRepository.new
		var folder : String init "platform:/resource/org.kermeta.language.resolver/src/interpreterTests/"
		var baseFileName : String init "beforePreresolveResolving"
		repository.registerEcoreFile("platform:/resource/org.kermeta.language.model/src/main/ecore/kermeta.ecore")
		var unresolvedModelResource : Resource init repository.getResource(folder+baseFileName+".km")
       	stdio.writeln("	********************* " + folder+baseFileName+".km" + " loaded ************************")
		       	
       	var unresolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel> init OrderedSet<org::kermeta::language::structure::Metamodel>.new
       	var resolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel>
       	
       	unresolvedModelResource.each{r|
       		if( r.isInstanceOf(org::kermeta::language::structure::Metamodel)) then
       			unresolvedMetamodels.add(r.asType(org::kermeta::language::structure::Metamodel))
       		end
		}
       	unresolvedMetamodels.each{mm|
       		mm.canUseCachedStructuralTypeDefinitions := true
       	}
       	
       	resolvedMetamodels := resolve(unresolvedMetamodels)
       	resolvedMetamodels.each{mm|
			checkUnresolved(mm)
	    }
       	stdio.writeln("unresolved elements checked")
       	//workaround to remove cache before saving as it triggers errors in interpreted mode
      	resolvedMetamodels.each{mm|
       		mm.cache := void
       	}
       	unresolvedModelResource.saveWithNewURI(folder+"results/"+baseFileName+"StaticSetted.km")
       	
       	stdio.writeln("	********************* " + folder+"results/"+baseFileName+"StaticSetted.km" + " saved ************************")
       	if not getErrors.isEmpty then
       		stdio.writeln("	********************* Errors detected")
       		getErrors.each{e | stdio.writeln(e.message)}
       	end
	end
	
	/* * 
		obtain the list of errors from the context
	*/
	operation getErrors() : Sequence<ResolverException> is do
		result := ctxt.errors
	end

	/* * 
		launch the entire resolving process
	*/
	operation resolve(unresolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel>) : Collection<org::kermeta::language::structure::Metamodel> is do
		result := doStaticSetting(
			doStructureResolving(
				doTypeAwareMerging(
					doPrimitiveTypeResolving(
						doTypeResolving(unresolvedMetamodels)
					)
				)
			)
		)
	end
	/* * 
		launch only the unresolved types resolution after this step all unresolved types should be resolved 
	*/
	operation doTypeResolving(unresolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel>) : Collection<org::kermeta::language::structure::Metamodel> is do
		//init of context
		stdio.writeln("	********************* 666 Type Resolving *********************")
		ctxt:= LanguageVisitorContext.new.initialize(unresolvedMetamodels)
		ctxt.verbose := false
		unresolvedMetamodels.each{mm|
			mm.resolveStructureInheritance(ctxt)
		}
		stdio.writeln("	********************* End of Type Resolving *********************")
		result:=unresolvedMetamodels
	end
	
	
	operation doPrimitiveTypeResolving(unresolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel>) : Collection<org::kermeta::language::structure::Metamodel> is do
		//stdio.writeln("doPrimitiveTypeResolving")
		stdio.writeln("	********************* Primitive Type Resolving *********************")
		unresolvedMetamodels.each{mm|
			mm.resolvePrimitiveTypeEquivalence(ctxt)
		}
		stdio.writeln("	********************* End of Primitive Type Resolving *********************")
		result:=unresolvedMetamodels
	end
	/* *
		pass to launch only when there are no more unresolved types
		merge the operations and properties that have the same signature (not possible if some types are unresolved)
	*/
	operation doTypeAwareMerging(unresolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel>) : Collection<org::kermeta::language::structure::Metamodel> is do
		stdio.writeln("	********************* Type Aware Merging  *********************")
		var mergeCtxt : TypeAwareMergerContext init TypeAwareMergerContext.new
		mergeCtxt.errors:=ctxt.errors
		unresolvedMetamodels.each{mm|
			mm.typeAwareMerge( mergeCtxt)
		}
		stdio.writeln("	********************* End of Type Aware Merging  *********************")
		result:=unresolvedMetamodels
	
	end
	
	/* *
		resolve the remaining of the unresolved parts of the structure 
		i.e. : unresolved properties and unresolved operations
		not possible until unresolved types are resolved 
		(to resolve the super operation of from you have to resolve the super type where to find it first
		to resolve an opposite, you have to resolve the type of the property first)
		not possible until there is one unique definition for each operation and property (i.e. not possible before type aware merging) 
		
	*/
	operation doStructureResolving(unresolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel>) : Collection<org::kermeta::language::structure::Metamodel> is do
		//init of context
		stdio.writeln("	********************* Structure Resolving  *********************")
		unresolvedMetamodels.each{mm|
			mm.resolveStructure(ctxt)
		}
		stdio.writeln("	********************* End of Structure Resolving  *********************")
		result:=unresolvedMetamodels
	end


	/* *
	*	chain all the resolving passes for the structural part of the program
	*/
	operation doResolving(unresolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel>) : Collection<org::kermeta::language::structure::Metamodel> is do
		stdio.writeln("	********************* Resolving " + unresolvedMetamodels.toString() + " *********************")
       	/*var unresolvedFinder : ResolverUnresolvedFinderVisitor init ResolverUnresolvedFinderVisitor.new

		ctxt := LanguageVisitorContext.new.initialise()
	
   		unresolvedMetamodels.accept(unresolvedFinder, ctxt)*/
   		
   		doStructureResolving(doTypeAwareMerging(doPrimitiveTypeResolving(doTypeResolving(unresolvedMetamodels))))
       	stdio.writeln("	********************* " + unresolvedMetamodels.toString() + " resolved *********************")
       	
       	//checkDangling(unresolvedMetamodels.containingResource())       	
		//checkUnresolved(unresolvedMetamodels)
       	
       	result := unresolvedMetamodels
	end
	
	/* *
		resolve all the behavioral part and add static types
	*/
	operation doStaticSetting(unresolvedMetamodels : Collection<org::kermeta::language::structure::Metamodel>) : Collection<org::kermeta::language::structure::Metamodel> is do      	
		stdio.writeln("	********************* Static setting " + unresolvedMetamodels.toString() + " *********************")
		var staticSetterContext : StaticSetterContext init StaticSetterContext.new.initialize(unresolvedMetamodels)
		
		staticSetterContext.verbose := false
		staticSetterContext.errors  := ctxt.errors
		
		unresolvedMetamodels.each{mm|
			mm.inferContainedExpressionStatic(staticSetterContext)
		}
		
       	stdio.writeln("	********************* " + unresolvedMetamodels.toString() + " statically set *********************")
       	result := unresolvedMetamodels
	end
	
	/* * 
		check if an unresolved element remains in the model
	*/
	operation checkUnresolved(aKermetaModelElement : org::kermeta::language::structure::KermetaModelElement) : Void is do
		aKermetaModelElement.eachOwnedElement{p |
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedType) then
				stdio.writeln("UNRESOLVED_TYPE -- typeIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedType).typeIdentifier.toString)
				p.asType(org::kermeta::language::structure::UnresolvedType).usings.each{ us |
					stdio.writeln("|-------------usings: " + us.toString)
				}
				p.asType(org::kermeta::language::structure::UnresolvedType).generics.each{g |
					if (g.isInstanceOf(org::kermeta::language::structure::UnresolvedType)) then
						stdio.writeln("UNRESOLVED_TYPE on GENERICS -- typeIdentifier: " + g.asType(org::kermeta::language::structure::UnresolvedType).typeIdentifier.toString)
						g.asType(org::kermeta::language::structure::UnresolvedType).usings.each{ us |
							stdio.writeln("|-------------usings: " + us.toString)
						}
					end
				}
			end
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedOperation) then
				stdio.writeln("UNRESOLVED_OPERATION -- operationIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedOperation).operationIdentifier.toString)
				stdio.writeln("|-------------from: " + p.asType(org::kermeta::language::structure::UnresolvedOperation).~from.toString)
			end
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedProperty) then
				stdio.writeln("UNRESOLVED_PROPERTY -- propertyIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedProperty).propertyIdentifier.toString)
			end
			if p.isInstanceOf(org::kermeta::language::behavior::UnresolvedCall) then
				stdio.writeln("UNRESOLVED_CALL -- name: " + p.asType(org::kermeta::language::behavior::UnresolvedCall).name)
			end
			if p.isInstanceOf(org::kermeta::language::behavior::Expression) then
				if p.asType(org::kermeta::language::behavior::Expression).staticType.isVoid then
					stdio.writeln("-*-*-STATIC_TYPE VOID FOUND")
				end
			end
			if p.isInstanceOf(org::kermeta::language::structure::KermetaModelElement) then
				checkUnresolved(p.asType(org::kermeta::language::structure::KermetaModelElement))
			end
			p
		}
	end

	
}