/* $Id:$ 
 * Creation : December 30, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise
 */
@mainClass "org::kermeta::language::resolver::FullStaticResolver"
@mainOperation "testMain"


package org::kermeta::language::resolver;


require kermeta

require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"

require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverException.kmt"

require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/behaviorResolver_inferedStaticType.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/callOperationConformanceChecker.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/StaticSetter_kermeta_aspect.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/StaticSetter_typevariableResolver.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/StaticSetterContext.kmt"

require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/primitiveType_aspect.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/ResolverContext_Aspect.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/resolveStructureOperation.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/resolveStructureProperty.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/resolveStructureType.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/structureResolver.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/structureResolver/unresolvedType_Aspect.kmt"

require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/typeawaremerger/TypeAwareMerger.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/typeawaremerger/TypeAwareMergerContext.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/typeawaremerger/TypeRebind.kmt"

require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/OperationSignatureEquivalence_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetCallableFeatures_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetQualifiedName_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/eachOwnedElement_kermeta_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetAllSuperTypes_TypeDefinition_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/ModelingUnitHelper_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/TypeEquality_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetRootContainer_object_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/CreationHelper.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/prettyprinters/PrettyPrinter_kermeta_aspect.kmt"

using org::kermeta::language::staticsetter
using org::kermeta::language::resolver
using kermeta::persistence
using kermeta::standard

class FullStaticResolver
{
	attribute ctxt : LanguageVisitorContext

	/* *
		this is the operation you will want to launch if you want to launch the 
		resolver with the interpreter of kermeta V1
		to do so you just have to put a unresolved but merged km file named beforeResolving.km
		in the folder "src/interperterTests"
		After launching you will see the results in the folder "results" (how surprising)
	*/
	operation testMain() : Void is do 
		var repository : EMFRepository init EMFRepository.new
		var folder : String init "platform:/resource/org.kermeta.language.resolver/src/interpreterTests/"
		var baseFileName : String init "beforeResolving"
		repository.registerEcoreFile("platform:/resource/org.kermeta.language.model/src/main/ecore/kermeta.ecore")
		var unresolvedModelResource : Resource init repository.getResource(folder+baseFileName+".km")
       	stdio.writeln("	********************* " + folder+baseFileName+".km" + " loaded ************************")
		       	
       	var unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit
       	var resolvedModelingUnit : org::kermeta::language::structure::ModelingUnit 
       	unresolvedModelingUnit ?= unresolvedModelResource.one
       	unresolvedModelingUnit.canUseCachedStructuralTypeDefinitions := true
       	//checkUnresolved(unresolvedModelingUnit)
        /*resolvedModelingUnit := doResolving(unresolvedModelingUnit)
        
        //workaround to remove cache before saving as it triggers errors in interpreted mode
       	var cache : org::kermeta::language::structure::internal::ModelingUnitCache init resolvedModelingUnit.cache
        resolvedModelingUnit.cache:=void
       	         
        stdio.writeln("	********** saving intermediate resolved but not set file "+ folder+"results/"+baseFileName+"Resolved.km")  	    	
       	stdio.writeln("0")
       //	unresolvedModelResource.saveWithNewURI(folder+"results/"+baseFileName+"Resolved.km")
       	stdio.writeln("1")
       	//workaround to remove cache before saving as it triggers errors in interpreted mode
       	resolvedModelingUnit.cache:=cache
        	stdio.writeln("2")      	

       	resolvedModelingUnit := unresolvedModelingUnit
       	stdio.writeln("3")
       	checkUnresolved(resolvedModelingUnit)
       	stdio.writeln("4")
       	resolvedModelingUnit := doStaticSetting(resolvedModelingUnit)
       	*/
       	resolvedModelingUnit := resolve(unresolvedModelingUnit)
       	checkUnresolved(resolvedModelingUnit)
       	stdio.writeln("unresolved elements checked")
       	//workaround to remove cache before saving as it triggers errors in interpreted mode
       	resolvedModelingUnit.cache:=void
       	unresolvedModelResource.saveWithNewURI(folder+"results/"+baseFileName+"StaticSetted.km")
       	
       	stdio.writeln("	********************* " + folder+"results/"+baseFileName+"StaticSetted.km" + " saved ************************")
       	if not getErrors.isEmpty then
       		stdio.writeln("	********************* Errors detected")
       		getErrors.each{e | stdio.writeln(e.message)}
       	end
	end
	
	/* * 
		obtain the list of errors from the context
	*/
	operation getErrors() : Sequence<ResolverException> is do
		result := ctxt.errors
	end

	/* * 
		launch the entire resolving process
	*/
	operation resolve(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		result := doStaticSetting(doStructureResolving(doTypeAwareMerging(doPrimitiveTypeResolving(doTypeResolving(unresolvedModelingUnit)))))
	end
	/* * 
		launch only the unresolved types resolution after this step all unresolved types should be resolved 
	*/
	operation doTypeResolving(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		//init of context
		stdio.writeln("	********************* 666 Type Resolving *********************")
		ctxt:= LanguageVisitorContext.new.initialize(unresolvedModelingUnit)
		ctxt.verbose := false
		unresolvedModelingUnit.resolveStructureInheritance(ctxt)
		stdio.writeln("	********************* End of Type Resolving *********************")
		result:=unresolvedModelingUnit
	end
	
	
	operation doPrimitiveTypeResolving(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		//stdio.writeln("doPrimitiveTypeResolving")
		stdio.writeln("	********************* Primitive Type Resolving *********************")
		unresolvedModelingUnit.resolvePrimitiveTypeEquivalence(ctxt)
		stdio.writeln("	********************* End of Primitive Type Resolving *********************")
		result:=unresolvedModelingUnit
	end
	/* *
		pass to launch only when there are no more unresolved types
		merge the operations and properties that have the same signature (not possible if some types are unresolved)
	*/
	operation doTypeAwareMerging(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		stdio.writeln("	********************* Type Aware Merging  *********************")
		var mergeCtxt : TypeAwareMergerContext init TypeAwareMergerContext.new
		mergeCtxt.errors:=ctxt.errors
		unresolvedModelingUnit.typeAwareMerge( mergeCtxt)
		stdio.writeln("	********************* End of Type Aware Merging  *********************")
		result:=unresolvedModelingUnit
	
	end
	
	/* *
		resolve the remaining of the unresolved parts of the structure 
		i.e. : unresolved properties and unresolved operations
		not possible until unresolved types are resolved 
		(to resolve the super operation of from you have to resolve the super type where to find it first
		to resolve an opposite, you have to resolve the type of the property first)
		not possible until there is one unique definition for each operation and property (i.e. not possible before type aware merging) 
		
	*/
	operation doStructureResolving(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		//init of context
		stdio.writeln("	********************* Structure Resolving  *********************")
		unresolvedModelingUnit.resolveStructure(ctxt)
		stdio.writeln("	********************* End of Structure Resolving  *********************")
		result:=unresolvedModelingUnit
	end


	/* *
	*	chain all the resolving passes for the structural part of the program
	*/
	operation doResolving(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do
		stdio.writeln("	********************* Resolving " + unresolvedModelingUnit.toString() + " *********************")
       	/*var unresolvedFinder : ResolverUnresolvedFinderVisitor init ResolverUnresolvedFinderVisitor.new

		ctxt := LanguageVisitorContext.new.initialise()
	
   		unresolvedModelingUnit.accept(unresolvedFinder, ctxt)*/
   		
   		doStructureResolving(doTypeAwareMerging(doPrimitiveTypeResolving(doTypeResolving(unresolvedModelingUnit))))
       	stdio.writeln("	********************* " + unresolvedModelingUnit.toString() + " resolved *********************")
       	
       	//checkDangling(unresolvedModelingUnit.containingResource())       	
		//checkUnresolved(unresolvedModelingUnit)
       	
       	result := unresolvedModelingUnit
	end
	
	/* *
		resolve all the behavioral part and add static types
	*/
	operation doStaticSetting(unresolvedModelingUnit : org::kermeta::language::structure::ModelingUnit) : org::kermeta::language::structure::ModelingUnit is do      	
		stdio.writeln("	********************* Static setting " + unresolvedModelingUnit.toString() + " *********************")
		var staticSetterContext : StaticSetterContext init StaticSetterContext.new.initialize(unresolvedModelingUnit)
		
		staticSetterContext.verbose := false
		staticSetterContext.errors  := ctxt.errors
		
		unresolvedModelingUnit.inferContainedExpressionStatic(staticSetterContext)
		
       	stdio.writeln("	********************* " + unresolvedModelingUnit.toString() + " statically set *********************")
       	result := unresolvedModelingUnit
	end
	
	/* * 
		check if an unresolved element remains in the model
	*/
	operation checkUnresolved(aKermetaModelElement : org::kermeta::language::structure::KermetaModelElement) : Void is do
		aKermetaModelElement.eachOwnedElement{p |
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedType) then
				stdio.writeln("UNRESOLVED_TYPE -- typeIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedType).typeIdentifier.toString)
				p.asType(org::kermeta::language::structure::UnresolvedType).usings.each{ us |
					stdio.writeln("|-------------usings: " + us.toString)
				}
				p.asType(org::kermeta::language::structure::UnresolvedType).generics.each{g |
					if (g.isInstanceOf(org::kermeta::language::structure::UnresolvedType)) then
						stdio.writeln("UNRESOLVED_TYPE on GENERICS -- typeIdentifier: " + g.asType(org::kermeta::language::structure::UnresolvedType).typeIdentifier.toString)
						g.asType(org::kermeta::language::structure::UnresolvedType).usings.each{ us |
							stdio.writeln("|-------------usings: " + us.toString)
						}
					end
				}
			end
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedOperation) then
				stdio.writeln("UNRESOLVED_OPERATION -- operationIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedOperation).operationIdentifier.toString)
				stdio.writeln("|-------------from: " + p.asType(org::kermeta::language::structure::UnresolvedOperation).~from.toString)
			end
			if p.isInstanceOf(org::kermeta::language::structure::UnresolvedProperty) then
				stdio.writeln("UNRESOLVED_PROPERTY -- propertyIdentifier: " + p.asType(org::kermeta::language::structure::UnresolvedProperty).propertyIdentifier.toString)
			end
			if p.isInstanceOf(org::kermeta::language::behavior::UnresolvedCall) then
				stdio.writeln("UNRESOLVED_CALL -- name: " + p.asType(org::kermeta::language::behavior::UnresolvedCall).name)
			end
			if p.isInstanceOf(org::kermeta::language::behavior::Expression) then
				if p.asType(org::kermeta::language::behavior::Expression).staticType.isVoid then
					stdio.writeln("-*-*-STATIC_TYPE VOID FOUND")
				end
			end
			if p.isInstanceOf(org::kermeta::language::structure::KermetaModelElement) then
				checkUnresolved(p.asType(org::kermeta::language::structure::KermetaModelElement))
			end
			p
		}
	end

	
}