package org::kermeta::language::structure;
require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/TypeEquality_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/eachOwnedElement_kermeta_aspect.kmt"
require "TypeAwareMergerContext.kmt"
require "TypeRebind.kmt"
using kermeta::standard
using org::kermeta::language::resolver
using kermeta::utils



aspect class KermetaModelElement{

	operation typeAwareMerge(context : TypeAwareMergerContext) is do
		self.eachOwnedElement{ e|
				if e.isInstanceOf(KermetaModelElement) then
					e.asType(KermetaModelElement).typeAwareMerge(context)
				end
			e}// must return somthing for scala compiler to work		
		
	end
}

aspect class ClassDefinition {

	method typeAwareMerge(context : TypeAwareMergerContext) is do
		mergeInheritedClasses(context)
		mergeOperations(context)
		mergeProperties(context)
	end

	operation mergeOperations(context : TypeAwareMergerContext) is do
		var opsToMerge : Sequence<Operation> init Sequence<Operation>.new
		opsToMerge.addAll(ownedOperation)
		ownedOperation.clear
		opsToMerge.each{op|
			var mergeable : Operation init ownedOperation.detect{ ownedOp| ownedOp.mergeableWith(op, context) }
			if not mergeable.isVoid then
				mergeable.merge(op, context)
			else
				ownedOperation.add(op)
			end
		}
	
	end

	operation mergeInheritedClasses(context : TypeAwareMergerContext) is do
	
	
	end
	operation mergeProperties(context: TypeAwareMergerContext) is do
		
	end

}

aspect class Operation {

	operation merge(otherOperation : Operation, context : TypeAwareMergerContext) is do
		if self.body.isVoid 
		and not otherOperation.body.isVoid then
			otherOperation.body.rebind(self.typeParameter, otherOperation.typeParameter)
			self.body:=otherOperation.body
		end
		
		kOwnedTags.addAll(otherOperation.kOwnedTags)
		kTag.addAll(otherOperation.kTag)
		
		otherOperation.~pre.each{c|
			c.body.rebind(self.typeParameter, otherOperation.typeParameter)}
		self.~pre.addAll(otherOperation.~pre)
		
		otherOperation.~post.each{c|
			c.body.rebind(self.typeParameter, otherOperation.typeParameter)}
		self.~post.addAll(otherOperation.~post)

	end
	
	/**says if two operations are mergeable
	
	two operations are mergeable if  : 
	
	-at least one of the body is void
	- is abstract is equal
	- all the MultiplicityElement attributes are equal (isOrdered, isUnique, lower, upper)
	- name is equal
	- ownedParameter is equal in size, in names of parameters, in types of parameters (modulo the typeParameter), in order of parameters
	- owningClass is equal
	- raisedException is equal
	- superOperation is equal
	- type is equal
	*/
	operation mergeableWith(otherOperation : Operation , context : TypeAwareMergerContext) : Boolean is do
		result:=false
		/*stdio.writeln("self "+name+" to merge with "+otherOperation.name+" : "
			+(self.body.isVoid or otherOperation.body.isVoid).toString
			+(self.name == otherOperation.name).toString
			+ (self.owningClass == otherOperation.owningClass).toString
			+(self.isOrdered == otherOperation.isOrdered).toString
			+( self.isUnique == otherOperation.isUnique).toString
			+( self.lower == otherOperation.lower).toString
			+( self.upper == otherOperation.upper).toString
			+( self.ownedParameter.size == otherOperation.ownedParameter.size).toString
			
		)*/
			
		//check quick equality check
		if 	(self.body.isVoid or otherOperation.body.isVoid)
			and self.name == otherOperation.name 
			//and self.owningClass == otherOperation.owningClass 
			and self.isOrdered == otherOperation.isOrdered
			and self.isUnique == otherOperation.isUnique
			and self.lower == otherOperation.lower
			and self.upper == otherOperation.upper
			and self.ownedParameter.size == otherOperation.ownedParameter.size then
			//stdio.writeln("self "+name+" to merge with "+otherOperation.name+" : "+result.toString())
			//stdio.writeln("1")
			//check the parameters names
			var paramNamesAreEqual : Boolean init true
			from var i : Integer init 0
			until i==self.ownedParameter.size loop
				paramNamesAreEqual:= paramNamesAreEqual 
					and self.ownedParameter.elementAt(i).name == otherOperation.ownedParameter.elementAt(i).name
				i:=i+1
			end	
		
			//check type equivalence
			if	paramNamesAreEqual
				and self.typeParameter.size == otherOperation.typeParameter.size then

				//stdio.writeln("2")
				//create set of equivalent typevariables from typeParameters of the operations
				var binding : Sequence<Binding> init Sequence<Binding>.new
				from var i : Integer init 0
				until i==self.typeParameter.size loop
					var equivalentVars : Binding init Binding.new
					equivalentVars.types:=Set<TypeVariable>.new
					equivalentVars.types.add(self.typeParameter.elementAt(i))
					equivalentVars.types.add(otherOperation.typeParameter.elementAt(i))
					binding.add(equivalentVars) 
					i:=i+1
				end	
				
				//check type equivalence for parameters
				var paramTypesAreEquivalent : Boolean init true
				from var i : Integer init 0
				until i==self.ownedParameter.size loop
					if paramTypesAreEquivalent then
						paramTypesAreEquivalent := self.ownedParameter.elementAt(i).type.typeEquivalence(otherOperation.ownedParameter.elementAt(i).type, binding)
						//stdio.writeln("i"+paramTypesAreEquivalent.toString)
					end
					i:=i+1
				end	
				
				//check type equivalence for return type superOperation and Exception Type
				if paramTypesAreEquivalent then
					//stdio.writeln("3")
					
					var superOperationsAreEquivalent : Boolean 
					
					//check type equivalence for superOperation
					if not self.superOperation.isVoid and not self.superOperation.isVoid then
						superOperationsAreEquivalent:=self.superOperation.asType(UnresolvedOperation).~from.typeEquivalence(otherOperation.superOperation.asType(UnresolvedOperation).~from, binding)
					else
						superOperationsAreEquivalent:=self.superOperation.isVoid and self.superOperation.isVoid
					end
					
					
					result:= self.type.typeEquivalence(otherOperation.type, binding)
							and superOperationsAreEquivalent
							and self.raisedException.forAll{selfException|
									otherOperation.raisedException.exists{otherException| selfException.typeEquivalence(otherException, binding)}}
				end
			end	
		end
		//stdio.writeln("self "+name+" to merge with "+otherOperation.name+" : "+result.toString())
	end
	
	
	
}
