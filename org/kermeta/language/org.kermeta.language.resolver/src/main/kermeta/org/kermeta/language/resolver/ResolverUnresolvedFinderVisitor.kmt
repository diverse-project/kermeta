/* $Id:$ 
 * Creation : November 16, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            cguy
 */
package org::kermeta::language::resolver;

//Kermeta metamodel
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
//Visitor of org::kermeta::language::structure
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/StructureVisitor.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/StructureVisitor_Aspect_Accept.kmt"
//Aspect of org::kermeta::language::structure elements to get their qualified name
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetQualifiedName_structure_aspect.kmt"
//Aspect of StructureVisitor for the Resolver
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverContext_Aspect.kmt"
//Aspects of Unresolveds to store the Resolved found by the Resolver
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/UnresolvedType_Aspect_CorrespondingResolvedType.kmt"
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/UnresolvedOperation_Aspect_CorrespondingResolvedOperation.kmt"
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/UnresolvedProperty_Aspect_CorrespondingResolvedProperty.kmt"
//Aspect to prevent the Resolver from visiting several time the same object
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverVisitedAs_Aspect.kmt"
//Resolved finders
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverResolvedTypeFinder.kmt"
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverResolvedPropertyFinder.kmt"
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverResolvedOperationFinder.kmt"

using org::kermeta::language::structure
using language::helpers::structure
using kermeta::exceptions
using org::kermeta::language::resolver
using kermeta::standard
using kermeta::utils

class ResolverUnresolvedFinderVisitor inherits StructureVisitor
{
	reference resolvedTypeFinder : ResolverResolvedTypeFinder
	reference resolvedPropertyFinder : ResolverResolvedPropertyFinder
	reference resolvedOperationFinder : ResolverResolvedOperationFinder
	
	reference unresolvedTypesToBeRemoved : Collection<UnresolvedType>
	
	//The first pass does not resolve UnresolvedOperation (UnresolvedOperation need all ClassDefinition resolved)
	//The second pass does not resolve some UnresolvedType (UnresolvedType may need all Operations resolved)
	//This should probably be rewrite in three really separate passes
	attribute pass : Integer
	
	/*
	* ResolvedTypeFinder call operations
	*/
	operation callTypeFinder(ctxt : StructureVisitorContext) is do
		//If we have already found the corresponding type
		if (ctxt.unresolved.asType(UnresolvedType).correspondingType.isVoid()) then
			ctxt.foundType := ctxt.unresolved.asType(UnresolvedType).correspondingType
		else
			var initialQualifiedPath : Sequence<String> init ctxt.qualifiedPath
			var initialUnresolvedName : String init ctxt.unresolvedName
		
			if (resolvedTypeFinder.isVoid()) then
				resolvedTypeFinder := ResolverResolvedTypeFinder.new
			end
			
			var notTypeTypeContainer : TypeContainer init recursiveGetTypeContainer(ctxt.unresolved.asType(UnresolvedType))
		
			/*
			* TypeParameters cases
			*/
		
			//If the type we are looking for is in a parameter, it can be a typeParameter
			if (notTypeTypeContainer.isInstanceOf(Parameter)) then
				//If the Operation contains a TypeVariable which name is the unresolvedName, we found the good TypeVariable
				ctxt.foundType := notTypeTypeContainer.container.asType(Operation).typeParameter.detect{t|
					t.name.equals(initialUnresolvedName)
				}
				if (ctxt.foundType.isVoid()) then
					//If the ClassDefinition contains a TypeVariable which name is the unresolvedName, we found the good TypeVariable
					ctxt.foundType := notTypeTypeContainer.container.asType(Operation).container.asType(ClassDefinition).typeParameter.detect{t|
						t.name.equals(ctxt.unresolvedName)
					}
				end
			end
			
			//If the type we are looking for is in an operation, it can be a typeParameter
			if (notTypeTypeContainer.isInstanceOf(Operation)) then	
				//If the containing Operation contains a TypeVariable which name is the unresolvedName, we found the good TypeVariable
				ctxt.foundType := notTypeTypeContainer.asType(Operation).typeParameter.detect{t|
					t.name.equals(ctxt.unresolvedName)
				}
				if (ctxt.foundType.isVoid()) then
					//If the ClassDefinition contains a TypeVariable which name is the unresolvedName, we found the good TypeVariable
					ctxt.foundType := notTypeTypeContainer.asType(Operation).container().asType(ClassDefinition).typeParameter.detect{t|
						t.name.equals(ctxt.unresolvedName)
					}
				end
			end
		
			//If the type we are looking for is contained by a Property, it can be a typeParameter
			if (notTypeTypeContainer.isInstanceOf(Property)) then
				var typeVar : TypeVariable
				//If the ClassDefinition contains a TypeVariable which name is the unresolvedName, we found the good TypeVariable
				typeVar := notTypeTypeContainer.container.asType(ClassDefinition).typeParameter.detect{t|
					t.name.equals(ctxt.unresolvedName)
				}
				ctxt.foundType := typeVar
			end
			
			//If the type we are looking for is contained by a ClassDefinition, it can be a typeParameter
			if (notTypeTypeContainer.isInstanceOf(ClassDefinition)) then									
				var typeVar : TypeVariable
				//If the containing ClassDefinition contains a TypeVariable which name is the unresolvedName, we found the good TypeVariable
				typeVar := notTypeTypeContainer.asType(ClassDefinition).typeParameter.detect{t|
					t.name.equals(ctxt.unresolvedName)
				}
				ctxt.foundType := typeVar
			end
			
			/*
			* If we have not found a corresponding TypeParameter
			*/
			
			if (ctxt.foundType.isVoid()) then
				if (ctxt.qualifiedPath.isEmpty() and not ctxt.currentPackage.isVoid()) then
					ctxt.currentPackage.accept(resolvedTypeFinder, ctxt)
					
					if not ctxt.unresolved.asType(UnresolvedType).usings.isEmpty() then
						var i : Integer init 0
						var use : Using
						var found : Boolean init not ctxt.foundType.isVoid()
						from found				
						until found or i == ctxt.unresolved.asType(UnresolvedType).usings.size()
						loop
							use := ctxt.unresolved.asType(UnresolvedType).usings.at(i)
							//If the using does not define an alias
							if (use.toName.isVoid() or use.toName == "") then
								//We now look for a type which the same name and which qualifiedPath is the fromQName
								ctxt.qualifiedPath := use.fromQName.split("::")
								ctxt.currentModelingUnit.accept(resolvedTypeFinder, ctxt)						
							else
								//We need to compare the alias to the unresolvedName and the qualifiedName we are looking for
								//If the alias is name of the type we are looking for
								if (use.toName.equals(initialUnresolvedName)) then
									//We now look for a type which name is the last part of the fromQName and which qualifiedPath is the rest of the fromQName
									ctxt.qualifiedPath := use.fromQName.split("::")
									ctxt.unresolvedName := ctxt.qualifiedPath.last()
									ctxt.qualifiedPath.remove(ctxt.qualifiedPath.last())
									ctxt.currentModelingUnit.accept(resolvedTypeFinder, ctxt)
								else
									//Else if the alias is the first part of the qualifiedPath we are looking for
									if (not ctxt.qualifiedPath.isEmpty()) then
										if (use.toName.equals(ctxt.qualifiedPath.first())) then
											//We now look for a type which the same name and which qualifiedPath is the fromQName
											ctxt.qualifiedPath := use.fromQName.split("::")
											ctxt.qualifiedPath.remove(ctxt.qualifiedPath.last())
											ctxt.currentModelingUnit.accept(resolvedTypeFinder, ctxt)
										end
									end
								end
							end
							
							found := not ctxt.foundType.isVoid()
							i := i + 1
							ctxt.resetCompleteName(initialUnresolvedName, initialQualifiedPath)
						end
					end
				else
					ctxt.currentModelingUnit.accept(resolvedTypeFinder, ctxt)
				end
	
				if (ctxt.foundType.isVoid() and pass == 3 and (ctxt.verbose == 1 or ctxt.verbose == 5 or ctxt.verbose == 4)) then
					var error : String init "Resolver: No corresponding TypeDefinition found for UnresolvedType "
					initialQualifiedPath.each{s|
						error := error + s + "::"
					}
					error := error + initialUnresolvedName + " referenced by "
					
					if (ctxt.currentElement.isInstanceOf(NamedElement)) then
						error := error + ctxt.currentElement.asType(NamedElement).getQualifiedName
					else
						error := error + ctxt.currentElement.toString()
					end
					
					error := error + " and contained by "
					
					if (ctxt.unresolved.container.isInstanceOf(NamedElement)) then
						error := error + ctxt.unresolved.container.asType(NamedElement).getQualifiedName
					else
						error := error + ctxt.unresolved.container.toString()
					end
					
					error := error + "\n	(looked for in current package: " + ctxt.currentPackage.getQualifiedName() + " and in packages: "
					ctxt.unresolved.asType(UnresolvedType).usings.each{u|
						error := error + u.fromQName
						if (not u.equals(ctxt.unresolved.asType(UnresolvedType).usings.last())) then
							error := error + ", "
						end
					}
					error := error + ")"
					
					if (ctxt.exceptions) then
						
						var except : Exception init Exception.new
						except.message := error
						raise except
					else
						stdio.writeln(error)
					end
				end
			end
			if not ctxt.foundType.isVoid() then
				ctxt.unresolved.asType(UnresolvedType).correspondingType := ctxt.foundType
			end
		end
		ctxt.reset()
	end
	
	/*
	* Return the first Container of t which is not a Type
	*/
	operation recursiveGetTypeContainer(t : Type) : TypeContainer is do
		if (not t.container.isVoid()) then
			if t.container.isInstanceOf(UnresolvedType) then
				result := recursiveGetTypeContainer(t.container.asType(UnresolvedType))
			else
				if (not t.typeContainer.isInstanceOf(Type)) then
					result := t.typeContainer
				else
					result := recursiveGetTypeContainer(t.typeContainer.asType(Type))
				end
			end			
		else
			result := void
		end
	end
	
	operation callPropertyFinder(ctxt : StructureVisitorContext) is do
		if (ctxt.unresolved.asType(UnresolvedProperty).correspondingProperty.isVoid()) then
			if (resolvedPropertyFinder.isVoid()) then
				resolvedPropertyFinder := ResolverResolvedPropertyFinder.new
			end
			if (ctxt.qualifiedPath.isEmpty() and not ctxt.currentPackage.isVoid()) then
				ctxt.currentPackage.accept(resolvedPropertyFinder, ctxt)
			else
				ctxt.currentModelingUnit.accept(resolvedPropertyFinder, ctxt)
			end
			if (ctxt.foundProperty.isVoid() and (ctxt.verbose == 2 or ctxt.verbose >= 4)) then
				var qualifiedPath : String init ""
				ctxt.qualifiedPath.each{s|
					qualifiedPath := qualifiedPath + s + "::"
				}
				
				var error : String init "Resolver: No corresponding Property found for UnresolvedProperty " + qualifiedPath + ctxt.unresolvedName
				error := error + " in " + ctxt.unresolved.container.toString()
				
				if (ctxt.exceptions) then
					var except : Exception init Exception.new
					except.message := error
					raise except
				else
					stdio.writeln(error)
				end
			end
			if not ctxt.foundProperty.isVoid() then
				ctxt.unresolved.asType(UnresolvedProperty).correspondingProperty := ctxt.foundProperty
			end
		else
			ctxt.foundProperty := ctxt.unresolved.asType(UnresolvedProperty).correspondingProperty
		end
		ctxt.reset()
	end
	
	/*
	*
	*/
	
	operation callOperationFinder(ctxt : StructureVisitorContext) is do
		//If we have already found the corresponding operation
		if (not ctxt.unresolved.asType(UnresolvedOperation).correspondingOperation.isVoid()) then
			ctxt.foundOperation := ctxt.unresolved.asType(UnresolvedOperation).correspondingOperation
		else
			//If the resolvedOperationFinder is not yet implemented
			if (resolvedOperationFinder.isVoid()) then
				//Implement it
				resolvedOperationFinder := ResolverResolvedOperationFinder.new
			end
			
			//If there is a from			
			if (not ctxt.unresolved.asType(UnresolvedOperation).~from.isVoid()) then
				//And it is a Class
				if (ctxt.unresolved.asType(UnresolvedOperation).~from.isInstanceOf(Class)) then
					//We look for the Operation in the ClassDefinition of this Class
					ctxt.unresolved.asType(UnresolvedOperation).~from.asType(Class).typeDefinition.asType(ClassDefinition).accept(resolvedOperationFinder, ctxt)
				else
					if (not ctxt.unresolved.asType(UnresolvedOperation).~from.isInstanceOf(UnresolvedType) and (ctxt.verbose == 3 or ctxt.verbose == 5)) then
						var error : String init "Resolver: UnresolvedOperation " + ctxt.unresolvedName + " is inherited from a Type which is not a class:" + ctxt.unresolved.asType(UnresolvedOperation).~from.getMetaClass().toString()
						
						if (ctxt.exceptions) then
							var except : Exception init Exception.new
							except.message := error
							raise except
						else
							stdio.writeln(error)
						end
					end
				end
				
			//If there is no from
			else
				//We look for the Operation in all the superTypes of the of the container of the UnresolvedOperation			
				var containingClassDef : ClassDefinition init ctxt.unresolved.asType(UnresolvedOperation).container.container.asType(ClassDefinition)
				containingClassDef.superType.each{st|
					st.accept(resolvedOperationFinder, ctxt)					
				}
			end

			if (ctxt.foundOperation.isVoid() and ctxt.verbose >= 3) then			
				var error : String init "Resolver: No corresponding Operation found for UnresolvedOperation " + ctxt.unresolvedName
				error := error + " in " + ctxt.unresolved.container.asType(Operation).container.asType(ClassDefinition).name
				if (not ctxt.unresolved.asType(UnresolvedOperation).~from.isVoid()) then
					error := error + " from " + ctxt.unresolved.asType(UnresolvedOperation).~from.toString()
				end
				
				if (ctxt.exceptions) then
					var except : Exception init Exception.new
					except.message := error
					raise except
				else
					stdio.writeln(error)
				end
			end
			if not ctxt.foundOperation.isVoid() then
				ctxt.unresolved.asType(UnresolvedOperation).correspondingOperation := ctxt.foundOperation
			end
		end
		ctxt.reset()
	end


	/*
	* Visit methods
	*/

	method visitClass(c : Class, ctxt : StructureVisitorContext) is do
		if (c.visitedAsClass.isVoid) then
			c.visitedAsClass := true
		
			//Visiting inherited properties from ParameterizedType
			visitParameterizedType(c, ctxt)
		end
	end
	
	method visitClassDefinition(c : ClassDefinition, ctxt : StructureVisitorContext) is do
		if (c.visitedAsClassDefinition.isVoid) then	
			c.visitedAsClassDefinition := true
				
			//Visiting inherited properties from GenericTypeDefinition
			visitGenericTypeDefinition(c, ctxt)
			
			//Visiting contained Properties	and handling UnresolvedProperties
			var propertiesToBeAdded : Collection<Property> init Set<Property>.new
			var propertiesToBeRemoved : Collection<UnresolvedProperty> init Set<UnresolvedProperty>.new
			var foundProperty : Property
			c.ownedAttribute.each{a|
				
				ctxt.currentElement := c
				
				a.accept(self, ctxt)
				if (not ctxt.unresolved.isVoid()) then
					callPropertyFinder(ctxt)
					foundProperty := ctxt.getFoundProperty()
					if not foundProperty.isVoid() then
						propertiesToBeRemoved.add(a.asType(UnresolvedProperty))					
						propertiesToBeAdded.add(foundProperty)
					end
				end
			}
			propertiesToBeRemoved.each{tbr|
				c.ownedAttribute.remove(tbr.asType(Property))
			}
			propertiesToBeAdded.each{tba|
				c.ownedAttribute.add(tba)
				tba.accept(self, ctxt)
			}
						
			//Visiting contained Operations	and handling UnresolvedOperations
			var operationsToBeAdded : Collection<Operation> init Set<Operation>.new
			var operationsToBeRemoved : Collection<UnresolvedOperation> init Set<UnresolvedOperation>.new
			var foundOperation : Operation
			c.ownedOperation.each{o|
				
				ctxt.currentElement := c
				
				o.accept(self, ctxt)
				
				if (pass >= 2) then
					if (not ctxt.unresolved.isVoid()) then	
						callOperationFinder(ctxt)
						foundOperation := ctxt.getFoundOperation()
						if not foundProperty.isVoid() then
							operationsToBeRemoved.add(o.asType(UnresolvedOperation))
							operationsToBeAdded.add(foundOperation)
						end
					end
				end
			}
			operationsToBeRemoved.each{tbr|
				c.ownedOperation.remove(tbr.asType(Operation))
			}
			operationsToBeAdded.each{tba|
				c.ownedOperation.add(tba)
				tba.accept(self, ctxt)
			}
		end
	end
		
	method visitDataType(d : DataType, ctxt : StructureVisitorContext) is do
		if (d.visitedAsDataType.isVoid) then
			d.visitedAsDataType := true
		
			//Visiting inherited properties from TypeDefinition
			visitTypeDefinition(d, ctxt)			
		end
	end
	
	method visitEnumeration(e : Enumeration, ctxt : StructureVisitorContext) is do
		if (e.visitedAsEnumeration.isVoid) then
			e.visitedAsEnumeration := true
	
			//Visiting inherited properties from DataType
			visitDataType(e, ctxt)
		end
	end
	
	method visitFunctionType(f : FunctionType, ctxt : StructureVisitorContext) is do
		if (f.visitedAsFunctionType.isVoid) then
			f.visitedAsFunctionType := true

			//Visiting inherited properties from TypeContainer
			visitTypeContainer(f, ctxt)			
			
			//Visiting left and right Types and handling Unresolved
			if (not f.right.isVoid) then
				if (isVisitable(f.right)) then
				
					ctxt.currentElement := f
				
					f.right.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then
						callTypeFinder(ctxt)
						var foundType : Type init ctxt.getFoundType
						if not foundType.isVoid() then
							f.right := foundType
							if (foundType.isInstanceOf(Class)) then
								f.containedType.add(foundType)
							end
						end
					end
				end
			end
			if (not f.left.isVoid) then
				if (isVisitable(f.left)) then
				
					ctxt.currentElement := f
				
					f.left.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then
						callTypeFinder(ctxt)
						var foundType : Type init ctxt.getFoundType
						if not foundType.isVoid() then
							f.left := foundType
							if (foundType.isInstanceOf(Class)) then
								f.containedType.add(foundType)
							end
						end
					end
				end
			end
		end
	end
	
	method visitGenericTypeDefinition(g : GenericTypeDefinition, ctxt : StructureVisitorContext) is do
		if (g.visitedAsGenericTypeDefinition.isVoid) then
			g.visitedAsGenericTypeDefinition := true
		
			//Visiting inherited properties from TypeDefinition
			visitTypeDefinition(g, ctxt)		
			
			//Visiting referenced TypeVariables and handling Unresolveds
			var typeParameterToBeAdded : Collection<TypeVariable> init Set<TypeVariable>.new
			var typeParameterToBeRemoved : Collection<UnresolvedType> init Set<UnresolvedType>.new
			var foundType : Type
			g.typeParameter.each{t|
				if (isVisitable(t)) then
				
					ctxt.currentElement := g
				
					t.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then
						callTypeFinder(ctxt)
						foundType := ctxt.getFoundType
						if not foundType.isVoid() then
							typeParameterToBeRemoved.add(t.asType(UnresolvedType))
							typeParameterToBeAdded.add(foundType().asType(TypeVariable))
							if (foundType.isInstanceOf(Class)) then
								g.containedType.add(foundType)
							end
						end
					end
				end
			}
			typeParameterToBeRemoved.each{tbr|
				g.typeParameter.remove(tbr.asType(TypeVariable))
			}
			typeParameterToBeAdded.each{tba|
				g.typeParameter.add(tba)
				tba.accept(self, ctxt)
			}
		end
	end
	
	method visitModelType(m : ModelType, ctxt : StructureVisitorContext) is do
		if (m.visitedAsModelType.isVoid) then
			m.visitedAsModelType := true
		
			//Visiting inherited properties from TypeDefinition
			visitTypeDefinition(m, ctxt)
		end
	end
	
	method visitModelTypeVariable(m : ModelTypeVariable, ctxt : StructureVisitorContext) is do
		if (m.visitedAsModelTypeVariable.isVoid) then
			m.visitedAsModelTypeVariable := true
		
			//Visiting inherited properties from TypeVariable
			visitTypeVariable(m, ctxt)			
			
			//Visiting referenced VirtualTypes and handling Unresolveds
			var virtualTypeToBeAdded : Collection<VirtualType> init Set<VirtualType>.new
			var virtualTypeToBeRemoved : Collection<UnresolvedType> init Set<UnresolvedType>.new
			var foundType : Type
			m.virtualType.each{t|
				if (isVisitable(t)) then
				
					ctxt.currentElement := m
				
					t.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then						
						callTypeFinder(ctxt)
						foundType := ctxt.getFoundType
						if not foundType.isVoid() then
							virtualTypeToBeRemoved.add(t.asType(UnresolvedType))
							virtualTypeToBeAdded.add(foundType.asType(VirtualType))
							if (foundType.isInstanceOf(Class)) then
								m.containedType.add(foundType)
							end
						end
					end
				end
			}
			virtualTypeToBeRemoved.each{tbr|
				m.virtualType.remove(tbr.asType(VirtualType))
			}
			virtualTypeToBeAdded.each{tba|
				m.virtualType.add(tba)
				tba.accept(self, ctxt)
			}
		end
	end
	
	method visitModelingUnit(m : ModelingUnit, ctxt : StructureVisitorContext) is do
		if (m.visitedAsModelingUnit.isVoid) then
			m.visitedAsModelingUnit := true
			
			unresolvedTypesToBeRemoved := Set<UnresolvedType>.new
			
			ctxt.currentModelingUnit := m
			//Visiting inherited properties from TypeDefinitionContainer
			visitTypeDefinitionContainer(m, ctxt)
			
			pass := 1
			
			//Visiting contained Packages
			m.packages.each{p|
				p.accept(self, ctxt)
			}
			
			pass := 2
			
			//Visiting contained Packages
			m.packages.each{p|
				p.accept(self, ctxt)
			}
			
			pass := 3
			
			//Visiting contained Packages
			m.packages.each{p|
				p.accept(self, ctxt)
			}
			
			//When we have visited all the elements of the modeling unit, for each UnresolvedType which has been resolved
			unresolvedTypesToBeRemoved.each{u|
				//We add the corresponding resolved type to the typeContainer of u
				u.typeContainer.containedType.add(u.correspondingType)
				//And we remove u
				u.typeContainer.containedType.remove(u)
			}
			
		end
	end
	
	method visitMultiplicityElement(m : MultiplicityElement, ctxt : StructureVisitorContext) is do
		if (m.visitedAsMultiplicityElement.isVoid) then
			m.visitedAsMultiplicityElement := true
			
			//Visiting inherited properties from TypedElement
			visitTypedElement(m, ctxt)
		end
	end
	
	method visitObjectTypeVariable(o : ObjectTypeVariable, ctxt : StructureVisitorContext) is do
		if (o.visitedAsObjectTypeVariable.isVoid) then	
			o.visitedAsObjectTypeVariable := true
		
			//Visiting inherited properties from TypeVariable
			visitTypeVariable(o, ctxt)
		end
	end
	
	method visitOperation(o : Operation, ctxt : StructureVisitorContext) is do
		if (o.visitedAsOperation.isVoid) then
			o.visitedAsOperation := true
		
			//Visiting inherited properties from MultiplicityElement
			visitMultiplicityElement(o, ctxt)	
			
			//Visiting referenced Types and handling Unresolveds
			var raisedExceptionsToBeAdded : Collection<Type> init Set<Type>.new
			var raisedExceptionsToBeRemoved : Collection<UnresolvedType> init Set<UnresolvedType>.new
			var foundType : Type
			o.raisedException.each{e|
				if (isVisitable(e)) then
				
					ctxt.currentElement := o
				
					e.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then						
						callTypeFinder(ctxt)
						foundType := ctxt.getFoundType
						if not foundType.isVoid() then
							raisedExceptionsToBeRemoved.add(e.asType(UnresolvedType))
							raisedExceptionsToBeAdded.add(foundType)
							if (foundType.isInstanceOf(Class)) then
								o.containedType.add(foundType)
							end
						end
					end
				end
			}
			raisedExceptionsToBeRemoved.each{tbr|
				o.raisedException.remove(tbr)
			}
			raisedExceptionsToBeAdded.each{tba|
				o.raisedException.add(tba)
				tba.accept(self, ctxt)
			}
			
			//Visiting owned Parameters
			o.ownedParameter.each{p|
				p.accept(self, ctxt)
			}
			
			//Visiting superOperation
			if (not o.superOperation.isVoid) then
				
				ctxt.currentElement := o
				
				o.superOperation.accept(self, ctxt)
				if (pass >= 2) then
					if (not ctxt.unresolved.isVoid()) then
						callOperationFinder(ctxt)
						var foundOperation : Operation init ctxt.getFoundOperation()
						if not foundOperation.isVoid() then
							o.superOperation := foundOperation
						end
					end
				end
			end
			
			//Deleting UnresolvedOperations (the only one is superOperation)
			o.ownedUnresolvedOperations.clear()
			
			//Visiting owningClass
			if (not o.owningClass.isVoid) then
				o.owningClass.accept(self, ctxt)
			end
			
			//Visiting referenced TypeVariables and handling Unresolved
			var typeParameterToBeAdded : Collection<TypeVariable> init Set<TypeVariable>.new
			var typeParameterToBeRemoved : Collection<UnresolvedType> init Set<UnresolvedType>.new
			o.typeParameter.each{t|
				if (isVisitable(t)) then
				
					ctxt.currentElement := o
				
					t.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then
						callTypeFinder(ctxt)
						foundType := ctxt.getFoundType
						if not foundType.isVoid() then
							typeParameterToBeRemoved.add(t.asType(UnresolvedType))
							typeParameterToBeAdded.add(foundType.asType(TypeVariable))
							if (foundType.isInstanceOf(Class)) then
								o.containedType.add(foundType)
							end
						end		
					end
				end
			}
			typeParameterToBeRemoved.each{tbr|
				o.typeParameter.remove(tbr.asType(TypeVariable))
			}
			typeParameterToBeAdded.each{tba|
				o.typeParameter.add(tba)
				tba.accept(self, ctxt)
			}
		end
	end

	method visitPackage(p : Package, ctxt : StructureVisitorContext) is do
		if (p.visitedAsPackage.isVoid) then
			p.visitedAsPackage := true
			
			ctxt.currentPackage := p
			//Visiting inherited properties from TypeDefinitionContainer
			visitTypeDefinitionContainer(p, ctxt)
			
			//Visiting contained Packages
			p.nestedPackage.each{n|
				n.accept(self, ctxt)
			}
		end
	end
	
	method visitParameter(p : Parameter, ctxt : StructureVisitorContext) is do
		if (p.visitedAsParameter.isVoid) then
			p.visitedAsParameter := true
		
			//Visiting inherited properties from MultiplicityElement
			visitMultiplicityElement(p, ctxt)
			
			//Visiting referenced Operation and handling Unresolved
			if (not p.~operation.isVoid()) then
				
				ctxt.currentElement := p
				
				p.~operation.accept(self, ctxt)
				if (not ctxt.unresolved.isVoid()) then
					callOperationFinder(ctxt)
					var foundOperation : Operation init ctxt.getFoundOperation()
					if not foundOperation.isVoid() then
						p.~operation := foundOperation
					end
				end
			end
		end
	end
	
	method visitParameterizedType(p : ParameterizedType, ctxt : StructureVisitorContext) is do
		if (p.visitedAsParameterizedType.isVoid) then
			p.visitedAsParameterizedType := true
			
			//Visiting referenced TypeVariableBindings
			p.virtualTypeBinding.each{v|
				v.accept(self, ctxt)
			}
			
			//Visiting referenced TypeVariableBindings
			p.typeParamBinding.each{t|
				t.accept(self, ctxt)
			}
		end
	end
	
	method visitPrimitiveType(p : PrimitiveType, ctxt : StructureVisitorContext) is do
		if (p.visitedAsPrimitiveType.isVoid) then
			p.visitedAsPrimitiveType := true

			//Visiting inherited properties from DataType
			visitDataType(p, ctxt)
			
			//Visiting instanceType and handling Unresolved
			if (not p.instanceType.isVoid) then
				if (isVisitable(p.instanceType)) then
				
					ctxt.currentElement := p
				
					p.instanceType.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then
						callTypeFinder(ctxt)
						var foundType : Type init ctxt.getFoundType
						if not foundType.isVoid() then
							p.instanceType := foundType
							if (foundType.isInstanceOf(Class)) then
								p.containedType.add(foundType)
							end
						end
					end
				end
			end
		end
	end
	
	method visitProductType(p : ProductType, ctxt : StructureVisitorContext) is do
		if (p.visitedAsProductType.isVoid) then
			p.visitedAsProductType := true

			//Visiting inherited properties from TypeContainer
			visitTypeContainer(p, ctxt)
			
			//Visiting Types and handling Unresolved
			var typesToBeAdded : Collection<Type> init Set<Type>.new
			var typesToBeRemoved : Collection<UnresolvedType> init Set<UnresolvedType>.new
			var foundType : Type
			p.type.each{t|
				if (isVisitable(t)) then
				
					ctxt.currentElement := p
				
					t.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then						
						callTypeFinder(ctxt)
						foundType := ctxt.getFoundType
						if not foundType.isVoid() then
							typesToBeRemoved.add(t.asType(UnresolvedType))
							typesToBeAdded.add(foundType)
							if (foundType.isInstanceOf(Class)) then
								p.containedType.add(foundType)
							end
						end						
					end
				end
			}
			typesToBeRemoved.each{tbr|
				p.type.remove(tbr)
			}
			typesToBeAdded.each{tba|
				p.type.add(tba)
				tba.accept(self, ctxt)
			}
		end
	end
	
	method visitProperty(p : Property, ctxt : StructureVisitorContext) is do
		if (p.visitedAsProperty.isVoid) then
			p.visitedAsProperty := true
			
			//Visiting properties inherited from MultiplicityElement
			visitMultiplicityElement(p, ctxt)
		
			//Visiting opposite and handling Unresolved
			if (not p.opposite.isVoid) then
				
				ctxt.currentElement := p
				
				p.opposite.accept(self, ctxt)
				if (not ctxt.unresolved.isVoid()) then
					callPropertyFinder(ctxt)
					var foundProperty : Property init ctxt.getFoundProperty()
					if not foundProperty.isVoid() then
						p.opposite := foundProperty
						//Deleting UnresolvedProperties (the only one is opposite)
						p.ownedUnresolvedProperties.clear()
					end
				end
			end
			
			//Visiting owningClass and handling Unresolved
			if (not p.owningClass.isVoid) then
				
				ctxt.currentElement := p
				
				p.owningClass.accept(self, ctxt)
			end
		end
	end
	
	method visitTypeContainer(tc : TypeContainer, ctxt : StructureVisitorContext) is do
		if (tc.visitedAsTypeContainer.isVoid) then
			tc.visitedAsTypeContainer := true
			
			//Visiting types and handling Unresolved
			var typesToVisit : Collection<Type> init Set<Type>.new
			var foundType : Type
			tc.containedType.each{t|
				if (isVisitable(t)) then
				
					ctxt.currentElement := tc
				
					t.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then						
						callTypeFinder(ctxt)
						foundType := ctxt.getFoundType
						if not foundType.isVoid() then
							unresolvedTypesToBeRemoved.add(t.asType(UnresolvedType))
							typesToVisit.add(foundType)
						end
					end
				end
			}
			typesToVisit.each{tba|
				tba.accept(self, ctxt)
			}
		end
	end
		
	method visitTypeDefinition(t : TypeDefinition, ctxt : StructureVisitorContext) is do
		if(t.visitedAsTypeDefinition.isVoid()) then
			t.visitedAsTypeDefinition := true
		
			//Visiting contained Types
			visitTypeContainer(t, ctxt)	
		
			//Visiting superTypes and handling Unresolved
			var typesToBeAdded : Collection<Type> init Set<Type>.new
			var typesToBeRemoved : Collection<UnresolvedType> init Set<UnresolvedType>.new
			var foundType : Type
			t.superType.each{y|
				if (isVisitable(y)) then
				
					ctxt.currentElement := t
				
					y.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then
						callTypeFinder(ctxt)
						foundType := ctxt.getFoundType
						if not foundType.isVoid() then
							typesToBeRemoved.add(y.asType(UnresolvedType))
							// do not introduce circular inheritance to self
							// this deal with the special case if we are org::kermeta::language::structure::Object and points to self
							// then do not add it, since it was introduced by the parser
							
							if foundType.getQualifiedName != t.getQualifiedName then
								typesToBeAdded.add(foundType)
								if (foundType.isInstanceOf(Class)) then
									t.containedType.add(foundType)
								end
							end
						end
					end
				end
			}
			typesToBeRemoved.each{tbr|
				t.superType.remove(tbr)
			}
			typesToBeAdded.each{tba|
				t.superType.add(tba)
				tba.accept(self, ctxt)
			}
			
			//Visiting typeMappings
			t.typeMappings.each{m|
				m.accept(self, ctxt)
			}
		end
	end
	
	method visitTypeDefinitionContainer(t : TypeDefinitionContainer, ctxt : StructureVisitorContext) is do
		if (t.visitedAsTypeDefinitionContainer.isVoid()) then
			t.visitedAsTypeDefinitionContainer := true
			
			//Visiting typeDefinitions
			t.ownedTypeDefinition.each{o|
				o.accept(self, ctxt)
			}
		end
	end
	
	method visitTypeMapping(t : TypeMapping, ctxt : StructureVisitorContext) is do
		if (t.visitedAsTypeMapping.isVoid()) then
			t.visitedAsTypeMapping := true
			
			//Visiting target and source Types and handling Unresolved
			if (isVisitable(t.targetType)) then
				
				ctxt.currentElement := t
				
				t.targetType.accept(self, ctxt)
				if (not ctxt.unresolved.isVoid()) then
					callTypeFinder(ctxt)
					var foundType : Type init ctxt.getFoundType
					if not foundType.isVoid() then
						t.targetType := foundType
						t.containedType.add(foundType)
					end
				end
			end
			
			if (isVisitable(t.sourceType)) then
				t.sourceType.accept(self, ctxt)
			end
		end
	end
	
	method visitTypeVariable(t : TypeVariable, ctxt : StructureVisitorContext) is do
		if (t.visitedAsTypeVariable.isVoid()) then
			t.visitedAsTypeVariable := true
			
			//Visiting properties inherited from TypeContainer
			visitTypeContainer(t, ctxt)
			
			//Visiting superType and handling Unresolved
			if (not t.supertype.isVoid()) then
				if (isVisitable(t.supertype)) then
				
					ctxt.currentElement := t
				
					t.supertype.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then
						callTypeFinder(ctxt)
						var foundType : Type init ctxt.getFoundType
						if not foundType.isVoid() then
							t.supertype := foundType
							if (foundType.isInstanceOf(Class)) then
								t.containedType.add(foundType)
							end
						end
					end
				end
			end
		end
	end
	
	method visitTypeVariableBinding(t : TypeVariableBinding, ctxt : StructureVisitorContext) is do
		if (t.visitedAsTypeVariableBinding.isVoid()) then
			t.visitedAsTypeVariableBinding := true
			
			//Visiting properties inherited from TypeContainer
			visitTypeContainer(t, ctxt)
			
			//Visiting variable and handling Unresolved
			if (isVisitable(t.variable)) then
				
				ctxt.currentElement := t
				
				t.variable.accept(self, ctxt)
				if (not ctxt.unresolved.isVoid()) then
					callTypeFinder(ctxt)
					var foundType : Type init ctxt.getFoundType
					if not foundType.isVoid() then
						t.variable := foundType.asType(TypeVariable)
						if (foundType.isInstanceOf(Class)) then
							t.containedType.add(foundType)
						end
					end
				end
			end
			
			//Visiting type and handling Unresolved
			if (isVisitable(t.type)) then
				
				ctxt.currentElement := t
				
				t.type.accept(self, ctxt)
				if (not ctxt.unresolved.isVoid()) then
					callTypeFinder(ctxt)
					var foundType : Type init ctxt.getFoundType
					if not foundType.isVoid() then
						t.type := ctxt.foundType
						if (foundType.isInstanceOf(Class)) then
							t.containedType.add(foundType)
						end
					end	
				end
			end
		end
	end
	
	method visitTypedElement(t : TypedElement, ctxt : StructureVisitorContext) is do
		if (t.visitedAsTypedElement.isVoid()) then
			t.visitedAsTypedElement := true
			
			//Visiting properties inherited from TypeContainer
			visitTypeContainer(t, ctxt)
			
			//Visiting type and handling Unresolved
			if (not t.type.isVoid()) then
				if (isVisitable(t.type)) then
				
					ctxt.currentElement := t
				
					t.type.accept(self, ctxt)
					if (not ctxt.unresolved.isVoid()) then
						callTypeFinder(ctxt)
						var foundType : Type init ctxt.getFoundType
						if not foundType.isVoid() then
							t.type := foundType
							if (foundType.isInstanceOf(Class)) then
								t.containedType.add(foundType)
							end
						end
					end
				end
			end
		end
	end

	method visitUnresolvedOperation(u : UnresolvedOperation, ctxt : StructureVisitorContext) is do
		//Visiting u.from and handling Unresolved
		if (not u.~from.isVoid()) then
			var foundType : Type
			if (isVisitable(u.~from)) then
				
				ctxt.currentElement := u
				
				u.~from.accept(self, ctxt)
				if (not ctxt.unresolved.isVoid()) then						
					callTypeFinder(ctxt)
					foundType := ctxt.getFoundType
					if not foundType.isVoid() then
						unresolvedTypesToBeRemoved.add(u.~from.asType(UnresolvedType))
						foundType.accept(self, ctxt)
					end
				end
			end
		end
		ctxt.unresolved := u
		ctxt.unresolvedName := u.operationIdentifier
		ctxt.identifierCounter := 0
	end
	
	method visitUnresolvedProperty(u : UnresolvedProperty, ctxt : StructureVisitorContext) is do
		ctxt.unresolved := u
		ctxt.qualifiedPath := u.propertyIdentifier.split("::")
		ctxt.qualifiedPath.remove(ctxt.qualifiedPath.last())
		ctxt.unresolvedName := u.propertyIdentifier.split("::").last()
		ctxt.identifierCounter := 0
	end
	
	method visitUnresolvedType(u : UnresolvedType, ctxt : StructureVisitorContext) is do
		ctxt.unresolved := u
		ctxt.qualifiedPath := u.typeIdentifier.split("::")
		ctxt.qualifiedPath.remove(ctxt.qualifiedPath.last())
		ctxt.unresolvedName := u.typeIdentifier.split("::").last()
		ctxt.identifierCounter := 0
	end
	
	method visitVirtualType(v : VirtualType, ctxt : StructureVisitorContext) is do
		if (v.visitedAsVirtualType.isVoid) then
			v.visitedAsVirtualType := true
			
			//Visiting properties inherited from ObjectTypeVariable
			visitObjectTypeVariable(v, ctxt)
			
			//Visiting modelType and handling Unresolved
			if (isVisitable(v.modelType)) then
				
				ctxt.currentElement := v
				
				v.modelType.accept(self, ctxt)
				if (not ctxt.unresolved.isVoid()) then
					callTypeFinder(ctxt)
					var foundType : Type init ctxt.getFoundType
					if not foundType.isVoid() then
						v.modelType := foundType.asType(ModelTypeVariable)
						if (foundType.isInstanceOf(Class)) then
							v.containedType.add(foundType)
						end
					end
				end
			end
			
			//Visiting typeParamBindings
			v.typeParamBinding.each{t|
				t.accept(self, ctxt)
			}
		end
	end
}
