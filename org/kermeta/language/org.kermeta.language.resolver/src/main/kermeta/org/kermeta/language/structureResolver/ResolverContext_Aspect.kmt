/* $Id:$ 
 * Creation : November 16, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            cguy
 */

package org::kermeta::language::resolver;

require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"

require "../resolver/ResolverException.kmt"

using org::kermeta::language::structure
using org::kermeta::language::resolver
using kermeta::standard
using kermeta::utils

class MapEntryTypeDef {

	reference x : String

	reference y : TypeDefinition

	operation initialize(aX :String, aY : TypeDefinition) : MapEntryTypeDef is do
		x:=aX
		y:=aY
		result:=self
	end 
}

class LanguageVisitorContext {
	attribute errors : OrderedSet<ResolverException>
	//Modeling unit the UnresolvedFinder is currently visiting
	reference currentModelingUnit : ModelingUnit
	//Package the UnresolvedFinder is currently visiting
	reference currentPackage : Package
	
	reference currentClassDef : ClassDefinition
	
	reference currentOperation : Operation
	//KermetaModelElement the UnresolvedFinder is currently visiting (except Unresolved)
	reference currentElement : KermetaModelElement
	//Unresolved object we want to replace
	//reference unresolved : Unresolved
	//Name of the unresolved object we want to replace
	//attribute unresolvedName : String
	//Qualified path to resolved object
	attribute qualifiedPath : Sequence<String>
	//Counter pointing the object name currently visited by the ResolvedFinder
	attribute identifierCounter : Integer
	
	//Resolved objects found by the ResolvedFinder
	reference foundType : Type
	reference foundOperation : Operation
	reference foundProperty : Property
	
	
	attribute typedefTable : Hashtable<String, Sequence<MapEntryTypeDef>>
	
	operation initialize(mu : ModelingUnit) : LanguageVisitorContext is do
		errors := OrderedSet<ResolverException>.new
		currentModelingUnit:=mu
		//TODO initialize the table of Type definitions 
		result := self
	end
	
	//Return the name of the Object currently pointed by identifierCounter
	operation getCurrentIdentifier() : String is do
		result := qualifiedPath.at(identifierCounter)
		identifierCounter := identifierCounter+1
	end
	
	//Return true if the last returned identifier is the last of the qualified path
	operation currentIdentifierIsLast() : Boolean is do
		result := (identifierCounter == qualifiedPath.size())
	end
	
	//Return true if the next returned identifier is the last of the qualified path
	operation nextIdentifierIsLast() : Boolean is do
		result := (identifierCounter == qualifiedPath.size()-1)
	end
	
	//Return the last identifier of the qualified path
	operation getLastIdentifier() : String is do
		result := qualifiedPath.last()
	end
	
	//Return the found type before resetting it
	operation getFoundType() : Type is do
		result := foundType
		foundType := void
	end
	
	//Return the found property before resetting it
	operation getFoundProperty() : Property is do
		result := foundProperty
		foundProperty := void
	end
	
	//Return the found operation before resetting it
	operation getFoundOperation() : Operation is do
		result := foundOperation
		foundOperation := void
	end
	
	/*operation reset() : Void is do
		unresolved := void
		unresolvedName := void
		resetCompleteName("", Sequence<String>.new)
	end
		
	operation resetCompleteName(n : String, q : Sequence<String>) : Void is do
		unresolvedName := n
		qualifiedPath := q
		identifierCounter := 0
	end*/
}