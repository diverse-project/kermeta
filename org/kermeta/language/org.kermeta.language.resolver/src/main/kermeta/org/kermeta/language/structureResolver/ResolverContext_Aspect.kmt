/* $Id:$ 
 * Creation : November 16, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            cguy
 */

package org::kermeta::language::resolver;

require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverException.kmt"

using org::kermeta::language::structure
using org::kermeta::language::behavior
using org::kermeta::language::resolver
using kermeta::standard
using kermeta::utils

class MapEntryTypeDef {

	reference x : String

	reference y : TypeDefinition

	operation initialize(aX :String, aY : TypeDefinition) : MapEntryTypeDef is do
		x:=aX
		y:=aY
		result:=self
	end 
}

aspect class LanguageVisitorContext {
	attribute errors : Sequence<ResolverException>
	//Metamodels the UnresolvedFinder is currently visiting
	reference currentMetamodels : Collection<Metamodel>
	//Package the UnresolvedFinder is currently visiting
	reference currentPackage : Package
	//Metamodel currently built
	reference currentlyBuiltMetamodel : Metamodel
	
	reference currentClassDef : ClassDefinition
	
	reference currentOperation : Operation
	//KermetaModelElement the UnresolvedFinder is currently visiting (except Unresolved)
	reference currentElement : KermetaModelElement
	//Qualified path to resolved object
	attribute qualifiedPath : Sequence<String>
	//Counter pointing the object name currently visited by the ResolvedFinder
	attribute identifierCounter : Integer
	
	//Resolved objects found by the ResolvedFinder
	reference foundType : Type
	reference foundOperation : Operation
	reference foundProperty : Property
	
	attribute typedefTable : Hashtable<String, Sequence<MapEntryTypeDef>>
	
	attribute primitiveTypesTable : Hashtable<PrimitiveType, Type>
	
	attribute verbose : Boolean
	
	//Stack of UnresolvedCall that have not been resolved and which target.staticType is a ModelType
	attribute unresolvedCallToTransformationStack : Collection<UnresolvedCall>
	
	operation initialize(mms : Collection<Metamodel>, currentMM : Metamodel, isVerbose : Boolean) : LanguageVisitorContext is do
		errors := Sequence<ResolverException>.new
		currentMetamodels:=mms
		currentlyBuiltMetamodel := currentMM
		//TODO initialize the table of Type definitions 
	 	verbose := isVerbose
		result := self
	end
	
	//Return the name of the Object currently pointed by identifierCounter
	operation getCurrentIdentifier() : String is do
		result := qualifiedPath.at(identifierCounter)
		identifierCounter := identifierCounter+1
	end
	
	//Return true if the last returned identifier is the last of the qualified path
	operation currentIdentifierIsLast() : Boolean is do
		result := (identifierCounter == qualifiedPath.size())
	end
	
	//Return true if the next returned identifier is the last of the qualified path
	operation nextIdentifierIsLast() : Boolean is do
		result := (identifierCounter == qualifiedPath.size()-1)
	end
	
	//Return the last identifier of the qualified path
	operation getLastIdentifier() : String is do
		result := qualifiedPath.last()
	end
	
	//Return the found type before resetting it
	operation getFoundType() : Type is do
		result := foundType
		foundType := void
	end
	
	//Return the found property before resetting it
	operation getFoundProperty() : Property is do
		result := foundProperty
		foundProperty := void
	end
	
	//Return the found operation before resetting it
	operation getFoundOperation() : Operation is do
		result := foundOperation
		foundOperation := void
	end
	
}