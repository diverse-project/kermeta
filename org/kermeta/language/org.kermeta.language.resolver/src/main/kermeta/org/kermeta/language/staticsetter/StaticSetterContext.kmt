/* $Id:$ 
 * Creation : October 29, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise, xdolques
 */


package org::kermeta::language::staticsetter;


require kermeta

require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/ResolverException.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetQualifiedName_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/CreationHelper.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/MetamodelCollection_GetTypeDefinitionByName.kmt"


using kermeta::standard
using kermeta::utils
using org::kermeta::language::structure
using org::kermeta::language::behavior
using org::kermeta::language::resolver
using kmt::language::helpers::structure

class StaticSetterContext
{
	reference errors : Sequence<ResolverException>
	
	//used to store context for late resolving of lambdaexpressions
	reference waitingContext : Sequence<ToBeResolvedLater>

	attribute verbose : Boolean

	operation initialize(mms : Collection<Metamodel>) : StaticSetterContext is do
	 	result := self
	 	currentMetamodels := mms
	 	waitingContext:=Sequence<ToBeResolvedLater>.new
	 	verbose := false	 	
	end
	
	operation saveWaitingContext(current : Expression) : Void is do
		var tobeResolved : ToBeResolvedLater init ToBeResolvedLater.new
		waitingContext.add(tobeResolved)
		var newContext : StaticSetterContext init StaticSetterContext.new
		tobeResolved.context:=newContext
		newContext.errors:=errors
		newContext.waitingContext:=waitingContext
		newContext.verbose:=verbose
		newContext.currentMetamodels:=currentMetamodels
		newContext.currentClassDefinition:=currentClassDefinition
		newContext.currentOperation:=currentOperation
		newContext.currentProperty:=currentProperty
		contextFrames.each{ f|
			newContext.contextFrames.add(f.copy())}

		tobeResolved.current:=current
		
		//var contextTmp : Sequence<StaticSetterContextFrame> init Sequence<StaticSetterContextFrame>.new
		//contextTmp
	
	end 
	
	/**
	 * Metamodels we are processing 
	 */
	reference currentMetamodels : Collection<Metamodel>
	reference mainCurrentMetamodel : Metamodel // metamodel of the project being resolve, we suppose that imported MM are resolved before hand
	reference currentClassDefinition : org::kermeta::language::structure::ClassDefinition
	reference currentOperation : org::kermeta::language::structure::Operation
	reference currentProperty : org::kermeta::language::structure::Property
	
	/**
	 * contextFrames is used to organize symbols using scopes. 
	 */
	attribute contextFrames : seq StaticSetterContextFrame[0..*]
	
	attribute typeDefFinder : TypeDefinitionFinder
	operation getTypeDefFinder() : TypeDefinitionFinder is do
		if typeDefFinder.isVoid then 
			typeDefFinder := TypeDefinitionFinder.new
		end
		result := typeDefFinder
	end
	
	operation pushContext() is do
		contextFrames.add(StaticSetterContextFrame.new.initialize())
	end
	
	operation popContext() is do
		contextFrames.remove(contextFrames.last)
	end
	
	operation addSymbol(symbol : String, type : org::kermeta::language::structure::Type) is do
		contextFrames.last.symbolMap.put(symbol, type)
	end
	
	operation getTypeForSymbol(symbol : String) : org::kermeta::language::structure::Type is do
		result := void
		// search in the contextFrame the deepest symbol that matches
		// TODO find a more efficient way, I currently don't know how to acheive a each in reverse other than doing a loop, I'm not sure, the overhead of the curent algorithm if so important  
		contextFrames.each{ f |
			var res :  org::kermeta::language::structure::Type
			res := f.symbolMap.getValue(symbol)
			if not res.isVoid then
				result := res
			end
		}
	end		
	
	// end of code about symbols
	
	operation createTypeFromQualifiedName(classDefinitionQualifiedName : String, currentMetamodel : Metamodel) : org::kermeta::language::structure::Type is do
		var cd : org::kermeta::language::structure::ClassDefinition
		cd ?= getTypeDefFinder.getTypeDefinitionByQualifiedName(classDefinitionQualifiedName, currentMetamodels, currentMetamodel)
		result := org::kermeta::language::structure::Class.new.initializeFromAClassDefinition(cd)
		if result.isVoid then
			errors.add(ResolverException.new.initialize("Not able to create type for "+ classDefinitionQualifiedName, self))
		end
	end
	
	operation getClassDefinitionFromQualifiedName(classDefinitionQualifiedName : String, currentMetamodel : Metamodel) : org::kermeta::language::structure::ClassDefinition is do
		var cd : org::kermeta::language::structure::ClassDefinition
		cd ?= getTypeDefFinder.getTypeDefinitionByQualifiedName(classDefinitionQualifiedName, currentMetamodels, currentMetamodel)
		result := cd
		if result.isVoid then
			if verbose then
				stdio.writeln("Not able to get ClassDefinition for "+ classDefinitionQualifiedName)
			end
			errors.add(ResolverException.new.initialize("Not able to get ClassDefinition for "+ classDefinitionQualifiedName, self))
		end
	end	
	
	operation createTypeFromPartialName(classDefinitionPartialName : String) : org::kermeta::language::structure::Type is do
		var cd : org::kermeta::language::structure::ClassDefinition
		cd ?= getTypeDefFinder.getFirstTypeDefinitionByName(classDefinitionPartialName, currentMetamodels)
		result := org::kermeta::language::structure::Class.new.initializeFromAClassDefinition(cd)
		if result.isVoid then
			errors.add(ResolverException.new.initialize("Not able to create type for "+ classDefinitionPartialName, self))
		end
	end
	operation getClassDefinitionFromPartialName(classDefinitionQualifiedName : String) : org::kermeta::language::structure::ClassDefinition is do
		var cd : org::kermeta::language::structure::ClassDefinition
		cd ?= getTypeDefFinder.getFirstTypeDefinitionByName(classDefinitionQualifiedName, currentMetamodels)
		result := cd
		if result.isVoid then
			if verbose then
				stdio.writeln("Not able to get ClassDefinition for "+ classDefinitionQualifiedName)
			end
			errors.add(ResolverException.new.initialize("Not able to get ClassDefinition for "+ classDefinitionQualifiedName, self))
		end
	end
	/**
	 * Return the type of self.
	 * The Type parameters are bound with least derived admitable type
	 */
	 
	operation createSelfType() : org::kermeta::language::structure::Type is do
		var selfType : org::kermeta::language::structure::Class  init org::kermeta::language::structure::Class.new
		selfType.typeDefinition := currentClassDefinition
		if selfType.typeDefinition.isVoid then
			errors.add(ResolverException.new.initialize("Not able to create SelfType ", self))
		else		
			result := selfType
		end
		if selfType.typeDefinition.typeParameter.size!=selfType.typeParamBinding.size then
		errors.add(ResolverException.new.initialize("Not implemented self with generics ", self))
		end
	end
	
	operation createTypeFromMultiplicityElement(element : org::kermeta::language::structure::MultiplicityElement ) : org::kermeta::language::structure::Type is do
		if (element.upper.isVoid) then
			errors.add(ResolverException.new.initialize("Upperbound is null.", element))
		else 
			// clone the type of the multiplicity element
			var typeCopy : org::kermeta::language::structure::Type
			typeCopy := element.type
			/*	// UGLY: need a real clone
				if element.type.isInstanceOf(org::kermeta::language::structure::Class) then
					result := org::kermeta::language::structure::Class.clone(element.type.asType(org::kermeta::language::structure::Class))
				end
				if element.type.isInstanceOf(org::kermeta::language::structure::FunctionType) then
					result := org::kermeta::language::structure::FunctionType.clone(element.type.asType(org::kermeta::language::structure::FunctionType))
				end
				// TODO deal with other concrete Type
			*/
				 
			if element.upper == 0 then
				// the only type valid with upper bound == 0 is Void 
				result := createTypeFromPartialName("kermeta::standard::Void")
				//stdio.writeln("createTypeFromMultiplicityElement typeCopy = VOID")
			else if element.upper == 1 then
				result := typeCopy
				//stdio.writeln("createTypeFromMultiplicityElement typeCopy = "+result.toString)
			else
				var typeParams : Sequence<org::kermeta::language::structure::Type> init Sequence<org::kermeta::language::structure::Type>.new
				typeParams.add(typeCopy)
				var cd : org::kermeta::language::structure::ClassDefinition
				if (element.isUnique() and element.isOrdered()) then
					
					cd ?= getTypeDefFinder.getFirstTypeDefinitionByName("kermeta::standard::OrderedSet", currentMetamodels)
					
					if cd.isVoid then
						errors.add(ResolverException.new.initialize("Not able to find  kermeta::standard::OrderedSet", element))
					else
						result := org::kermeta::language::structure::Class.new.initializeFromAGenericClassDefinition(cd, typeParams)
					end
					//stdio.writeln("createTypeFromMultiplicityElement typeCopy = OrderedSet<"+result.toString+">")
				else if (element.isUnique() and not element.isOrdered()) then
				
					cd ?= getTypeDefFinder.getFirstTypeDefinitionByName("kermeta::standard::Set", currentMetamodels)
					
					if cd.isVoid then
						errors.add(ResolverException.new.initialize("Not able to find kermeta::standard::Set", element))
					else
						result := org::kermeta::language::structure::Class.new.initializeFromAGenericClassDefinition(cd, typeParams)
					end
					//stdio.writeln("createTypeFromMultiplicityElement typeCopy = Set<"+result.toString+">")
				else if ( not element.isUnique() and element.isOrdered()) then
				
					cd ?= getTypeDefFinder.getFirstTypeDefinitionByName("kermeta::standard::Sequence", currentMetamodels)
					
					if cd.isVoid then
						errors.add(ResolverException.new.initialize("Not able to find kermeta::standard::Sequence", element))
					else
						result := org::kermeta::language::structure::Class.new.initializeFromAGenericClassDefinition(cd, typeParams)
					end
					//stdio.writeln("createTypeFromMultiplicityElement typeCopy = Sequence<"+result.toString+">")
				else
					
					cd ?= getTypeDefFinder.getFirstTypeDefinitionByName("kermeta::standard::Bag", currentMetamodels)
					
					if cd.isVoid then
						errors.add(ResolverException.new.initialize("Not able to find  kermeta::standard::Bag", element))
					else
						result := org::kermeta::language::structure::Class.new.initializeFromAGenericClassDefinition(cd, typeParams)
					end
					//stdio.writeln("createTypeFromMultiplicityElement typeCopy = Bag<"+result.toString+">")
				end end end
			end end
		end
	end
	
	
}

class StaticSetterContextFrame
{
	reference symbolMap : kermeta::utils::Hashtable<String, org::kermeta::language::structure::Type>
	
	operation initialize() : StaticSetterContextFrame is do
		symbolMap := kermeta::utils::Hashtable<String, org::kermeta::language::structure::Type>.new
		result := self
	end
	operation copy() : StaticSetterContextFrame is do
		var newContext : StaticSetterContextFrame init StaticSetterContextFrame.new.initialize()
		symbolMap.keys.each{ k |
			 newContext.symbolMap.put(k, symbolMap.getValue(k)) 
		}
		result := newContext
	end
}

class ToBeResolvedLater
{
	reference current : Expression
	
	reference context : StaticSetterContext


}