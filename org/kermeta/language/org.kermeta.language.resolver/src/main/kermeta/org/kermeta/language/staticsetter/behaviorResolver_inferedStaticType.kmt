/* $Id:$ 
 * Creation : October 29, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise, xdolques
 */


package org::kermeta::language;


require kermeta
require "StaticSetter_kermeta_aspect.kmt"
require "StaticSetter_typevariableResolver.kmt"
using kermeta::standard

using org::kermeta::language::structure
using org::kermeta::language::behavior
using org::kermeta::language::resolver
using org::kermeta::language::staticsetter
using kermeta::utils

/*
In this file we define the method setInferedStaticType(context,aType) which will set the staticType of an expression to aType but considering the possible bindings
*/

package behavior {
	aspect class Expression inherits TypeContainer
	{
	/**
		 * add this type to the Expression as staticType, also add to its containedType if it is not already contained
		 */
		operation setInferedStaticType(context : StaticSetterContext, type : Type) : Type is do
			
			if not type.isVoid then
				self.staticType := type
				if(type.container.isVoid) then
					self.containedType.add(self.staticType)
				end
				result := self.staticType
			end
		end
		
	}
	
	aspect class CallFeature inherits CallExpression
	{
	
		/**in a CallFeature the list of bindings is obtained by getting all the bindings from the target*/
		operation findBindings(context : StaticSetterContext,type : Type, bindings : kermeta::standard::Sequence<TypeVariableBinding>) is do
			if not target.isVoid then
				if target.staticType.isInstanceOf(Class) then
					bindings.addAll(target.staticType.asType(Class).getAllTypeVariableBindings())
				end
			end
			if (context.verbose) then 
				stdio.write("bindings.size : "+bindings.size.toString+" content = (")
				bindings.each{b | 
					stdio.write("["+b.type.toString+","+b.variable.prettyPrint+"], "
				)}
				stdio.writeln(") on type " +type.toString)
			end
		end
	
	/**
		 * add this type to the Expression as staticType, also add to its containedType if it is not already contained
		 */
		method setInferedStaticType(context : StaticSetterContext,type : Type) : Type from Expression is do
			if not type.isVoid then
				// make sure all parameter of this type are concrete
				var bindings : kermeta::standard::Sequence<TypeVariableBinding> init kermeta::standard::Sequence<TypeVariableBinding>.new
				findBindings(context ,type, bindings)
				self.staticType := type.resolveTypeVariables(context,bindings)
				if(self.staticType.isVoid) then
					if context.verbose then stdio.writeln("Warning static type is Void on CallFeature "+self.name + " replaced by VoidType") end					
					self.staticType := context.createTypeFromQualifiedName("kermeta::standard::Void")
				end
				if(self.staticType.container.isVoid) then
					
					self.containedType.add(self.staticType)
				end
				
				result := self.staticType
			else
				stdio.writeln("Warning setting void as statictype on "+ self.name)
			end
		end
	}
	
	
	aspect class CallOperation
	{
		/**in a CallFeature the list of bindings is obtained by getting all the bindings from the target (call to super) and from the staticTypeVariableBindings*/
		method findBindings(context : StaticSetterContext,type : Type, bindings : kermeta::standard::Sequence<TypeVariableBinding>) from CallFeature is do
		
			super(context ,type, bindings)
			from var i : Integer init 0
			until i==self.staticTypeVariableBindings.size loop
				
				if context.verbose then stdio.writeln("add one binding for variable : "+self.staticOperation.typeParameter.elementAt(i).name) end
				var tvb : TypeVariableBinding init TypeVariableBinding.new
				tvb.variable:=self.staticOperation.typeParameter.elementAt(i)
				tvb.type:=self.staticTypeVariableBindings.elementAt(i)
				bindings.add(tvb)
				i:=i+1
			end
			
			
		end
	
	}
	
	
	aspect class CallSuperOperation {
		/**in a CallSuperOperation the list of bindings is obtained by getting all the bindings from the target (super has no target), from the staticTypeVariableBindings (call to super) and from self */
		method findBindings(context : StaticSetterContext, type : Type, bindings : kermeta::standard::Sequence<TypeVariableBinding>) from CallOperation is do
			super(context ,type, bindings)
			bindings.addAll(getSelfType(context).getAllTypeVariableBindings())
		 end
		/** return the type of self*/
		operation getSelfType (context: StaticSetterContext) : Class is do 
			result := Class.new
			result.typeDefinition:=context.currentClassDefinition
			context.currentClassDefinition.typeParameter.each{ tv|
				var tvb : TypeVariableBinding init TypeVariableBinding.new
				tvb.variable:= tv
				tvb.type:=tv
				result.typeParamBinding.add(tvb)
				}
		end
		
	}
}