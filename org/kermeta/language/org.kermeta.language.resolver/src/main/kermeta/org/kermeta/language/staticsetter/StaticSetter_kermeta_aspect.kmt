/* $Id:$ 
 * Creation : December 29, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise,cbouhour
 * this Aspect compute the staticType and resolve the UnresolvedCall
 */


package org::kermeta::language;


require kermeta
require "platform:/resource/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/eachOwnedElement_kermeta_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetCallableFeatures_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/ModelingUnitHelper_structure_aspect.kmt"
require "StaticSetterContext.kmt"
require "../resolver/ResolverException.kmt"
require "StaticSetter_typevariableResolver.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetQualifiedName_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/TypeEquality_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/prettyprinters/PrettyPrinter_kermeta_aspect.kmt"


using org::kermeta::language::resolver
using org::kermeta::language::structure
using org::kermeta::language::staticsetter
using kermeta::standard

package structure {
	 aspect class KermetaModelElement {
		operation inferContainedExpressionStatic(context : StaticSetterContext) is do
						
			// the algorithm is bottom up
			// compute leaf then goes up in the container which can then reuse their results
			// workaround compiler bug : issue when adding aspect on object
			// put this method as helper that do the same, called by direct subclasses of KermetaModelElement
			context.inferContainedExpressionStatic(self)
		end
		
		
		operation getQualifiedNameResolving() : String is do
			if (not container.isVoid).andThen{b | container.isInstanceOf(KermetaModelElement) } then
				result := container().asType(KermetaModelElement).getQualifiedNameResolving()
			else
				result := ""
			end
		end
	} 


	aspect class ModelingUnit {
		method inferContainedExpressionStatic(context : StaticSetterContext) is do
			context.inferContainedExpressionStatic(self)
			//we manage unresolved lambda now after the call operation but if other resolving should be deferred 
			//it should be considered to move that part at the end of the resolving step
			
			from var lambdaToBeResolved : ToBeResolvedLater
			until context.waitingContext.isEmpty()
			loop
				if (context.verbose) then stdio.writeln("resolving a lambda") end
				lambdaToBeResolved := context.waitingContext.first()
				context.waitingContext.removeAt(0)
				//if the container of the lambda is still unresolved then there is nothing to do
				if lambdaToBeResolved.current.container.isInstanceOf(UnresolvedCall) then
					context.errors.add(ResolverException.new.initialize("The type of the lambda expression cannot be setted while its containing operation is not resolved", lambdaToBeResolved.current))
				else							
					lambdaToBeResolved.current.resolveCallAndInferStatic(lambdaToBeResolved.context)
				end
			end
		end
	
	}
	aspect class Package {
		method getQualifiedNameResolving() : String is do
			result := super
			
			if(result!="") then
				result := result + "::"
			end

			result := result + name
		end
	}


	aspect class NamedElement {
		method inferContainedExpressionStatic(context : StaticSetterContext) is do
			context.inferContainedExpressionStatic(self)
		end
	}


	aspect class TypeContainer {
		method inferContainedExpressionStatic(context : StaticSetterContext) is do
			context.inferContainedExpressionStatic(self)
		end
	}
	aspect class ClassDefinition {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement is do
			context.currentClassDefinition := self			
			super(context)		
			context.currentClassDefinition := void
		end
	}
	aspect class Operation {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement  is do
			context.currentOperation := self
			context.pushContext()
			self.ownedParameter.each{ param | 				
				context.addSymbol( param.name, param.type)
			}			
			super(context)
			context.popContext()
			context.currentOperation := void
		end		
	}
}

package behavior {
	aspect class Expression
	{
		operation resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Expression") end
			// by default the StaticType is void
			setInferedStaticType(context, context.createTypeFromQualifiedName("kermeta::standard::Void"))			
			result := self
			
			// the algorithm is bottom up
			// compute leaf then goes up in the container which can then reuse their results
			self.containedType.each{ e | 
				if ( e.isInstanceOf(Expression)) then
					if (context.verbose) then stdio.writeln("call resolveCallAndInferStatic of "+e.toString) end
					e.asType(Expression).resolveCallAndInferStatic(context)
				end
			} 
			self.kOwnedTags.each{ e | 
				if ( e.isInstanceOf(Expression)) then
					if (context.verbose) then stdio.writeln("call resolveCallAndInferStatic 2 of "+e.toString) end
					e.asType(Expression).resolveCallAndInferStatic(context)
				end
			}
		end
		
		/**
		 * add this type to the Expression as staticType, also add to its containedType if it is not already contained
		 */
		operation setInferedStaticType(context : StaticSetterContext, type : Type) : Type is do
			
			if not type.isVoid then
				self.staticType := type
				if(type.container.isVoid) then
					self.containedType.add(self.staticType)
				end
				result := self.staticType
			end
		end
		
	}
	
	aspect class Block
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			// compute content of the block 
			// super(context)
			
			// possibly replace all the statement by resolved ones
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Block") end
			var newStatements : kermeta::standard::OrderedSet<Expression> init kermeta::standard::OrderedSet<Expression>.new
			
			context.pushContext()
			self.statement.each{ oldStatement |
				newStatements.add(oldStatement.resolveCallAndInferStatic(context))
			}
			self.statement.clear
			self.statement.addAll(newStatements)
			
			self.rescueBlock.each{ r |
				r.resolveCallAndInferStatic(context)
			} 
			
			// TODO should we drill down into the other content of Block (for example: tag, ...)
			
			if (not self.statement.isEmpty()) then
				setInferedStaticType(context, self.statement.last.staticType)
			else
				setInferedStaticType(context, context.createTypeFromQualifiedName("kermeta::standard::Void"))
			end
			// type of the block is the same as the one of the last instruction of the block 
			result := self
			context.popContext()
		end 
	}
	//resolve parameters
	// this is called before the owning calloperation resolution
	aspect class CallExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallExpression") end
			
			var newParameters : kermeta::standard::OrderedSet<Expression> init kermeta::standard::OrderedSet<Expression>.new
			self.parameters.each{ oldParameter |
				newParameters.add(oldParameter.resolveCallAndInferStatic(context))
			}
			self.parameters.clear
			
			// self.parameters.addAll(newParameters)
			newParameters.each{ p | self.parameters.add(p) }
			
			result := self
		end
		
		
	}
	aspect class CallSuperOperation{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression from CallExpression is do
			
				//set parameters
				super(context)
				//get super operation from the currentOperation
				
				var callableOps: Set<Operation> init Set<Operation>.new
				if context.currentOperation.superOperation.isVoid then
					context.currentClassDefinition.superType.each{t|
						if t.isInstanceOf(Class) then
							callableOps.addAll(t.asType(Class).typeDefinition.asType(ClassDefinition).getAllCallableOperations().select{op|
								op.hasSameSignature(context.currentOperation)})
								
						end
						}
				else
					if context.currentOperation.superOperation.isInstanceOf(Operation) then
						callableOps.addAll(context.currentOperation.superOperation.asType(Operation).owningClass.getAllCallableOperations().select{op|
								op.hasSameSignature(context.currentOperation)})
					end
				end
					
				//var opCalled : Operation init context.currentOperation.superOperation.asType(Operation)
				if callableOps.size()==1 then
					self.staticOperation := callableOps.one
				else
					if callableOps.size()==0 then
						context.errors.add(ResolverException.new.initialize("The current operation doesn't have any super definition to call", self))
					else
						context.errors.add(ResolverException.new.initialize("The current operation have too many super definition to call", self))
					end
				end
				// The static type of the call operation must be infered.
				setInferedStaticType(context,context.currentOperation.type)
				
				
				result := self
			
		
		end
	}
	
	// FIXME to refactor: this method is too too long...
	aspect class UnresolvedCall {
		//an unresolved call could be replaced by: 
		//a callvariable
		//a callProperty
		//a callOperation
		//a TypeLiteral
		//an EnumLiteral
	
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of UnresolvedCall") end
			if (context.verbose) then stdio.writeln("resolving UnresolvedCall "+ name) end
			//var targetType : Type 
			if (target.isVoid) then
				// look for a variable in the context
				var symbolType : Type init context.getTypeForSymbol(self.name)
				if not symbolType.isVoid then	
					var callVariable : CallVariable init CallVariable.new
					callVariable.name := self.name
					if (context.verbose) then stdio.writeln("  FOUND callVariable="+callVariable.name) end
					if symbolType.isInstanceOf(FunctionType) and self.isCalledWithParenthesis then
						callVariable.setInferedStaticType(context,symbolType.asType(FunctionType).right)
					else
						callVariable.setInferedStaticType(context, symbolType)
					end
					//	this is the CallVariable that must replace this UnresolvedCall
					result := callVariable
				else
					target:= SelfExpression.new
				end
			end
			if not target.isVoid then	
				if (context.verbose) then stdio.writeln("  infering targetType...") end
				// replace current target by the possibly resolved one
				target := target.resolveCallAndInferStatic(context)
				
				if (context.verbose) then stdio.writeln("             target is infered as "+ target.staticType.toString + " for UnresolvedCall " + name) end
			end 
			//resolve parameters
			super(context)		
			
			//if result is a variable with parameters, add resolved parameters
			if not result.isVoid and not self.parameters.isEmpty then
				result.asType(CallVariable).parameters.addAll(self.parameters)
			end
			
			// if not already found, look for an Enumeration
			if result.isVoid and not target.isVoid and target.isInstanceOf(CallTypeLiteral) then
				var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
				// maybe the typeLiteral is an enumeration and we are looking for the EnumerationLiteral
				if callTypeLiteral.typeref.type.isInstanceOf(Enumeration) then
					if (context.verbose) then stdio.writeln("target is an Enumeration") end
					var enumLiteral : EnumerationLiteral init callTypeLiteral.typeref.type.getCallableEnumLiteralByName(self.name)
					if not enumLiteral.isVoid then
						if (context.verbose) then stdio.writeln(" found EnumerationLiteral "+enumLiteral.name) end
						var callEnumLiteral :  CallEnumLiteral init  CallEnumLiteral.new
						callEnumLiteral.staticEnumLiteral := enumLiteral
						callEnumLiteral.kOwnedTags.addAll(self.kOwnedTags)
						// callEnumLiteral.target := self.target
						result := callEnumLiteral
					end
				end
			end
			// if not already found, look for an Operation
			if result.isVoid then
				if (target.isVoid).orElse{x|target.staticType.isVoid} then 
					stdio.writeln("Warning: targetType of "+ name +" is void. Cannot test if this is an operation. Probably due to a previous element that hasn't been resolved" ) 
				else
					var op : Operation init target.staticType.getCallableOperationByName(self.name)
					//Here we must look if target is a TypeLiteral and if the type is a singleton
					if op.isVoid and target.isInstanceOf(CallTypeLiteral) and not target.isVoid then
						if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Operation1 of UnresolvedCall") end
						// this is a TypeLiteral  
						// if this is a singleteton, try to look in the typereference
						var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
						op := callTypeLiteral.typeref.type.getCallableOperationByName(self.name)
						
					end
					//Here we must look into Object which is the implicit superclass of everything
					if (op.isVoid) then
						if (context.verbose) then stdio.writeln("Implicit inheritance to Object to find operation : "+self.name) end
						var objectAny : ClassDefinition
						objectAny := context.getClassDefinitionFromQualifiedName("kermeta::standard::Object")
						op := objectAny.getCallableOperationByName(self.name)
					end
					//if we finally found an operation
					if not op.isVoid then
						if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Operation2 of UnresolvedCall") end
						var callOperation :  CallOperation init  CallOperation.new
						// move content of UnresolvedCall into the new CallOperation
						callOperation.name := self.name
						callOperation.kOwnedTags.addAll(self.kOwnedTags)
						// infer staticType of the content (except target which has been done previously)
						// TODO check if necessary, probably already done
						callOperation.eachOwnedElement{ e | 
							e.asType(KermetaModelElement).inferContainedExpressionStatic(context)
							e // scala compiler needs somthing to return
						}
						
						// reassign target and parameters
						callOperation.parameters.addAll(self.parameters)
						callOperation.target := self.target 
						// set staticOperation
						callOperation.staticOperation := op
						
						// The static type of the call operation must be infered.
						inferStaticTypeOfCallOperation(callOperation, op, context)
						
						if (context.verbose) then stdio.writeln("  CallOperation "+ name + " resolved with staticType="+ callOperation.staticType.toString) end
						//	this is the CallOperation that must replace this UnresolvedCall
						result := callOperation
						
						
						
					end
				end
			end
			// if not found, look for a Property
			if result.isVoid then
				if (context.verbose) then stdio.writeln("      still not found trying to find a property "+name) end
				if (target.isVoid).orElse{x|target.staticType.isVoid} then 
					stdio.writeln("Warning: targetType of "+ name +" is void. Cannot test if this is a property. Probably due to a previous element that hasn't been resolved" ) 
				else
					if (context.verbose) then stdio.writeln("      target.staticType "+target.staticType.toString) end
					var prop : Property init target.staticType.getCallablePropertyByName(self.name)
					//Here we look if the target is a TypeLiteral in case of a singleton
					if prop.isVoid and target.isInstanceOf(CallTypeLiteral) and not target.isVoid then
						if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Property1 of UnresolvedCall "+name) end
						// this is a TypeLiteral  
						// if this is a singleteton, try to look in the typereference
						var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
						prop := callTypeLiteral.typeref.type.getCallablePropertyByName(self.name)
					end
					//Here we must look into Object which is the implicit superclass of everything
					if (prop.isVoid) then
						if (context.verbose) then stdio.writeln("Implicit inheritance to Object to find property : "+self.name)  end
						var objectAny : ClassDefinition
						objectAny := context.getClassDefinitionFromQualifiedName("kermeta::standard::Object")
						prop := objectAny.getCallablePropertyByName(self.name)
					end
					
					//if we finally found a property
					if not prop.isVoid then
						if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Property2 of UnresolvedCall : "+self.name) end
						var callProperty :  CallProperty init  CallProperty.new
						// move content of UnresolvedCall into the new CallOperation
						callProperty.name := self.name
						//callProperty.parameters.addAll(self.parameters)
						callProperty.kOwnedTags.addAll(self.kOwnedTags)
						// infer staticType of the content (except target which has been done previously)
						callProperty.eachOwnedElement{ e | 
							e.asType(KermetaModelElement).inferContainedExpressionStatic(context)						
							e // scala compiler needs somthing to return
						}
						
						// reassign target
						callProperty.target := self.target 
						// set staticProperty
						callProperty.staticProperty := prop
						
						callProperty.setInferedStaticType(context, context.createTypeFromMultiplicityElement(prop))
						if (context.verbose) then stdio.writeln("  CallProperty "+ name + " resolved") end
						//	this is the CallProperty that must replace this UnresolvedCall
						result := callProperty
					end
				end
			end
			
			//if not found, look for a typevariable from the operation definition or the classdefinition and called by a CallTypeLiteral
			
			if result.isVoid then
			
				var typeVar :TypeVariable 
				//first in operation
				typeVar:=context.currentOperation.typeParameter.detect{ t| t.name==self.name}
				//then in classdef
				if typeVar.isVoid then
					typeVar:=context.currentClassDefinition.typeParameter.detect{ t|t.name==self.name}
				end
				if not typeVar.isVoid then
					var callTL : CallTypeLiteral init CallTypeLiteral.new
					callTL.typeref := TypeReference.new
					callTL.typeref.type := typeVar
					callTL.setInferedStaticType(context, context.createTypeFromQualifiedName("org::kermeta::language::structure::Class"))
					result:=callTL
				end
			end			
			
			// if not found, look for a TypeDefinition called by a CallTypeLiteral
			if result.isVoid then
				if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>TypeDef of UnresolvedCall") end
				var typeDef : TypeDefinition 
				typeDef := context.currentModelingUnit.getTypeDefinitionByNameAndUsings(self.name, usings, context.currentModelingUnit.retrievePackage(getQualifiedNameResolving()))
				
				if not typeDef.isVoid then
					if (context.verbose) then stdio.writeln("   resolveCallAndInferStatic>TypeDef found typeDef " + typeDef.name) end
					var callTypeLiteral : CallTypeLiteral init CallTypeLiteral.new
					callTypeLiteral.typeref := TypeReference.new
					if typeDef.isInstanceOf(ClassDefinition) then
						if (context.verbose) then stdio.writeln("   resolveCallAndInferStatic>TypeDef found a ClassDefinition " + typeDef.name) end
						callTypeLiteral.typeref.type := org::kermeta::language::structure::Class.new.initializeFromAClassDefinition(typeDef.asType(ClassDefinition))
						callTypeLiteral.typeref.containedType.add(callTypeLiteral.typeref.type)				
						// TODO deal with generics
										
						callTypeLiteral.setInferedStaticType(context, context.createTypeFromQualifiedName("org::kermeta::language::structure::Class"))
					end
					if typeDef.isInstanceOf(Enumeration) then
						if (context.verbose) then stdio.writeln("   resolveCallAndInferStatic>TypeDef found an Enumeration " + typeDef.name) end
						callTypeLiteral.typeref.type := typeDef.asType(Enumeration)										
										
						callTypeLiteral.setInferedStaticType(context, context.createTypeFromQualifiedName("org::kermeta::language::structure::Enumeration"))
					end
					//	this is the CallTypeLiteral that must replace this UnresolvedCall
					result := callTypeLiteral
				end	
			end
			if result.isVoid then
				context.errors.add(ResolverException.new.initialize("The call " + name + " is undefined.", self))
				result := self		
			end
		end
		
		
		/**
		 * This method infers the static type of the given call operation.
		 */
		operation inferStaticTypeOfCallOperation(callOperation : CallOperation, op : Operation, context : StaticSetterContext) : Void is do
			//  The call of operation new that must not return type Object but the corresponding type associated to the new.
			//TODO Method clone must be supported there as well.
			if(op.name=="new" and op.owningClass.getQualifiedName()=="org::kermeta::language::structure::Class" and 
				(not callOperation.target.isVoid).andThen{b | callOperation.target.isInstanceOf(CallTypeLiteral) }) then
				callOperation.setInferedStaticType(context,callOperation.target.asType(CallTypeLiteral).typeref.type)
			else
				//The call of operation asType must only take as parameter un type literal, for typing it statically, and must return
				//the type represented by this literal
				if op.name=="asType" and callOperation.parameters.size==1 then
					if callOperation.parameters.one.isInstanceOf(CallTypeLiteral) then
						callOperation.setInferedStaticType(context,callOperation.parameters.one.asType(CallTypeLiteral).typeref.type)
					else						
						context.errors.add(ResolverException.new.initialize("The special operation asType must have a type literal as a parameter.", self))
					end
				else
					callOperation.setInferedStaticType(context,context.createTypeFromMultiplicityElement(op))
				end
			end
		end
	}
	
	
	aspect class CallFeature
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallFeature") end
			// compute content of the CallFeature 
			super(context)		
			result := self
		end 
		
		/**
		 * add this type to the Expression as staticType, also add to its containedType if it is not already contained
		 */
		method setInferedStaticType(context : StaticSetterContext,type : Type) : Type is do
			
			if not type.isVoid then
				// make sure all parameter of this type are concrete
				var bindings : kermeta::standard::Sequence<TypeVariableBinding> init kermeta::standard::Sequence<TypeVariableBinding>.new
				
				if not target.isVoid then
					if target.staticType.isInstanceOf(Class) then
						bindings.addAll(target.staticType.asType(Class).getAllTypeVariableBindings())
					end
				end
				if (context.verbose) then 
					stdio.write("bindings.size : "+bindings.size.toString+" content = (")
					bindings.each{b | 
						stdio.write("["+b.type.toString+","+b.variable.prettyPrint+"], "
					)}
					stdio.writeln(") on type " +type.toString)
				end
				self.staticType := type.resolveTypeVariables(context,bindings)
				if(self.staticType.isVoid) then
					stdio.writeln("Warning static type is Void on CallFeature "+self.name + " replaced by VoidType")					
					self.staticType := context.createTypeFromQualifiedName("kermeta::standard::Void")
				end
				if(self.staticType.container.isVoid) then
					
					self.containedType.add(self.staticType)
				end
				
				result := self.staticType
			else
				stdio.writeln("Warning setting void as statictype on "+ self.name)
			end
		end
	}
	
	aspect class EmptyExpression
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of EmptyExpression") end
			setInferedStaticType(context, context.createTypeFromQualifiedName("kermeta::standard::Void"))			
			result := self
		end 
	}
	
	aspect class StringLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of StringLiteral") end
			setInferedStaticType(context, context.createTypeFromQualifiedName("kermeta::standard::String"))								
			result := self
		end 
	}

	aspect class IntegerLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of IntegerLiteral") end
			setInferedStaticType(context, context.createTypeFromQualifiedName("kermeta::standard::Integer"))								
			result := self
		end 
	}	
	
	aspect class VoidLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of VoidLiteral")	 end
			setInferedStaticType(context, context.createTypeFromQualifiedName("kermeta::standard::Void"))								
			result := self
		end 
	}
	
	aspect class BooleanLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of BooleanLiteral") end
			setInferedStaticType(context, context.createTypeFromQualifiedName("kermeta::standard::Boolean"))								
			result := self
		end 
	}
	
	aspect class VariableDecl {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of VariableDecl") end
			// compute contained expressions
			//super(context)
			
			// compute type of Initialization
			if (not self.initialization.isVoid) then
				self.initialization := self.initialization.resolveCallAndInferStatic(context)
			end
			
			//compute type of TypeReference
			var staticTypeVariable : Type init context.createTypeFromMultiplicityElement(self.type)
			
			// type of the variable
			setInferedStaticType(context, context.createTypeFromQualifiedName("kermeta::standard::Void"))
			 			 			
			result := self
			
			// this variable can be used in the current context stack
			context.addSymbol(self.identifier, staticTypeVariable)
		end 
	}
	
	aspect class Assignment {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Assignment") end
			
			self.target := self.target.resolveCallAndInferStatic(context).asType(CallExpression) 
					
			self.setInferedStaticType(context, self.target.staticType)
						
			self.~value := self.~value.resolveCallAndInferStatic(context)
			
			result := self
		end
	}
	
	aspect class Conditional {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Conditional") end
			
			
			self.condition := self.condition.resolveCallAndInferStatic(context)
			
			// see bug #1903, we limit ourself to the search to the nearest common supertype of the thenBody and elseBody
			var staticTypeOfIF : Type
			
			self.thenBody := self.thenBody.resolveCallAndInferStatic(context)
			if self.thenBody.staticType.isVoid then
				stdio.writeln(" WARNING thenBody.staticType is void in " + self.container().asType(KermetaModelElement).prettyPrint)
			end						
			
			if (not self.elseBody.isVoid) then
				self.elseBody := self.elseBody.resolveCallAndInferStatic(context)
				if self.elseBody.staticType.isVoid then
					stdio.writeln(" WARNING elseBody.staticType is void in " + self.container().asType(KermetaModelElement).prettyPrint)
				else
					// TODO temporary code
					if not self.elseBody.staticType.typeEquals(self.thenBody.staticType) then
						// use Object as common super type
						staticTypeOfIF:= context.createTypeFromQualifiedName("kermeta::standard::Object")
					end
					// TODO staticTypeOfIF:= getNearestCommonSuperType(self.thenBody.staticType, self.elseBody.staticType)
				end
				
			end
			
			self.setInferedStaticType(context, staticTypeOfIF)
			
			result := self
		end
	}
	
	aspect class Loop {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Loop") end
			
			var staticTypeOfLOOP : Type
			
			context.pushContext()
			
			if (not self.initialization.isVoid) then
				self.initialization := self.initialization.resolveCallAndInferStatic(context)
			end
			
			self.stopCondition := self.stopCondition.resolveCallAndInferStatic(context)
			
			if (not self.body.isVoid) then
				self.body := self.body.resolveCallAndInferStatic(context)
				staticTypeOfLOOP := self.body.staticType
			end
			
			if (staticTypeOfLOOP.isVoid) then
				context.createTypeFromQualifiedName("kermeta::standard::Void")
			end
			
			self.setInferedStaticType(context, staticTypeOfLOOP)
			
			result := self
			
			context.popContext()
		end
	}
	
	aspect class SelfExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of SelfExpression") end
			// Creation of a type based on the current class definition corresponding to the self.
			var type : Class init Class.new
			type.typeDefinition := context.currentClassDefinition
			type.typeDefinition.typeParameter.each{ tp |
				var tvb : TypeVariableBinding init  TypeVariableBinding.new
				tvb.variable := tp
				/*if tp.supertype.isVoid then
					tvb.type := context.createTypeFromQualifiedName("kermeta::standard::Object")
				else
					tvb.type := tp.supertype
				end*/
				tvb.type:=tp
				type.typeParamBinding.add(tvb)
			}
			self.setInferedStaticType(context, type)
			result := self
		end
	}
	
	aspect class Raise {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Raise") end
			
			self.expression := self.expression.resolveCallAndInferStatic(context)
			
			self.setInferedStaticType(context, self.expression.staticType)
			
			result := self
		end
	}
	//Lambda Expression can be resolved if its lambda parameters are explicitely typed
	//or if the container is a resolved operationCall 
	aspect class LambdaExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of LambdaExpression") end
			
			//if lambda parameters are explicitely typed
			if parameters.forAll{p|not p.type.type.isInstanceOf(UnresolvedInferredType)} then
				context.pushContext()
				self.parameters.each{x|
					context.addSymbol(x.name,context.createTypeFromMultiplicityElement(x.type))
					}
				self.body := self.body.resolveCallAndInferStatic(context)
			
				//self.setInferedStaticType(context, self.body.staticType)
				setFunctionType(context)
				context.popContext()
			//lambda parameters are implicitly typed
			else
				if container.isInstanceOf(UnresolvedCall) then
					context.saveWaitingContext(self)
				//save the context and resolve the lambda expression later
				else
				//resolve it now
					if container.isInstanceOf(CallOperation) and staticType.isVoid then
						context.pushContext()
						//find which parameter it is in the calloperation
						var paramPosition : Integer init container.asType(CallOperation).parameters.indexOf(self)
						//find the parameter's definition in the operation definition
						var paramDef : Parameter init container.asType(CallOperation).staticOperation.ownedParameter.elementAt(paramPosition)
						
						
						//check if it's really a function with the good number of parameters
						if paramDef.type.isInstanceOf(FunctionType) then
							var funcParamTypes : Sequence<Type> init Sequence<Type>.new
							if paramDef.type.asType(FunctionType).left.isInstanceOf(ProductType) then
								funcParamTypes.addAll(paramDef.type.asType(FunctionType).left.asType(ProductType).type)
							else
								funcParamTypes.add(paramDef.type.asType(FunctionType).left)
							end
							
							//get bindings from the type of the containing callOperation
							var bindings : kermeta::standard::Sequence<TypeVariableBinding> init kermeta::standard::Sequence<TypeVariableBinding>.new
							if container.asType(CallOperation).target.staticType.isInstanceOf(Class) then
								bindings.addAll(container.asType(CallOperation).target.staticType.asType(Class).getAllTypeVariableBindings())
							end
							stdio.writeln("lambda bindings.size : "+bindings.size.toString)
							
							if self.parameters.size == funcParamTypes.size then
								from var i : Integer init 0
								until i == self.parameters.size
								loop
									var typeRef : TypeReference init TypeReference.new
									typeRef.upper:=1
									parameters.elementAt(i).type :=typeRef 
									typeRef.type:=funcParamTypes.elementAt(i).resolveTypeVariables(context,bindings)
									if typeRef.type.container.isVoid then
										typeRef.containedType.add(typeRef.type)
									end
									i:=i+1
								end
							else
								context.errors.add(ResolverException.new.initialize("ERROR : your lambda expression doesn't have the right number of parameters", self))
							end
							
						
						else
							context.errors.add(ResolverException.new.initialize("ERROR : the parameter in the operation definition is not of type FunctionType", self))
						end
						self.parameters.each{x|
							context.addSymbol(x.name,context.createTypeFromMultiplicityElement(x.type))
						}
						self.body := self.body.resolveCallAndInferStatic(context)
						self.setFunctionType(context)
						context.popContext()
					
					else						
						context.errors.add(ResolverException.new.initialize("ERROR : the lambdaExpression is not a parameter of a CallOperation", self))
					end
				end
				
			end
				
			result := self
		end 
		
		operation setFunctionType(context : StaticSetterContext) : Void is do
		
			var funcType : FunctionType init FunctionType.new
			self.staticType:=funcType
			self.containedType.add(funcType)
			funcType.right:=self.body.staticType
			
			if parameters.size==1 then
				funcType.left:=context.createTypeFromMultiplicityElement(parameters.one.type)
				if funcType.left.container.isVoid then
					funcType.containedType.add(funcType.left)
				end
			else
				if parameters.size>1 then
					var prodType : ProductType init ProductType.new
					funcType.containedType.add(prodType)
					funcType.left:=prodType
					parameters.each{ p |
						prodType.type.add(context.createTypeFromMultiplicityElement(parameters.one.type))
					}
					prodType.type.each{t|
						if t.container.isVoid then
							prodType.containedType.add(t)
						end
					}
						
				end
			end
		
		end
		
	}
	
	

	
	
	aspect class Rescue {
		operation resolveCallAndInferStatic(context : StaticSetterContext) is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Rescue") end
				
			context.addSymbol(exceptionName,exceptionType.type)				
			var newBody : kermeta::standard::OrderedSet<Expression> init kermeta::standard::OrderedSet<Expression>.new

			self.body.each{rb |
				newBody.add(rb.resolveCallAndInferStatic(context))
			}
			
			self.body.clear
			self.body.addAll(newBody) 
		end 
	}
	
	aspect class CallResult {
		
	
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallResult") end  
			
			var operationContainer : Operation init context.currentOperation
			
			if (operationContainer.isVoid) then
				context.errors.add(ResolverException.new.initialize("Not able to find the containing operation.", self))
			else
				self.setInferedStaticType(context, context.createTypeFromMultiplicityElement(operationContainer) )
			end
			
			result := self
		end
	}
}