/* $Id:$ 
 * Creation : December 29, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise,cbouhour, ablouin
 * this Aspect compute the staticType and resolve the UnresolvedCall
 */


package org::kermeta::language;


require kermeta

require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/StaticSetterContext.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/callOperationConformanceChecker.kmt"
require "platform:/resource/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/staticsetter/behaviorResolver_inferedStaticType.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/behavior/CreationHelper.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/CreationHelper.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetPackage_KermetaModelElement_Aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetMetamodel_KermetaModelElement_Aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/MetamodelCollection_GetTypeDefinitionByName.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetCallableFeatures_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/TypeEquality_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.resolver/src/main/kermeta/org/kermeta/language/resolver/utils/UnresolvedReference_moveTagsToResolved_aspect.kmt"


using org::kermeta::language::resolver
using org::kermeta::language::structure
using org::kermeta::language::staticsetter
using kermeta::standard
using kmt::language::helpers::structure


package structure {
	 aspect class KermetaModelElement {
		operation inferContainedExpressionStatic(context : StaticSetterContext) is do
				
				
			self.eachOwnedElement{ e |
				if ( e.isInstanceOf(Expression)) then
					e.asType(Expression).resolveCallAndInferStatic(context)
				else if ( e.isInstanceOf(KermetaModelElement)) then
					e.asType(KermetaModelElement).inferContainedExpressionStatic(context)
				end end
				e // must return somthing for scala compiler to work
			}		
			// the algorithm is bottom up
			// compute leaf then goes up in the container which can then reuse their results
			// workaround compiler bug : issue when adding aspect on object
			// put this method as helper that do the same, called by direct subclasses of KermetaModelElement
			//context.inferContainedExpressionStatic(self)
		end
		
		
		operation getQualifiedNameResolving() : String is do
			if (not container.isVoid).andThen{b | container.isInstanceOf(KermetaModelElement) } then
				result := container().asType(KermetaModelElement).getQualifiedNameResolving()
			else
				result := ""
			end
		end
	} 


	aspect class Metamodel {
		method inferContainedExpressionStatic(context : StaticSetterContext) from KermetaModelElement is do
			super(context)
			
		end
	
	}
	aspect class Package {
		method getQualifiedNameResolving() : String is do
			result := super
			
			if(result!="") then
				result := result + "::"
			end

			result := result + name
		end
	}


	aspect class NamedElement {
		method inferContainedExpressionStatic(context : StaticSetterContext) from KermetaModelElement is do
			super(context)
		end
	}


	aspect class TypeContainer {
		method inferContainedExpressionStatic(context : StaticSetterContext) from KermetaModelElement is do
			super(context)
		end
	}
	aspect class ClassDefinition {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement is do
			context.currentClassDefinition := self			
			super(context)		
			context.currentClassDefinition := void
		end
	}
	
	aspect class Property {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement is do
			context.currentProperty := self
			context.pushContext()
			if not getterBody.isVoid then
				//replacement of body is needed in the case of a body without block
				getterBody:=getterBody.resolveCallAndInferStatic(context)
			end
			if not setterBody.isVoid then
				//replacement of body is needed in the case of a body without block
				setterBody:=setterBody.resolveCallAndInferStatic(context)
			end
			context.popContext()
			context.currentProperty := void
		end
	}
	aspect class Operation {
		 
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement  is do
			context.currentOperation := self
			context.pushContext()
			self.ownedParameter.each{ param | 				
				context.addSymbol( param.name, context.createTypeFromMultiplicityElement(param))
			}			
			
			if not body.isVoid then
				//replacement of body is needed in the case of a body without block
				body:=body.resolveCallAndInferStatic(context)
			end
			~post.each{c|c.inferContainedExpressionStatic(context)}
			~pre.each{c|c.inferContainedExpressionStatic(context)}

			
			context.popContext()
			context.currentOperation := void
		end		
	}
	
	aspect class Constraint {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement is do
			if not body.isVoid then
				//replacement of body is needed in the case of a body without block
				body:=body.resolveCallAndInferStatic(context)
			end
			
		end
	}
}

package behavior {
	aspect class Expression
	{
		operation resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Expression") end
			// by default the StaticType is void
			setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::Void"))			
			result := self
			
			// the algorithm is bottom up
			// compute leaf then goes up in the container which can then reuse their results
			self.containedType.each{ e | 
				if ( e.isInstanceOf(Expression)) then
					if (context.verbose) then stdio.writeln("call resolveCallAndInferStatic of "+e.toString) end
					e.asType(Expression).resolveCallAndInferStatic(context)
				end
			} 
			self.kOwnedTags.each{ e | 
				if ( e.isInstanceOf(Expression)) then
					if (context.verbose) then stdio.writeln("call resolveCallAndInferStatic 2 of "+e.toString) end
					e.asType(Expression).resolveCallAndInferStatic(context)
				end
			}
		end
		

		
	}
	
	
	aspect class JavaStaticCall {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do 
			var newParameters : kermeta::standard::Sequence<Expression> init kermeta::standard::Sequence<Expression>.new
			self.parameters.each{ oldParameter |
				newParameters.add(oldParameter.resolveCallAndInferStatic(context))
			}
			self.parameters.clear
			
			// self.parameters.addAll(newParameters)
			newParameters.each{ p | self.parameters.add(p) }
			setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::Object"))
			result := self
		end
		
	}
	
	aspect class Block
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			// compute content of the block 
			// super(context)
			
			// possibly replace all the statement by resolved ones
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Block") end
			var newStatements : kermeta::standard::Sequence<Expression> init kermeta::standard::Sequence<Expression>.new
			
			context.pushContext()
			self.statement.each{ oldStatement |
				newStatements.add(oldStatement.resolveCallAndInferStatic(context))
			}
			self.statement.clear
			self.statement.addAll(newStatements)
			
			self.rescueBlock.each{ r |
				r.resolveCallAndInferStatic(context)
			} 
			
			// TODO should we drill down into the other content of Block (for example: tag, ...)
			
			if (not self.statement.isEmpty()) then
				setInferedStaticType(context, self.statement.last.staticType)
			else
				setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::Void"))
			end
			// type of the block is the same as the one of the last instruction of the block 
			result := self
			context.popContext()
		end 
	}
	//resolve parameters
	// this is called before the owning calloperation resolution
	aspect class CallExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallExpression") end
			
			var newParameters : kermeta::standard::Sequence<Expression> init kermeta::standard::Sequence<Expression>.new
			self.parameters.each{ oldParameter |
				newParameters.add(oldParameter.resolveCallAndInferStatic(context))
			}
			self.parameters.clear
			
			// self.parameters.addAll(newParameters)
			newParameters.each{ p | self.parameters.add(p) }
			
			result := self
		end
		
		
	}

	aspect class CallSuperOperation{
		/** Checks the the super call operation, which super type is not specified, has a single corresponding class with the operation. */
		operation checkOperationInSuperTypes(context : StaticSetterContext) : Boolean is do
			var matchingClasses : Sequence<Type> init context.currentClassDefinition.superType.select{t| 
				t.isInstanceOf(Class).andThen{b | t.asType(Class).ownedOperation.exists{op | op.name==context.currentOperation.name}}}
			if(matchingClasses.size==0) then
				context.errors.add(ResolverException.new.initialize("No super operation corresponding to "+ context.currentClassDefinition.name, self))
				result := false
			else
				if(matchingClasses.size==1) then
					result := true
				else
					context.errors.add(ResolverException.new.initialize("Several super operations '" + context.currentClassDefinition.name +
						"' are possible (because of multi-inheritance). The name of the targeted class must be specified like this 'super[MyType]'.", self))
					result := false
				end
			end
		end
	
		/** Checks that the super call operation is valid: the class has a super type having the corresponding operation. */
		operation checkSuperTypeForSuperCall(context : StaticSetterContext) : Boolean is do
			if(context.currentClassDefinition.superType.size==0) then
				context.errors.add(ResolverException.new.initialize("No super type found: "+ context.currentClassDefinition.name, self))
				result := false
			else
				if(context.currentClassDefinition.superType.size>1) then
					
					context.errors.add(ResolverException.new.initialize("More than : "+context.currentOperation.name, self))
					result := checkOperationInSuperTypes(context)
				else result := true end
			end
		end
	
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression from CallExpression is do
			if context.currentOperation.isVoid then
				context.errors.add(ResolverException.new.initialize("\"super\" keyword should not be used outside of an operation", self))
			else
				//set parameters
				super(context)
				
				// Resolving the super class targeted by the super call (super[FooClass])
				// Suppose that a class does not inherit from several classes with the same name (but not the same qualified name).
				if superType.isInstanceOf(UnresolvedType) then
					var superClassName : String init superType.asType(UnresolvedType).typeIdentifier
					var type : Type
					
					if(superClassName=="") then // No super class is specified. Must check single inheritance.
						if(checkSuperTypeForSuperCall(context)) then// If the check is ok the inferred type is the single super type.
							type := context.currentClassDefinition.superType.one
						end
					else
						type := context.currentClassDefinition.superType.detect{t| t.isInstanceOf(Class).andThen{b | t.asType(Class).name==superClassName}}
					end
					
					if(type.isVoid) then 
						context.errors.add(ResolverException.new.initialize("No super class with this name found: "+superClassName, self))
					else superType := type end
				end
				
				// Resolving the super operation using the resolved super type.
				if (staticOperation.isVoid or staticOperation.isInstanceOf(UnresolvedOperation)) and superType.isInstanceOf(Class) then
					var clazz : ClassDefinition init superType.asType(Class).typeDefinition.asType(ClassDefinition)
					var op : Operation init clazz.ownedOperation.detect{op2| op2.name==context.currentOperation.name}
					if op.isVoid then 
						context.errors.add(ResolverException.new.initialize("No super operation with this name found: "+context.currentOperation.name, self))
					else staticOperation := op end
				end
				
				//retry to resolve lambda here, when staticOperation is known
				from var lambdaToBeResolved : ToBeResolvedLater
				until context.waitingContext.isEmpty()
				loop
					if (context.verbose) then stdio.writeln("resolving a lambda") end
					lambdaToBeResolved := context.waitingContext.first()
					context.waitingContext.removeAt(0)
					//if the container of the lambda is still unresolved then there is nothing to do
					if lambdaToBeResolved.current.container.isInstanceOf(UnresolvedCall).andThen{x| lambdaToBeResolved.current.container.asType(UnresolvedCall).resolvedCall.isVoid} then
						context.errors.add(ResolverException.new.initialize("The type of the lambda expression cannot be setted while its containing operation is not resolved", lambdaToBeResolved.current))
					else							
						lambdaToBeResolved.current.resolveCallAndInferStatic(lambdaToBeResolved.context)
					end
				end
				
				if not staticOperation.isVoid then
					self.inferTypeVariableFromParameters(context)
					// The static type of the call operation must be infered.
					setInferedStaticType(context, staticOperation.type)
				end
				
				result := self
			end
		end
	}
	
		aspect class UnresolvedCall {
		//an unresolved call could be replaced by: 
		//a callvariable
		//a callProperty
		//a callOperation
		//a TypeLiteral
		//an EnumLiteral
	
		reference resolvedCall : CallExpression
		
		
		operation resolveCallToVariable(context : StaticSetterContext) : CallVariable is do
			if target.isVoid then
				var symbolType : Type init context.getTypeForSymbol(self.name)
				if not symbolType.isVoid then	
					var callVariable : CallVariable init CallVariable.new
					callVariable.name := self.name
					if (context.verbose) then stdio.writeln("  FOUND callVariable="+callVariable.name) end
					if symbolType.isInstanceOf(FunctionType) and self.isCalledWithParenthesis then
						callVariable.setInferedStaticType(context,symbolType.asType(FunctionType).right)
					else
						callVariable.setInferedStaticType(context, symbolType)
					end
					//	this is the CallVariable that must replace this UnresolvedCall
					result := callVariable
					self.resolvedCall:=result
				else
					result:= void
				end
			else
				result:=void
			end
		end
		
		
		operation resolveCallToEnumLiteral(context : StaticSetterContext) : CallEnumLiteral is do
			
			if not target.isVoid and target.isInstanceOf(CallTypeLiteral) then
				var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
				// maybe the typeLiteral is an enumeration and we are looking for the EnumerationLiteral
				if (context.verbose) then stdio.writeln(callTypeLiteral.typeref.type.toString) end
				if callTypeLiteral.typeref.type.isVoid.~not.andThen{x| callTypeLiteral.typeref.type.realInstanceType.isVoid.~not.andThen{y|callTypeLiteral.typeref.type.realInstanceType.isInstanceOf(Enumeration)}} then
					if (context.verbose) then stdio.writeln("target is an Enumeration") end
					var enumLiteral : EnumerationLiteral init callTypeLiteral.typeref.type.getCallableEnumLiteralByName(self.name)
					if not enumLiteral.isVoid then
						if (context.verbose) then stdio.writeln(" found EnumerationLiteral "+enumLiteral.name) end
						var callEnumLiteral :  CallEnumLiteral init  CallEnumLiteral.new
						callEnumLiteral.staticEnumLiteral := enumLiteral
						callEnumLiteral.staticType:= callTypeLiteral.typeref.type
						// callEnumLiteral.kOwnedTags.addAll(self.kOwnedTags) Handled in moveTagsToResolvedOperation
						// callEnumLiteral.target := self.target
						result := callEnumLiteral
						self.resolvedCall:=result
					else
						result := void
					end
				else
					result:=void
				end
			else
				result:=void
			end
		end
		
		operation resolveCallToOperation(context : StaticSetterContext) : CallOperation is do
			if (context.verbose) then stdio.writeln("resolveCallToOperation "+ self.name) end
			if (target.isVoid).orElse{x|target.staticType.isVoid.orElse{y|target.staticType.realInstanceType.isVoid}} then 
					stdio.writeln("Warning: targetType of "+ name +" is void. Cannot test if this is an operation. Probably due to a previous element that hasn't been resolved" )
					result:=void 
			else
				if context.verbose then
					stdio.writeln((target.isVoid).orElse{x|target.staticType.isVoid}.toString())
					stdio.writeln(target.toString)
					stdio.writeln(target.staticType.realInstanceType.toString)
					stdio.writeln(target.staticType.getAllCallableOperations.toString)
				end
				if (context.verbose) then stdio.writeln(target.staticType.realInstanceType.toString) end
				if target.staticType.realInstanceType.isInstanceOf(UnresolvedType) then
					stdio.writeln(target.staticType.realInstanceType.asType(UnresolvedType).typeIdentifier)
				end
				var ops : Sequence<Operation> init target.staticType.realInstanceType.getAllCallableOperations.select{o|o.name==self.name}
				//Here we must look if target is a TypeLiteral and if the type is a singleton
				if ops.isEmpty and target.isInstanceOf(CallTypeLiteral) and not target.isVoid then
					if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Operation1 of UnresolvedCall") end
					// this is a TypeLiteral  
					// if this is a singleteton, try to look in the typereference
					var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
					if 	callTypeLiteral.typeref.type.realInstanceType.isInstanceOf(Class)
						.andThen{x|callTypeLiteral.typeref.type.realInstanceType.asType(Class).typeDefinition.asType(ClassDefinition).isSingleton} then
						ops := callTypeLiteral.typeref.type.realInstanceType.getAllCallableOperations.select{o|o.name==self.name}
					end
				end
				//Here we must look into Object which is the implicit superclass of everything
				if ops.isEmpty then
					if (context.verbose) then stdio.writeln("Implicit inheritance to Object to find operation : "+self.name) end
					var objectAny : ClassDefinition
					objectAny := context.getClassDefinitionFromPartialName("kermeta::standard::Object")
					ops := objectAny.getAllCallableOperations.select{o|o.name==self.name}
				end
				//if we finally found at least one operation
				if not ops.isEmpty then
					if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Operation2 of UnresolvedCall") end
										
					
					//check if there is only one
					var op : Operation
					op:=ops.detect{o|o.ownedParameter.size()==self.parameters.size()}
					if op.isVoid then
						context.errors.add(ResolverException.new.initialize("Incorrect number of parameters: expected " + ops.one.ownedParameter.size().toString() + " found "+ 
						 self.parameters.size().toString , self))
					else
						//	this is the CallOperation that must replace this UnresolvedCall
						var callOperation :  CallOperation init  CallOperation.new
						//it is stored temporarily to be used when resolving lambdas
						self.resolvedCall:=callOperation
						callOperation.staticOperation:=op
						// move content of UnresolvedCall into the new CallOperation
						callOperation.name := self.name
						//callOperation.kOwnedTags.addAll(self.kOwnedTags) Handled in moveTagsToResolvedOperation
						// infer staticType of the content (except target which has been done previously)
						// TODO check if necessary, probably already done
						callOperation.eachOwnedElement{ e | 
							e.asType(KermetaModelElement).inferContainedExpressionStatic(context)
							e // scala compiler needs somthing to return
						}
						
						//retry to resolve lambda here, when staticOperation is known
						
						
						from var lambdaToBeResolved : ToBeResolvedLater
						until context.waitingContext.isEmpty()
						loop
							if (context.verbose) then stdio.writeln("resolving a lambda") end
							lambdaToBeResolved := context.waitingContext.first()
							context.waitingContext.removeAt(0)
							//if the container of the lambda is still unresolved then there is nothing to do
							if lambdaToBeResolved.current.container.isInstanceOf(UnresolvedCall).andThen{x| lambdaToBeResolved.current.container.asType(UnresolvedCall).resolvedCall.isVoid} then
								context.errors.add(ResolverException.new.initialize("The type of the lambda expression cannot be setted while its containing operation is not resolved", lambdaToBeResolved.current))
							else							
								lambdaToBeResolved.current.resolveCallAndInferStatic(lambdaToBeResolved.context)
							end
						end
						
						
						
					end	
					
					
					if not self.resolvedCall.isVoid then
						
						// reassign target and parameters
						self.resolvedCall.parameters.addAll(self.parameters)
						
						// check if type parameters are explicitely passed
						if not self.generics.isEmpty then
							if self.generics.size == self.resolvedCall.asType(CallOperation).staticOperation.typeParameter.size then
								self.resolvedCall.staticTypeVariableBindings.addAll(self.generics)
								self.resolvedCall.containedType.addAll(self.containedType)
							else
								context.errors.add(ResolverException.new.initialize("Number of type parameters different from the operation definition", resolvedCall))
							end
						else
						//if not, try to infer them
							self.resolvedCall.asType(CallOperation).inferTypeVariableFromParameters(context)
						end
						self.resolvedCall.asType(CallOperation).target := self.target 
						
						// The static type of the call operation must be infered.
						inferStaticTypeOfCallOperation(self.resolvedCall.asType(CallOperation), op, context)
						
						
						if (context.verbose) then stdio.writeln("  CallOperation "+ name + " resolved with staticType="+ self.resolvedCall.staticType.toString) end
					
					
						result := self.resolvedCall.asType(CallOperation)
					else
						result:=void
					end
				else
				 	result:=void
				end
			end
		end
	
		operation resolveCallToProperty(context : StaticSetterContext) : CallProperty is do
			if (target.isVoid).orElse{x|target.staticType.isVoid.orElse{y|target.staticType.realInstanceType.isVoid}} then 
					stdio.writeln("Warning: targetType of "+ name +" is void. Cannot test if this is a property. Probably due to a previous element that hasn't been resolved" )
					result:=void 
			else
				if (context.verbose) then stdio.writeln("      target.staticType "+target.staticType.toString) end
				var prop : Property init target.staticType.realInstanceType.getCallablePropertyByName(self.name)
				//Here we look if the target is a TypeLiteral in case of a singleton
				if prop.isVoid and target.isInstanceOf(CallTypeLiteral) and not target.isVoid then
					if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Property1 of UnresolvedCall "+name) end
					// this is a TypeLiteral  
					// if this is a singleteton, try to look in the typereference
					var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
					prop := callTypeLiteral.typeref.type.realInstanceType.getCallablePropertyByName(self.name)
				end
				//Here we must look into Object which is the implicit superclass of everything
				if (prop.isVoid) then
					if (context.verbose) then stdio.writeln("Implicit inheritance to Object to find property : "+self.name)  end
					var objectAny : ClassDefinition
					objectAny := context.getClassDefinitionFromPartialName("kermeta::standard::Object")
					prop := objectAny.getCallablePropertyByName(self.name)
				end
				
				//if we finally found a property
				if not prop.isVoid then
					if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Property2 of UnresolvedCall : "+self.name) end
					var callProperty :  CallProperty init  CallProperty.new
					// move content of UnresolvedCall into the new CallOperation
					callProperty.name := self.name
					//callProperty.parameters.addAll(self.parameters)
					//callProperty.kOwnedTags.addAll(self.kOwnedTags) Handled in moveTagsToResolvedOperation
					// infer staticType of the content (except target which has been done previously)
					callProperty.eachOwnedElement{ e | 
						e.asType(KermetaModelElement).inferContainedExpressionStatic(context)						
						e // scala compiler needs somthing to return
					}
					
					// reassign target
					callProperty.target := self.target 
					// set staticProperty
					callProperty.staticProperty := prop
					
					callProperty.setInferedStaticType(context, context.createTypeFromMultiplicityElement(prop))
					if (context.verbose) then stdio.writeln("  CallProperty "+ name + " resolved") end
					//	this is the CallProperty that must replace this UnresolvedCall
					result := callProperty
				else
					result:=void
				end
			end
		end
		/**
			check if the current unresolved call should be resolved as a CallTypeLiteral with the type being a TypeVariable. Return void if not the case
		*/
		operation resolveCallToTypeVariable(context : StaticSetterContext) : CallTypeLiteral is do
			if target.isVoid then
				var typeVar :TypeVariable 
				//first in operation if we are in an operation 
				if not context.currentOperation.isVoid then
					typeVar:=context.currentOperation.typeParameter.detect{ t| t.name==self.name}
				end
				//then in classdef
				if typeVar.isVoid then
					typeVar:=context.currentClassDefinition.typeParameter.detect{ t|t.name==self.name}
				end
				if not typeVar.isVoid then
					var callTL : CallTypeLiteral init CallTypeLiteral.new
					callTL.typeref := TypeReference.new.initialize(typeVar)
					callTL.setInferedStaticType(context, context.createTypeFromPartialName("org::kermeta::language::structure::Class"))
					result:=callTL
				else 
					result:=void
				end
			else
				result:=void
			end
		end
		/**
			check if the current unresolved call should be resolved as a CallTypeLiteral. Return void if not the case
		*/
		operation resolveCallToTypeLiteral(context : StaticSetterContext) : CallTypeLiteral is do
			if target.isVoid then
				var typeDef : TypeDefinition
								
				var typeDefFinder : TypeDefinitionFinder init context.getTypeDefFinder()
				typeDef := typeDefFinder.getTypeDefinitionByNameAndUsings(self.name, usings, self.getRootMetamodel(), self.getPackage())
				
				if not typeDef.isVoid then
					if (context.verbose) then stdio.writeln("   resolveCallAndInferStatic>TypeDef found typeDef " + typeDef.name) end
					var callTypeLiteral : CallTypeLiteral init CallTypeLiteral.new
					callTypeLiteral.typeref := TypeReference.new
					if typeDef.isInstanceOf(ClassDefinition) then
						if (context.verbose) then stdio.writeln("   resolveCallAndInferStatic>TypeDef found a ClassDefinition " + typeDef.name) end
						callTypeLiteral.typeref.initialize(org::kermeta::language::structure::Class.new.initializeFromAClassDefinition(typeDef.asType(ClassDefinition)))
						callTypeLiteral.typeref.containedType.add(callTypeLiteral.typeref.type)				
						// TODO deal with generics
						if typeDef.asType(ClassDefinition).typeParameter.isEmpty.~not() then
							
							if generics.size()==typeDef.asType(ClassDefinition).typeParameter.size() then
								
								from var i : Integer init 0
								until i==generics.size
								loop
								
									var typeVar : TypeVariable init typeDef.asType(ClassDefinition).typeParameter.elementAt(i)
									var varType : Type init self.generics.elementAt(i)
									var tvb : TypeVariableBinding init TypeVariableBinding.new
									tvb.variable:=typeVar
									tvb.type:=varType
									if varType.isInstanceOf(DataType).~not() then
										tvb.containedType.add(varType)
									end
									callTypeLiteral.typeref.type.asType(Class).typeParamBinding.add(tvb)
									
									i:=i+1
								end
							
							else
								context.errors.add(ResolverException.new.initialize("The classDefinition "+typeDef.getQualifiedName()+"must have "+typeDef.asType(ClassDefinition).typeParameter.size().toString()+" type parameters. Given :"+generics.size().toString() , self))
							end
						end
						
										
						callTypeLiteral.setInferedStaticType(context, context.createTypeFromPartialName("org::kermeta::language::structure::Class"))
					end
					if typeDef.isInstanceOf(DataType) then
						if (context.verbose) then stdio.writeln("   resolveCallAndInferStatic>TypeDef found an Enumeration " + typeDef.name) end
						callTypeLiteral.typeref.type := typeDef.asType(DataType)										
						if typeDef.asType(Type).realInstanceType.isInstanceOf(Class) then /*#1*/										
							callTypeLiteral.setInferedStaticType(context, context.createTypeFromPartialName("org::kermeta::language::structure::Class"))
						else if typeDef.asType(Type).realInstanceType.isInstanceOf(Enumeration) then /*#2*/
							callTypeLiteral.setInferedStaticType(context, context.createTypeFromPartialName("org::kermeta::language::structure::Enumeration"))
						else if typeDef.asType(Type).realInstanceType.isInstanceOf(FunctionType) then /*#3*/
							callTypeLiteral.setInferedStaticType(context, context.createTypeFromPartialName("org::kermeta::language::structure::FunctionType"))
						end /*#3*/ end /*#2*/ end /*#1*/
					end
					//TODO deal with function types
					
					//	this is the CallTypeLiteral that must replace this UnresolvedCall
					result := callTypeLiteral
				else
				 	result := void
				end	
			else
				result := void
			end
		end
	
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of UnresolvedCall") end
			if (context.verbose) then stdio.writeln("resolving UnresolvedCall "+ name) end
			
			var isTargetInitiallyVoid : Boolean init true
			//var targetType : Type 
			if (target.isVoid) then
				// look for a variable in the context
				result:=resolveCallToVariable(context)
				
				if result.isVoid then
					target:= SelfExpression.new
				end
			else
				isTargetInitiallyVoid:=false	
			end
			
			//if we are not looking for a variable, then we need to know what is the type of the target to
			//know where to look
			if not target.isVoid then	
				if (context.verbose) then stdio.writeln("  infering targetType...") end
				// replace current target by the possibly resolved one
				target := target.resolveCallAndInferStatic(context)
				
				if (context.verbose) then stdio.writeln("             target is infered as "+ target.staticType.toString + " for UnresolvedCall " + name) end
			end 
			
			//resolve parameters
			super(context)
			
			//if result is a variable with parameters, add resolved parameters
			if not result.isVoid and not self.parameters.isEmpty then
				result.asType(CallVariable).parameters.addAll(self.parameters)
			end
			
			// if not already found, look for an Enumeration
			if result.isVoid  then
				result := resolveCallToEnumLiteral(context)
			end
			
			// if not already found, look for an Operation
			if result.isVoid then
				result := resolveCallToOperation(context)
			end
			
			// if not found, look for a Property
			if result.isVoid then
				if (context.verbose) then stdio.writeln("      still not found trying to find a property "+name) end
				result:=resolveCallToProperty(context)
			end
			
			if result.isVoid and isTargetInitiallyVoid then
				//if we are looking for a typeliteral, then we shouldn't keep the artificially added self as target
				target:=void
			
				//if not found, look for a typevariable from the operation definition or the classdefinition and called by a CallTypeLiteral
				result:=resolveCallToTypeVariable(context)
			
				// if not found, look for a TypeDefinition called by a CallTypeLiteral
				if result.isVoid then
					if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>TypeDef of UnresolvedCall") end
					result:=resolveCallToTypeLiteral(context)
				end
			end
			if result.isVoid then
			
				if target.isVoid then
					context.errors.add(ResolverException.new.initialize("The call " + name + " is undefined.", self))
				else
					if not target.staticType.isVoid then
						context.errors.add(ResolverException.new.initialize("The call " + name + " is undefined for type "+target.staticType.getQualifiedName, self))
					else
						context.errors.add(ResolverException.new.initialize("The call " + name + " is undefined.", self))
					end
				end
				result := self		
			end
			self.moveTagsToResolved(result)
		end
		
		
		/**
		 * This method infers the static type of the given call operation.
		 */
		operation inferStaticTypeOfCallOperation(callOperation : CallOperation, op : Operation, context : StaticSetterContext) : Void is do
			//  The call of operation new that must not return type Object but the corresponding type associated to the new.
			//TODO Method clone must be supported there as well.
			if(op.name=="new" and op.owningClass.getQualifiedName().endsWith("#org::kermeta::language::structure::Class") and 
				(not callOperation.target.isVoid).andThen{b | callOperation.target.isInstanceOf(CallTypeLiteral) }) then
				callOperation.setInferedStaticType(context,callOperation.target.asType(CallTypeLiteral).typeref.type)
			else
				//The call of operation asType must only take as parameter un type literal, for typing it statically, and must return
				//the type represented by this literal
				if op.name=="asType" and callOperation.parameters.size==1 then
					if callOperation.parameters.one.isInstanceOf(CallTypeLiteral) then
						callOperation.setInferedStaticType(context,callOperation.parameters.one.asType(CallTypeLiteral).typeref.type)
					else						
						context.errors.add(ResolverException.new.initialize("The special operation asType must have a type literal as a parameter.", self))
					end
				else
					//todo : should take into account the infered type parameters
					callOperation.setInferedStaticType(context,context.createTypeFromMultiplicityElement(op))
				end
			end
		end
	}
	
	
	aspect class CallFeature
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallFeature") end
			// compute content of the CallFeature 
			super(context)		
			result := self
		end 
	}
	
	aspect class EmptyExpression
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of EmptyExpression") end
			setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::Void"))			
			result := self
		end 
	}
	
	aspect class StringLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of StringLiteral") end
			setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::String"))								
			result := self
		end 
	}

	aspect class IntegerLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of IntegerLiteral") end
			setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::Integer"))								
			result := self
		end 
	}	
	
	aspect class VoidLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of VoidLiteral")	 end
			setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::Void"))								
			result := self
		end 
	}
	
	aspect class BooleanLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of BooleanLiteral") end
			setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::Boolean"))								
			result := self
		end 
	}
	
	aspect class VariableDecl {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of VariableDecl") end
			// compute contained expressions
			//super(context)
			
			// compute type of Initialization
			if (not self.initialization.isVoid) then
				self.initialization := self.initialization.resolveCallAndInferStatic(context)
			end
			
			//compute type of TypeReference
			var staticTypeVariable : Type init context.createTypeFromMultiplicityElement(self.type)
			
			// type of the variable
			setInferedStaticType(context, context.createTypeFromPartialName("kermeta::standard::Void"))
			 			 			
			result := self
			
			// this variable can be used in the current context stack
			context.addSymbol(self.identifier, staticTypeVariable)
		end 
	}
	
	aspect class Assignment {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Assignment") end
			
			self.target := self.target.resolveCallAndInferStatic(context).asType(CallExpression) 
					
			self.setInferedStaticType(context, self.target.staticType)
						
			self.~value := self.~value.resolveCallAndInferStatic(context)
			
			result := self
		end
	}
	
	aspect class Conditional {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Conditional") end
			
			
			self.condition := self.condition.resolveCallAndInferStatic(context)
			
			// see bug #1903, we limit ourself to the search to the nearest common supertype of the thenBody and elseBody
			var staticTypeOfIF : Type
			
			self.thenBody := self.thenBody.resolveCallAndInferStatic(context)
			if self.thenBody.staticType.isVoid then
				stdio.writeln(" WARNING thenBody.staticType is void in " + self.container().asType(KermetaModelElement).prettyPrint)
			end						
			
			if (not self.elseBody.isVoid) then
				self.elseBody := self.elseBody.resolveCallAndInferStatic(context)
				if self.elseBody.staticType.isVoid then
					stdio.writeln(" WARNING elseBody.staticType is void in " + self.container().asType(KermetaModelElement).prettyPrint)
				else
					// TODO temporary code
					if not self.elseBody.staticType.realInstanceType.typeEquals(self.thenBody.staticType.realInstanceType) then
						// use Object as common super type
						staticTypeOfIF:= context.createTypeFromPartialName("kermeta::standard::Object")
					else
						staticTypeOfIF:=self.elseBody.staticType	
				
					end
					// TODO staticTypeOfIF:= getNearestCommonSuperType(self.thenBody.staticType, self.elseBody.staticType)
				end
			else
				staticTypeOfIF:=self.thenBody.staticType	
				
			end
			
			self.setInferedStaticType(context, staticTypeOfIF)
			
			result := self
		end
	}
	
	aspect class Loop {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Loop") end
			
			var staticTypeOfLOOP : Type
			
			context.pushContext()
			
			if (not self.initialization.isVoid) then
				self.initialization := self.initialization.resolveCallAndInferStatic(context)
			end
			
			self.stopCondition := self.stopCondition.resolveCallAndInferStatic(context)
			
			if (not self.body.isVoid) then
				self.body := self.body.resolveCallAndInferStatic(context)
				staticTypeOfLOOP := self.body.staticType
			end
			
			if (staticTypeOfLOOP.isVoid) then
				context.createTypeFromPartialName("kermeta::standard::Void")
			end
			
			self.setInferedStaticType(context, staticTypeOfLOOP)
			
			result := self
			
			context.popContext()
		end
	}
	
	aspect class SelfExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of SelfExpression") end
			// Creation of a type based on the current class definition corresponding to the self.
			var type : Class init Class.new
			type.typeDefinition := context.currentClassDefinition
			type.typeDefinition.typeParameter.each{ tp |
				var tvb : TypeVariableBinding init  TypeVariableBinding.new
				tvb.variable := tp
				/*if tp.supertype.isVoid then
					tvb.type := context.createTypeFromQualifiedName("kermeta::standard::Object")
				else
					tvb.type := tp.supertype
				end*/
				tvb.type:=tp
				type.typeParamBinding.add(tvb)
			}
			self.setInferedStaticType(context, type)
			result := self
		end
	}
	
	aspect class Raise {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Raise") end
			
			self.expression := self.expression.resolveCallAndInferStatic(context)
			
			self.setInferedStaticType(context, self.expression.staticType)
			
			result := self
		end
	}
	//Lambda Expression can be resolved if its lambda parameters are explicitely typed
	//or if the container is a resolved operationCall 
	aspect class LambdaExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of LambdaExpression") end
			
			//if lambda parameters are explicitely typed
			if parameters.forAll{p|not p.type.type.isInstanceOf(UnresolvedInferredType)} then
				context.pushContext()
				self.parameters.each{x|
					context.addSymbol(x.name,context.createTypeFromMultiplicityElement(x.type))
					}
				self.body := self.body.resolveCallAndInferStatic(context)
			
				//self.setInferedStaticType(context, self.body.staticType)
				setFunctionType(context)
				context.popContext()
			//lambda parameters are implicitly typed
			else
				if container.isInstanceOf(UnresolvedCall).andThen{x| container.asType(UnresolvedCall).resolvedCall.isVoid}
					.orElse{x|container.isInstanceOf(CallSuperOperation).andThen{x|container.asType(CallSuperOperation).staticOperation.isVoid}} then
					context.saveWaitingContext(self)
				//save the context and resolve the lambda expression later
				else
				//resolve it now
				//can be a parameter of a calloperation(so unresolvedcall) or a call to super
					if  container.isInstanceOf(UnresolvedCall).andThen{x| container.asType(UnresolvedCall).resolvedCall.isInstanceOf(CallOperation)}
						.orElse{x|container.isInstanceOf(CallSuperOperation).andThen{x|container.asType(CallSuperOperation).staticOperation.isVoid.~not}}
						 and staticType.isVoid 
						
						then
						context.pushContext()
						//find which parameter it is in the calloperation
						var paramPosition : Integer init container.asType(CallExpression).parameters.indexOf(self)
						
						
						//find the parameter's definition in the operation definition
						var paramDef : Parameter
						if container.isInstanceOf(UnresolvedCall) then
							paramDef:= container.asType(UnresolvedCall).resolvedCall.asType(CallOperation).staticOperation.ownedParameter.elementAt(paramPosition)
						else
							paramDef:= container.asType(CallSuperOperation).staticOperation.ownedParameter.elementAt(paramPosition)
						end
						//check if it's really a function with the good number of parameters
						if paramDef.type.realInstanceType.isInstanceOf(FunctionType) then
							var funcParamTypes : Sequence<Type> init Sequence<Type>.new
							if paramDef.type.realInstanceType.asType(FunctionType).left.isInstanceOf(ProductType) then
								funcParamTypes.addAll(paramDef.type.asType(FunctionType).left.asType(ProductType).type)
							else
								funcParamTypes.add(paramDef.type.asType(FunctionType).left)
							end
							
							//get bindings from the type of the containing callOperation
							var bindings : kermeta::standard::Sequence<TypeVariableBinding> init kermeta::standard::Sequence<TypeVariableBinding>.new
							if container.isInstanceOf(UnresolvedCall).andThen{x|container.asType(UnresolvedCall).target.staticType.realInstanceType.isInstanceOf(Class)} then //#1
								bindings.addAll(container.asType(UnresolvedCall).target.staticType.realInstanceType.asType(Class).getAllTypeVariableBindings())
							else if container.isInstanceOf(CallSuperOperation) then /*#2*/
								bindings.addAll(container.asType(CallSuperOperation).getSelfType(context).getAllTypeVariableBindings())
							end /*#2*/ end /*#1*/
							
							if context.verbose then stdio.writeln("lambda bindings.size : "+bindings.size.toString) end
							
							if self.parameters.size == funcParamTypes.size then
								from var i : Integer init 0
								until i == self.parameters.size
								loop
									var typeRef : TypeReference init TypeReference.new
									typeRef.upper:=1
									parameters.elementAt(i).type :=typeRef 
									typeRef.type:=funcParamTypes.elementAt(i).resolveTypeVariables(context,bindings)
									if typeRef.type.container.isVoid then
										typeRef.containedType.add(typeRef.type)
									end
									var c : Class
									c ?= typeRef.type
									var pt : PrimitiveType
									pt ?= typeRef.type
									if(not c.isVoid) then
										typeRef.name := c.name
									end
									if(not pt.isVoid) then
										typeRef.name := pt.name
									end
									i:=i+1
								end
							else
								context.errors.add(ResolverException.new.initialize("ERROR : your lambda expression doesn't have the right number of parameters", self))
							end
							
						
						else
							context.errors.add(ResolverException.new.initialize("ERROR : the parameter in the operation definition is not of type FunctionType", self))
						end
						self.parameters.each{x|
							context.addSymbol(x.name,context.createTypeFromMultiplicityElement(x.type))
						}
						self.body := self.body.resolveCallAndInferStatic(context)
						self.setFunctionType(context)
						context.popContext()
					
					else						
						context.errors.add(ResolverException.new.initialize("ERROR : the lambdaExpression is not a parameter of a CallOperation", self))
					end
				end
				
			end
				
			result := self
		end 
		
		operation setFunctionType(context : StaticSetterContext) : Void is do
		
			var funcType : FunctionType init FunctionType.new
			self.staticType:=funcType
			self.containedType.add(funcType)
			funcType.right:=self.body.staticType
			
			if parameters.size==1 then
				funcType.left:=context.createTypeFromMultiplicityElement(parameters.one.type)
				if funcType.left.container.isVoid then
					funcType.containedType.add(funcType.left)
				end
			else
				if parameters.size>1 then
					var prodType : ProductType init ProductType.new
					funcType.containedType.add(prodType)
					funcType.left:=prodType
					var i : Integer init 0
					parameters.each{ p |
						prodType.type.add(context.createTypeFromMultiplicityElement(parameters.elementAt(i).type))
						i:=i+1
					}
					prodType.type.each{t|
						if t.container.isVoid then
							prodType.containedType.add(t)
						end
					}
						
				end
			end
		
		end
		
	}
	
	

	
	
	aspect class Rescue {
		operation resolveCallAndInferStatic(context : StaticSetterContext) is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Rescue") end
				
			context.addSymbol(exceptionName,exceptionType.type)				
			var newBody : kermeta::standard::Sequence<Expression> init kermeta::standard::Sequence<Expression>.new

			self.body.each{rb |
				newBody.add(rb.resolveCallAndInferStatic(context))
			}
			
			self.body.clear
			self.body.addAll(newBody) 
		end 
	}
	
	aspect class CallResult {
		
	
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallResult") end  
			var multiplicityElementContainer : MultiplicityElement
			
			if not context.currentOperation.isVoid then
				multiplicityElementContainer:=context.currentOperation
			else
				if not context.currentProperty.isVoid then
					multiplicityElementContainer:=context.currentProperty
				else
					context.errors.add(ResolverException.new.initialize("Not able to find the containing operation.", self))
				end
			end
			
			if not multiplicityElementContainer.isVoid then
				self.setInferedStaticType(context, context.createTypeFromMultiplicityElement(multiplicityElementContainer) )
			end
			
			
			result := self
		end
	}
	
	aspect class CallValue {
		
	
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallValue") end  
			if not context.currentProperty.isVoid then
				self.setInferedStaticType(context, context.createTypeFromMultiplicityElement(context.currentProperty) )
			else
				context.errors.add(ResolverException.new.initialize("\"value\" cannot be called outside of the setter body of a derived property.", self))
			end
			result := self
		end
	}
}