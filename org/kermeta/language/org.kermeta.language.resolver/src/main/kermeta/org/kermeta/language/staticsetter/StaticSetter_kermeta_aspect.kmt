/* $Id:$ 
 * Creation : December 29, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise,cbouhour
 * this Aspect compute the staticType and resolve the UnresolvedCall
 */


package org::kermeta::language;


require kermeta
require "platform:/resource/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/eachOwnedElement_kermeta_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetCallableFeatures_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/ModelingUnitHelper_structure_aspect.kmt"
require "StaticSetterContext.kmt"
require "../resolver/ResolverException.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetQualifiedName_structure_aspect.kmt"

using org::kermeta::language::resolver
using org::kermeta::language::structure
using org::kermeta::language::staticsetter

package structure {
	 aspect class KermetaModelElement {
		operation inferContainedExpressionStatic(context : StaticSetterContext) is do
						
			// the algorithm is bottom up
			// compute leaf then goes up in the container which can then reuse their results
			// workaround compiler bug : issue when adding aspect on object
			// put this method as helper that do the same, called by direct subclasses of KermetaModelElement
			context.inferContainedExpressionStatic(self)
		end
		
		
		operation getQualifiedNameResolving() : String is do
			if (not container.isVoid).andThen{b | container.isInstanceOf(KermetaModelElement) } then
				result := container().asType(KermetaModelElement).getQualifiedNameResolving()
			else
				result := ""
			end
		end
	} 

	aspect class Package {
		method getQualifiedNameResolving() : String is do
			result := super
			
			if(result!="") then
				result := result + "::"
			end

			result := result + name
		end
	}


	aspect class NamedElement {
		method inferContainedExpressionStatic(context : StaticSetterContext) is do
			context.inferContainedExpressionStatic(self)
		end
	}


	aspect class TypeContainer {
		method inferContainedExpressionStatic(context : StaticSetterContext) is do
			context.inferContainedExpressionStatic(self)
		end
	}
	aspect class ClassDefinition {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement is do
			context.currentClassDefinition := self			
			super(context)		
			context.currentClassDefinition := void
		end
	}
	aspect class Operation {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement  is do
			context.currentOperation := self
			context.pushContext()
			self.ownedParameter.each{ param | 				
				context.addSymbol( param.name, param.type)
			}			
			super(context)
			context.popContext()
			context.currentOperation := void
		end		
	}
}

package behavior {
	aspect class Expression
	{
		operation resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Expression") end
			// by default the StaticType is void
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Void"))			
			result := self
			
			// the algorithm is bottom up
			// compute leaf then goes up in the container which can then reuse their results
			self.containedType.each{ e | 
				if ( e.isInstanceOf(Expression)) then
					if (context.verbose) then stdio.writeln("call resolveCallAndInferStatic of "+e.toString) end
					e.asType(Expression).resolveCallAndInferStatic(context)
				end
			} 
			self.kOwnedTags.each{ e | 
				if ( e.isInstanceOf(Expression)) then
					if (context.verbose) then stdio.writeln("call resolveCallAndInferStatic 2 of "+e.toString) end
					e.asType(Expression).resolveCallAndInferStatic(context)
				end
			}
		end
		
		/**
		 * add this type to the Expression as staticType, also add to its containedType if it is not already contained
		 */
		operation setInferedStaticType(type : Type) : Type is do
			if not type.isVoid then
				self.staticType := type
				if(type.container.isVoid) then
					self.containedType.add(self.staticType)
				end
				result := self.staticType
			end
		end
	}
	
	aspect class Block
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			// compute content of the block 
			// super(context)
			
			// possibly replace all the statement by resolved ones
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Block") end
			var newStatements : kermeta::standard::OrderedSet<Expression> init kermeta::standard::OrderedSet<Expression>.new
			
			context.pushContext()
			self.statement.each{ oldStatement |
				newStatements.add(oldStatement.resolveCallAndInferStatic(context))
			}
			self.statement.clear
			self.statement.addAll(newStatements)
			
			self.rescueBlock.each{ r |
				r.resolveCallAndInferStatic(context)
			} 
			
			// TODO should we drill down into the other content of Block (for example: tag, ...)
			
			if (not self.statement.isEmpty()) then
				setInferedStaticType(self.statement.last.staticType)
			else
				setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Void"))
			end
			// type of the block is the same as the one of the last instruction of the block 
			result := self
			context.popContext()
		end 
	}
	
	aspect class CallExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallExpression") end
			
			var newParameters : kermeta::standard::OrderedSet<Expression> init kermeta::standard::OrderedSet<Expression>.new
			self.parameters.each{ oldParameter |
				newParameters.add(oldParameter.resolveCallAndInferStatic(context))
			}
			self.parameters.clear
			
			// self.parameters.addAll(newParameters)
			newParameters.each{ p | self.parameters.add(p) }
			
			result := self
		end
	}
	
	// FIXME to refactor: this method is too too long...
	aspect class UnresolvedCall {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of UnresolvedCall") end
			if (context.verbose) then stdio.writeln("resolving UnresolvedCall "+ name) end
			var targetType : Type 
			if (target.isVoid) then
				targetType := context.createSelfType
				if (context.verbose) then stdio.writeln("  targetType is self : targetType.typeDefinition="+targetType.asType(Class).typeDefinition.toString) end
				// look for a variable in the context
				var symbolType : Type init context.getTypeForSymbol(self.name)
				if not symbolType.isVoid then	
					var callVariable : CallVariable init CallVariable.new
					callVariable.name := self.name
					if (context.verbose) then stdio.writeln("  FOUND callVariable="+callVariable.name) end
					callVariable.setInferedStaticType(symbolType)
					//	this is the CallVariable that must replace this UnresolvedCall
					result := callVariable
				end
			else	
				if (context.verbose) then stdio.writeln("  infering targetType...") end
				// replace current target by the possibly resolved one
				target := target.resolveCallAndInferStatic(context)
				targetType := target.staticType
				if (context.verbose) then stdio.writeln("             targetType is infered as "+ targetType.toString + " for UnresolvedCall " + name) end
			end 
			
			super(context)		
				
			// if not already found, look for an Operation
			if result.isVoid then
				if (targetType.isVoid) then 
					stdio.writeln("Warning: targetType of "+ name +" is void. Cannot test if this is an operation. Probably due to a previous element that hasn't been resolved" ) 
				else
					var op : Operation init targetType.getCallableOperationByName(self.name)
					if op.isVoid and target.isInstanceOf(CallTypeLiteral) and not target.isVoid then
						if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Operation1 of UnresolvedCall") end
						// this is a TypeLiteral  
						// if this is a singleteton, try to look in the typereference
						var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
						op := callTypeLiteral.typeref.type.getCallableOperationByName(self.name)
					end
					//Here we must look into Object which is the implicit superclass of everything
					if (op.isVoid) then
						if (context.verbose) then stdio.writeln("Implicit inheritance to Object to find operation : "+self.name) end
						var objectAny : ClassDefinition
						objectAny := context.createClassDefinitionFromQualifiedName("kermeta::standard::Object")
						op := objectAny.getCallableOperationByName(self.name)
					end
					if not op.isVoid then
						if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Operation2 of UnresolvedCall") end
						var callOperation :  CallOperation init  CallOperation.new
						// move content of UnresolvedCall into the new CallOperation
						callOperation.name := self.name
						callOperation.kOwnedTags.addAll(self.kOwnedTags)
						// infer staticType of the content (except target which has been done previously)
						callOperation.eachOwnedElement{ e | 
							e.asType(KermetaModelElement).inferContainedExpressionStatic(context)
							e // scala compiler needs somthing to return
						}
						
						// reassign target and parameters
						callOperation.parameters.addAll(self.parameters)
						callOperation.target := self.target 
						// set staticOperation
						callOperation.staticOperation := op

						// The static type of the call operation must be infered.
						inferStaticTypeOfCallOperation(callOperation, op, context)

						if (context.verbose) then stdio.writeln("  CallOperation "+ name + " resolved") end
						//	this is the CallOperation that must replace this UnresolvedCall
						result := callOperation
					end
				end
			end
			// if not found, look for a Property
			if result.isVoid then
				if (targetType.isVoid) then 
					stdio.writeln("Warning: targetType of "+ name +" is void. Cannot test if this is a property. Probably due to a previous element that hasn't been resolved" ) 
				else
					var prop : Property init targetType.getCallablePropertyByName(self.name)
					if prop.isVoid and target.isInstanceOf(CallTypeLiteral) and not target.isVoid then
						if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Property1 of UnresolvedCall") end
						// this is a TypeLiteral  
						// if this is a singleteton, try to look in the typereference
						var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
						prop := callTypeLiteral.typeref.type.getCallablePropertyByName(self.name)
					end
					//Here we must look into Object which is the implicit superclass of everything
					if (prop.isVoid) then
						if (context.verbose) then stdio.writeln("Implicit inheritance to Object to find property : "+self.name)  end
						var objectAny : ClassDefinition
						objectAny := context.createClassDefinitionFromQualifiedName("kermeta::standard::Object")
						prop := objectAny.getCallablePropertyByName(self.name)
					end
					if not prop.isVoid then
						if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>Property2 of UnresolvedCall") end
						var callProperty :  CallProperty init  CallProperty.new
						// move content of UnresolvedCall into the new CallOperation
						callProperty.name := self.name
						//callProperty.parameters.addAll(self.parameters)
						callProperty.kOwnedTags.addAll(self.kOwnedTags)
						// infer staticType of the content (except target which has been done previously)
						callProperty.eachOwnedElement{ e | 
							e.asType(KermetaModelElement).inferContainedExpressionStatic(context)						
							e // scala compiler needs somthing to return
						}
						
						// reassign target
						callProperty.target := self.target 
						// set staticProperty
						callProperty.staticProperty := prop
						
						callProperty.setInferedStaticType(context.createTypeFromMultiplicityElement(prop))
						if (context.verbose) then stdio.writeln("  CallProperty "+ name + " resolved") end
						//	this is the CallProperty that must replace this UnresolvedCall
						result := callProperty
					end
				end
			end
			// if not found, Look into TypeDefinition  ( is there any TypeLiteral in kermeta 2 ?)
			if result.isVoid then
				if (context.verbose) then stdio.writeln("resolveCallAndInferStatic>TypeDef of UnresolvedCall") end
				var typeDef : TypeDefinition init context.currentModelingUnit.getTypeDefinitionByQualifiedName(self.name)
				
				//trying with the package
				if (typeDef.isVoid) then
					typeDef := context.currentModelingUnit.getTypeDefinitionByQualifiedName(getQualifiedNameResolving()+"::"+self.name)
				end
				
				// TODO deal with using
				if not typeDef.isVoid then
					if (context.verbose) then stdio.writeln("   resolveCallAndInferStatic>TypeDef found typeDef " + typeDef.name) end
					var callTypeLiteral : CallTypeLiteral init CallTypeLiteral.new
					callTypeLiteral.typeref := TypeReference.new
					if typeDef.isInstanceOf(ClassDefinition) then
						if (context.verbose) then stdio.writeln("   resolveCallAndInferStatic>TypeDef found a ClassDefinition " + typeDef.name) end
						callTypeLiteral.typeref.type := org::kermeta::language::structure::Class.new.initializeFromAClassDefinition(typeDef.asType(ClassDefinition))
						callTypeLiteral.typeref.containedType.add(callTypeLiteral.typeref.type)				
						// TODO deal with generics
										
						callTypeLiteral.setInferedStaticType(context.createTypeFromQualifiedName("org::kermeta::language::structure::Class"))
					end
					//	this is the CallTypeLiteral that must replace this UnresolvedCall
					result := callTypeLiteral
				end	
			end
			if result.isVoid then
				context.errors.add(ResolverException.new.initialize("The call " + name + " is undefined.", self))
				result := self		
			end
		end
		
		
		/**
		 * This method infers the static type of the given call operation.
		 */
		operation inferStaticTypeOfCallOperation(callOperation : CallOperation, op : Operation, context : StaticSetterContext) : Void is do
			//  The call of operation new that must not return type Object but the corresponding type associated to the new.
			//TODO Method clone must be supported there as well.
			if(op.name=="new" and op.owningClass.getQualifiedName()=="org::kermeta::language::structure::Class" and 
				(not callOperation.target.isVoid).andThen{b | callOperation.target.isInstanceOf(CallTypeLiteral) }) then
				callOperation.setInferedStaticType(callOperation.target.asType(CallTypeLiteral).typeref.type)
			else
				callOperation.setInferedStaticType(context.createTypeFromMultiplicityElement(op))
			end
		end
	}
	
	aspect class CallFeature
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallFeature") end
			// compute content of the CallFeature 
			super(context)		
			result := self
		end 
	}
	
	aspect class EmptyExpression
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of EmptyExpression") end
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Void"))			
			result := self
		end 
	}
	
	aspect class StringLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of StringLiteral") end
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::String"))								
			result := self
		end 
	}

	aspect class IntegerLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of IntegerLiteral") end
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Integer"))								
			result := self
		end 
	}	
	
	aspect class VoidLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of VoidLiteral")	 end
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Void"))								
			result := self
		end 
	}
	
	aspect class BooleanLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of BooleanLiteral") end
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Boolean"))								
			result := self
		end 
	}
	
	aspect class VariableDecl {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of VariableDecl") end
			// compute contained expressions
			//super(context)
			
			// compute type of Initialization
			if (not self.initialization.isVoid) then
				self.initialization := self.initialization.resolveCallAndInferStatic(context)
			end
			
			//compute type of TypeReference
			var staticTypeVariable : Type init context.createTypeFromMultiplicityElement(self.type)
			
			// type of the variable
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Void"))
			 			 			
			result := self
			
			// this variable can be used in the current context stack
			context.addSymbol(self.identifier, staticTypeVariable)
		end 
	}
	
	aspect class Assignment {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Assignment") end
			
			self.target := self.target.resolveCallAndInferStatic(context).asType(CallExpression) 
					
			self.setInferedStaticType(self.target.staticType)
						
			self.~value := self.~value.resolveCallAndInferStatic(context)
			
			result := self
		end
	}
	
	aspect class Conditional {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Conditional") end
			
			var staticTypeOfIF : ProductType init ProductType.new
			
			self.thenBody := self.thenBody.resolveCallAndInferStatic(context)
			
			staticTypeOfIF.type.add(self.thenBody.staticType)
			
			self.condition := self.condition.resolveCallAndInferStatic(context)
			
			if (not self.elseBody.isVoid) then
				self.elseBody := self.elseBody.resolveCallAndInferStatic(context)
				staticTypeOfIF.type.add(self.elseBody.staticType)
			end
			
			self.setInferedStaticType(staticTypeOfIF)
			
			result := self
		end
	}
	
	aspect class Loop {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Loop") end
			
			var staticTypeOfLOOP : Type
			
			context.pushContext()
			
			if (not self.initialization.isVoid) then
				self.initialization := self.initialization.resolveCallAndInferStatic(context)
			end
			
			self.stopCondition := self.stopCondition.resolveCallAndInferStatic(context)
			
			if (not self.body.isVoid) then
				self.body := self.body.resolveCallAndInferStatic(context)
				staticTypeOfLOOP := self.body.staticType
			end
			
			if (staticTypeOfLOOP.isVoid) then
				context.createTypeFromQualifiedName("kermeta::standard::Void")
			end
			
			self.setInferedStaticType(staticTypeOfLOOP)
			
			result := self
			
			context.popContext()
		end
	}
	
	aspect class SelfExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of SelfExpression") end
			// Creation of a type based on the current class definition corresponding to the self.
			var type : Class init Class.new
			type.typeDefinition := context.currentClassDefinition
			self.setInferedStaticType(type)
			result := self
		end
	}
	
	aspect class Raise {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Raise") end
			
			self.expression := self.expression.resolveCallAndInferStatic(context)
			
			self.setInferedStaticType(self.expression.staticType)
			
			result := self
		end
	}
	
	aspect class LambdaExpression {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of LambdaExpression") end
				
			self.body := self.body.resolveCallAndInferStatic(context)
			
			self.setInferedStaticType(self.body.staticType)
			
			result := self
		end 
	}
	
	aspect class Rescue {
		operation resolveCallAndInferStatic(context : StaticSetterContext) is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of Rescue") end
				
				
			var newBody : kermeta::standard::OrderedSet<Expression> init kermeta::standard::OrderedSet<Expression>.new

			self.body.each{rb |
				newBody.add(rb.resolveCallAndInferStatic(context))
			}
			
			self.body.clear
			self.body.addAll(newBody) 
		end 
	}
	
	aspect class CallResult {
		operation findOperation(currentContainer : KermetaModelElement) : Operation is do
			if currentContainer.isInstanceOf(Operation) then
				result := currentContainer.asType(Operation)
			else
				if currentContainer.container.isVoid then
					result := void
				else
					result := findOperation(currentContainer.container.asType(KermetaModelElement))
				end
			end
		end
	
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			if (context.verbose) then stdio.writeln("resolveCallAndInferStatic of CallResult") end  
			
			var operationContainer : Operation init findOperation(self.container().asType(KermetaModelElement))
			
			if (operationContainer.isVoid) then
				context.errors.add(ResolverException.new.initialize("Not able to find the containing operation.", self))
			else
				self.setInferedStaticType(operationContainer.type)
			end
			
			result := self
		end
	}
}