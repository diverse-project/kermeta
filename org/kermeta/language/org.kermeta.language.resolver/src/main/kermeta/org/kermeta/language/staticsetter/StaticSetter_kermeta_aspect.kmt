/* $Id:$ 
 * Creation : December 29, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            dvojtise
 * this Aspect compute the staticType and resolve the UnresolvedCall
 */


package org::kermeta::language;


require kermeta
require "platform:/resource/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/eachOwnedElement_kermeta_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetCallableFeatures_structure_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/ModelingUnitHelper_structure_aspect.kmt"
require "StaticSetterContext.kmt"
require "../resolver/ResolverException.kmt"

using org::kermeta::language::structure
using org::kermeta::language::staticsetter

package structure {
	 aspect class Object {
		operation inferContainedExpressionStatic(context : StaticSetterContext) is do
						
			// the algorithm is bottom up
			// compute leaf then goes up in the container which can then reuse their results
			// workaround compiler bug : issue when adding aspect on object
			// put this method as helper that do the same, called by direct subclasses of Object
			context.inferContainedExpressionStatic(self)
		end
	} 
	aspect class NamedElement {
		method inferContainedExpressionStatic(context : StaticSetterContext) is do
			context.inferContainedExpressionStatic(self)
		end
	}
	aspect class TypeContainer {
		method inferContainedExpressionStatic(context : StaticSetterContext) is do
			context.inferContainedExpressionStatic(self)
		end
	}
	aspect class ClassDefinition {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement is do
			context.currentClassDefinition := self			
			super(context)
			context.currentClassDefinition := void
		end
	}
	aspect class Operation {
		method inferContainedExpressionStatic(context : StaticSetterContext) from NamedElement  is do
			context.currentOperation := self
			context.pushContext()
			self.ownedParameter.each{ param | 				
				context.addSymbol( param.name, param.type)
			}			
			super(context)
			context.popContext()
			context.currentOperation := void
		end
	}
}

package behavior {
	aspect class Expression
	{
		operation resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			// by default the StaticType is void
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Void"))			
			result := self
			
			// the algorithm is bottom up
			// compute leaf then goes up in the container which can then reuse their results
			self.containedType.each{ e | 
				if ( e.isInstanceOf(Expression)) then
					e.asType(Expression).resolveCallAndInferStatic(context)
				end
			} 
			self.kOwnedTags.each{ e | 
				if ( e.isInstanceOf(Expression)) then
					e.asType(Expression).resolveCallAndInferStatic(context)
				end
			}
		end
		
		/**
		 * add this type to the Expression as staticType, also add to its containedType if it is not already contained
		 */
		operation setInferedStaticType(type : Type) : Type is do
			if type.isVoid then
				raise org::kermeta::language::resolver::ResolverException.new
			end
			self.staticType := type
			if(type.container.isVoid) then
				self.containedType.add(self.staticType)
			end
			result := self.staticType
		end
	}
	
	aspect class Block
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			// compute content of the block 
			// super(context)
			
			// possibly replace all the statement by resolved ones
			var newStatements : kermeta::standard::OrderedSet<Expression> init kermeta::standard::OrderedSet<Expression>.new
			self.statement.each{ oldStatement |
				newStatements.add(oldStatement.resolveCallAndInferStatic(context))
			}
			self.statement.clear
			self.statement.addAll(newStatements)
			
			self.rescueBlock.each{ r |
				r.inferContainedExpressionStatic(context)
			} 
			
			// TODO should we drill down into the other content of Block (for example: tag, ...)
			
			setInferedStaticType(self.statement.last.staticType)
			// type of the block is the same as the one of the last instruction of the block 
			result := self
		end 
	}
	
	aspect class UnresolvedCall {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			stdio.writeln("resolving UnresolvedCall "+ name)
			var targetType : Type 
			if (target.isVoid) then
				targetType := context.createSelfType
				stdio.writeln("  targetType is self : targetType.typeDefinition="+targetType.asType(Class).typeDefinition.toString)
				// look for a variable in the context
				var symbolType : Type init context.getTypeForSymbol(self.name)
				if not symbolType.isVoid then	
					var callVariable : CallVariable init CallVariable.new
					callVariable.name := self.name
					callVariable.setInferedStaticType(symbolType)
					//	this is the CallVariable that must replace this UnresolvedCall
					result := callVariable
				end
			else	
				
				
				stdio.writeln("  infering targetType...")
				// replace current target by the possibly resolved one
				target := target.resolveCallAndInferStatic(context)
				targetType := target.staticType
				stdio.writeln("  targetType is infered as "+ targetType.toString)
			end 
			
			// possibly replace all the parameters by resolved ones
			var newParameters : kermeta::standard::OrderedSet<Expression> init kermeta::standard::OrderedSet<Expression>.new
			self.parameters.each{ oldParameter |
				newParameters.add(oldParameter.resolveCallAndInferStatic(context))
			}
			self.parameters.clear
			
			// self.parameters.addAll(newParameters)
			newParameters.each{ p | self.parameters.add(p) }
			
			
				
			// if not already found, look for an Operation
			if result.isVoid then
				var op : Operation init targetType.getCallableOperationByName(self.name)
				if op.isVoid and target.isInstanceOf(CallTypeLiteral) and not target.isVoid then
					// this is a TypeLiteral  
					// if this is a singleteton, try to look in the typereference
					var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
					op := callTypeLiteral.typeref.type.getCallableOperationByName(self.name)
				end
				if not op.isVoid then
					var callOperation :  CallOperation init  CallOperation.new
					// move content of UnresolvedCall into the new CallOperation
					callOperation.name := self.name
					callOperation.kOwnedTags.addAll(self.kOwnedTags)
					// infer staticType of the content (except target which has been done previously)
					callOperation.eachOwnedElement{ e | 
						e.asType(Object).inferContainedExpressionStatic(context)
						e // scala compiler needs somthing to return
					}
					
					// reassign target and parameters
					callOperation.parameters.addAll(self.parameters)
					callOperation.target := self.target 
					// set staticOperation
					callOperation.staticOperation := op
					
					callOperation.setInferedStaticType(context.createTypeFromMultiplicityElement(op))
					stdio.writeln("  CallOperation "+ name + " resolved")
					//	this is the CallOperation that must replace this UnresolvedCall
					result := callOperation
				end
			end
			// if not found, look for a Property
			if result.isVoid then
				var prop : Property init targetType.getCallablePropertyByName(self.name)
				if prop.isVoid and target.isInstanceOf(CallTypeLiteral) and not target.isVoid then
					// this is a TypeLiteral  
					// if this is a singleteton, try to look in the typereference
					var  callTypeLiteral : CallTypeLiteral init target.asType(CallTypeLiteral)
					prop := callTypeLiteral.typeref.type.getCallablePropertyByName(self.name)
				end
				if not prop.isVoid then
					var callProperty :  CallProperty init  CallProperty.new
					// move content of UnresolvedCall into the new CallOperation
					callProperty.name := self.name
					//callProperty.parameters.addAll(self.parameters)
					callProperty.kOwnedTags.addAll(self.kOwnedTags)
					// infer staticType of the content (except target which has been done previously)
					callProperty.eachOwnedElement{ e | 
						e.asType(Object).inferContainedExpressionStatic(context)						
						e // scala compiler needs somthing to return
					}
					
					// reassign target
					callProperty.target := self.target 
					// set staticProperty
					callProperty.staticProperty := prop
					
					callProperty.setInferedStaticType(context.createTypeFromMultiplicityElement(prop))
					stdio.writeln("  CallProperty "+ name + " resolved")
					//	this is the CallProperty that must replace this UnresolvedCall
					result := callProperty
				end
			end
			// if not found, Look into TypeDefinition  ( is there any TypeLiteral in kermeta 2 ?)
			if result.isVoid then
				var typeDef : TypeDefinition init context.currentModelingUnit.getTypeDefinitionByQualifiedName(self.name)
				// TODO deal with using
				if not typeDef.isVoid then
					var callTypeLiteral : CallTypeLiteral init CallTypeLiteral.new
					callTypeLiteral.typeref := TypeReference.new
					if typeDef.isInstanceOf(ClassDefinition) then
						callTypeLiteral.typeref.type := org::kermeta::language::structure::Class.new.initializeFromAClassDefinition(typeDef.asType(ClassDefinition))
						callTypeLiteral.typeref.containedType.add(callTypeLiteral.typeref.type)				
						// TODO deal with generics
										
						callTypeLiteral.setInferedStaticType(context.createTypeFromQualifiedName("org::kermeta::language::structure::Class"))
					end
					//	this is the CallTypeLiteral that must replace this UnresolvedCall
					result := callTypeLiteral
				end	
			end
			if result.isVoid then
				raise org::kermeta::language::resolver::ResolverException.new.initialize("failed to resolve UnresolvedCall "+ name, void)
			else
				
			end
		end
	}
	
	aspect class CallFeature
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			// compute content of the CallFeature 
			super(context)
			
			
			var targetType : Type 
			if (target.isVoid) then
				targetType := context.createSelfType
			else
				targetType := target.staticType
			end 
			result := self
		end 
	}
	
	aspect class EmptyExpression
	{
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::Void"))			
			result := self
		end 
	}
	
	aspect class StringLiteral {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			setInferedStaticType(context.createTypeFromQualifiedName("kermeta::standard::String"))								
			result := self
		end 
	}
	
	
	aspect class VariableDecl {
		method resolveCallAndInferStatic(context : StaticSetterContext) : Expression is do
			// compute contained expressions
			super(context)
			
			// type of the variable
			setInferedStaticType(context.createTypeFromMultiplicityElement(self.type)) 			 			
			result := self
			
			// this variable can be used in the current context stack
			context.addSymbol(self.identifier, self.staticType)
		end 
	}
}