/* $Id:$ 
 * Creation : July 6, 2011
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            cbouhour
 *			Xavier Dolques
 */
package org::kermeta::language;



using kermeta::standard
using kermeta::io
using org::kermeta::language::structure
using org::kermeta::language::behavior



package structure{

	class Helper {
	
		operation keywordEscape(s : String):String is do
			if s.equals("operation") or s.equals("result") or s.equals("value") or s.equals("class") or s.equals("abstract") then
				result:="~"+s
			else
				result:=s
			end
			
		end
	}
	
	aspect class NamedElement{
		operation qualifiedName() : String is do
			result:=""
			if not name.isVoid then
				if  container.isVoid.~not.andThen{x|container.isInstanceOf(NamedElement) and not container.isInstanceOf(ModelingUnit)} then
					result:=container.asType(NamedElement).qualifiedName+"::"+name
				else
					result:=name
				end
			else
				StdIO.writeln("namedElement without name")
				StdIO.writeln(self.toString)
				
			end
		end
	}

	aspect class KermetaModelElement{
		operation prettyPrint(indent : Integer) : String is do
			result := ""
		end
		
		operation printIndent(indent:Integer):String is do
			result :=""
			from var i : Integer init 0
			until i==indent 
			loop
				result:=result+"\t"
				i:=i+1
			end
			
		end
	}

	aspect class ModelingUnit{
		method prettyPrint(indent : Integer) : String is do
			result := ""
			self.packages.each{ onePackage |
				result := result + onePackage.prettyPrint(indent)
			}
		end
	}
	
	aspect class Package{
		method prettyPrint(indent : Integer) : String is do
			result :=printIndent(indent)+ "package "+self.name+" {\n"
			self.nestedPackage.each{p|
				result := result + p.prettyPrint(indent+1)
			}
			result:=result+"\n"
			self.ownedTypeDefinition.each{ td |
				result := result + td.prettyPrint(indent +1)
			}
			result := result + "}\n"
		end
	}
	
	aspect class ClassDefinition{
		method prettyPrint(indent : Integer) : String is do
			if not name.isVoid then
				result :=printIndent(indent)+ "class "+self.name+" {\n"
				self.ownedAttribute.each{att|
					result := result + att.prettyPrint(indent +1)
				
				}
				self.ownedOperation.each{op|
					result := result + op.prettyPrint(indent +1)
				}
				
				result := result + printIndent(indent)+"}\n"
			else
				result:=""
				StdIO.writeln("classdef with no name")
			end
		end
	}
	aspect class Class {
		method typePrettyPrint(indent : Integer) : String is do
			if not typeDefinition.isVoid then
				result := typeDefinition.qualifiedName
				
			else
				result:=""
				StdIO.writeln("class with no typedef")
			end
					
		
		end
	}
	
	aspect class Property{
		method prettyPrint(indent : Integer) : String is do
			if not (name.isVoid or type.isVoid) then
				var propertyType : String //init 
				
				if isComposite then 
				
					propertyType:="attribute " 
				else 
				
					propertyType:="reference " 
				end
				
				result := printIndent(indent)+ propertyType +Helper.new.keywordEscape(self.name)+" : "+self.type.typePrettyPrint(indent) + "\n"

			else
				result:=""
				StdIO.writeln("property with no name or type")
			end
		end
	}
	
	aspect class Type{
		operation typePrettyPrint(indent : Integer):String is do
		result:=""
		end
	
	}
	aspect class UnresolvedType{
		method typePrettyPrint(indent : Integer) : String is do
			result := typeIdentifier
			if generics.size!=0 then
				result := result+"<"
				var first :Boolean init true
				generics.each{g|
					result := result+g.prettyPrint(indent)
					if first then
						first:=false
					else
						result := result+","
					end	
				} 
				
				result := result+">"
			end
		end
	
	}
	
	
	aspect class Operation{
		method prettyPrint(indent : Integer) : String is do
			
			result :=printIndent(indent)+ "operation "+self.name()+"("
			if (not self.ownedParameter.isVoid) then
				var i : Integer init 0
				self.ownedParameter.each{ oneParam |
					if (i!=0) then
						result := result + ","
					end 
					if oneParam.name.isVoid.~not then
						result := result + Helper.new.keywordEscape(oneParam.name) + ":" + oneParam.type.typePrettyPrint(indent)
					else
						StdIO.writeln("param with no name")
					end
					i := i + 1
				}
			end
			result := result + ")"
			if not type.isVoid then
				result := result + ":" + self.type.typePrettyPrint(indent)
			else
				StdIO.writeln("op with no type"+name)
			end
			result := result + " is\n"
			if (not self.body.isVoid) then
				result := result + self.body.prettyPrint(indent +1)
			end
			result := result + "\n"
		end
	}
	
}

package behavior {
	
	aspect class Expression {
		method prettyPrint(indent : Integer) : String is do
			result := ""
		end
	}
	
	aspect class CallTypeLiteral {
		method prettyPrint(indent : Integer) : String is do
			result:=typeref.prettyPrint(indent)
		end
	
	}
	
	aspect class TypeReference {
	
		method prettyPrint(indent : Integer) : String is do
		if upper!=1 then
			if isOrdered and isUnique then
				result:="oset "
			end
			if isOrdered and not isUnique then
				result:="seq "
			end
			if isUnique and not isOrdered then
				result:="set "
			end
			if (not isUnique) and not isOrdered then
				result:="bag "
			end
		else
			result:=""	
		end
		result:=result+type.typePrettyPrint(indent)
		if upper!=1 then
			result:=result+"["+lower+","+"*]"
		end
		end
	
	}
	
	aspect class Block {
		method prettyPrint(indent : Integer) : String is do
			if not container.isInstanceOf(Block) then
				result := printIndent(indent)
			else
				result:=""
			end
			result := result+"do\n"
			if (not self.statement.isVoid) then
				self.statement.each{ one |
					result := result + printIndent(indent+1)+ one.prettyPrint(indent+1)+"\n"
				}
			end
			result := result +printIndent(indent)+ "end\n"
		end
	}
	
	aspect class VariableDecl {
		method prettyPrint(indent : Integer) : String is do
			if not container.isInstanceOf(Block) then
				result := printIndent(indent)
			else
				result:=""
			end
			result := result +"var "+self.identifier+" : "+self.type.toString()
			if (not self.initialization.isVoid) then
				result := result + " init " + self.initialization.prettyPrint(indent)
			end
			result := result + "\n"
		end
	}
	
	aspect class Conditional {
		method prettyPrint(indent : Integer) : String is do
			if not container.isInstanceOf(Block) then
				result := printIndent(indent)
			else
				result:=""
			end
			result := result +"if ("+self.condition.prettyPrint(indent)+") then\n"
			result := result + self.thenBody.prettyPrint(indent+1)
			if (not self.elseBody.isVoid) then
				result := result + printIndent(indent)+ "else\n"
				result := result + self.elseBody.prettyPrint(indent+1)
			end
			result :=result + printIndent(indent)+ "end\n" 
		end
	}
	
	aspect class Loop {
		method prettyPrint(indent : Integer) : String is do
			if (not self.initialization.isVoid) then
				result := printIndent(indent)+"from "+self.initialization.prettyPrint(indent)
			else
				result:=""
			end
			result := result+printIndent(indent)+" until "+self.stopCondition.prettyPrint(indent)+" loop\n"
			if (not self.body.isVoid) then
				result := result + self.body.prettyPrint(indent+1)
			end
			result := printIndent(indent)+result + "\n"
		end
	}
	
	aspect class LambdaExpression{
		method prettyPrint(indent : Integer) : String is do
			result := "{ "
			
			if (not self.parameters.isVoid) then
				var i : Integer init 0
				self.parameters.each{ oneParam |
					if (i!=0) then
						result := result + ","
					end 
					result := result + oneParam.name() + ":" + oneParam.type.toString()
					i := i + 1
				}
			end
			
			result := result + " | \n"
			
			result := result + self.body.prettyPrint(indent)
			
			result := result + "}"
		end
	}
	
	aspect class IntegerLiteral {
		method prettyPrint(indent : Integer) : String is do
			result := self.~value.toString() 
		end
	}
	
	aspect class StringLiteral {
		method prettyPrint(indent : Integer) : String is do
			result := "\""+self.~value +"\""
		end
	}
	
	aspect class BooleanLiteral {
		method prettyPrint(indent : Integer) : String is do
			result := self.~value.toString()
		end
	}
	
	aspect class VoidLiteral {
		method prettyPrint(indent : Integer) : String is do
			result := "Void"
		end
	}
	
	aspect class CallFeature {
		method prettyPrint(indent : Integer) : String is do
			if not self.name.isVoid then
				if target.isVoid then
					result := Helper.new.keywordEscape(self.name)
				else
					result :=target.prettyPrint(indent)+"."+Helper.new.keywordEscape(self.name)
				end
				if (not self.parameters.isVoid) then
					result := result + "("
					var i : Integer init 0
					self.parameters.each{ oneParam |
						if (i!=0) then
							result := result + ","
						end 
						result := result + oneParam.prettyPrint(indent)
						i := i + 1
					}
					
					result := result + ")"
				end
				
			else
				result:=""
				StdIO.writeln("call expression without name")
			end
		end
	}
	aspect class CallResult {
		method prettyPrint(indent : Integer) : String is do
			result := "result"
		end
	}
	
	aspect class SelfExpression {
		method prettyPrint(indent : Integer) : String is do
			result := "self"
		end
	}
	
	aspect class UnresolvedCall {
		method prettyPrint(indent : Integer) : String from org::kermeta::language::behavior::CallFeature is do
			result := ""
			if (not self.target.isVoid) then
				result := self.target.prettyPrint(indent)+"."
			end
			result := result + self.name
		end
	}
}