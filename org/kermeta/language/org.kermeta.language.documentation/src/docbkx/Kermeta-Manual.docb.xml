<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!-- $Id$ -->
<book lang="en-US">
	<bookinfo>
		<mediaobject>
			<imageobject>
				<imagedata fileref="Kermeta-Manual_figures/KermetaLogo.png" format="PNG" />
			</imageobject>
		</mediaobject>
		<title>Kermeta language</title>

		<pubdate>Build
			: &version; &buildNumber;
		</pubdate>
		<date>$Date::                     $</date>


		<author>
			<firstname>Zoé</firstname>
			<surname>Drey</surname>
		</author>

		<author>
			<firstname>Cyril</firstname>
			<surname>Faucher</surname>
		</author>

		<author>
			<firstname>Franck</firstname>
			<surname>Fleurey</surname>
		</author>

		<author>
			<firstname>Vincent</firstname>
			<surname>Mahé</surname>
		</author>

		<author>
			<firstname>Didier</firstname>
			<surname>Vojtisek</surname>
		</author>

		<keywordset>
			<keyword>Kermeta</keyword>
			<keyword>metamodeling</keyword>
			<keyword>language</keyword>
		</keywordset>

		<subtitle>Reference manual</subtitle>
		<bibliomisc>License EPL</bibliomisc>

		<abstract>
			<para>This manual presents the various aspects of the Kermeta
				language.
				This is the reference
				manual for anybody who want to use
				Kermeta.
			</para>
		</abstract>

		<publisher>
			<publishername>INRIA</publishername>

			<address><state>France</state>
<otheraddr><ulink url="http://www.inria.fr">http://www.inria.fr</ulink></otheraddr></address>
		</publisher>
	</bookinfo>

	<preface id="preface.link">
		<title id="preface.title.link">
			Preface
			<phrase id="preface"></phrase>
		</title>
		<para>Kermeta is workbench and an action language dedicated to
			metamodel
			engineering.
		</para>
		<para>
			The action language is a Domain Specific Language (DLS) that
			fills the
			gap let by MOF which
			defines only the structure
			of
			meta-models, by adding a way to specify static semantic (similar to
			OCL) and dynamic semantic (using operational semantic in the
			operation of
			the metamodel). Kermeta
			uses the object-oriented paradigm
			like Java or
			Eiffel.
		</para>
		<para>The workbench allows to mashup various languages that, like
			Kermeta,
			works at the MOF level.
			(For example, OCL, QVT, UML profiles,
			...).
			This means that, at design time, a user may decide to
			use a
			language
			adapted for a given task.
			The workbench will help to combine
			the various inputs in an
			efficient
			runtime.
		</para>

		<para>
			This document gives beginners an
			<link linkend="chapter_introduction.link">introduction</link>
			to the Kermeta
			action language and to the workbench, then it offers a
			<link linkend="chapter_reference">reference</link>
			of all the aspects of the
			language, including the textual syntax, the
			metamodeling features and
			some
			more advanced features. Two other
			chapters present the
			<link linkend="chapter_kermeta_mm">Kermeta Metamodel</link>
			and the
			<link linkend="chapter_framework">Kermeta framework</link>
			.
		</para>

		<important>
			<para>
				Kermeta is an evolving software and despite that we put a lot of
				attention to this document, it
				may contain errors (more likely in
				the code samples). If you find any error or have some
				information
				that improves this document, please send it to us using the bug
				tracker in the forge:

				<ulink type="" url="http://gforge.inria.fr/tracker/?group_id=32">
					<emphasis role="strong">http://gforge.inria.fr/tracker/?group_id=32
					</emphasis>
				</ulink>

				or using the developer mailing list
				(kermeta-developers@lists.gforge.inria.fr)
			</para>
		</important>

		<tip>
			<para>
				The most update version of this document is available on line from
				<ulink type="" url="http://www.kermeta.org/">http://www.kermeta.org</ulink>
				.
			</para>
		</tip>
		<simplesect>
			<title>New or changed in Kermeta 2</title>
			<para>Kermeta has undergone a major refactorings between its version
				1.x and 2.x. They apply both
				to the internal tooling and also on the
				language itself.
				In order to help identify the major
				changes between
				these versions,
				you can look for notes like the following :
			</para>
			<note>
				<title>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="gfx/fire.png" contentdepth="2em" />
						</imageobject>
					</inlinemediaobject>
					New in Kermeta 2
				</title>
				<para></para>
			</note>
			<para>
				<itemizedlist>
					<listitem>
						<para>
							<xref linkend="section_singleton_class.link" />
							,
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<note>
				<title>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="gfx/fire.png" contentdepth="2em" />
						</imageobject>
					</inlinemediaobject>
					Changed in Kermeta 2
				</title>
				<para></para>
			</note>
			<para>
				You'll find the most significant in the following sections :
				<itemizedlist>
					<listitem>
						<para>
							<xref linkend="section_using.link" />
							,
						</para>
					</listitem>
					<listitem>
						<para>
							<xref linkend="section_singleton_class.link" />
							,
						</para>
					</listitem>
					<listitem>
						<para>
							<xref linkend="section_weaving.link" />
							,
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</simplesect>
	</preface>

	<chapter id="chapter_introduction.link">
		<title id="chapter_introduction.title.link">Introduction to Kermeta</title>

		<para>This chapter aims to help you to have a quick overview of most
			of
			the features of Kermeta.
			Then, it gives the pointers to the
			detailed
			sections in the reference chapter. It also gives some
			small
			examples
			that
			should help you to understand the basis of the concepts
			without having to
			jump to
			the corresponding detailed section.
		</para>

		<section id="sec_introduction_presentation.link">
			<title id="sec_introduction_presentation.title.link">Presentation</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>Kermeta is a metamodeling language which allows describing both
				the structure and the
				behavior of models. It has been designed to be
				compliant with the OMG metamodeling language EMOF
				(part of the MOF
				2.0
				specification) and Ecore (from Eclipse). It provides an action
				language
				for
				specifying the behavior of models.
			</para>

			<para>Kermeta is intended to be used as the core language of a model
				oriented platform. It has
				been designed to be a common basis to
				implement Metadata languages, action languages, constraint
				languages
				or
				transformation language.
			</para>

			<figure id="refIllustration0">
				<title>Kermeta positioning</title>

				<mediaobject>
					<imageobject>
						<imagedata fileref="Kermeta-Manual_figures/kermeta_positioning2.png" />
					</imageobject>
				</mediaobject>
			</figure>

			<para>In a nutshell, Kermeta is :</para>

			<itemizedlist>
				<listitem>
					<para>MOF compliant (EMOF compliant to be precise)</para>
				</listitem>

				<listitem>
					<para>Model oriented</para>
				</listitem>

				<listitem>
					<para>Imperative</para>
				</listitem>

				<listitem>
					<para>Object-Oriented</para>
				</listitem>
				<listitem>
					<para>Aspect-Oriented</para>
				</listitem>

				<listitem>
					<para>Statically Typed (100% typesafe)</para>
				</listitem>
			</itemizedlist>

			<para>In addition to these characteristics, it includes some
				typically
				model-oriented concepts like
				associations, multiplicities
				or object
				containment management.
			</para>

			<para>This chapter presents the main features of the Kermeta
				language.
				Section 2 presents the
				general syntax of the language,
				sections 3 &amp;
				4 give details about the object-oriented and
				model-oriented features
				of
				the language and finally section 4 provides
				information about some
				extra
				concepts in Kermeta (including aspect
				orientation).
			</para>
			<para>With its workbench, it's goal is to provide a
				support for all
				Language Driven Engineering
				activities. It will be
				typically
				used to
				build tools useful to build software. This includes (but
				is not
				restricted to):
				model checkers, simulators, model transformations
				(any kind of
				transformations
				including model weavers or compilers).
			</para>

		</section>

		<section>
			<title>Action language : An imperative syntax</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>Th action language of Kermeta is an imperative language for
				modeling, with a basic
				syntax
				inspired from Eiffel. Code is
				statically type checked, and
				execution is made by a compiler in its
				version 2.x. The previous
				version of Kermeta (up to 1.x)
				were executed
				thanks to an interpreter.
			</para>

			<section id="section_first_program.link">
				<title id="section_first_program.title.link">
					First Program
					<phrase id="section_first_program"></phrase>
				</title>

				<para>Even if it is not very useful in our context, since it doesn't
					show the really interresting
					structures of the language, here is
					the
					traditional " Hello world " example you can find in every
					programming
					book.
				</para>
				<example>
					<title>MainClass.kmt</title>
					<programlisting language="kermeta">package helloworld;

using kermeta::standard             // shorthand for standard types
using kermeta::io::StdIO => stdio   // shorthand to kermeta::io::StdIO

class HelloworldExample
{
    operation sayHello() is
    do
        stdio.writeln("Hello world, ...")
    end
}</programlisting>
				</example>
				<example>
					<title>hello.kp</title>
					<programlisting language="kp">KermetaProject "hello"
	groupId = "my.group"
	defaultMainClass = "helloworld::HelloworldExample"
	defaultMainOperation = "sayHello"
	sources = {
		require "${project.baseUri}/src/main/kmt/MainClass.kmt"
	}
	dependencies = {
		//default dependency to kermeta framework (try first in eclipse plugin, then look into maven repository)
		dependency "library.core" ="platform:/plugin/org.kermeta.language.library.core",
		                           "mvn:org.kermeta.language/language.library.core/2.0.4"
	}</programlisting>
				</example>
			</section>

			<section>
				<title>Classic features</title>

				<para>Kermeta language includes usual statements like blocks and
					loops, comments, etc
				</para>

				<programlisting language="kermeta">do
    // a loop for getting a text from an user
    var s : kermeta::standard::String
    from var found : kermeta::standard::Boolean init false
    until found
    loop
        s := stdio.read("Enter a text:\n --&gt; ")
        if s.size &gt; 0 then
            found := true
        else
            stdio.writeln("ERROR - Empty text!")
        end
    end
    stdio.writeln("\n You entered: " + s)
end
</programlisting>
			</section>

			<section>
				<title>Corresponding sections in the Reference chapter</title>

				<para>
					All these "classic" imperative features and their syntaxes are
					described in
					<xref linkend="chapter_reference.link" />
					. More precisely
					in
					<itemizedlist>
						<listitem>
							<para>
								<xref linkend="section_comments.link" />
								,
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_statements.link" />
								,
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_variables.link" />
								,
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_operators.link" />
								,
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_reserved_keywords.link" />
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
		</section>

		<section>
			<title>Action language : An object-oriented language</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>Users of modern programming languages, like Java, would feel
				easy with object-oriented
				features in Kermeta: classes, inheritance,
				exceptions, and even genericity.
			</para>

			<programlisting language="kermeta">// persons who write documents
class Writer {
    attribute name : kermeta::standard::String
}

// generic concept for every document
abstract class Document {
    reference author : Writer
    attribute text : kermeta::standard::String
}

// a "Document" from the real world
class Book inherits Document {}

// a specialized "Book"
class ChildBook inherits Book {
    attribute minimalAge : kermeta::standard::Integer
}</programlisting>

			<para>Such classes can be used for verifications:</para>

			<programlisting language="kermeta">// a specialized Exception
class AgeException inherits kermeta::exceptions::Exception {}

abstract class Reader {
    operation read(book : ChildBook) : Void is abstract
}

class Child inherits Reader {
    attribute age :  kermeta::standard::Integer
    operation initialize(age :  kermeta::standard::Integer) : Child is
    do
        self.age := age
        result := self // return self so we can chain this call directly after a new
    end
    // an action which triggers an Exception
    operation read(book : ChildBook) : Void is
    do
        if age &lt; book.minimalAge then
            raise AgeException.new
        end
    end
}</programlisting>

			<section>
				<title>Corresponding sections in the Reference chapter</title>

				<para>
					You can get more informations about Kermeta object-oriented
					features in
					<xref linkend="chapter_reference.link" />
					. More precisely
					in
					<itemizedlist>
						<listitem>
							<para>
								<xref linkend="section_classesandmethods.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_inheritance.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_genericity.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_exceptions.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_packages.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_properties.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_singleton_class.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_object_comparison.link" />
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
		</section>

		<section>
			<title>Action Language : A model-oriented language</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>
				As explained in the
				<xref endterm="preface.title.link" linkend="preface.link" />
				and in
				<xref endterm="section_architecture.title.link" linkend="section_architecture.link" />
				, Kermeta extends the MOF. It
				provides useful means to manipulate
				models. The support of model
				introduces
				the main difference with
				"more" traditional programming languages.
			</para>

			<section id="section_toward_a_first_concrete_example.link">
				<title>Associations : toward a first concrete
					example of a Kermeta
					model
				</title>

				<para>Association is one of the key concepts when using and defining
					models.
					It is obviously part
					of Kermeta.
				</para>
				<para>
					MOF defines the concept of "Property" which generalizes the
					notions
					of attributes, and
					associations (composite or not) that you
					can find
					in UML. Kermeta syntax also distinguishes these
					two notions
					as
					introduced in
					<xref linkend="section_properties.link" />
					.
				</para>

				<para>
					As a reminder, the
					<literal>attribute</literal>
					keyword defines
					a link with containment (a composite association)
					whereas the
					<literal>reference</literal>
					keyword just defines an association. As
					you can see, property
					declarations are very close to
					variable
					declarations introduced in
					<xref linkend="section_variables.link" />
					).
					Each reference may be explicitly linked to another reference (it
					is
					the
					<literal>opposite</literal>
					concept in MOF terminology – see also
					section
					<xref linkend="section_properties-opposite.link" />
					).
				</para>

				<programlisting language="kermeta">class Library
{
    attribute books : set Book[0..*]
}

class Book
{
    attribute title : String
    attribute subtitle : String

    reference authors : oset Author[1..*]#works
}


class Author
{
    attribute name : String
    attribute lastName : String
    
    reference works : set Book[0..*]#authors
}</programlisting>

				<para>
					If we represent our Kermeta model in a graphical syntax we
					obtain
					the following class diagram (
					<xref linkend="refIllustration6" />
					).
				</para>

				<figure id="refIllustration6">
					<title>A concrete example : a library</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/library.png" />
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section>
				<title>Loading an existing model</title>

				<para>Using Eclipse Modeling Framework (EMF), Kermeta can load and
					save models done with other
					EMF tools.
				</para>

				<programlisting language="kermeta">/* Initialize the EMF repository */
var repository : EMFRepository init EMFRepository.new

/* Create an EMF Resource, given model and metamodel URIs as String */
var resource : Resource init repository.createResource(myModelURI, itsMetamodelURI)

/* Load the resource */
resource.load

// get elements from the resource
// in this sample, you know that your root element is always a Library, 
// so you can directly get the first one
var aLibrary : Libray
aLibrary ?= resource.one // note the conditional assignment using the ?=, if not a Library you'll get Void</programlisting>

				<para>In the same way, you can serialize a model, or load, change
					and
					save an existing model.
				</para>

				<caution>
					<para>Your model URI MUST be of the form
						"platform:/resource/myProject/myModel" or
						"platform:/plugin/myProject/myModel".
					</para>

					<para>Your metamodel URI MUST be of the form
						"platform:/resource/myProject/myModel" or
						"platform:/plugin/myProject/myModel" or an URI registered in the
						EMF
						registry.
					</para>
				</caution>

				<caution>
					<para>Be aware that you CANNOT load kermeta text files (*.kmt).
						Only xmi
						files are allowed to be
						loaded. Parsing and obtaining a
						model from a
						textual syntax is not part of
						Kermeta. This is the
						role
						of other tools (like sintaks). Technically, it
						is possible to
						create some
						Kermeta operation
						that will hide this step, however,
						this is not the goal
						of this manual to explain
						this procedure.
					</para>
				</caution>
			</section>

			<section>
				<title>Navigation in a model</title>

				<para>Actually, navigating in a model is as simple as using objects
					in
					an object-oriented program.
					However, several features have been
					added
					in order to ease this activity.
				</para>

				<para>
					For example, thanks to the lambda expressions, the collections
					of
					the language are easily
					manipulated using lexical closure (select,
					collect, each, etc). This applies to all the
					collections of the
					language, the one you may define directly but also the one which
					are
					used when
					an
					<link linkend="section_properties.link">Attribute or
						Reference
					</link>
					has a multiplicity greater than 1.
				</para>

				<para>
					Example (based on the library sample of
					<xref linkend="section_toward_a_first_concrete_example.link" />
					):
				</para>
				<programlisting language="kermeta">
var smithBooks : Set&lt;Book&gt; init Set&lt;Book&gt;.new
smithBooks.addAll(
	lib.books.select{aLibraryBook | 
		aLibraryBook.authors.exists{aBookAuthor | aBookAuthor.lastName == "Smith"}})
		</programlisting>
				<para>In the example above, lib is an instance of Library. It
					searchs in the books, select the
					books
					where the author last name is
					"Smith".
				</para>
			</section>

			<section>
				<title>Model type</title>

				<para>In order to improve reuse of existing code between metamodel
					variants, the language
					introduces the notion of ModelType. It is
					based
					on the notion of conformance between two
					metamodels. This
					allows to
					write behavior that is valid for a given metamodel and
					that will
					also
					work for any conformant metamodel.
				</para>


				<para>TODO write a small illustrative example of a simple printer
					based on a ModelType : a subset
					of class diagram of UML
				</para>
			</section>

			<section>
				<title>Kermeta model reflexively available</title>

				<para>
					Kermeta has been developed, using MDE principles so it also
					provides its own metamodel
					(reflectiveley available). Details of
					Kermeta metamodel is available in
					<xref linkend="section_kermeta_metamodel.link" />
				</para>
			</section>

			<section>
				<title>Corresponding sections in the Reference chapter</title>

				<para>
					You can get more informations about all Kermeta model-oriented
					features in the
					<xref linkend="chapter_reference.link" />
					. More
					precisely in
					<itemizedlist>
						<listitem>
							<para>
								<xref linkend="section_loadingsaving_models.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_kermeta_metamodel.link" />
							</para>
						</listitem>

						<listitem>
							<para>
								<xref linkend="section_modeltype.link" />
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
		</section>
		<section>
			<title>Mashup of metalanguages</title>
			<para>Since Kermeta is an extension of MOF, a MOF meta-model can
				conversely be seen as a valid
				Kermeta program that just declares
				packages, classes and so on but does
				nothing.
				Kermeta can then
				be used
				to breath life into this meta-model by
				incrementally
				introducing
				aspects for handling
				concerns of static semantics, dynamic
				semantics,
				or model transformations.
			</para>
			<para>Kermeta allow to keep the concerns seprated at design time and
				then merge them to build a
				runable tool.
				It uses a powerful mecanism
				of static introduction that works at the
				model level
				and
				at the model
				element level.
			</para>
			<section>
				<title>Model static introduction</title>
				<para>
					One of the key feature of the workbench is the static composition
					operator
					<literal>require</literal>
					. This operator allows defining these various
					aspects in separate
					units and integrating them
					automatically into the
					meta-model. The
					composition
					is done statically and the composed model is
					typed-checked to ensure
					the safe integration of all units.
					This
					mechanism makes it easy to reuse
					existing meta-models or to split
					meta-models into reusable pieces.
					It allows to compose the
					various
					files and models that will form
					the final tool.
				</para>
				<para>
					The workbench will seamlessly convert and merge the various files
					into the final kermeta
					program.
					The classic inputs will be ecore
					files, kmt files or uml profiles
					files. The finala
					assembly will
					depend
					on the capabilities of the inputs models. For example, a
					ecore model
					has a
					granularity at the class level
					(ie. it will just
					add new classes) whereas Kermeta has a
					granularity at
					the feature
					level and thus can
					add new features to a class(see next section
					<xref linkend="intro_model_element_static_introduction.link" />
					for more details)
				</para>
				<para>TODO add a sample</para>
			</section>
			<section>
				<title>
					Model element static introduction : Aspect-oriented language
					<phrase id="intro_model_element_static_introduction.link"></phrase>
				</title>
				<warning>
					<title>Text not verified for kermeta 2</title>
					<para></para>
				</warning>

				<para>
					One of the key features of Kermeta is the static composition
					operator
					<literal>require</literal>
					allows extending an existing meta-model with new elements
					such as
					properties, operations,
					constraints or classes. This operator
					allows defining these various
					aspects in separate units and
					integrating them automatically into the
					meta-model. The composition
					is done statically and the
					composed model is typed-checked to
					ensure
					the safe integration of all units.
					This mechanism makes
					it
					easy to reuse existing meta-models or to split
					meta-models into
					reusable pieces.
					It can be
					compared to the open class paradigm.
					Consequently a
					meta-class that identifies a domain concept
					can be
					extended without editing the meta-model directly. Open classes
					in
					Kermeta are used to
					organize
					<literal>cross-cutting</literal>
					concerns separately from the meta-model to which they belong, a key
					feature of aspect-oriented
					programming. With this mechanism,
					Kermeta can support the addition of new
					meta-class, new
					subclasses,
					new methods, new properties, new contracts to
					existing meta-model.
					The
					require
					mechanism also provides flexibility. For example,
					several
					operational semantics could be
					defined
					in separate units for
					a single meta-model and then alternatively
					composed depending on
					particular
					needs. This is the case for instance in the UML
					meta-model when
					several semantics
					variation points
					are defined.
				</para>
				<para>
					Thank to this composition operator, Kermeta can remain a
					kernel platform
					to safely integrate
					all the
					concerns around a
					meta-model. This feature has proved to be extremly useful
					in the
					context
					of
					metamodel engineering.
				</para>
				<section>
					<title>Corresponding section in the Reference chapter</title>
					<para>
						You'll find more details in the Reference chapter, more precisely
						in:
						<xref linkend="section_weaving.link" />
					</para>
				</section>
			</section>
		</section>
		<section>
			<title>Some "advanced" features</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>Kermeta implements several "less common" or advanced features
				that
				helps in many situations.
			</para>
			<para> Typically, lambda
				expressions/functions is a well known
				concept, very useful in almost all
				kermeta code. Even, if you will
				probably not write your own function,
				you'll certainly use the
				existing one defined on collections.
			</para>

			<section>
				<title>
					Functions in Kermeta
					<phrase id="function-types.link"></phrase>
				</title>

				<para>In order to implement and statically type check OCL-like
					iterators, Kermeta includes some
					limited functional features by
					implementing lambda expressions.
				</para>

				<para>
					This is typically used on
					<literal>Collection</literal>
					which
					provides operations that uses a function as parameter. For
					example :
					<literal>each</literal>
					,
					<literal>select</literal>
					,
					<literal>forAll</literal>
					,
					<literal>detect</literal>
					...
				</para>

				<para>
					<emphasis role="strong">Example 1</emphasis>
					: the following code
					will build a collection of names of the
					operations that start with
					"test".
				</para>

				<programlisting language="kermeta">var names : Collection&lt;String&gt;
names := self.getMetaClass.classDefinition.ownedOperation
            .select{ op | op.name.indexOf("test") == 0}
            .collect{ op | op.name }
	    </programlisting>
				<para>
					<emphasis role="strong">Example 2</emphasis>
					: Providing a time
					function on Integer
				</para>

				<programlisting language="kermeta">operation times(body : &lt;Integer-&gt;Object&gt;) : Void is do
    from var i : Integer init 0
    until i == self
    loop
        body(i)
        i := i + 1
    end
end</programlisting>

				<para>this allows to write code like :</para>

				<programlisting language="kermeta">var res : Integer
10.times { i | stdio.writeln(i.toString + ": Hello") } // Say 10 times Hello</programlisting>

				<para>
					See sections "
					<xref endterm="section_lambda_expression.title.link" linkend="section_lambda_expression.link" />
					" and
					<xref endterm="section_lambda_expression_mm.title.link" linkend="section_lambda_expression_mm.link" />
					for detailed
					informations.
				</para>
			</section>

			<section>
				<title>Other advanced features</title>

				<section>
					<title>High level modeling</title>

					<para>
						Kermeta most recent versions embed advanced concepts like
						<xref endterm="section_lambda_expression.title.link" linkend="section_lambda_expression.link" />
						,
						<xref endterm="section_dynamic_expressions.title.link" linkend="section_dynamic_expressions.link" />
						,
						<xref endterm="section_contracts.title.link" linkend="section_contracts.link" />
						or
						<xref endterm="section_weaving.title.link" linkend="section_weaving.link" />
						.
					</para>
				</section>

				<section>
					<title>Other technical features</title>

					<para>
						As Kermeta language is implemented upon Eclipse and Java, you
						can
						call Java code inside Kermeta
						code.(see
						<xref linkend="section_java_code.link" />
						)
					</para>

					<para>There is some special behavior regarding object comparison or
						cloning.
					</para>
				</section>
			</section>
		</section>
	</chapter>

	<chapter id="chapter_reference.link">
		<title id="chapter_reference.title.link">
			Reference
			<phrase id="chapter_reference"></phrase>
		</title>

		<para>The reference sections are ordered in four parts: the imperative
			syntax (1-6), the
			object-oriented (7-10) and the model-oriented
			(11-15)
			features, the advanced concepts (16-21).
		</para>

		<section id="section_comments.link">
			<title id="section_comments.title.link">
				Comments
				<phrase id="section_comments"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<warning>
				<para>
					Comments are a little bit particular in the Kermeta language
					because they are not all ignored by
					the interpreter. There are two
					kinds of comments: the first (syntax : // foo , /* bar *

					<emphasis role="strong">/) is only associated to the text editor
						view
						in which the user edits his
						Kermeta file, and the second
						one(syntax
						:
					</emphasis>

					/** foo */

					<emphasis role="strong">or</emphasis>

					@tag_name "tag value") is translated into a MOF tag linked to
					structures described in the
					Kermeta model.
					The first one, is a text
					decoration, the second one is part of the
					Kermeta model.
				</para>
			</warning>

			<section>
				<title>Simple and multi-line text comments</title>

				<para>Like in many languages, Kermeta provides two ways to add
					comments in your models:
				</para>

				<itemizedlist>
					<listitem>
						<para>simple line comments, i.e text line beginning with //</para>

						<programlisting language="kermeta">// This is a single line comment</programlisting>
					</listitem>

					<listitem>
						<para>
							multi-line comments, i.e text between /* */. Be careful with
							this
							notation : the opening syntax
							must not have juxtaposed stars
							("/**"), otherwise it will be considered as a linked comment
							(see
							<xref linkend="section_linked-comments.link" />
							), i.e a comment
							that is part of the Kermeta program as a model.
						</para>

						<programlisting language="kermeta">/* This a multi line comment
all these lines are comments
this line too. */</programlisting>
					</listitem>
				</itemizedlist>
			</section>

			<section id="section_linked-comments.link">
				<title>
					Linked comments
					<phrase></phrase>
				</title>

				<para>
					Kermeta provides a way to define named and unnamed annotations,
					that have to be defined just
					above any model element among
					<literal>Package</literal>
					,
					<literal>ClassDefinition</literal>
					,
					<literal>Property</literal>
					,
					<literal>Operation</literal>
					. Such
					annotations correspond to MOF tags, and are linked to the
					elements
					which immediately
					follows.
				</para>

				<para>To define a named annotation, you have to use a special symbol
					"@", whereas an anonymous
					annotation has to be written between /**
					and
					*/
				</para>

				<para>
					<emphasis role="strong">Example 1:</emphasis>
					you can define an
					annotation to describe the role of a property
				</para>

				<programlisting language="kermeta">@usage "count the number of ..."
reference myCounter : Integer </programlisting>

				<para>
					<emphasis role="strong">Example 2</emphasis>
					: you can document
					your classes and operation using /** ... */
				</para>

				<programlisting language="kermeta">/** * This is a documentation tag for the class "myClass" */
class MyClass {
    /** This is a documentation tag for myOperation */
    operation myOperation() is do
        // Unlinked comment
    end
    @desc "This is a named annotation for thisOperation"
    operation thisOperation() is do
        /* This is an unlinked comment */
    end
}</programlisting>
			</section>
		</section>

		<section id="section_reserved_keywords.link">
			<title id="section_reserved_keywords.title.link">
				Escaping reserved
				keywords
				<phrase id="section_keywords"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>
				Kermeta textual syntax uses several keywords like
				<literal>class</literal>
				,
				<literal>attribute</literal>
				,
				<literal>reference</literal>
				,
				<literal>result</literal>
				, etc. (Please
				see
				<xref linkend="appendix_keywords.link" />
				at the end of this
				document to get the complete list of Kermeta
				keywords.)
			</para>

			<para>This doesn't mean you cannot use these words for your own
				model.
				Moreover, this is only a
				textual syntax limitation.
			</para>

			<para>So Kermeta syntax allows you to use the word you want, you
				simply
				have to prefix it with a
				tilda ~.
			</para>

			<para>This example is valid even if we use "class" and "attribute"
				which
				are keywords in the
				language:
			</para>

			<programlisting language="kermeta">
class ~class {
    attribute ~attribute : kermeta::standard::String
    attribute ~class : kermeta::standard::String
}</programlisting>
		</section>

		<section id="section_operators.link">
			<title id="section_operators.title.link">
				Operators
				<phrase id="section_operators"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<informaltable>
				<tgroup cols="4">
					<colspec colname="c1" colwidth="1*" />

					<colspec colname="c2" colwidth="1*" />

					<colspec colname="c3" colwidth="1.5*" />

					<colspec colname="c4" colwidth="8*" />

					<thead>
						<row>
							<entry>
								<para>Priority</para>
							</entry>

							<entry>
								<para>Operator</para>
							</entry>

							<entry>
								<para>Operand types</para>
							</entry>

							<entry>
								<para>Semantic</para>
							</entry>
						</row>
					</thead>

					<tbody>
						<row>
							<entry align="center" valign="bottom">
								<para>1</para>
							</entry>

							<entry align="center">
								<para>
									<literal>+</literal>
								</para>
							</entry>

							<entry align="center">
								<para>Numeric</para>
								<para>String</para>
							</entry>

							<entry>
								<para>Add two numeric values</para>
								<para>Concatenate two
									strings
								</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="bottom">
								<para>1</para>
							</entry>

							<entry align="center">
								<para>
									<literal>-</literal>
								</para>
							</entry>

							<entry align="center">
								<para>Numeric</para>
							</entry>

							<entry>
								<para>Subtract two numerous values</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="bottom">
								<para>2</para>
							</entry>

							<entry align="center">
								<para>
									<literal>*</literal>
								</para>
							</entry>

							<entry align="center">
								<para>Numeric</para>
							</entry>

							<entry>
								<para>Multiply two numeric values</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="bottom">
								<para>2</para>
							</entry>

							<entry align="center">
								<para>
									<literal>/</literal>
								</para>
							</entry>

							<entry align="center">
								<para>Numeric</para>
							</entry>

							<entry>
								<para>Divide the first operand by the
									second
								</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>

			<para>Notice that most of these arithmetic operators are only defined
				for numeric primitive types
				like Integer. Except the + operator
				which is
				a concatenation operator for String, they are not
				applicable
				on
				String,
				Boolean nor collections
			</para>

			<informaltable>
				<tgroup cols="4">
					<colspec colname="c1" colwidth="1*" />

					<colspec colname="c2" colwidth="1*" />

					<colspec colname="c3" colwidth="1.5*" />

					<colspec colname="c4" colwidth="8*" />

					<thead>
						<row>
							<entry>
								<para>Priority</para>
							</entry>

							<entry>
								<para>Operators</para>
							</entry>

							<entry>
								<para>Operand Types</para>
							</entry>

							<entry>
								<para>Semantics</para>
							</entry>
						</row>
					</thead>

					<tbody>
						<row>
							<entry align="center" valign="bottom">
								<para>3</para>
							</entry>

							<entry align="center">
								<para>
									<literal>==</literal>
								</para>
							</entry>

							<entry align="center">
								<para>All</para>
							</entry>

							<entry>
								<para>True, if op1 value's is the same that op2
									value's
								</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="bottom">
								<para>3</para>
							</entry>

							<entry align="center">
								<para>
									<literal>!=</literal>
								</para>
							</entry>

							<entry align="center">
								<para>All</para>
							</entry>

							<entry>
								<para>True if op1 value's is different of op2
									value's
								</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="middle">
								<para>3</para>
							</entry>

							<entry align="center" valign="middle">
								<para>
									<literal>&lt;</literal>
								</para>
							</entry>

							<entry align="center" valign="middle">
								<para>Numeric</para>
							</entry>

							<entry>
								<para>True if op1value's is strictly smaller than op2
									value's
								</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="middle">
								<para>3</para>
							</entry>

							<entry align="center" valign="middle">
								<para>
									<literal>&lt;=</literal>
								</para>
							</entry>

							<entry align="center" valign="middle">
								<para>Numeric</para>
							</entry>

							<entry valign="middle">
								<para>True if op1 value's is smaller or
									equals than op2 value's
								</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="middle">
								<para>3</para>
							</entry>

							<entry align="center" valign="middle">
								<para>
									<literal>&gt;</literal>
								</para>
							</entry>

							<entry align="center" valign="middle">
								<para>Numeric</para>
							</entry>

							<entry valign="middle">
								<para>True if op1 value's is strictly
									greater than op2 value's
								</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="middle">
								<para>3</para>
							</entry>

							<entry align="center" valign="middle">
								<para>
									<literal>&gt;=</literal>
								</para>
							</entry>

							<entry align="center" valign="middle">
								<para>Numeric</para>
							</entry>

							<entry valign="middle">
								<para>True if op1 value's is greater or
									equals than op2 value's
								</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>

			<informaltable>
				<tgroup cols="4">
					<colspec colname="c1" colwidth="1*" />

					<colspec colname="c2" colwidth="1*" />

					<colspec colname="c3" colwidth="1.5*" />

					<colspec colname="c4" colwidth="8*" />

					<thead>
						<row>
							<entry><?border-top 0.0007inch solid #000000?>
								<para>Priority</para>
							</entry>

							<entry><?border-top 0.0007inch solid #000000?>
								<para>Operators</para>
							</entry>

							<entry><?border-top 0.0007inch solid #000000?>
								<para>Operands
									Types
								</para>
							</entry>

							<entry><?border 0.0007inch solid #000000?>
								<para>Semantics</para>
							</entry>
						</row>
					</thead>

					<tbody>
						<row>
							<entry align="center" valign="bottom">
								<para>4</para>
							</entry>

							<entry align="center">
								<para>
									<literal>and </literal>
								</para>
							</entry>

							<entry align="center">
								<para>Boolean</para>
							</entry>

							<entry>
								<para>True if op1 and op2 are evaluated to
									true
								</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="bottom">
								<para>4</para>
							</entry>

							<entry align="center">
								<para>
									<literal>or</literal>
								</para>
							</entry>

							<entry align="center">
								<para>Boolean</para>
							</entry>

							<entry>
								<para>True if one of the operators is evaluated to
									true
								</para>
							</entry>
						</row>

						<row>
							<entry align="center" valign="bottom">
								<para>4</para>
							</entry>

							<entry align="center">
								<para>
									<literal>not </literal>
								</para>
							</entry>

							<entry align="center">
								<para>Boolean</para>
							</entry>

							<entry>
								<para>True if op is false.</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>

			<note>
				<para>
					The
					<literal>==</literal>
					and
					<literal>!=</literal>
					can be
					applied to any Object, in this case, the comparison is based
					on the
					<literal>equals</literal>
					operation defined for the object and thus
					can be redefined to
					compare only the values of the
					objects. To be sure
					to compare the
					identity of objects even if they redefine the
					operation
					<literal>equals</literal>
					, you need to compare their
					<literal>oid</literal>
					(ie. their identifiers).
				</para>

				<para>
					See
					<xref linkend="section_object_comparison.link" />
					for more
					details about object comparison.
				</para>
			</note>
		</section>

		<section id="section_statements.link">
			<title id="section_statements.title.link">
				Statements : block, condition,
				loop
				<phrase id="section_statements"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<section>
				<title>Block statement</title>

				<para>
					Kermeta provides a block notion to manage scope of variable.
					Instruction of the block have to be
					inserted between
					<literal>do</literal>
					and
					<literal>end</literal>
					keywords. Theses two
					keywords may be omitted for the conditional and
					for the loop
					structures.
				</para>

				<para>A variable could only be accessed in the block where it was
					defined and in its sub blocks:
				</para>

				<programlisting language="kermeta">do
    var v1 : Integer init 3
    var v2 : Integer init 2
    do
        var v3 : Integer
        v3 := v1 + v2

        var v2 : Integer // error : v2 is already declared in the upper block
    end
    var v4 : Integer init v3 // error : v3 is unknown here
end</programlisting>
			</section>

			<section>
				<title>Conditional statement</title>

				<para>
					Kermeta's conditional statement is composed of at least two
					elements : a boolean expression and
					a block that is executed if the
					boolean is evaluated to
					<literal>true</literal>
					. You can add a third
					element, with the
					<literal>else</literal>
					keyword, that is executed if
					the boolean expression is evaluated to
					<literal>false</literal>
					.
				</para>

				<para>
					<emphasis role="strong">Example 1</emphasis>
					: if..then..else
					block
				</para>

				<programlisting language="kermeta">var v1 : Integer init 2
var v2 : String init "blah"

if v1 &gt; 5 then v1 := v1-5

if v1 == 2 then
    v2 := v1
    v1 := v2 + v1
else
    v1 := 0
end</programlisting>

				<para>
					The
					<literal>if</literal>
					statement is an expression (see
					<xref linkend="section_kermeta_metamodel.link" />
					). As any expression in
					Kermeta, it can return a value. The return
					type of the
					<literal>if</literal>
					statement must be a super type of the values
					"returned" by both
					<literal>then</literal>
					and
					<literal>else</literal>
					blocks (otherwise the type checker will send an error). The values
					considered as the result of
					the evaluation (the "returned" values)
					of
					the
					<literal>if</literal>
					statement are the last evaluated statement
					inside
					<literal>then</literal>
					or
					<literal>else</literal>
					block
				</para>

				<para>
					<emphasis role="strong">Example 2</emphasis>
					: conditional is an
					expression
				</para>

				<programlisting language="kermeta">var s : String
    s := if false then "a" else "b" end</programlisting>

				<para>Example 3: a more complex conditional</para>

				<programlisting language="kermeta">var x : String
    var y : Integer init 5 
    x := if y &lt; 3 then 
         stdio.writeln("hello")
         "a" 
         else 
         "b"
         "c" 
         end // The String "c" will be the value of x</programlisting>
			</section>

			<section>
				<title>Loop Statement</title>

				<para>Here is a sample of a typical loop in Kermeta.</para>

				<programlisting language="kermeta">var v1 : Integer init 3
var v2 : Integer init 6

from var i : Integer init 0
until i == 10
loop
    i := i + 1
end</programlisting>

				<note>
					<para>Unlike Java, there is no exit, break or continue function in
						Kermeta.
					</para>
				</note>

				<para>
					See
					<xref linkend="section_collections.link" />
					for functions
					offering iterator-like scanning.
				</para>
			</section>
		</section>

		<section id="section_files.link">
			<title>
				File dependency : structuring code
				<phrase id="section_files"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>
				Kermeta code can be quite large, and invloves many classes in
				different metamodels. The main
				mechanism used to organise your code
				is
				the
				<literal>require</literal>
				statement.
			</para>

			<section>
				<title>Require</title>

				<para>
					When you need to refer explicitly another entity defined in
					another
					file, you have to use the
					<literal>require</literal>
					primitive. It allows loading definitions of an other Kermeta file
					when
					file is processed. In the
					following example, we define a class
					C which
					inherits from the A class previously defined.
				</para>

				<programlisting language="kermeta">// file : MyPackage-part1.kmt
package subPackage1;

class A 
{
  // ...
}</programlisting>

				<programlisting language="kermeta">// file : MyPackage-part2.kmt
package MyPackage;
require "MyPackage-part1.kmt"

class C inherits subPackage1::A 
{
	// ...
}</programlisting>

				<note>
					<para>
						In most case, the order of the declaration in not important. The
						only exception is a very rare
						situation related to aspects (see

						<xref linkend="section_weaving.link" />

						).
					</para>
				</note>

				<note>
					<para>You can create cyclic dependencies of files, the environment
						will deal with that.
					</para>
				</note>
			</section>

			<section>
				<title>Accepted require content</title>

				<para>
					You can
					<literal>require</literal>
					different kind of
					entity
				</para>

				<para>
					Obvioulsy, you can
					<literal>require</literal>
					Kermeta textual
					syntax, ie.
					<emphasis role="strong">*.kmt files</emphasis>
				</para>

				<para>
					You can
					<literal>require</literal>
					Kermeta models, ie.
					<emphasis role="strong">*.km files</emphasis>
					.
				</para>

				<para>
					You can
					<literal>require</literal>
					Ecore models, ie.
					<emphasis role="strong">*.ecore files</emphasis>
					. These models can then be used
					as if they were written in Kermeta.
					In order to add behavior to
					the
					classes defined in .ecore files you
					may : use the
					<link linkend="section_weaving.link">weaving</link>
					to dynamically weave
					behavior to the ecore, or roundtrip using the
					button action in the
					workbench
					(ecore-&gt;kmt-&gt;ecore) to
					statically add the behavior
					(as
					EAnnotations) into the ecore file.
				</para>


				<warning>
					<para>A special attention must be put when requiring resources. It
						is not allowed
						to get several
						versions of the same class that comes
						from several
						required files.
						Kermeta cannot know which
						version it
						must use, so you'll get an error.
					</para>
					<para>A typical error, is to require both an ecore file and the
						registered version of it. They
						represent two
						distinct resources in
						memory.
					</para>
					<para>
						A more clever error, is when the two versions are hidden
						inside an
						erroneous ecore file
						which uses
						several ways to access
						some metaclass and actually is not consistent.
						(ex: you find
						references to both
						http://www.eclipse.org/emf/2002/Ecore
						and
						platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore in the
						ecore file or one of the
						dependent files)
					</para>
				</warning>

				<para>
					In order to use the seamless java import (still prototype in
					v0.4.2), you can require a
					<emphasis role="strong">jar
						file
					</emphasis>
					. It will automatically convert the java into a Kermeta
					representation in order to be able to
					call java code as if it was
					written in Kermeta. see
					<xref linkend="section_java_code.link" />
					for
					more details.
				</para>

			</section>
			<section>
				<title>Supported protocols</title>
				<para>Kermeta reuse some of the protocols provided by Eclipse.
				</para>
				<formalpara>
					<title>Relative path</title>
					<para>You can use a path relative to the
						current file using the
						normal syntax (./ , ../, etc)
					</para>
				</formalpara>
				<formalpara>
					<title>Eclipse workspace relative path</title>
					<para>
						In Eclipse, you can use a path
						relative to the user's workspace. In
						that case the path looks
						like
						<literal>
							platform:/resource/
							<replaceable>your_project_name</replaceable>
							/
							<replaceable>path_to_the_file</replaceable>
						</literal>
					</para>
				</formalpara>
				<formalpara>
					<title>Eclipse plugin relative path</title>
					<para>
						In Eclipse, you can use a path that search in
						the installed
						plugins. In that case the path looks
						like
						<literal>
							platform:/plugin/
							<replaceable>plugin_name</replaceable>
							/
							<replaceable>path_to_the_file</replaceable>
						</literal>
					</para>
				</formalpara>
				<formalpara>
					<title>Eclipse workspace or plugin relative path</title>
					<para>
						When deploying Kermeta code, it is
						sometime interesting to search
						in both the user's workspace
						and in the
						plugins. In that case the
						path looks like
						<literal>
							platform:/lookup/
							<replaceable>plugin_or_project_name</replaceable>
							/
							<replaceable>path_to_the_file</replaceable>
						</literal>
					</para>
				</formalpara>
				<note>
					<para>This platform:/lookup/ is available in Kermeta only, and only
						in the require statement.
					</para>
					<para>Be careful, using the current version (Kermeta 1.3.1) since a
						deployed plugin using this
						protocol may be modified by the user's
						workspace content!
					</para>
				</note>
				<formalpara>
					<title>Registered Ecore</title>
					<para>
						A variant of requiring an ecore file is to require a
						<emphasis role="strong">registered EPackage</emphasis>
						. When Eclipse deploys an
						ecore model plugin, it also registers the
						EPackage using a unique
						identifier (nsuri) in order to retreive it
						quickly. In Kermeta you
						can
						also use this nsuri into
						the require
						statement. This approach is
						useful because you can be sure that you
						require the very
						same
						model as
						Eclipse use to load and save models
						of that sort. For example, instead
						of requiring
						ecore.ecore you may
						use
						<literal>require
							"http://www.eclipse.org/emf/2002/Ecore"
						</literal>
						. This also works for
						all other registered metamodels (Your own
						registered metamodel, UML
						metamodel, etc).
						<ulink url="http://www.kermeta.org/documents/ui_user_guide/">Kermeta user
							interface
						</ulink>
						provides a view that display all registered
						EPackages and their
						nsuri.
					</para>
				</formalpara>
			</section>
			<section>
				<title>Organizing code</title>

				<para>
					Kermeta lets you organise your code the way you prefer. There is
					no
					predefined organisation of
					your code, but the language and the
					workbench proposes various mechanisms and tools to structure
					it
					according to your needs and the style you wish for your code.
					Typically if you use Kermeta
					internal weaver (see
					<xref linkend="section_weaving.link" />
					), manually transform your ecore into
					Kermeta, eventually weaving
					the ecore using the merge
					button available
					on the worbench.
				</para>

				<para>
					For example, you can put all your classes into a single file
					(like
					in Ecore, every classes is in
					the .ecore file) or you may create
					a
					file for each of them and then use the
					<literal>require</literal>
					to
					indicates that they must know each other. You can also use an
					organisation like java, with a
					file per class and a directory per
					package.
				</para>
			</section>
		</section>

		<section id="section_variables.link">
			<title id="section_variables.title.link">
				Using
				Variables
				<phrase></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>Whenever you need a data locally to a block because it doesn't
				goes into a class attribute
				or reference, you can use a local
				variable.
			</para>

			<para>
				A variable is defined by a name and by a type. If needed, the name
				of the variable can be
				<link linkend="section_reserved_keywords.link">escaped</link>
				using the tilda
				(~)
			</para>

			<para>Declaring a variable:</para>

			<programlisting language="kermeta">var foo : String // This is a variable declaration</programlisting>

			<para>
				In the following example, we define 3 variables of type integer.
				The
				first is initialized with the
				"14" literal value, the second is
				initialized with an expression using v1. For the last variable,
				we
				use a
				multiplicity notation to specify an ordered set of integer (see
				<xref linkend="section_collections.link" />
				and
				<xref linkend="section_properties.link" />
				for more information on
				sets).
			</para>

			<programlisting language="kermeta">do
    var v1 : Integer init 14
    var v2 : Integer init 145 * v1

    var tab : Integer[0..*] init kermeta::standard::OrderedSet&lt;Integer&gt;.new
    v1 := v2/v1
end</programlisting>

			<para>
				Be careful to the multiplicity, when you create a variable with
				multiplicity, you have to
				initialize it with a
				<link linkend="section_collections.link">collection</link>
				. Then to use its
				content, you need to use the collection operation
				like add, addAll,
				remove,
				select, etc. If you use the assignment
				<literal>:=</literal>
				it
				will replace your collection.
			</para>
		</section>

		<section id="section_basic_types.link">
			<title id="section_basic_types.title.link">Basic types</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<section>
				<title>Primitive types</title>

				<para>Kermeta implements a few primitive types. By primitive types,
					we
					mean types that are basic
					to any language, i.e integer, and that
					have
					a literal value. See below table.
				</para>

				<informaltable>
					<tgroup cols="3">
						<colspec colname="c1" colwidth="1*" />

						<colspec colname="c2" colwidth="4*" />

						<colspec colname="c3" colwidth="2*" />

						<thead>
							<row>
								<entry>
									<para>Name</para>
								</entry>

								<entry>
									<para>Description</para>
								</entry>

								<entry>
									<para>Literal Example</para>
								</entry>
							</row>
						</thead>

						<tbody>
							<row>
								<entry>
									<para>Integer</para>
								</entry>

								<entry>
									<para>Represents integer numeric value like 10 or 12.
										(« int »
										data type in Java)
									</para>
								</entry>

								<entry>
									<para>101, 12, 14, -45, -123</para>
								</entry>
							</row>

							<row>
								<entry>
									<para>String</para>
								</entry>

								<entry>
									<para>Represents a string of like « helloworld »
										(« String »
										data type in Java)
									</para>
								</entry>

								<entry>
									<para>"helloworld", "this is a string
										!!!"
									</para>
								</entry>
							</row>

							<row>
								<entry>
									<para>Boolean</para>
								</entry>

								<entry>
									<para>Represents a true/false value. (« boolean » data
										type in
										Java)
									</para>
								</entry>

								<entry>
									<para>true, false</para>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>

				<programlisting language="kermeta">// Simple datatypes examples
var myVar1 : Integer init 10
var myVar2 : Integer
var myVar4 : String init "a new string value"
var myVar5 : boolean</programlisting>

				<para>Kermeta also supports some other primitive types like Float
					and
					Character, but they
					currently don't have a surface syntax for
					their
					literals. The way to get them is to use the
					convertion methods
					available on String (for both of them) or Integer (for Float).
				</para>
				<para>For example:</para>
				<programlisting language="kermeta">
var c : Character init "f".elementAt(0)
var r : Real init "4.5".toReal
</programlisting>
			</section>

			<section>
				<title>Enumeration types</title>

				<para>You can define enumerations using the following syntax.
					Note
					that each enumeration literal
					must end with a ";".
				</para>

				<programlisting><emphasis role="strong">enumeration</emphasis> Size { small; normal; big; huge; } </programlisting>

				<para>You can manipulate enumerated variables and literals with
					classical operators such as in
					the following example.
				</para>

				<programlisting language="kermeta">var mySize : Size
if ( mySize == Size.small ) then 
    stdio.writeln("This is small !") 
end</programlisting>

				<note>
					<para>
						Enumeration is a concept of the same level as Class, they
						must both be
						defined in a
						package.
					</para>
				</note>
			</section>

			<section id="section_alias.link">
				<title id="section_alias.title.link">
					Local datatype using
					"alias"
					<phrase id="section_alias"></phrase>
				</title>

				<para>In Kermeta, you can define your own datatype based on existing
					types without a hard
					dependency like inheritance.
				</para>

				<para>This is done using the alias syntax.</para>

				<para>Ex:</para>

				<programlisting><emphasis role="strong">alias</emphasis> MyString : kermeta::standard::String;</programlisting>

				<para>In this sample, MyString has all the behavior of
					kermeta::standard::String but is declared
					locally. This means that
					you
					don't have any dependency to the framework, even to the String
					in the
					framework.
				</para>

				<para>Obviously you can reuse existing type names :</para>

				<programlisting><emphasis role="strong">alias</emphasis> String : kermeta::standard::String;</programlisting>

				<para>This will create a new type String in your package with the
					behavior of String in the
					framework.
				</para>

				<para>
					The definition of an alias is different from the use of "using"
					statement (as defined in
					<xref linkend="section_using.link" />
					), when
					you write
				</para>

				<para>
					<emphasis role="strong">using</emphasis>
					kermeta::standard
				</para>

				<para role="lineBreak">you simply defined a syntactical shortcut
					allowing
					you to access any definition in
					this package from within this
					file.
				</para>

				<para>Wheras defining an alias allows you to access this new
					definition from another package if
					needed.
				</para>

				<tip>
					<para>
						It is interesting to redefine your own datatype for all the
						standard
						type you use in your
						metamodel, so when you convert the
						file into
						ecore in order to have serialisation, you won't
						have any
						dependency to framework.ecore (which is the ecore version of the
						framework where
						Kermeta standard type) This allow a lazy coupling
						of the type definitions.
					</para>
				</tip>
			</section>
		</section>

		<section id="section_classesandmethods.link">
			<title id="section_classesandmethods.title.link">
				Classes and
				methods
				<phrase id="section_classes"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<section>
				<title>Classes</title>

				<para>
					As introduced in the "Hello world" example (see
					<xref linkend="section_first_program.link" />
					), Kermeta is an
					object-oriented language. Kermeta
					provides all MOF
					concepts like properties,
					attributes, package.
					In addition, it
					provides a body to operations and derived properties.
				</para>

				<para>Classes and abstract classes can be defined in a Java-like
					way.
					Class definition must be
					placed into brackets as it is in the
					following example.
				</para>

				<programlisting><emphasis>// an empty simple class</emphasis>
<emphasis role="strong">class</emphasis> myFirstClass 
{

}

<emphasis>// a simple abstract class</emphasis>
<emphasis role="strong">abstract</emphasis> <emphasis role="strong">class</emphasis> MyAbstractClass
{

}</programlisting>

				<para>
					Additionally, for better code robustness, and more user-friendly
					programming, classes can use
					the genericity mechanisms (see
					<xref linkend="section_genericity.link" />
					for more information).
				</para>

				<programlisting><emphasis>// This is a parametric class</emphasis>
<emphasis role="strong">class</emphasis> A&lt;G&gt; {
}

<emphasis>// This is the type variable binding : G is binded with Integer</emphasis>
<emphasis role="strong">var</emphasis> a : A&lt;Integer&gt;
a := A&lt;Integer&gt;.new
</programlisting>

				<para>There are some limitations in regards to Java. For example,
					you
					cannot define nested classes
					in Kermeta. Kermeta offers the same
					structural concepts than MOF language.
				</para>
			</section>

			<section id="section_defining_operations.link">
				<title>Defining operations</title>

				<para>Kermeta provides a way to add operational (action) semantics
					to your metamodels. For that,
					you can define operations with their
					body, as in a classical programming language. You can also
					specify
					abstract operations (they have no body). Kermeta requires that
					every
					class that contains
					an abstract operation must be declared as
					an
					abstract class.
				</para>

				<para>In the following example, we define some operations, based on
					a
					visitor pattern
					implementation
				</para>

				<programlisting><emphasis role="strong">class</emphasis> Inventory 
{
    <emphasis role="strong">operation</emphasis> visitLibrary(l : Library) <emphasis role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        writeln("Inventory : ");
        l.books.each(b : Book | b.accept(<emphasis role="strong">self</emphasis>))
        writeln("----")
    <emphasis role="strong">end</emphasis>

    <emphasis role="strong">operation</emphasis> visitBook(b : Book) <emphasis role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        stdio.write("Book : ", b.title, " by ")
        b.authors.each(a : Author | a.accept(<emphasis role="strong">self</emphasis>))
    <emphasis role="strong">end</emphasis>

    <emphasis role="strong">operation</emphasis> visitAuthor(a : Author) <emphasis role="strong">is</emphasis> 
    <emphasis role="strong">do</emphasis>
        stdio.write(a.name, " ", a.lastName)
    <emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Library {
    // ...
    <emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
					role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        visitor.visitLibrary(self)
    <emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Book
{
    // ...
    <emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
					role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        visitor.visitBook(self)
    <emphasis role="strong">end</emphasis>
}

<emphasis role="strong">class</emphasis> Author
{
    // ...
    <emphasis role="strong">operation</emphasis> accept(visitor : Inventory) <emphasis
					role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        visitor.visitAuthor(self)
    <emphasis role="strong">end</emphasis>
}</programlisting>

				<para>
					In this small example we define an
					<literal>Inventory</literal>
					class which can go over the library structure and print books
					informations. For that, we apply
					the visitor GoF pattern's on the
					library structure defining an
					<literal>accept</literal>
					method in
					every library structures.
				</para>

				<section>
					<title>Result</title>

					<para>
						The special variable
						<literal>result</literal>
						is used to
						store the value that will be returned by the operation.
					</para>

					<programlisting><emphasis role="strong">operation</emphasis> getName() : String<emphasis
						role="strong"> is</emphasis>
    <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := <emphasis role="strong">self</emphasis>.name
    <emphasis role="strong">end</emphasis></programlisting>

					<note>
						<para>
							This is different of the
							<literal>return</literal>
							in java, since it doesn't end the block. Other instructions can
							be used after the
							<literal>result</literal>
							assignment.
						</para>
					</note>
				</section>

				<section>
					<title>Operations as main entry point.</title>

					<para>
						When you run a Kermeta program you'll start from an operation.
						The
						main operation that you want
						to run can have any number of
						parameters, whose types must be only and only String. For
						operations
						that are
						<emphasis role="strong">not</emphasis>
						intended to be run,
						you can put any type of parameters.
					</para>

					<para>Technically, if you use Kermeta inside Eclipse, when you will
						ask it to run your
						operation, the interpreter will implicitely
						instanciate the class containing this operation,
						and then will
						call
						this operation.
					</para>

					<para>
						<emphasis role="strong">Example</emphasis>
						: 3 different kinds
						of "runnable" operations
					</para>

					<programlisting><emphasis role="strong">class</emphasis> A{
    <emphasis role="strong">operation</emphasis> main0() <emphasis role="strong">is</emphasis> <emphasis
						role="strong">do</emphasis>
        <emphasis>// do something</emphasis>
    <emphasis role="strong">end</emphasis>
    <emphasis role="strong">operation</emphasis> main1( arg1 : String) <emphasis role="strong">is</emphasis> <emphasis
						role="strong">do</emphasis>
        <emphasis>// do something with 1rst argument</emphasis>
    <emphasis role="strong">end</emphasis>
    <emphasis role="strong">operation</emphasis> main3( arg1 : String, arg2 : String) <emphasis
						role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>// do something with 1st and 2nd arguments</emphasis>
    <emphasis role="strong">end</emphasis>
}
<emphasis>// If you ask to launch main0, Kermeta interpereter will create an instance of A and will run main0 on it.</emphasis></programlisting>
				</section>
			</section>

			<section>
				<title>Initializing classes</title>

				<para>Kermeta doesn't use constructors.</para>

				<para>However in some situation, you may need to provide some
					initialization operation. The best
					approach is simply to declare an
					operation which will return self after having done the
					initialization
					work.
				</para>

				<programlisting language="kermeta">
class A
{
	attribute name : String
	operation initialize(name : String) : A is do
		self.name := name
	end
}        
        </programlisting>

				<programlisting language="kermeta">
// now you can use it easily in one line
	var aA : A init A.new.initialize("hello")
        </programlisting>
			</section>

			<section>


				<title>Rationale</title>

				<para>Here are some explanation about some design choice of Kermeta
					classes.
				</para>

				<section>
					<title>No constructor</title>

					<para>This is because of the compatibility with EMOF and Ecore. In
						those metalanguages, the user
						must always be able to create object
						(except if they are declared abstract), it cannot rely on
						a action
						language (since they don't define one). In addition, we want that
						all
						Meta tool be able
						to create the object the same way, so, as
						Ecore
						doesn't provide constructor with its editors,
						then neither
						does
						Kermeta.
					</para>
					<para>
						However, you can easily add an
						<literal>init</literal>
						or
						<literal>myInitialize</literal>
						operation that will
						take as many parameters as you want. Even
						better, you can use a
						Builder or a
						Factory design pattern.
					</para>
					<programlisting language="kermeta">
aspect class ClassFromMyEcore {
	 
	operation init(myParam : String) : ClassFromMyEcore is do
		// assign myParam to some attribute 
		self.name := myParam
		// return self for easier use
		result := self
	end
	// now you can create and initialize this class in one line
	// var foo : ClassFromMyEcore init ClassFromMyEcore.new.init("foo")	
}
          </programlisting>

				</section>



				<section>
					<title>No operation overloading</title>

					<para>In order to simplify multiple inheritance management, Kermeta
						allows only one operation or
						property with the same name in a
						given
						class.
					</para>
				</section>


			</section>
		</section>

		<section id="section_inheritance.link">
			<title id="section_inheritance.title.link">
				Inheritance
				<phrase id="section_inheritance"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>As Kermeta is object-oriented, it supports inheritance. Like
				its
				basis EMOF, it support both,
				simple and multiple inheritance.
			</para>

			<section>
				<title>
					Using simple inheritance
					<phrase id="sec_simple-inheritance.link"></phrase>
				</title>

				<programlisting language="kermeta">abstract class Person
{
    attribute name : string
    attribute lastName : string

    reference father : Male#children 
    reference mother : Female#children
}

class Male inherits Person
{
    reference children : oset Person[0..*]#father
    reference wife : Female[0..1]#husband
}

class Female inherits Person
{
    reference children : oset Person[0..*]#mother
    reference husband : Male[0..1]#wife
}</programlisting>

				<para>
					In this example, we define a simple model which represent
					simples
					family trees. Here, persons are
					defined by their name and last
					name. Each person have a father and mother and respectively might
					have
					children. The figure representing this example is
					<xref linkend="refIllustration7" />
				</para>

				<figure id="refIllustration7">
					<title>A simple family tree model</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/person.png" />
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section>
				<title>Cast</title>

				<para>As Kermeta is strongly typed, you cannot assign or pass
					something of the wrong type.
				</para>

				<para>For example :</para>

				<programlisting language="kermeta">
class A {
}
class SubA inherits A {
}
class AnotherSubA inherits A {
}

// ...
	var aA    : A init SubA.new
	var aSubA : SubA
	aSubA := aA  // doesn't work because not type safe
        </programlisting>

				<para>In this situation you must use one of the following methods :
					conditional assignment or
					asType
				</para>

				<section>
					<title>Casting using conditional assignment</title>

					<para>
						The conditional assignment
						<literal>?=</literal>
						allows to
						assign only if the passed object is of the correct type.
						If not of
						the correct type,
						the assigned value will simply be
						<literal>Void</literal>
						.
					</para>

					<programlisting language="kermeta">
	aSubA ?= aA  // works
	var aAnotherSubA : AnotherSubA
	aAnotherSubA ?= aA  // works too, but has been assigned Void and not the value 
        	</programlisting>

					<para>This still propose some control on the types and won't accept
						all kind of cast, for
						example, you cannot conditionaly assign if
						you don't have a common supertype.
					</para>

					<programlisting language="kermeta">
class B {
}
// ...	
	var aB : B
	aB ?= aA  // doesn't work because not type safe
        	</programlisting>
				</section>

				<section>
					<title>Casting using asType</title>

					<para>
						You can also use the operation
						<literal>asType</literal>
						to
						cast your value. This one use a syntax which is shorter in some
						situation, since you don't
						have to create an intermediate variable
						before passing the casted value to an operation.
						However, the
						drawback is that, if it fails to cast, then it will raise an
						exception.
					</para>

					<programlisting language="kermeta">
class C {
	operation needASubA(sa : SubA) : Void	is do
		// do something
	end
}
	// ... typical code using ?= 
	var aC : C init C.new	
	aC.needASubA(aA.asType(SubA))
        	</programlisting>
				</section>

				<section>
					<title>Useful functions when casting</title>

					<para>
						In complement you can use the
						<literal>isVoid</literal>
						operation (available on every object) to test the result of a
						conditional cast. Or you may use
						the
						<literal>isKindOf</literal>
						or the
						<literal>isInstanceOf</literal>
						operations to test if the calling object has the same type of the
						given class before
						the
						assignment/asType. The
						<literal>isKindOf</literal>
						operation returns
						<literal>true</literal>
						if the calling object
						has exactly the same type than the given
						class. The
						<literal>isInstanceOf</literal>
						operation returns
						<literal>true</literal>
						if the calling object has the exact type or one of its super type
						than the given class.
					</para>
				</section>
			</section>

			<section>
				<title>Using multiple inheritance</title>

				<programlisting><emphasis role="strong">class</emphasis> Parent
{
     <emphasis role="strong">reference</emphasis> children : oset Child[0..*]#parent
}

<emphasis role="strong">class</emphasis> Child
{
     <emphasis role="strong">reference</emphasis> parent : Parent#children</programlisting>

				<programlisting>}

<emphasis role="strong">class</emphasis> Male { }

<emphasis role="strong">class</emphasis> GrandFather <emphasis role="strong">inherits</emphasis> Parent, Male
{
     <emphasis role="strong">boolean</emphasis> healthy : Boolean
}</programlisting>

				<para>The above example defines a class "GrandFather" that inherits
					at
					the same time the class
					"Parent", and the class "Male". Its
					graphical
					representation is shown in below figure.
				</para>

				<figure id="refIllustration8">
					<title>: multiple inheritance</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/KMM_multiple_inheritance.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para></para>
			</section>

			<section>
				<title>Overriding behavior with methods</title>

				<para>
					In the following sample, when an operation is declared for the
					first time (in the parent class
					Person), it uses the
					<literal>operation</literal>
					keyword. Then, whenever you override it,
					you will have to use the
					<literal>method</literal>
					keyword.
				</para>

				<note>
					<para>
						In the sample,Person and adopt are abstract, but this has no
						influence on the
						operation-method keywords rule, it would have
						been the same even if Person was not abstract or
						if adopt had a
						behavior in this class.
					</para>
				</note>

				<programlisting><emphasis role="strong">abstract class</emphasis> Person
{
    <emphasis role="strong">attribute</emphasis> name : String
    <emphasis role="strong">reference</emphasis> father : Male#children 
    <emphasis role="strong">reference</emphasis> mother : Female#children
    <emphasis role="strong">operation</emphasis> adopt(child : Person) <emphasis role="strong">is</emphasis> <emphasis
					role="strong">abstract</emphasis>}</programlisting>

				<programlisting><emphasis role="strong">class</emphasis> Male <emphasis role="strong">inherits</emphasis> Person 
{
    <emphasis role="strong">reference</emphasis> wife : Female#husband
    <emphasis role="strong">reference</emphasis> children : oset Person[0..*]#father<emphasis></emphasis>    <emphasis
					role="strong">method</emphasis> adopt(child : Person) <emphasis role="strong">is</emphasis>    <emphasis
					role="strong">do</emphasis>        children.add(child)
        <emphasis role="strong">if</emphasis> <emphasis role="strong">not</emphasis> wife.children.contains(child) <emphasis
					role="strong">then</emphasis>            child.father := <emphasis role="strong">self</emphasis>            wife.adopt(child)
        <emphasis role="strong">end</emphasis>    <emphasis role="strong">end</emphasis>}</programlisting>

				<programlisting><emphasis role="strong">class</emphasis> Female <emphasis role="strong">inherits</emphasis> Person
{
    <emphasis role="strong">reference</emphasis> husband : Male#wife
    <emphasis role="strong">reference</emphasis> children : oset Person[0..*]#mother<emphasis></emphasis>    <emphasis
					role="strong">method</emphasis> adopt(child : Person) <emphasis role="strong">is</emphasis>    <emphasis
					role="strong">do</emphasis>        children.add(child)
        <emphasis role="strong">if</emphasis> <emphasis role="strong">not</emphasis> husband.children.contains(child) <emphasis
					role="strong">then</emphasis>            child.mother := <emphasis role="strong">self</emphasis>
            husband.adopt(child)
        <emphasis role="strong">end</emphasis>    <emphasis role="strong">end</emphasis>}</programlisting>
			</section>

			<section>
				<title>Some limitations</title>

				<para>A MOF class can have operations but MOF does not provide any
					way
					to describe the behavior of
					these operations. Furthermore MOF
					does
					not
					provide any semantics neither for operation call nor
					for
					operation
					inheritance and redefinition. This section investigates
					how, while
					weaving actions
					into MOF, MOF semantics can be extended
					to support
					behavior definition and extension mechanisms
					provided by
					the action
					language. This implies answering several questions
					concerning
					redefinition
					and dispatch.
				</para>

				<section>
					<title>Operation redefinition</title>

					<para>MOF does not specify the notion of overriding an operation
						because from a structural point
						of view it does not make any
						sense.
						To stick to MOF structure one can argue that redefinition
						should be
						forbidden in an executable MOF. This is the simplest
						solution as
						it
						also solves the
						problem of the dynamic dispatch since
						a simple
						static binding policy can be used.
					</para>

					<para>However, operation redefinition is one of the key features of
						Object-Oriented (OO)
						languages. The OO paradigm has demonstrated
						that operation redefinition is a useful and
						powerful mechanism to
						define the behavior of objects and allow for variability. This
						would
						be
						very convenient to properly model dynamic semantic
						variation
						points existing in e.g. UML
						state-charts. For this reason
						we
						believe
						that an important feature of an executable MOF is to
						provide a
						precise behavior redefinition mechanism. The choice of
						the operation
						overriding
						mechanism must take into account the usual
						problem of
						redefinition such as method specialization
						and
						conflicting
						redefinitions related to multiple inheritance.
					</para>

					<table id="refTable0">
						<title>Operation redefinition in Kermeta</title>

						<tgroup cols="2">
							<colspec colname="c1" colwidth="1*" />

							<colspec colname="c2" colwidth="2*" />

							<tbody>
								<row>
									<entry align="right">
										<mediaobject>
											<imageobject>
												<imagedata depth="9.208cm" fileref="Kermeta-Manual_figures/operation_redefinition.png"
													width="2.29cm" />
											</imageobject>
										</mediaobject>
										<para></para>
									</entry>

									<entry>
										<programlisting><emphasis role="strong">class</emphasis> A
{
     <emphasis role="strong">operation</emphasis> m1() <emphasis role="strong">is</emphasis> <emphasis
											role="strong">do</emphasis>
         <emphasis>// Some behavior</emphasis>
     <emphasis role="strong">end</emphasis>

     <emphasis>// operation m2 is abstract</emphasis>
     <emphasis role="strong">operation</emphasis> m2() <emphasis role="strong">is</emphasis> <emphasis
											role="strong">abstract</emphasis>
}
</programlisting>
										<programlisting><emphasis role="strong">class</emphasis> B <emphasis role="strong">inherits</emphasis> A
{    
     <emphasis>// method m1 inherits operation m1 from A</emphasis>
     <emphasis role="strong">method</emphasis> m1() <emphasis role="strong">is</emphasis> <emphasis
											role="strong">do</emphasis>
         <emphasis>// Behavior redefinition</emphasis>
     <emphasis role="strong">end</emphasis>

     <emphasis role="strong">method</emphasis> m2() <emphasis role="strong">is</emphasis> <emphasis
											role="strong">do</emphasis> <emphasis>//</emphasis><emphasis> Implementation of the abstract method</emphasis>
     <emphasis role="strong">end</emphasis>
}</programlisting>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>

					<note>
						<para>
							Notice in that sample that method redefinition uses the

							<literal>method</literal>

							keyword instead of

							<literal>operation.</literal>


						</para>
					</note>
				</section>

				<section>
					<title>Operation specialization</title>

					<para>The issue of choosing semantics for operation overriding has
						been widely studied for the
						design of OO languages ( cf. M. Abadi
						and L. Cardelli, A theory of objects, Springer). However,
						OO
						languages have not adopted a unique solution to this problem. In
						this context, any language
						that defines an operation overriding
						mechanism should define precisely the solution it
						implements.
					</para>

					<para>
						The simplest approach to overriding is to require that an
						overriding method has exactly the
						same signature as the overridden
						method. That is that both the type of the parameters and the
						return
						type of the operation should be
						<emphasis>invariant</emphasis>
						among
						the implementations of an operation. For the sake of
						simplicity this
						is the solution we
						have chosen for the current
						version of
						Kermeta.
					</para>

					<para>
						However, this condition can be relaxed to allow method
						<emphasis>specialization,</emphasis>
						i.e. specialization on the
						types of parameters or/and return type
						of the operation. On one
						hand,
						the return type of the overriding
						method can be a sub-type of
						the return type of the overridden
						method. Method specialization is
						said to be
						<emphasis>covariant</emphasis>
						for the return types. On
						the other hand, the types of parameters of
						the overriding method
						might
						be super types of the parameters of the
						overridden methods.
						Method specialization is thus
						<emphasis>contravariant</emphasis>
						for
						the parameters.
					</para>

					<para>In practice languages can allow method specialization only on
						the return type (this is the
						case of Java 1.5) or both on
						parameters
						and return type (this is the case of Eiffel). Among
						these solutions,
						we may choose a less restrictive policy then
						strict invariance for
						future
						versions of Kermeta in order to
						improve the static type
						checking of Kermeta programs.
					</para>
				</section>

				<section>
					<title>Operation overloading</title>

					<para>Overloading is not allowed in Kermeta. This mechanism allows
						multiple operations taking
						different types of parameters to be
						defined with the same name. For each call, depending on the
						type
						of
						the actual parameters, the compiler or interpreter automatically
						calls the right one.
						This provides a convenient way for writing
						operations whose behaviors differ depending on the
						static type of
						the parameters. Overloading is extensively used is some functional
						languages such
						as Haskell and has been implemented in OO languages
						such as Java or C#. However it causes
						numerous problems in an OO
						context due to inheritance and even multiple inheritance in our
						case
						[REF?]. It is not implemented in some OO languages such as
						Eiffel
						for this reason, and that is
						why we chose to exclude
						overloading
						from Kermeta.
					</para>

					<programlisting><emphasis role="strong">class</emphasis> A
{
    <emphasis role="strong">method</emphasis> m(i : Integer) <emphasis role="strong">is</emphasis> <emphasis
						role="strong">do</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end 
    method </emphasis>m(s : String)<emphasis role="strong"> is do </emphasis><emphasis>// this is not allowed in Kermeta !!!</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end</emphasis>
}</programlisting>
				</section>

				<section>
					<title>Conflicts related to multiple inheritance</title>

					<para>This is also a classical problem that has been solved in
						several OO languages. There are
						mainly two kinds of conflicts when
						a
						class inherits features from several super-classes:
					</para>

					<itemizedlist>
						<listitem>
							<para>Several features with the same name might be inherited
								from
								different super classes
								causing a name clash.
							</para>
						</listitem>

						<listitem>
							<para>Several implementations of a single operation could be
								inherited from different super
								classes.
							</para>
						</listitem>
					</itemizedlist>

					<para>There are two kinds of solutions to resolve these conflicts.
						The first one is to have an
						implicit resolution mechanism which
						chooses the method to inherit according to an arbitrary
						policy.
						The
						second one is to include in the language constructions that
						allow
						the programmer to
						explicitly resolve conflicts. In Eiffel,
						for
						instance, the programmer can rename features in
						order to avoid
						name
						clashes and can select the method to inherit if several
						redefinition
						of an
						operation are inherited from parent classes.
					</para>

					<para>
						In the current version of Kermeta, we have chosen to include a
						minimal selection mechanism that
						allows the user to explicitly
						select the inherited method to override if several
						implementations
						of an operation are inherited. This mechanism does not allow
						resolving some name
						clashes and thus reject some ambiguous
						programs.
						For the future version of Kermeta we plan to
						include a
						more general
						mechanism such as
						<emphasis>traits</emphasis>
						proposed by Schärli et
						al. In any case we believe the conflict
						resolution mechanism should
						be
						explicit for the programmer.
					</para>

					<table id="refTable1">
						<title>Explicit selection of super operation in Kermeta</title>

						<tgroup cols="2">
							<colspec colname="c1" colwidth="1*" />

							<colspec colname="c2" colwidth="2*" />

							<tbody>
								<row>
									<entry align="center">
										<mediaobject>
											<imageobject>
												<imagedata depth="11.374cm" fileref="Kermeta-Manual_figures/superoperation_selection.png"
													width="5.636cm" />
											</imageobject>
										</mediaobject>
										<para></para>
									</entry>

									<entry>
										<programlisting><emphasis role="strong">class</emphasis> O
{
    <emphasis role="strong">operation</emphasis> m() <emphasis role="strong">is</emphasis> <emphasis
											role="strong">abstract</emphasis>
}
</programlisting>
										<programlisting><emphasis role="strong">class</emphasis> A <emphasis role="strong">inherits</emphasis> O
{
    <emphasis role="strong">method</emphasis> m() <emphasis role="strong">is</emphasis> <emphasis
											role="strong">do</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end</emphasis>
}
</programlisting>
										<programlisting><emphasis role="strong">class</emphasis> B <emphasis role="strong">inherits</emphasis> O
{
    <emphasis role="strong">method</emphasis> m() <emphasis role="strong">is</emphasis> <emphasis
											role="strong">do</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end</emphasis>
}
</programlisting>
										<programlisting><emphasis role="strong">class</emphasis> C <emphasis role="strong">inherits</emphasis> A, B
{
<emphasis>// "from" : an explicit selection of the//implementation to inherit</emphasis>
    <emphasis role="strong">method</emphasis> m() <emphasis role="strong">from</emphasis> A <emphasis
											role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis>// [...]</emphasis>
    <emphasis role="strong">end</emphasis>
} 
</programlisting>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</section>
			</section>
		</section>

		<section id="section_genericity.link">
			<title id="section_genericity.title.link">
				Genericity
				<phrase id="section_genericity"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>One of the core characteristics of Kermeta is to be statically
				typed. In order to allow
				static typing of OCL-like expressions, a
				few
				modifications had to be made to the EMOF type system
				(Please
				refer to
				paper Weaving Executability into Object-Oriented
				Meta-Languages by P.A.
				Muller et
				al., presented at the Models05
				conference).
			</para>

			<para>As a result to these modifications genericity support has been
				added into Kermeta. Like
				Eiffel and Java 5, Kermeta supports generic
				classes and generic operations. This section gives on
				overview of
				these
				concepts in Kermeta.
			</para>

			<section>
				<title>Generic classes</title>

				<para>In Kermeta classes can have a set of type parameters. These
					type
					variables can be used in
					the implementation of the class as any
					other
					type. By default a type variable can take as value
					any type;
					but a
					type variable can also be constrained by a type: in that case,
					this
					type variable
					can only be substituted by a sub-type of this
					type.
					The
					following code demonstrates how to create
					generic classes.
				</para>

				<programlisting language="kermeta">// A class with a type variable G that can be bound with any type</programlisting>

				<programlisting><emphasis role="strong">class</emphasis> Queue&lt;G&gt;
{
     <emphasis role="strong">reference</emphasis> elements : oset G[*]

     <emphasis role="strong">operation</emphasis> enqueue(e : G) : <emphasis role="strong">Void</emphasis> <emphasis
					role="strong">is</emphasis> <emphasis role="strong">do</emphasis> 
         elements.add(e)
     <emphasis role="strong">end</emphasis>
     
     <emphasis role="strong">operation</emphasis> dequeue() : G <emphasis role="strong">is</emphasis> <emphasis
					role="strong">do</emphasis>
         <emphasis role="strong">result</emphasis> := elements.first
         elements.removeAt(0)
     <emphasis role="strong">end</emphasis>
}
</programlisting>

				<programlisting language="kermeta">// A class with a type variable C that can be bound with any sub-type of Comparable</programlisting>

				<programlisting><emphasis role="strong">class</emphasis> SortedQueue&lt;C : Comparable&gt; <emphasis
					role="strong">inherits</emphasis> Queue&lt;C&gt; 
{
     <emphasis role="strong">method</emphasis> enqueue(e : C) : <emphasis role="strong">Void</emphasis> <emphasis
					role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
         <emphasis role="strong">var</emphasis> i : Integer
         <emphasis role="strong">from</emphasis> i := 0
         <emphasis role="strong">until</emphasis> i == elements.size <emphasis role="strong">or</emphasis> e &gt; elements.elementAt(i)
         <emphasis role="strong">loop</emphasis>
             i := i + 1
         <emphasis role="strong">end</emphasis>
         elements.addAt(i, e)
     <emphasis role="strong">end</emphasis>
}
</programlisting>
			</section>

			<section>
				<title>Generic operations</title>

				<para>Kermeta operations can contain type parameters. Like type
					variables for classes these type
					parameters can be constrained by a
					super type. However, unlike for classes, for which the
					bindings to
					these type parameters are explicit, for operations the actual type
					to
					bind to the
					variable is statically inferred for each call
					according to
					the type of the actual parameters.
				</para>

				<programlisting><emphasis role="strong">class</emphasis> Utils {
    <emphasis role="strong">operation</emphasis> max&lt;T : Comparable&gt;(a : T, b : T) : T <emphasis
					role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := <emphasis role="strong">if</emphasis> a &gt; b <emphasis
					role="strong">then</emphasis> a <emphasis role="strong">else</emphasis> b <emphasis role="strong">end</emphasis>
    <emphasis role="strong">end</emphasis>
}
</programlisting>

				<note>
					<para>
						Notice in that sample that even the "if" is an expression
						that can
						return a value that is
						assigned here to the special
						variable
						"result".
					</para>
				</note>
			</section>

			<section>
				<title>Type usable with genericity</title>

				<para>
					Actually, all types can be used as a parameter of a generic
					class or
					generic operation. More, the
					ModelType, is really useful when
					combined with generics. see
					<xref linkend="section_modeltype.link" />
				</para>
			</section>
		</section>

		<section id="section_exceptions.link">
			<title id="section_exceptions.title.link">
				Exception handling
				<phrase id="section_exceptions"></phrase>
			</title>
			<para>Kermeta provides also an exception mechanism. You can define a
				"rescue" block to manage
				errors occurring during the execution of
				another block. Exception mechanism is very close to the
				Java
				Exception
				mechanism.
			</para>

			<para>
				<emphasis role="strong">Example 1</emphasis>
				: a simple exception
				raising
			</para>

			<programlisting><emphasis role="strong">do</emphasis>
    <emphasis role="strong">var</emphasis> excep : kermeta::exceptions::Exception
    
    excep := kermeta::exceptions::Exception.new
    stdio.writeln("Throwing an exception ! ")
    <emphasis role="strong">raise</emphasis> excep
<emphasis role="strong">end</emphasis></programlisting>

			<para>Any block can then rescue exceptions.</para>

			<para>
				<emphasis role="strong">Example 2</emphasis>
				: rescue block
			</para>

			<programlisting><emphasis role="strong">var</emphasis> v1 : Integer <emphasis role="strong">init</emphasis> 2
<emphasis role="strong">var</emphasis> v2 : Integer <emphasis role="strong">init</emphasis> 3

<emphasis role="strong">do</emphasis>
    var v3 : Integer
    v3 := v1 + v2
<emphasis role="strong">rescue</emphasis> (myConstraintError : kermeta::exceptions::ConstraintViolatedInv)
    // something with myConstraintError
    // ...
<emphasis role="strong">rescue</emphasis> (myError : kermeta::exceptions::Exception)
    // something with myError
    // ...
<emphasis role="strong">end</emphasis></programlisting>

			<tip>
				<para>
					do not hesitate to create "do .. end" block into another block
					if you
					want to check for an
					exception only in a part of the code.
					This
					also works if you want to rescue code from within a
					rescue
					code.
				</para>
			</tip>
		</section>

		<section id="section_loadingsaving_models.link">
			<title id="section_loadingsaving_models.title.link">
				Loading and saving
				models
				<phrase id="section_serialization"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>This section explains how to load and save (deserialize and
				serialize) an EMF model in
				Kermeta. For this purpose, we will use
				the
				following small example :
			</para>

			<figure float="" id="refIllustration9">
				<title>cs.ecore sample metamodel</title>

				<mediaobject>
					<imageobject>
						<imagedata fileref="Kermeta-Manual_figures/cs_ecore.gif" />
					</imageobject>
				</mediaobject>
			</figure>

			<note>
				<para>
					Loading and saving model has it own tutorial. It provides more
					information in a step by step
					approach. See the EMF tutorial at
					<ulink type="" url="http://www.kermeta.org/documents/emfTutorial/">http://www.kermeta.org/documents/emfTutorial/
					</ulink>
				</para>
			</note>

			<section>
				<title>Prepare a model</title>

				<para>The user will refer to Eclipse documentation for the creation
					of
					an EMF model from its ECore
					meta-model. We suggest to use the
					Wizard
					samples to create, at the first hand, an Ecore
					meta-model,
					and
					then,
					at the second hand, instances of this Ecore meta-model,
					using the
					generated
					EMF reflexive editors.
				</para>

				<para>
					Once you created the ECore meta-model, please check that you
					correctly filled the property "
					<literal>Ns URI"</literal>
					of the root
					package of the Ecore meta-model, otherwise the resource
					load will
					fail. This NsURI
					must equal the real path of your
					metamodel. (You can
					modify this property through the Properties
					View
					of your
					meta-model)
				</para>
			</section>

			<section>
				<title>Load a model from an EMF Resource</title>

				<para>In the current version of the EMF resource loader, you have to
					prepare your EMF Resource
					following these rules :
				</para>

				<itemizedlist>
					<listitem>
						<para>
							At the top of the source code where you will access your
							model,
							don't forget to add
							<literal>require "your_metamodel.ecore"
							</literal>
							so you can tell Kermeta that you will create/load/manipulate
							instances of these metaclasses.
						</para>

						<para>
							Alternatively, you can use the Kermeta version of your
							metamodel
							using
							<literal>require "your_metamodel.kmt"</literal>
							or
							<literal>require "your_metamodel.km"</literal>
							.
						</para>

						<para role="lineBreak">In this case, be careful that your kmt
							required
							metamodel is strictly equivalent
							to the ecore version of
							your
							metamodel that is used in createResource method.
						</para>
					</listitem>

					<listitem>
						<para>
							Then, create a repository and the resource that will contain
							the
							model instance that you want
							to load. In the following code
							example,
							<literal>uri</literal>
							stands for the uri (as relative or
							absolute path
							<footnote id="ftn2">
								<para>in this case, don't forget to put the protocol, i.e.
									platform:/, file:/, etc.
								</para>
							</footnote>
							) of the model instance, and
							<literal>mm_uri</literal>
							is the uri of the meta-model of the
							model instance.
						</para>
					</listitem>
				</itemizedlist>

				<programlisting language="kermeta">@mainClass "root::TestCSLoading"
@mainOperation "main"

package root;

require kermeta
require "cs.ecore"

using kermeta::standard
using kermeta::persistence

class TestCSLoading
{
     operation initialize(uri : String, mm_uri : String) : Set&lt;Object&gt; is do
         /* Initialize the EMF repository */
         var repository     : EMFRepository init EMFRepository.new
         /* Create an EMF Resource */
         var resource : Resource init repository.createResource(uri, mm_uri)
         /* Load the resource */
         resource.load
         /* Get the loaded __root__ instances (a Set&lt;Object&gt;) */
         result := resource  // a resource is a collection of objects contained
     end</programlisting>

				<itemizedlist>
					<listitem>
						<para>
							Once you loaded your EMF resource, you can get its attribute
							<literal>instances</literal>
							, that contains all the objects that
							you created through your EMF
							generated reflexive editor.
							Now you
							can "visit" your instances,
							provided you "visit" them according to
							their types. In the
							simplest way, you can make very basic tests
							to
							display your
							instances content, as in the
							following example, which
							visit the
							objects of resource instances which types are
							<literal>cs::Template</literal>
							and
							<literal>cs::Decision.</literal>
						</para>
					</listitem>
				</itemizedlist>

				<programlisting language="kermeta">
operation main() is do 
   var instances : Set&lt;Object&gt; init self.initialize("./test.cs", "./cs.ecore")
   instances.each{ o |
      if (o == void) then stdio.writeln("Void object!") 
      else 
         stdio.writeln("---------------------------------") 
         stdio.writeln("Objet : " + o.getMetaClass.typeDefinition.qualifiedName 
            + " ( " + o.getMetaClass.typeDefinition.ownedAttribute.size.toString+ "attr.)" ) 
      end
      var template : cs::Template // Print instances which type is cs::Template 
      if (cs::Template.isInstance(o)) 
      then 
         template ?= o 
         stdio.writeln(" name : " + template.name) 
         stdio.writeln(" decision : " + template.decision.toString) 
         stdio.writeln(" content : " + template.content) stdio.writeln(" referer : " + template.referer.toString) 
      end
      // Print instances which type is cs::Decision 
      if (cs::Decision.isInstance(o)) 
      then
         decision ?= o 
         stdio.writeln(" name : " + decision.name) 
      end
   }
}</programlisting>

				<para>If your resource is dependent of other resources and that EMF
					succed to load it, the
					Repository that was used to load your
					resource
					will automatically load all these dependent
					resources.
				</para>
			</section>

			<section>
				<title>Save a model into an EMF Resource</title>

				<para>To save a model, simply add the model elements in a Resource
					then
					call the save operation.
					All model elements contained by these
					added
					elements
					will also be saved in the Resource.
				</para>
				<para>You can split your model in several files by using several
					resources,
					but you need to make
					sure that they all belong to the
					same Repository.
					Otherwise,
					you'll get at best a Dangling
					exception,
					or worse create inconsistent
					files.
				</para>
			</section>
		</section>

		<section id="section_packages.link">
			<title id="section_packages.title.link">
				Packages
				<phrase id="section_packages"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>

			<para>
				Kermeta provides package to structure models. So you can define
				packages and sub-package as deep
				as you want. There are two main
				ways
				to do this, as shown in examples 2 and 3 (below). If you want
				to
				define some classes in a package you may define them in a specific
				file and start this file
				with a package naming directive (followed
				by
				a semi-colon) like in the following example
				<footnote id="ftn1">
					<para>Each Kermeta file(.kmt) must declare a package
						directive.
					</para>
				</footnote>
				.
			</para>

			<para>
				<emphasis role="strong">Example 1</emphasis>
				: 1 file.kmt == 1
				package naming directive
			</para>

			<programlisting language="kermeta">// My file
package MyNewPackage;

class A { 
// ... 
}</programlisting>

			<programlisting language="kermeta">
class B {
// ... 
}</programlisting>

			<para>Here, classes A and B are defined in a package called
				"MyNewPackage". All classes defined in
				this file are under the scope
				of this package.
			</para>

			<para>You can also define explicitly sub-packages using braces (see
				the following example):
			</para>

			<para role="lineBreak">
				<emphasis role="strong">Example 2</emphasis>
				:
				Defining subpackages using braces
			</para>

			<programlisting language="kermeta">// file : MyPackage-part1.kmt
package MyPackage;

package subPackage1 
{
    class A 
    {
// ...
    }
}

package subPackage2
{
    class B
    {
// ...
    }
}</programlisting>

			<para>In this example, we define a main package called "MyPackage"
				which contains 2 sub-packages
				"subPackage1" and "subPackage2". The
				first one contains the A class and the second one the B
				class.
			</para>

			<para>If you want, you can declare the same package in several files.
				You can also directly define
				subpackages in the package naming
				directive of your file (see example 1 above). In the following
				example, we define a new sub-package of "MyPackage" called
				"subPackage3" directly in the file.
				All features defined in this
				file
				will belong to this sub-package.
			</para>

			<para>
				<emphasis role="strong">Example 3</emphasis>
				: Defining
				subpackage using
				<literal>::</literal>
				syntactic sugar
			</para>

			<programlisting language="kermeta">// file : subPackage3.kmt
package MyPackage::subPackage3;

class C 
{
// ...
}</programlisting>



		</section>
		<section id="section_using.link">
			<title id="section_using.title.link">
				<literal>using</literal>
				keyword syntactic sugar
				<phrase id="section_using"></phrase>
			</title>
			<note>
				<title>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="gfx/fire.png" contentdepth="2em" />
						</imageobject>
					</inlinemediaobject>
					Changed in Kermeta 2
				</title>
				<para></para>
			</note>
			<para>While coding in Kermeta you regularly need to refer to class
				definitions.
				For example to
				indicate the type of a paramzeter or a
				variable or to
				initialize an instance of it (ie. call new).
			</para>
			<para>If the definition you want to use isn't defined in the package
				where you need to use it, the
				normal way to acces it is to use the
				full qualified name.
			</para>
			<example>
				<title>use of full qualified name</title>
				<programlisting language="kermeta">...
var s : kermeta::standard::Integer
var e : kermeta::exceptions::NotImplementedException init kermeta::exceptions::NotImplementedException.new
...</programlisting>
			</example>
			<para>
				Like the
				<literal>import</literal>
				statement in Java, Kermeta allows to defines shorcuts which allow
				you to specify classes from
				other packages that can be referenced
				without qualifying them with their full qualified name.
				The
				keyword
				used for that is
				<literal>using</literal>
				. It supports various syntax option in order to haheve either a fine
				or coarse grain resolution.
			</para>
			<example>
				<title>shorthand giving access to the full content of a package
				</title>
				<programlisting language="kermeta">using kermeta::standard::*	
		// direct access to all definitions in Package kermeta::standard
using kermeta::exceptions::*
		// direct access to all definitions in Package kermeta::exceptions 
...
// allows to write :
var s : Integer
var e : NotImplementedException init NotImplementedException.new
</programlisting>
			</example>
			<note>
				<para>For support of retro compatibilty with kermeta 1, the 2
					following syntaxes have the same
					effect. However the second one
					raises a deprecation warning inviting you to use the first
					syntax.
				</para>
				<programlisting language="kermeta">using kermeta::standard::*	// direct access to all definition of Package
using kermeta::standard		// retro compatibility supported, exactly the same as above   
                            // (should raise a deprecation warning)</programlisting>
			</note>

			<example>
				<title>shorthand giving access to a single definition with renaming
				</title>
				<programlisting language="kermeta">using kermeta::standard::Integer => MyInteger   // renaming
using kermeta::exceptions::NotImplementedException => NIException   // renaming
...
// allows to write :
var s : MyInteger
var e : NIException init NIException.new</programlisting>
			</example>
			<example>
				<title>shorthand giving access to a single definition with direct
					renaming
				</title>
				<programlisting language="kermeta">using kermeta::standard::{Integer}
			// same as using kermeta::standard::Integer => Integer
using kermeta::exceptions::{NotImplementedException}
			// same as kermeta::exceptions::NotImplementedException => NotImplementedException
...
// allows to write :
var s : Integer
var e : NotImplementedException init NotImplementedException.new</programlisting>
			</example>

			<example>
				<title>Other examples of renaming and shortcuts</title>
				<programlisting language="kermeta">using kermeta::standard::Integer => standard::Integer     // with renaming for direct access
using kermeta::{standard::Integer}              // shortcut : same as above
using kermeta::standard::Integer => ks::Integer // another renaming

using kermeta::exceptions::* => ke::*             // global renaming of a package
...
// allows to write :
var i1 : standard::Integer
var i2 : ks::Integer		
// note that i1 and i2 are actually of the same type kermeta::standard::Integer

var e : ke::NotImplementedException init ke::NotImplementedException.new</programlisting>
			</example>

			<note>
				<para>
					The
					<literal>using</literal>
					statement is just a syntactic sugar used by the type resolver when
					building the Kermeta model of
					the program.
					This is different from
					the definition of a local datatype with an
					<literal>alias</literal>
					. (See
					<xref endterm="section_alias.title.link" linkend="section_alias.link" />
					subsection )
				</para>
			</note>
			<para>
				Be careful when declaring your
				<literal>using</literal>
				statements if there is a risk of conflicting names. In such
				situation,
				the type resolver will
				first look into the current
				package, then try
				each
				<literal>using</literal>
				in the order they are defined
				and choose the first type definition
				that exists.
			</para>
		</section>
		<section id="section_collections.link">
			<title id="section_collections.title.link">
				Collections
				<phrase id="section_collections"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>
				Collections are widely used in Kermeta not only because of their
				usual usage for collecting data
				in variables but also because they
				are
				used to represent
				<link linkend="section_properties.link">class
					property
				</link>
				when the multiplicity is greater than 1.
			</para>

			<para>Collections is one of the concept where the genericity is the
				most
				visible since it greatly
				helps to write more robust code.
			</para>

			<section>
				<title>Definition and initialization</title>

				<para>
					Kermeta defines some collection data types handling sets of
					values.
					The different available
					collection types are the result of a
					combination of the constraints
					<emphasis role="strong">unique</emphasis>
					and
					<emphasis role="strong">ordered</emphasis>
					.
				</para>

				<itemizedlist>
					<listitem>
						<para>Unique specifies a collection type that cannot contain
							doublet
						</para>
					</listitem>

					<listitem>
						<para>Ordered specifies a collection type where the position of an
							object inside the collection
							can be modified.
						</para>
					</listitem>
				</itemizedlist>

				<informaltable>
					<tgroup cols="4">
						<colspec colname="c1" colwidth="1*" />

						<colspec colname="c2" colwidth="4*" />

						<colspec colname="c3" colwidth="1*" />

						<colspec colname="c4" colwidth="1*" />

						<thead>
							<row>
								<entry morerows="1" valign="middle">
									<para>Name</para>
								</entry>

								<entry morerows="1" valign="middle">
									<para>Description</para>
								</entry>

								<entry nameend="c4" namest="c3">
									<para>Constraints</para>
								</entry>
							</row>

							<row>
								<entry>
									<para>Unique</para>
								</entry>

								<entry>
									<para>Ordered</para>
								</entry>
							</row>
						</thead>

						<tbody>
							<row>
								<entry valign="middle">
									<para>set</para>
								</entry>

								<entry valign="middle">
									<para>Represents an unordered
										collection of objects with no
										doublet (Set)
									</para>
								</entry>

								<entry align="center" valign="middle">
									<para>True</para>
								</entry>

								<entry align="center" valign="middle">
									<para>False</para>
								</entry>
							</row>

							<row>
								<entry valign="middle">
									<para>oset</para>
								</entry>

								<entry valign="middle">
									<para>Represents an ordered collection
										of objects with no
										doublet (OrderedSet)
									</para>
								</entry>

								<entry align="center" valign="middle">
									<para>True</para>
								</entry>

								<entry align="center" valign="middle">
									<para>True</para>
								</entry>
							</row>

							<row>
								<entry valign="middle">
									<para>seq</para>
								</entry>

								<entry valign="middle">
									<para>Represents an ordered collection
										of objects (Sequence)
									</para>
								</entry>

								<entry align="center" valign="middle">
									<para>False</para>
								</entry>

								<entry align="center" valign="middle">
									<para>True</para>
								</entry>
							</row>

							<row>
								<entry valign="middle">
									<para>bag</para>
								</entry>

								<entry valign="middle">
									<para>Represents a basic collection of
										objects (Bag)
									</para>
								</entry>

								<entry align="center" valign="middle">
									<para>False</para>
								</entry>

								<entry align="center" valign="middle">
									<para>False</para>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>

				<figure id="refIllustration4">
					<title>: The Kermeta collections</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/collections.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para></para>

				<para>Another way to define set of objects would have been to use
					arrays. In fact, Kermeta does
					not define explicitly the concept of
					array, but it provides a multiplicity concept which can be
					used
					instead. Multiplicities are a way to define a lower and upper bound
					on
					a collection.
					Syntactically, lower and upper bounds are defined
					between brackets and are separated by two
					dots. Bounds can be an
					integer literal value or a star to specify there's no upper
					bound.
				</para>

				<para>
					<emphasis role="strong">Example 1</emphasis>
					: how to declare
					collections
				</para>

				<programlisting language="kermeta">
using kermeta::standard		// don't need to specify it all the time
	// This is the simpliest and recommanded way of declaring a collection variable
	var myColA : Set&lt;Integer&gt; // this is equivalent to saying set Integer[0..*]
	var myColB : OrderedSet&lt;Integer&gt; // this is equivalent to saying oset Integer[0..*]
		</programlisting>

				<programlisting language="kermeta">
	// Collection with multiplicities
    var myCol1 : set Integer[4..6] // At least 4 elements and never more than 6
	var myCol3 : seq String[2..*] // At least two strings in the sequence
	var myCol4 : set String[1..*] // An non empty set
	var myCol5 : String[1..*] // If you don't specify any keyword, it is an ordered set
        </programlisting>

				<para>
					There is currently no way to define a collection by extension
					like
					you can do in C or Java. You
					must initialize your collection
					either
					by calling
					<literal>new</literal>
					<emphasis role="strong">
					</emphasis>
					(Kermeta constructor operation) on your collection type, or
					initialize by copy.
				</para>

				<para>
					<emphasis role="strong">Example 2</emphasis>
					: initialize
					collections
				</para>

				<programlisting language="kermeta">// Example of declaration of variables as Collections. All those syntaxes are valid
<phrase id="DDE_LINK1"></phrase>var myCol1 : set Integer[0..*]    init kermeta::standard::Set&lt;Integer&gt;.new
// Fill in myCol1
myCol1.add(10)
myCol1.add(50)

var myCol2 : oset String[0..*]    init kermeta::standard::OrderedSet&lt;String&gt;.new
var myCol3 : bag Boolean[0..*]    init kermeta::standard::Bag&lt;Boolean&gt;.new
var myCol4 : seq Integer[0..*]    init kermeta::standard::Sequence&lt;Integer&gt;.new
// if no keyword specified, and multiplicity is set, it is an OrderedSet</programlisting>

				<programlisting language="kermeta">var myCol4 : String[0..*] init kermeta::standard::OrderedSet&lt;String&gt;.new
</programlisting>

				<programlisting language="kermeta">var myCol1a : seq Integer[0..*]    init myCol1
var myCol2a : oset String[0..*]    init myCol2
var myCol3a : kermeta::standard::Bag&lt;Boolean&gt; init myCol3
var myCol3a : kermeta::standard::Sequence&lt;Integer&gt; init myCol4</programlisting>

				<note>
					<para>
						Conclusion : in most cases, you don't need to use this
						special syntax, you
						can simply use
						the generic collection names
						(Set&lt;Something&gt;,
						OrderedSet&lt;Something&gt;, etc.) available
						in Kermeta framework.
						Moreover, lower and upper bounds aren’t
						checked yet by Kermeta
						type checker
						and interpreter.
					</para>
				</note>
			</section>

			<section>
				<title>Some existing useful functions</title>

				<para>
					The collections in Kermeta implement several functions based on
					lambda expressions (see
					<xref linkend="section_lambda_expression.link" />
					). These ones are very
					useful for model navigation.
				</para>

				<section>
					<title>
						Function
						<emphasis>each</emphasis>
					</title>
					<para>TODO</para>
					<programlisting language="kermeta">aCollection.each { e | 
	    /* do something with each element e of this collection */
}</programlisting>
				</section>

				<section>
					<title>
						Function
						<emphasis>forAll</emphasis>
					</title>
					<para>TODO</para>
					<programlisting language="kermeta">aBoolean := aCollection.forAll { e | /* put here a condition */
	} // return true if the condition is true for all elements in the collection.</programlisting>
				</section>

				<section>
					<title>
						Function
						<emphasis>select</emphasis>
					</title>
					<para>TODO</para>
					<programlisting language="kermeta">aCollection2 := aCollection.<emphasis role="strong">select</emphasis> { e | 
	     /* put here a condition that returns true for elements that must be included in the resulting Collection */
	}</programlisting>
				</section>

				<section>
					<title>
						Function
						<emphasis>reject</emphasis>
					</title>
					<para>TODO</para>
					<programlisting language="kermeta">aCollection2 := aCollection.<emphasis role="strong">reject</emphasis> { e | 
	     /* put here a condition that returns true for elements that must be exclude in the resulting Collection */
	}</programlisting>
				</section>

				<section>
					<title>
						Function
						<emphasis>collect</emphasis>
					</title>
					<para>TODO</para>
					<programlisting language="kermeta"> // return a new collection which size is the same as in the original 
			 // collection, and which element type is the type of the result of the expression.
			aCollection2 := aCollection.<emphasis role="strong">collect</emphasis> { e | 
			     /* put here an expression, for example e.name */
			}</programlisting>
				</section>

				<section>
					<title>
						Function
						<emphasis>detect</emphasis>
					</title>
					<para>TODO</para>
					<programlisting language="kermeta">anObject := aCollection.<emphasis role="strong">detect</emphasis> { e | /* a condition */} // returns an element (usually the first) that fulfills the condition.</programlisting>
				</section>

				<section>
					<title>
						Function
						<emphasis>exists</emphasis>
					</title>
					<para>
						Function
						<emphasis>exists</emphasis>
						returns
						<emphasis>true</emphasis>
						if at least one element fulfills the last boolean
						expression
						defined into the block. For
						instance:
					</para>
					<programlisting language="kermeta">aBoolean := aCollection.<emphasis role="strong">exists</emphasis> { e | /* a condition */} // returns true if at least one element fulfills the condition.</programlisting>
					<para>
						If several boolean condition are defined into the block of
						function
						<emphasis>exists</emphasis>
						, the last condition is used for the test.
						For instance, the
						following function exists returns
						true at the first
						iteration:
					</para>
					<programlisting language="kermeta">aBoolean := aCollection.<emphasis role="strong">exists</emphasis> { e | false true }</programlisting>
					<para>
						Instructions can be defined into the block of function
						<emphasis>exists</emphasis>
						. For instance, the following code displays the current object at
						each iteration:
					</para>
					<programlisting language="kermeta">aBoolean := aCollection.<emphasis role="strong">exists</emphasis> { e |
				stdio.writeln(e.toString)
				/* a condition */
			}
			</programlisting>
					<para>
						If no boolean expression is defined, value
						<emphasis>Void</emphasis>
						is returned, as illstrated in the following example. Such a use of
						function
						<emphasis>exists</emphasis>
						is not adviced
						since it corresponds to the use of function
						<emphasis>each</emphasis>
						.
					</para>
					<programlisting language="kermeta">aBoolean := aCollection.<emphasis role="strong">exists</emphasis> { e | stdio.writeln(e.toString) }/* The value of aBoolean is Void */</programlisting>
				</section>
			</section>
		</section>

		<section id="section_properties.link">
			<title id="section_properties.title.link">
				Class properties
				<phrase id="section_properties"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>
				A property of a (meta)class can be expressed in three ways : as a
				reference, an attribute, or a
				derived property. In Kermeta, each
				kind of
				these properties has a specific behavior and a
				dedicated
				syntax, which
				is
				<emphasis role="strong">attribute </emphasis>
				(for attribute),
				<emphasis role="strong">reference</emphasis>
				(for reference),
				<emphasis role="strong">property</emphasis>
				(for derived property)
			</para>

			<para role="lineBreak">
				References and attributes can have
				<emphasis role="strong">opposite</emphasis>
				properties. This last concept is
				explained in the following
				subsection.
			</para>

			<para>Unlike UML, there is no concept of visibility in Kermeta, so
				every
				property is visible
			</para>

			<section id="section_properties-opposite.link">
				<title id="section_properties-opposite.title.link">
					Attributes
					<emphasis>(attribute)</emphasis>
					, references
					<emphasis>(reference)</emphasis>
				</title>

				<para>We introduce here the 2 first cases, which are relationships
					between two concrete entities.
				</para>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis>attribute</emphasis>
							: an attribute defines a
							<emphasis>composition </emphasis>
							(e.g the black diamond) between
							two entities. The diamond-ed
							association end is navigable by
							definition
						</para>
					</listitem>
				</itemizedlist>

				<programlisting><emphasis role="strong">class</emphasis> A { <emphasis role="strong">attribute</emphasis> x : <emphasis
					role="strong">set</emphasis> X[0..*] } 
<emphasis role="strong">class</emphasis> X {}</programlisting>

				<note>
					<para>
						Composition notion also relates to containment notion. So,
						there are some
						restriction about
						valid model. For example, in an
						association,
						only one end can be an attribute, otherwise this
						means
						that we
						have an association with a diamond on both end and we
						cannot say
						who is the
						container of the other.
					</para>
				</note>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis>reference</emphasis>
							: a reference defines an
							association between two entities.
						</para>
					</listitem>
				</itemizedlist>

				<programlisting><emphasis role="strong">class</emphasis> A { <emphasis role="strong">reference</emphasis> x : set X[0..*] } 
<emphasis role="strong">class</emphasis> X {}</programlisting>
			</section>

			<section>
				<title>properties modifiers</title>

				<para>
					Attributes, references and properties underlying collections may
					eventually be specialized. By
					default, they are represented by an
					OrderedSet. If you wish to be more precise and for exemple
					allow to
					have several items with the same value in your collection, you can
					use
					the collection
					modifiers as defined in
					<xref linkend="section_collections.link" />
				</para>

				<para>For example :</para>

				<programlisting language="kermeta">
class A {
	attribute x1 : seq String[0..*]  // allows duplicates, ordered
	attribute x2 : set String[0..*]  // doesn't allow duplicates, not ordered        
	attribute x3 : bag String[0..*]  // allows duplicates, not ordered               
	attribute x4 : oset String[0..*] // (default if no modifier) doesn't allow duplicates, ordered        
}        </programlisting>
			</section>

			<section>
				<title>Association using opposite properties</title>

				<para>
					The opposite [property] of a property defines an association
					(bidirectional link) between two
					entities. An opposite is expressed
					by
					a sharp #. In the following example,
					<literal>a</literal>
					is the
					opposite property of the entity of type B, and
					<literal>b</literal>
					is
					mutually the opposite property of the entity of type A.
				</para>

				<caution>
					<para>
						A property whose type is a DataType (i.e String, Boolean,
						Integer)
						cannot have an opposite!
					</para>
				</caution>

				<para>
					<emphasis role="strong">Example 1</emphasis>
					: definition of an
					attribute, a reference, and an opposite property
				</para>

				<para>This means that a can be accessed from b. Subsequently, if you
					modify the property b of an
					instance of A, it will mutually update
					its
					opposite property, i.e the property a of the instance
					of B
					contained
					in property b. You can make a test with the following
					example of
					code.
				</para>

				<para>
					<emphasis role="strong">Example 2</emphasis>
					: navigability of
					opposite properties
				</para>

				<programlisting><emphasis role="strong">var</emphasis> a1 : A <emphasis role="strong">init</emphasis> A.new
a1.name := "a1"
<emphasis role="strong">var</emphasis> b1 : B <emphasis role="strong">init</emphasis> C.new
a1.b := b1
stdio.writeln("b1 opposite : " + b1.a.name) <emphasis>// This prints "a1"!</emphasis></programlisting>

				<para>The following paragraph shows a set of examples of attributes
					and references.
				</para>

				<figure id="refIllustration5">
					<title>Attributes and references</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/properties.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					<emphasis role="strong">Example 3</emphasis>
					: a set of
					attributes and references, with multiplicities and
					opposites.
				</para>

				<para>TODO : add an example of code using those classes !! See
					https://gforge.inria.fr/plugins/scmcvs/cvsweb.php/integration_projects/other/org.openembedd.formations/Kermeta/Basics/docs/FR_formation_Kermeta_1er_niveau.odp?cvsroot=openembedd
					for such examples (p. 21).
				</para>

				<programlisting><emphasis role="strong">package</emphasis> root;</programlisting>

				<programlisting>
<emphasis role="strong">class</emphasis> A1 {
    <emphasis role="strong">attribute</emphasis> b : B1[0..*] 
}
<emphasis role="strong">class</emphasis> B1 {}
			</programlisting>

				<programlisting>
<emphasis role="strong">class</emphasis> A2 {}
<emphasis role="strong">class</emphasis> B2 {
    <emphasis role="strong">reference</emphasis> a : A2 
}
			</programlisting>

				<programlisting>
<emphasis role="strong">class</emphasis> A3 {
    <emphasis role="strong">reference</emphasis> b : B3#a
}
<emphasis role="strong">class</emphasis> B3 {
    <emphasis role="strong">reference</emphasis> a : A3#b
}
			</programlisting>

				<programlisting>
<emphasis role="strong">class</emphasis> A4 {
    <emphasis role="strong">reference</emphasis> a : A4[0..*]
}</programlisting>

				<programlisting>
<emphasis role="strong">class</emphasis> A5 {
    <emphasis role="strong">attribute</emphasis> ab : A5[0..*]#aa
    <emphasis role="strong">reference</emphasis> aa : A5#ab
}</programlisting>

				<programlisting>
<emphasis role="strong">class</emphasis> A6 {
    <emphasis role="strong">attribute</emphasis> b : B6#a
}
<emphasis role="strong">class</emphasis> B6 {
    <emphasis role="strong">reference</emphasis> a : A6[1..1]#b
}</programlisting>

				<programlisting><emphasis role="strong">class</emphasis> A7 {
    <emphasis role="strong">attribute</emphasis> b : B7[0..*]#a
}
<emphasis role="strong">class</emphasis> B7 {
    <emphasis role="strong">reference</emphasis> a : A7#b 
}</programlisting>

				<programlisting><emphasis role="strong">class</emphasis> A8 {
    <emphasis role="strong">attribute</emphasis> b : B8[1..1]#a
}
<emphasis role="strong">class</emphasis> B8 {
    <emphasis role="strong">reference</emphasis> a : A8#b
}</programlisting>

				<programlisting><emphasis role="strong">class</emphasis> A9 {}
<emphasis role="strong">class</emphasis> B9 {
    <emphasis role="strong">reference</emphasis> a : A9[1..1]
}</programlisting>

				<note>
					<para>
						For every case where the upper bound of a property is upper to 1,
						the type of the property is

						<literal>OrderedSet</literal>

						. The reader will refer to

						<xref linkend="section_collections.link" />

						(except the bag type) to have the available types for a
						[m..n](n&gt;1) multiplicity property.
					</para>
				</note>
			</section>

			<section id="section_derived_properties.link">
				<title id="section_derived_properties.title.link">
					Derived properties
					<emphasis>(property)</emphasis>
				</title>

				<para>In a class definition, a derived property is a property that
					is
					derived or calculated, i.e
					it contains a body, like operations.
					Usually, such properties are calculated from other
					properties
					available from its owning class definition. In practice, you can
					define the code that
					you want inside a derived property.
				</para>

				<para>In other words it does not reference to a concrete entity: it
					is
					calculated, through the
					accessor operations getter and setter.
				</para>

				<para>
					The special parameter
					<literal>value</literal>
					is used in the setter
					to get the value passed when calling the
					setter.
				</para>
				<para>Let's take the following class definitions :</para>

				<programlisting><emphasis>// readonly property : it has no setter</emphasis>
<emphasis role="strong">class</emphasis> A 
{
    <emphasis role="strong">attribute</emphasis> period : Real
    <emphasis role="strong">property</emphasis> <emphasis role="strong">readonly</emphasis> frequency : Real <emphasis>// property : keyword for derived property</emphasis>
        <emphasis role="strong">getter</emphasis> <emphasis role="strong">is</emphasis> do
            <emphasis role="strong">result</emphasis> := 1/period
        <emphasis role="strong">end</emphasis>
}
<emphasis>// modifiable property :</emphasis>
<emphasis role="strong">class</emphasis> B 
{
    <emphasis role="strong">attribute</emphasis> period : Real
    <emphasis role="strong">property</emphasis> frequency : Real
        <emphasis role="strong">getter</emphasis> <emphasis role="strong">is</emphasis> <emphasis
					role="strong">do</emphasis>
            <emphasis role="strong">result</emphasis> result := 1/period
        <emphasis role="strong">end</emphasis>
        <emphasis role="strong">setter</emphasis> <emphasis role="strong">is</emphasis> <emphasis
					role="strong">do</emphasis>
            period := 1/<emphasis role="strong">value</emphasis>
        <emphasis role="strong">end</emphasis>
}

// a typical use would be (with aB an instance of class B) 
<emphasis role="strong">var</emphasis> freq : Real
fred := aB.frequency // to use the getter
aB.frequency := freq + 1 // to use the setter, the period is also updated in the process 
</programlisting>

				<note>
					<para>
						To understand to role of the
						<literal>value</literal>
						keyword, you can imagine
						that in this sample the setter syntax is a
						shortcut syntax of :

						<literal>
							setter( value : Real) is do ...
						</literal>
						(even if actually this syntax isn't supported).
					</para>
				</note>
				<warning>
					<para>
						Since derived properties aims to behave like attributes or
						references,
						if the multiplicity
						is greater than 1,
						it doesn't make
						sense to define a setter. This is because it means
						reassigning the
						internal collection which is in fact calculated.
					</para>
				</warning>
				<para>Properties are accessed or modified as classical properties.
					See
					next subsection for
					examples.
				</para>
			</section>

			<section>
				<title>How to access and control the properties in Kermeta</title>

				<para>
					<emphasis role="strong">Example 1</emphasis>
					: let's take the
					example with A6 and B6 :
				</para>

				<programlisting><emphasis role="strong">class</emphasis> A6 {
     <emphasis role="strong">attribute</emphasis> b : B6[0..*]#a
}

<emphasis role="strong">class</emphasis> B6 {
    <emphasis role="strong">reference</emphasis> a : A6#b 
}</programlisting>

				<informaltable>
					<tgroup cols="2">
						<colspec colname="c1" colwidth="1*" />

						<colspec colname="c2" colwidth="4*" />

						<thead>
							<row>
								<entry>
									<para>Access</para>
								</entry>

								<entry>
									<para>Kermeta expression</para>
								</entry>
							</row>
						</thead>

						<tbody>
							<row>
								<entry>
									<para>Get the attribute of an instance</para>
								</entry>

								<entry>
									<programlisting><emphasis role="strong">var</emphasis> a6 : A6 <emphasis role="strong">init</emphasis> A6.new
<emphasis role="strong">var</emphasis> b6 : OrderedSet&lt;B6&gt;
<emphasis>// get the b attribute</emphasis>
<emphasis>// Note that as the attribute as a multiplicity &gt;1 it is an OrderedSet </emphasis>
b6 := a6.b</programlisting>
								</entry>
							</row>

							<row>
								<entry>
									<para>Add an element to a property with multiplicity
										[m..n],
										n&gt;1</para>
								</entry>

								<entry>
									<programlisting><emphasis role="strong">var</emphasis> a6 : A6 init A6.new
<emphasis role="strong">var</emphasis> b6 : B6 init B6.new
<emphasis>// add b6 to the attribute b of A.</emphasis> 
<emphasis>// </emphasis><emphasis>Note : you don’t have to initialize b! done through A6.new</emphasis>
a6.b.add(b6)</programlisting>
								</entry>
							</row>

							<row>
								<entry>
									<para>Remove an element from a property</para>
								</entry>

								<entry>
									<programlisting><emphasis>// OrderedSet owns a method that removes an element given its
     // index in the set. For unordered sets, use "remove" method</emphasis>
a6.b.removeAt(0)
<emphasis>// Also valid : a6.b.remove(b6)</emphasis></programlisting>
								</entry>
							</row>

							<row>
								<entry>
									<para>Get the opposite of a property</para>
								</entry>

								<entry>
									<programlisting><emphasis role="strong">var</emphasis> a6 : A6 init A6.new
<emphasis role="strong">var</emphasis> b6 : B6 init B6.new
a6.b.add(b6)
<emphasis>// this assertion is true. Moreover, any instance in a6.b will
// have a6 as their opposite since b is a collection</emphasis>
assert(b6.a == a6)</programlisting>
								</entry>
							</row>

							<row>
								<entry>
									<para>Get the container of a property</para>
								</entry>

								<entry>
									<programlisting><emphasis role="strong">var</emphasis> a6 : A6 <emphasis role="strong">init</emphasis> A6.new
<emphasis role="strong">var</emphasis> b6 : B6 <emphasis role="strong">init</emphasis> B6.new
<emphasis>// add ab6 to the attribute "b"</emphasis>
a6.b.add(b6)</programlisting>
									<programlisting><emphasis role="strong">var</emphasis> a6c : A6 <emphasis role="strong">init</emphasis> b6.container()
<emphasis>// this assertion is true</emphasis>
assert(a6c.equals(a6))</programlisting>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>

				<para>It is not different with references that have a [m..1] (m=0 or
					m=1) multiplicity:
				</para>

				<para>
					<emphasis role="strong">Example 2</emphasis>
					: the A5 B5
					case
				</para>

				<programlisting><emphasis role="strong">class</emphasis> A5 {
    <emphasis role="strong">attribute</emphasis> b : B5#a <emphasis>// no multiplicity means [0..1]</emphasis>
}
<emphasis role="strong">class</emphasis> B5 {
    <emphasis role="strong">reference</emphasis> a : A5[1..1]#b
}</programlisting>

				<informaltable>
					<tgroup cols="2">
						<colspec colname="c1" colwidth="1*" />

						<colspec colname="c2" colwidth="4*" />

						<thead>
							<row>
								<entry><?border-top 0.0007inch solid #000000?>
									<para>Access</para>
								</entry>

								<entry><?border 0.0007inch solid #000000?>
									<para>Kermeta
										expression
									</para>
								</entry>
							</row>
						</thead>

						<tbody>
							<row>
								<entry>
									<para>Get the attribute of an instance</para>
								</entry>

								<entry>
									<programlisting><emphasis role="strong">var</emphasis> a5 : A5 <emphasis role="strong">init</emphasis> A5.new
<emphasis role="strong">var</emphasis> b5 : B5
<emphasis>// get the b attribute</emphasis>
b5 := a5.b</programlisting>
								</entry>
							</row>

							<row>
								<entry>
									<para>Set a property (with multiplicity [m..1],
										m≤1)
									</para>
								</entry>

								<entry>
									<programlisting><emphasis role="strong">var</emphasis> a5 : A5 init A5.new
<emphasis role="strong">var</emphasis> b5 : B5 init B5.new
<emphasis>// set b5 to the attribute b of A.</emphasis>
a5.b := b5</programlisting>
								</entry>
							</row>

							<row>
								<entry>
									<para>Unset a property</para>
								</entry>

								<entry>
									<programlisting language="kermeta">a5.b := void</programlisting>
								</entry>
							</row>

							<row>
								<entry>
									<para>Get the opposite of a property</para>
								</entry>

								<entry>
									<programlisting><emphasis role="strong">var</emphasis> a5 : A5 init A5.new
<emphasis role="strong">var</emphasis> b5 : B5 init B5.new
a5.b := b5
<emphasis>// this assertion is true.</emphasis>
assert(b5.a == a5)</programlisting>
								</entry>
							</row>

							<row>
								<entry>
									<para>Get the container of a property</para>
								</entry>

								<entry>
									<programlisting><emphasis role="strong">var</emphasis> a5 : A5 <emphasis role="strong">init</emphasis> A5.new
<emphasis role="strong">var</emphasis> b5 : B5 <emphasis role="strong">init</emphasis> B5.new
<emphasis>// add b5 to the attribute "b"</emphasis>
a5.b := b5</programlisting>
									<programlisting><emphasis role="strong">var</emphasis> a5c : A5 <emphasis role="strong">init</emphasis> b5.container()
<emphasis>// this assertion is true</emphasis>
assert(a5c.equals(a5))</programlisting>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>

				<note>
					<para>
						Be careful with attributes or references ref with multiplicity
						greater than 1, they are
						automatically initialized with a
						reflective collection (ie. a collection that is aware of an
						eventual opposite). So, you cannot assign them using := If you
						wish to change completely its
						content with the one of another
						collection, you must use the

						<literal>clear</literal>

						and

						<literal>addAll</literal>

						operations.
					</para>
				</note>
				<note>
					<para>
						For the same reason,
						<literal>reference refA : OrderedSet&lt;String&gt;</literal>
						is different from
						<literal>reference refB : String[0..*]</literal>
						.
						If both can be navigated the same way (using add, each or any
						operation available on
						Collection),
						<literal>refA</literal>
						needs to be created before use with
						<literal>refA := OrderedSet&lt;String&gt;.new</literal>
						.
						<literal>refA</literal>
						is a reference to a colection whereas
						<literal>refB</literal>
						is a reference to
						String with a multiplicity greater than 1 (which
						is internally
						represented as a
						ReflectiveCollection&lt;String&gt;)
					</para>
				</note>
			</section>

			<section id="section_assignment_behavior_4_attribute.link">
				<title>Assignment behavior for attribute (and reference)</title>

				<para>Attribute and reference have one main behavior
					difference.
				</para>

				<para>Attribute has a notion of containment that reference
					hasn't.
				</para>

				<para>This has some implication on the behavior of the assignment
					because an attribute cannot be
					owned by more than one object at a
					time.
				</para>

				<para>
					There is an exception for attributes which type is a primitive
					type
					(String, Integer, Boolean,
					Real, Char) : since those types inherit
					from
					<literal>ValueType</literal>
					,
					they are not concerned by the composition, opposite concepts.
					In
					this case, the assignment
					doesn't impact any value but the
					assigned
					one.
				</para>

				<para>
					<emphasis role="strong">Example 1</emphasis>
					: Assignment
					behavior for attribute
				</para>

				<programlisting><emphasis role="strong">class</emphasis> A { <emphasis role="strong">attribute</emphasis> c1 : C }
<emphasis role="strong">class</emphasis> B { <emphasis role="strong">attribute</emphasis> c2 : C }
<emphasis role="strong">class</emphasis> C { }
aA.c1 := C.new
aB.c2 := aA.c1     <emphasis>// now aA.c1 == void !!!</emphasis></programlisting>

				<para>
					<emphasis role="strong">Example 2</emphasis>
					: Assignment
					behavior for reference
				</para>

				<programlisting><emphasis role="strong">class</emphasis> A { <emphasis role="strong">reference</emphasis> c1 : C }
<emphasis role="strong">class</emphasis> B {<emphasis role="strong"> reference</emphasis> c2 : C }
<emphasis role="strong">class</emphasis> C { }

aA.c1 := C.new
aB.c2 := aA.c1     <emphasis>// aB.c2 == aA.c1 and aA.c1 keeps its value !!!</emphasis></programlisting>

				<para>
					<emphasis role="strong">Example 3</emphasis>
					: Assignment
					behavior for attribute which type is String
				</para>

				<programlisting><emphasis role="strong">class</emphasis> A { <emphasis role="strong">reference</emphasis> c1 : String }<emphasis
					role="strong">class</emphasis> B {<emphasis role="strong"> reference</emphasis> c2 : String }aA.c1 := "Robert"aB.c2 := aA.c1 // aB.c2 == aA.c1 == "Robert"</programlisting>

				<note>
					<para>
						The assignment into a

						<literal>variable</literal>

						or a

						<literal>reference</literal>

						is not a problem because it doesn't change the owner of the
						assigned object.
					</para>
				</note>
			</section>
		</section>
		<section id="section_singleton_class.link">
			<title id="section_singleton_class.title.link">
				Singleton class
				<phrase id="section_singleton_class"></phrase>
			</title>
			<note>
				<title>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="gfx/fire.png" contentdepth="2em" />
						</imageobject>
					</inlinemediaobject>
					New in Kermeta 2
				</title>
				<para></para>
			</note>
			<para>
				It is possible to declare a class as a singleton. The singleton
				works like
				<literal>companion object</literal>
				in scala or is similar to a static class in java.
				Which means that
				only a single instance of the
				class exists in memory.
			</para>
			<para>Access to this instance is done directly via the class name.
			</para>
			<para>As any class, the singleton supports operations, attributes,
				references...
			</para>
			<example>
				<title>StdIO singleton</title>
				<para>For example, StdIO is now defined as a singleton like this :
				</para>
				<programlisting language="kermeta">singleton StdIO
{
	/**
	 * Writeln the object to standard output
	 */ 
	operation writeln(object : String) : Void is do
		// code for printing on console
	end
	// other operations in StdIO
}</programlisting>
				<para>It can be directly used like this :</para>
				<programlisting language="kermeta">kermeta::io::StdIO.writeln("my message")</programlisting>
			</example>
			<caution>
				<para>Be careful when deploying a code that use singleton in
					environment that uses multiple
					classpath.
					For example in OSGI and
					eclipse, you can (on purpose or not) create
					several classpathes
					that
					aren't shared and create several
					instances of the same singleton.
				</para>
			</caution>
		</section>
		<section id="section_object_comparison.link">
			<title id="section_object_comparison.title.link">
				Objects
				comparison
				<phrase id="section_objects_comparison"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>
				Kermeta users could be confused about
				<literal>==</literal>
				operator and
				<literal>equals</literal>
				method. Unlike, Java they do the
				same and redefining the equals to
				compare the content also
				affects the
				<literal>==</literal>
				.
			</para>

			<para>To compare the identity of two objects you must compare the
				identifier of each object :
				using their oid
			</para>

			<section>
				<title>equals method</title>

				<para>
					The
					<emphasis>equals</emphasis>
					method behaves the same way as
					in java. This means that you can
					overwrite it, if you want to
					compare
					the contents of two objects of
					the same class.
				</para>

				<programlisting language="kermeta">@mainClass "root::Main"
@mainOperation "main"

package root;

require kermeta
using kermeta::standard
using kermeta::kunit
class A {

  reference x : Integer

  method equals(compared : Object) : Boolean is do
    var castedCompared : A
    castedCompared ?= compared
    result := x.equals (castedCompared.x)
  end

}


class Main inherits kermeta::kunit::TestCase{

  operation main() : Void is do

    var a1 : A init A.new
    var a2 : A init A.new
 
    a1.x := 10
    a2.x := 20

    assert( not a1.equals(a2) )	// objects are different with all methods
    assert( not a1 == a2 )
    assert ( a1.oid == a2.oid ) 

    a2.x := 10
 
    assert ( a1.equals(a2) ) 	// objects becomes equals
    assert ( a1 == a2  )		// also with ==
    assert ( a1.oid == a2.oid ) // but they physically are still different

  end

}</programlisting>
			</section>

			<section>
				<title>Comparison for Primitive Types</title>

				<para>In Kermeta language, there is a notion of primitive type. Here
					is the list of primitive
					types :
				</para>

				<itemizedlist>
					<listitem>
						<para>Boolean</para>
					</listitem>

					<listitem>
						<para>Integer</para>
					</listitem>

					<listitem>
						<para>String</para>
					</listitem>

					<listitem>
						<para>Character</para>
					</listitem>
					<listitem>
						<para>Real</para>
					</listitem>
				</itemizedlist>

				<para>
					We do not want two Integer objects with the same value to be
					different. What we want is to use
					<emphasis>==</emphasis>
					operator to
					compare values of primitive types. These classes simply
					redefine the
					equals. Then we
					can write this code :
				</para>

				<programlisting language="kermeta">var i1 : Integer init 10
var i2 : Integer init 10
assert (i1.equals(i2))

var i3 : Integer init 10
var i4 : Integer init 10
assert (i3 == i4)
</programlisting>
			</section>

			<section>
				<title>Collection comparison</title>

				<para>
					The method
					<literal>equals</literal>
					exists for the collections. The generic behavior
					is the following :
					for two collections a and b,
					if all elements of a
					are contained in b
					and vice-versa, then it returns true, false
					otherwise.
					This behavior
					is little bit different for ordered
					collection which takes into
					account the order of
					elements. Have a
					look
					to the following pieces of
					code :
				</para>

				<programlisting language="kermeta">operation test_try1() : Void is do
   var os : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os.add(1) os.add(2) os.add(3) os.add(4) os.add(5) os.add(6)

   var os2 : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os2.add(1) os2.add(2) os2.add(3) os2.add(4) os2.add(5) os2.add(6)

   assert (os.equals(os2) )
end

operation test_try2() : Void is do
   var os : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os.add(1) os.add(2) os.add(3) os.add(4) os.add(5) os.add(6)

   var os2 : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os2.add(1) os2.add(2) os2.add(3) os2.add(4) os2.add(5)

   assert ( not os.equals(os2) )
end

/**
 * An ordered set takes care about the order.
 */
operation test_try3() : Void is do
   var os : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os.add(1) os.add(2) os.add(3) os.add(4) os.add(5) os.add(6)

   var os2 : OrderedSet&lt;Integer&gt; init OrderedSet&lt;Integer&gt;.new
   os2.add(4) os2.add(6) os2.add(3) os2.add(1) os2.add(5) os2.add(2)

   assert ( not os.equals(os2) )
end

/**
 * A set does not care about the order.
 */
operation test_try4() : Void is do
   var os : Set&lt;Integer&gt; init Set&lt;Integer&gt;.new
   os.add(1) os.add(2) os.add(3) os.add(4) os.add(5) os.add(6)

   var os2 : Set&lt;Integer&gt; init Set&lt;Integer&gt;.new
   os2.add(4) os2.add(6) os2.add(3) os2.add(1) os2.add(5) os2.add(2)

   assert ( os.equals(os2) )
end
</programlisting>
			</section>
		</section>

		<section id="section_lambda_expression.link">
			<title id="section_lambda_expression.title.link">
				Lambda Expressions and functions
				<phrase id="section_lambda_expressions"></phrase>
			</title>
			<para>
				<phrase id="section_lambda_expression"></phrase>
				Kermeta proposes an
				implementation of lambda expressions, that is
				useful for example when
				implementing OCL-like functions.
			</para>

			<section id="section_function-syntax.link">
				<title id="section_function-syntax.title.link">
					Syntax
					<phrase id="sec:function-syntax"></phrase>
				</title>

				<itemizedlist>
					<listitem>
						<para>Definition of the type of the function:</para>
						<para>Kermeta has a special type called "function type" that can
							be used in several places.
						</para>
						<para>This type can be used in all the location a type is
							expected, in operation parameter,
							return type of an operation,
							variables, attributes, references. The
							most typical use is in the
							parameter of an operation.
						</para>
						<programlisting><emphasis>// function type that takes one parameter as input</emphasis>
&lt;TYPE-&gt;RETURN_TYPE&gt;
<emphasis>// function type that takes several input parameters</emphasis>
[TYPE_1, TYPE_2, ...]-&gt;RETURN_TYPE&gt; // replace here the ... with as many type you wish
<emphasis>// function type that takes one input parameter of type Void can be called without parameter</emphasis>
&lt;Void-&gt;RETURN_TYPE&gt;</programlisting>
					</listitem>
					<listitem>
						<para>When an operation has only one parameter of type "function",
							then a special shortcut
							syntax allows to ommit the perenthesis
							when calling this operation.
						</para>
						<para>Examples of definition and call of operations that use only
							one
							function as parameter:
						</para>
						<para>Operation with a function parameter that uses one input:
						</para>
						<programlisting language="kermeta">operation operationWithOneLambdaParameter ( lambda : &lt;INPUT_TYPE-&gt;RETURN_TYPE&gt; ) : Void is do
	var foo : INPUT_TYPE init INPUT_TYPE.new
	lambda(foo) // will call the lambda with foo)
end

[...]
	// example of call
	// calling with the full syntax		
	operationWithOneLambdaParameter({ i : INPUT_TYPE | /* do something on i and return something of kind RETURN_TYPE */})
	// calling with the shortcut syntax : the type of i and the parenthesis can be ommitted
	operationWithOneLambdaParameter{ i  | /* do something on i and return something of kind RETURN_TYPE */}</programlisting>

						<para>Operation with a function parameter that uses several
							inputs:
						</para>
						<programlisting language="kermeta">
// function with several parameters, (the example use 2 parameters but you can use more than 2 ...)
operation operationWithSeveralLambdaParameters ( mylambda : &lt;INPUT_TYPE1, INPUT_TYPE2-&gt;RETURN_TYPE&gt; ) : Void is do
	var foo : INPUT_TYPE1 init INPUT_TYPE1.new
	var bar : INPUT_TYPE2 init INPUT_TYPE2.new
	mylambda(foo, bar) // will call the lambda
end

[...]
	// example of call
	// calling with the full syntax		
	operationWithSeveralLambdaParameters({ x, y : INPUT_TYPE | /* do something on x and y and return something of kind RETURN_TYPE */})
	// calling with the shortcut syntax : the type of i and the parenthesis can be ommitted
	operationWithSeveralLambdaParameters{ x, y  | /* do something on  x and y  and return something of kind RETURN_TYPE */}</programlisting>
						<note>
							<title>
								<inlinemediaobject>
									<imageobject>
										<imagedata fileref="gfx/fire.png" contentdepth="2em" />
									</imageobject>
								</inlinemediaobject>
								New in Kermeta 2
							</title>
							<para>
								It is now possible to ommit the variable when calling an
								operation that uses a single lambda
								parameter with
								<literal>Void</literal>
								input type.
							</para>
						</note>
						<para>
							Operation with a function parameter that uses a single input of
							type
							<literal>Void</literal>
							:
						</para>
						<programlisting language="kermeta">// With 0 parameter
operation operationWithSeveralLambdaParameters ( lambda : &lt;Void-&gt;RETURN_TYPE&gt; ) : Void is do
	lambda(void) // will call the lambda
	lambda()	// void can be ommitted to call the lambda, however the parenthesis are still mandatory
end

[...]
	// example of call
	// calling with the full syntax		
	operationWithSeveralLambdaParameters({ void : Void | /* do something  and return something of kind RETURN_TYPE */})
	// calling with the shortcut syntax : the type, the variable and the parenthesis can be ommitted
	operationWithSeveralLambdaParameters{   | /* do something  and return something of kind RETURN_TYPE */}</programlisting>
						<para>
							The operation
							<literal>indexedEach</literal>
							and
							<literal>forAllCpl</literal>
							on
							<literal>Collection</literal>
							are examples of such lambda with several input parameters. (See
							section bellow).
						</para>
						<para>Using the full syntax you can create operations that use
							parameters of mixed type
							including function type:
						</para>
						<programlisting language="kermeta">operation operationWithMixedParameters ( f : &lt;INPUT_TYPE-&gt;RETURN_TYPE&gt;, otherParam : String ) : Void is do
	var foo : INPUT_TYPE init INPUT_TYPE.new
	f(foo) // will call the lambda
	// do something with otherParam
end

[...]
	// example of call
	// only the full syntax is allowed		
	operationWithSeveralLambdaParameters({ x : INPUT_TYPE | /* do something on x and return something of kind RETURN_TYPE */}, "hellow world")</programlisting>
					</listitem>

					<listitem>
						<para>Declaring and defining an "anonymous" function inside a
							variable for reuse.
						</para>

						<programlisting language="kermeta">var f1 : &lt;TYPE -&gt; RETURN_TYPE&gt;
f1 := { var_name : TYPE | /* SOME_CODE_WITH_RETURN_TYPE_RESULT */ }

var f2 : &lt;[ TYPE_1, TYPE_2, TYPE_3 ] -&gt; RETURN_TYPE&gt;
f2 :=  { var_name_1 : TYPE_1, var_name_2 : TYPE_2, var_name_3 : TYPE_3 | /* SOME_CODE_WITH_RETURN_TYPE_RESULT */ }</programlisting>
						<tip>
							<para>You can also use function type in reference or attribute to
								store them. However, since
								ecore doesn't know about them, you'll
								have to define them on the kermeta side and thus cannot
								be
								serialized in a model.
							</para>
						</tip>
					</listitem>
				</itemizedlist>

				<para>In the following sections, you will find many examples of
					declarations, definitions, and
					uses of functions.
				</para>
			</section>

			<section>
				<title>Some existing useful functions</title>

				<para>The collections in Kermeta implement several functions based
					on
					lambda expression. These
					ones are very useful for model
					navigation.
				</para>

				<para>
					<emphasis role="strong">Example 1:</emphasis>
					closure definition
					for collection iterator-like in Kermeta
				</para>

				<programlisting>aCollection.<emphasis role="strong">each</emphasis> { e | 
    <emphasis>/* do something with each element e of this collection */</emphasis>
}
</programlisting>

				<para>
					See
					<xref linkend="section_collections.link" />
					for other
					existing functions on collections.
				</para>

				<para>
					<emphasis role="strong">Example 2:</emphasis>
					another useful
					function that is defined on Integer : the function
					times
				</para>

				<programlisting>10.<emphasis role="strong">times</emphasis> { i | stdio.writeln(i.toString) } <emphasis>// prints 0 to 9</emphasis> </programlisting>

				<para>Notice that you can also write some complex code in the
					function, using internal variables,
					etc. In such a case, the last
					statement evaluation will be the returned result of the lambda
					expression (provided it is declared to return something)
				</para>

				<para>
					<emphasis role="strong">Example 3</emphasis>
					: "complex"" code in a
					lambda expression
				</para>

				<programlisting>aCollection.<emphasis role="strong">each</emphasis> { e | 
    <emphasis>stdio.writeln("I am complex code!"
    stdio.writeln("Element : " + e.toString)
<emphasis>    var i : Integer init 5
    i := i + 132458</emphasis>
}</emphasis></programlisting>

				<para>
					<emphasis role="strong">Example 4</emphasis>
					: postponing parameter evaluation in the andThen operation
				</para>
				<para>The operation andThen and orElse of Boolean use the ability of
					functions to postpone the
					parameter evaluation.
					This allows to
					implement the expected behavior without adding new
					construct
					to the
					language.
				</para>
				<programlisting language="kermeta">
        // this kind of code allows to avoid a cast exception on the second test
        if cl.isInstanceOf(NamedElement).andThen{|	cl.asType(NamedElement).name == "foo"} then
        	// do something...
        end</programlisting>
				<para>
					<emphasis role="strong">Example 5</emphasis>
					: using operation that use a function with several inputs
				</para>

				<programlisting language="kermeta">aCollection.indexedEach { e, eachContext | 
	stdio.write("element "+ eachContext.index.toString + ": " + e.toString)
	if(!eachContext.isLast) then stdio.writeln(",") end 
  }</programlisting>
				<programlisting language="kermeta">aCollectionOfNamedElement.forAllCpl{s1,s2| (s1.name==s2.name).implies(s1==s2)}</programlisting>
			</section>

			<section>
				<title>Defining new functions in a class</title>

				<para>
					You can also define your own functions, by declaring an
					operation,
					with a parameter as a function
					using the syntax described
					in
					<xref linkend="section_function-syntax.link" />
					.
				</para>

				<para>
					<emphasis role="strong">Example</emphasis>
					: definition of
					functions for collections
				</para>

				<programlisting><emphasis role="strong">abstract</emphasis> <emphasis role="strong">class</emphasis> Collection&lt;G&gt;
{     
     <emphasis>/** * runs func on each element of the collection */</emphasis>
     <emphasis role="strong">operation</emphasis> each(func : &lt;G -&gt; Object&gt;) : Void <emphasis
					role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
         <emphasis role="strong">from</emphasis> <emphasis role="strong">var</emphasis> it : Iterator&lt;G&gt; <emphasis
					role="strong">init</emphasis> iterator
         <emphasis role="strong">until</emphasis> it.isOff
         <emphasis role="strong">loop</emphasis>
             func(it.next)
         <emphasis role="strong">end</emphasis>
      <emphasis role="strong">end</emphasis></programlisting>

				<programlisting>     <emphasis>/** * checks that the condition is true on all the element of the collection * returns true if the collection is empty */</emphasis>
     <emphasis role="strong">operation</emphasis> forAll(func : &lt;G -&gt; Boolean&gt;) : Boolean <emphasis
					role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
         <emphasis role="strong">var</emphasis> test : Boolean <emphasis role="strong">init</emphasis> true
         <emphasis role="strong">from</emphasis> <emphasis role="strong">var</emphasis> it : Iterator&lt;G&gt; init iterator
         <emphasis role="strong">until</emphasis> it.isOff
         <emphasis role="strong">loop</emphasis>
            test := test <emphasis role="strong">and</emphasis> func(it.next)
         <emphasis role="strong">end</emphasis>
         <emphasis role="strong">result</emphasis> := test
     <emphasis role="strong">end</emphasis>
}</programlisting>
			</section>

			<section>
				<title>Defining lambda expression variables</title>

				<para>You can also define lambda expression as variable. This can be
					useful if you don't want to
					( or can't) modify the class.
				</para>

				<itemizedlist>
					<listitem>
						<para>A basic lambda expression</para>
					</listitem>
				</itemizedlist>

				<para>With one Integer argument and returning an Integer.</para>

				<programlisting language="kermeta">var aLambdaExp : &lt;Integer-&gt;Integer&gt;
var aLambdaResult : Integer
aLambdaExp :=  { i : Integer | i.plus(4) }
// aLambdaResult equals 7
aLambdaResult := aLambdaExp(3)</programlisting>

				<itemizedlist>
					<listitem>
						<para>A lambda expression with several parameters</para>
					</listitem>
				</itemizedlist>

				<programlisting language="kermeta">var aLambdaExp : &lt;[Integer, Integer]-&gt;Integer&gt;
var aLambdaResult : Integer
aLambdaExp :=  { i : Integer, j : Integer | i * j }
// aLambdaResult equals 12
aLambdaResult := aLambdaExp(3, 4)</programlisting>

				<itemizedlist>
					<listitem>
						<para>A lambda expression on a collection</para>
					</listitem>
				</itemizedlist>

				<programlisting language="kermeta">var init_set : Set&lt;Integer&gt; := Set&lt;Integer&gt;.new
init_set.add(32)
init_set.add(23)
init_set.add(41)

// This sequence equals : [320, 230, 410]
var sequence : Sequence&lt;Integer&gt; := init_set.collect { element | element*10}</programlisting>

				<para>The code within the function can be as complex as you want,
					using internal variables, etc.
				</para>

				<programlisting language="kermeta">var factoExp : &lt;Integer-&gt;Integer&gt;
    factoExp :=  { n : Integer | 
        var fact : Integer := 1
        from var x : Integer := 1 
        until x &gt; n 
        loop
            fact := fact * x 
            x:=x+1
        end
        fact // return fact as the result of the function
        //shorter alternative ;-)... if n&lt;=1 then 1 else factoExp(n -1) * n end
    }
    var cnkExp : &lt;[Integer, Integer]-&gt;Integer&gt;
    cnkExp :=  { n : Integer, k : Integer |
        factoExp(n) / (factoExp(k) * factoExp(n-k))
    }</programlisting>
			</section>
			<section>
				<title>Useful patterns that use lambda</title>
				<para>
					When starting to use the lambda expression you can define some
					useful design patterns. One of
					them is the ability to propose an
					<literal>each</literal>
					that traverses all the owned element of a given metamodel. For some
					usage, this can be an
					interresting alternative to the visitor
					design pattern.
				</para>
				<para>Let's have the following metamodel:</para>
				<programlisting language="kermeta">class NamedElement {
	attribute name : String
}
class A inherits NamedElement {
	attribute ownedAs : A[0..*]
}
class B inherits A {
	attribute ownedBs : B[0..*]
}
class C inherits A {
	attribute ownedBs : B[0..*]
	attribute ownedC : C
}</programlisting>
				<para>It would be nice to be able to call a simple lambda on all the
					elements directly owned by
					an element. This can be done by adding
					an operation using the
					following pattern:
				</para>
				<programlisting language="kermeta">aspect class NamedElement {
	operation eachOwnedElement(func : &lt;NamedElement -&gt; Void&gt;) : Void is do
		// String attributes are value, so they aren't really "owned"  
	end
}
aspect class A inherits NamedElement {
	operation eachOwnedElement(func : &lt;NamedElement -&gt; Void&gt;) : Void is do
		super(func)
		self.ownedAs.each{ e |
			func(e)
		}
	end
}
aspect class B inherits A {
	operation eachOwnedElement(func : &lt;NamedElement -&gt; Void&gt;) : Void is do
		super(func) // makes sure to call func on attributes inherited from A
		self.ownedBs.each{ e |
			func(e)
		}
	end
}
aspect class C inherits A {
	operation eachOwnedElement(func : &lt;NamedElement -&gt; Void&gt;) : Void is do
		super(func) // makes sure to call func on attributes inherited from A
		self.ownedBs.each{ e |
			func(e)
		}
		if(not ownedC.isVoid) then
			func(ownedC)
		end
	end
}</programlisting>
				<para>Then a call like the following will ensure to traverse all the
					directly owned elements.
				</para>
				<programlisting language="kermeta">var c : C := // initialize it with a complex model :-)
// write the name of all the elements directly  contained by c
c.eachOwnedElement{ aNamedElement | stdio.writeln(aNamedElement.name) }

// collect all the elements directly contained by c
var ownedElements : Sequence&lt;Object&gt; := Sequence&lt;Object&gt;.new
c.eachOwnedElement{ aNamedElement | ownedElements.add(aNamedElement) }
stdio.writeln("ownedElements.size = "+ ownedElements.size.toString)</programlisting>
				<para>It is then easy to extend this pattern to traverse the
					directly and indirectly owned
					elements.
				</para>
				<programlisting language="kermeta">aspect class NamedElement {
	operation eachAllOwnedElement(func : &lt;NamedElement -&gt; Void&gt;) : Void is do			
		eachOwnedElement{e|
			func(e) 
			e.eachAllOwnedElement{child|func(child)} 
		}
	end
}</programlisting>
				<para>This new operation can be called in the same easy way:</para>
				<programlisting language="kermeta">// write the name of all the elements directly or indirectly contained by c
c.eachAllOwnedElement{ aNamedElement | stdio.writeln(aNamedElement.name) }

// collect all the elements directly or indirectly contained by c
var allownedElements : Sequence&lt;Object&gt; := Sequence&lt;Object&gt;.new
c.eachAllOwnedElement{ aNamedElement | allownedElements.add(aNamedElement) }</programlisting>
				<tip>
					<para>Like any pattern, this task can be automated by using a model
						transformation. The Ecore
						MDK offers such transformation that
						generates this pattern for a given Ecore model.
					</para>
				</tip>
			</section>
		</section>

		<section id="section_dynamic_expressions.link">
			<title id="section_dynamic_expressions.title.link">
				Dynamic evaluation of
				Kermeta expressions
				<phrase id="section_dynamic_expressions"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para>
					The dynamic expression are currently
					<emphasis role="strong">not implemented</emphasis>
					in Kermeta 2. However, there are some plan to reimplement them in
					the future.
				</para>
			</warning>
			<para>
				<phrase id="dynamic_expression"></phrase>
				Kermeta allow you to evaluate dynamically a Kermeta Expression with
				a specific context.
			</para>

			<para>
				<emphasis role="strong">Example 1</emphasis>
				: my first dynamic expression
			</para>

			<programlisting><emphasis role="strong">var</emphasis> de : DynamicExpression <emphasis
				role="strong">init</emphasis> DynamicExpression.new
de.initializeDefaults
de.formalParameters.put(<emphasis>"a"</emphasis>, String)
de.parse(<emphasis>"stdio.writeln(a)"</emphasis>)
<emphasis role="strong">var</emphasis> params : Hashtable&lt;String, Object&gt; <emphasis
				role="strong">init</emphasis> Hashtable&lt;String, Object&gt;.new
params.put(<emphasis>"a"</emphasis>, <emphasis>"hello world!"</emphasis>)
de.execute(void, params)</programlisting>

			<para>If you want to dynamically evaluate more than one statement,
				you
				will have to surround your
				set of statements with "do.. end"
				block:
			</para>

			<para role="lineBreak">
				<emphasis role="strong">Example 2</emphasis>
				: yet
				another example
			</para>

			<programlisting><emphasis>// let's get previous example and modify it </emphasis><emphasis></emphasis><emphasis>// [...] (carriage return is not necessary inside the block)</emphasis>
de.parse(<emphasis>"do stdio.writeln(a) stdio.writeln("another stdio writeln ... ") end"</emphasis>)
<emphasis>// [...]</emphasis></programlisting>

			<para>
				<emphasis role="strong">Example 3</emphasis>
				: another more complex
				sample of dynamic expressions :
			</para>

			<programlisting><emphasis role="strong">package</emphasis> testDynamicExpression;

<emphasis role="strong">using</emphasis> kermeta::interpreter
<emphasis role="strong">using</emphasis> kermeta::utils
<emphasis role="strong">using</emphasis> kermeta::standard

<emphasis role="strong">class</emphasis> TestMain
{

    <emphasis role="strong">operation</emphasis> TestToto() <emphasis role="strong">is</emphasis> <emphasis
				role="strong">do</emphasis>
        stdio.writeln("J'ai essayé de lancer testtoto!")
    <emphasis role="strong">end</emphasis>

    <emphasis role="strong">operation</emphasis> testDynExp() <emphasis role="strong">is</emphasis> <emphasis
				role="strong">do</emphasis>
        <emphasis role="strong">var</emphasis> dynExpr : DynamicExpression <emphasis role="strong">init</emphasis> DynamicExpression.new
        dynExpr.initializeDefaults()

        <emphasis role="strong">self</emphasis>.getMetaClass.ownedOperation.select{op| <emphasis
				role="strong">not</emphasis>( op.name.indexOf("Test")==-1)
and op.name.indexOf("All")==-1}

            .collect{op|op.name}.each{opName|

                    stdio.writeln("execution de "+opName)
                    dynExpr.initializeDefaults
                    dynExpr.parse("testDynamicExpression ::TestMain.new." +opName)
                    dynExpr.execute(void,Hashtable&lt;String,Object&gt;.new)
            }
    <emphasis role="strong">end</emphasis>
}</programlisting>

			<caution>
				<para>
					You cannot use "self" inside a dynamic expression
				</para>
			</caution>
		</section>

		<section id="section_contracts.link">
			<title id="section_contracts.title.link">
				Design by contract (pre, post,
				inv contraints)
				<phrase id="section_contracts"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>In Kermeta, a contract is specified by "pre" and "post"
				conditions
				and by the "invariant"
				constraint too.
			</para>

			<section>
				<title>Writing a contract</title>

				<section id="section_pre_post_syntax.link">
					<title>pre – post conditions syntax</title>

					<para>A pre or a post condition is a boolean expression that may be
						a simple equality checking
						or a lambda expression. The Kermeta
						interpreter evaluates the body content like a boolean
						result
					</para>

					<para>The "pre condition" are declared just before the "is" of the
						operation body
					</para>

					<programlisting><emphasis role="strong">operation</emphasis> opName(c : String) : String
    
    <emphasis>// Declaration of the pre-condition</emphasis>
    <emphasis role="strong">pre</emphasis> notVoidInput <emphasis role="strong">is</emphasis> <emphasis
						role="strong">do</emphasis>
        c != <emphasis role="strong">void</emphasis> and c != ""
    <emphasis role="strong">end</emphasis>

    <emphasis>// Declaration of the post-condition</emphasis>
    <emphasis role="strong">post</emphasis> notVoidOutput <emphasis role="strong">is</emphasis>
        <emphasis role="strong">result</emphasis> != <emphasis role="strong">void</emphasis> and <emphasis
						role="strong">result</emphasis> != ""

<emphasis role="strong">is</emphasis>
    <emphasis role="strong">do</emphasis>
        // operation body
    <emphasis role="strong">end</emphasis></programlisting>

					<tip>
						<para>
							If the body contains only one expression, the block
							declaration "do
							... end" is not
							mandatory. If your block contains
							several
							instructions, the latest one will be evaluated as a
							boolean
							expression.
						</para>
					</tip>
				</section>

				<section id="section_inv_syntax.link">
					<title>Invariant constraint syntax</title>

					<para>An invariant constraint is declared anywhere in a
						ClassDefinition block.
					</para>

					<para>An invariant declaration is a boolean expression that may be
						a
						simple equality checking or
						a lambda expression. The Kermeta
						interpreter evaluates the body content like a boolean result.
					</para>

					<para>A very simple example :</para>

					<programlisting><emphasis role="strong">class</emphasis> className {

    ...

    <emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
    <emphasis role="strong">inv</emphasis> nameOfTheInvariant <emphasis role="strong">is do</emphasis>
        <emphasis role="strong">self</emphasis>.name != ""
    <emphasis role="strong">end</emphasis>

    ...
}</programlisting>

					<tip>
						<para>If the body contains only one instruction, the block
							declaration "do ... end" is not
							mandatory.
						</para>

						<programlisting><emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
<emphasis role="strong">inv</emphasis> nameOfTheInvariant <emphasis role="strong">is self</emphasis>.name != ""</programlisting>
					</tip>

					<para>A lambda expression can be used into an invariant
						declaration:
					</para>

					<programlisting><emphasis>// Declaration of the invariant : deterministicTransition</emphasis>
<emphasis role="strong">inv</emphasis> deterministicTransition <emphasis role="strong">is</emphasis> <emphasis
						role="strong">do</emphasis>
    <emphasis role="strong">self</emphasis>.outgoingTransition.forAll{tr1 |
        <emphasis role="strong">self</emphasis>.outgoingTransition.forAll{ tr2 |
            ( tr2.input==tr1.input ) == (tr1==tr2)
        }
    }
<emphasis role="strong">end</emphasis></programlisting>
				</section>
			</section>

			<section>
				<title>Checking your constraints</title>

				<section>
					<title>Checking pre – post condition</title>

					<para>The activation of the checking of the pre - post conditions
						depends of the run
						configuration, see the Kermeta UI user guide
						for
						more information.
					</para>

					<para>
						If the boolean statement is evaluated to "false" then the pre
						or
						post condition is violated and
						an exception
						<literal>ConstraintViolatedPre</literal>
						or
						<literal>ConstraintViolatedPost</literal>
						is raised.
					</para>
				</section>

				<section>
					<title>Checking invariant</title>

					<para>
						In order to check the well-formedness rules of a model
						element,
						there are two methods in
						Kermeta. The first-one :
						<literal>checkInvariants</literal>
						, consists to check only the
						current model element and the
						second-one :
						<literal>checkAllInvariants</literal>
						, checks recursively the
						element being a containment link with the
						checked element.
					</para>

					<programlisting language="kermeta">theModelElement.checkInvariants
</programlisting>

					<para>The checkAllInvariants operation is a recursive method which
						checks all the elements
						having a containment relation by
						transitivity with the checked element.
					</para>

					<para>checkAllInvariants is used especially to check the validity
						of
						a model fragment or a
						complete model.
					</para>

					<programlisting>theModelElement.checkAllInvariants</programlisting>

					<para>
						If the boolean statement is evaluated to
						"
						<literal>false</literal>
						" then the invariant constraint is violated
						and an exception
						<literal>ConstraintViolatedInv</literal>
						is raised.
						This exception can be handled by a
						<literal>rescue</literal>
						call.
					</para>

					<programlisting><emphasis>// Call the invariant verification</emphasis>
<emphasis role="strong">do</emphasis>
    theModelElement.checkInvariants
    <emphasis role="strong">rescue</emphasis> (err : ConstraintViolatedInv)
        stdio.writeln(err.toString)
        stdio.write(err.message)
<emphasis role="strong">end</emphasis></programlisting>
				</section>
			</section>
		</section>

		<section id="section_weaving.link">
			<title id="section_weaving.title.link">
				Weaving Kermeta code
				<phrase id="section_weaving"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>Since version 0.4.1, it is possible to write Kermeta code using
				a simplified Aspect Oriented
				approach.
			</para>

			<para>Technically, you can declare classes as "aspects" that will
				contribute features (attributes,
				references, properties, operations,
				constraints) to an existing classes. In such situation, the
				definition
				of two classes that have the same qualified name will be
				merged into a
				single class at
				run time.
			</para>

			<para>This is a great help when you want to separate the concerns
				into
				several files. For example,
				you may have one file containing
				the
				structural part of your metamodel, one file
				containing the
				constraints for a given purpose and another file
				containing the
				operation and special extension to
				the metamodel for
				an
				interpreter.
			</para>
			<para>As a general guideline, this allow to reopen existing structure
				in order to add new element.
				It is not possible to remove or change
				an existing information. For example, you cannot trnasform
				an
				abstract class into a concrete class.
			</para>
			<para>Obviously, the merge will be successful only if there is no
				conflict between all the
				declared features.
			</para>

			<section>
				<title>Textual syntax for merging</title>
				<para>The merge is driven by the qualified name of the element to
					merge. Two classes will be
					merged if they have exactly the same
					qualified name (packages names + class name)
				</para>

				<para>The merge is allowed only if you add the following keyword:
				</para>

				<variablelist>
					<varlistentry>
						<term>aspect</term>

						<listitem>
							<para>This keyword is placed on a class, it indicates that this
								class is an
								aspect of another
								one. This allows to complement a
								class with
								the features of the aspect class.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>

			</section>

			<section>


				<title>Example 1: Simple Class merge</title>

				<para>In this sample, writing:</para>
				<simplesect>
					<title>
						file
						<filename>aspect1.kmt</filename>
					</title>
					<programlisting language="kermeta">package pack;
// this is the first aspect of class A
aspect class A {
	attribute decorations : Decoration[0..*]
}
// this aspect also declares a new class, visible only when requiring this aspect
class Decoration{
	attribute val : kermeta::standard::String
}</programlisting>
				</simplesect>
				<simplesect>
					<title>
						<filename>base.kmt</filename>
					</title>
					<programlisting language="kermeta">package pack;
// this is the base class
class A {
	attribute name : kermeta::standard::String
	
	 // operation in this context have access only to the base's features 
	operation getName() : kermeta::standard::String is do
		result := name
	end
}</programlisting>
				</simplesect>
				<simplesect>
					<title>
						<filename>aspect2.kmt</filename>
					</title>
					<programlisting language="kermeta">package pack;

// is this context we have access to all the features of class A : from base, aspect1 and aspect2
aspect class A {
	attribute id : kermeta::standard::Integer
	operation getFullSpecification() : kermeta::standard::String is do
		result := name
		result := "(" + id.toString + ")"
		decorations.each{ decoration | result := result + "&lt;" + decoration.val+ "&gt;" }
	end
}</programlisting>
				</simplesect>
				<simplesect>
					<title>
						<filename>aspect_sample.kp</filename>
					</title>
					<programlisting language="kp">KermetaProject "aspect_sample"
	groupId = "my.group"
	defaultMainClass = "sample::AspectExample"
	defaultMainOperation = "main"
	sources = {
		require "${project.baseUri}/base.kmt"
		require "${project.baseUri}/aspect1.kmt"
		require "${project.baseUri}/aspect2.kmt"
	}
	dependencies = {
		//default dependency to kermeta framework (try first in eclipse plugin, then look into maven repository)
		dependency "library.core" ="platform:/plugin/org.kermeta.language.library.core",
		                           "mvn:org.kermeta.language/language.library.core/LATEST"
	}</programlisting>
				</simplesect>

				<note>
					<title>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="gfx/fire.png" contentdepth="2em" />
							</imageobject>
						</inlinemediaobject>
						New in Kermeta 2
					</title>
					<para>In kermeta 1, the require statements were at the file level,
						now they apply at the project
						level. This means that the
						contibution of an aspect will be visible in all the project. It is
						still possible to manage the visibility of aspects using project
						dependencies. It is often
						useful to separate some set of files
						into projects.
					</para>
				</note>

				<tip>
					<para>In the previous example we aspectize a *.kmt, we could choose
						to aspectize the
						corresponding *.ecore file.
					</para>
					<para>In fact, the both formats are available: *.kmt or *.ecore.
					</para>
				</tip>

				<para>from the point of view of the project, the 3 kmt files are
					equivalent to write a single kmt file containing :
				</para>

				<programlisting language="kermeta">package pack;
class A {
	attribute name : kermeta::standard::String
	attribute decorations : Decoration[0..*]	
	attribute id : kermeta::standard::Integer
	
	 // operation in this context have access only to the base's features 
	operation getName() : kermeta::standard::String is do
		result := name
	end
	operation getFullSpecification() : kermeta::standard::String is do
		result := name
		result := "(" + id.toString + ")"
		decorations.each{ decoration | result := result + "&lt;" + decoration.val+ "&gt;" }
	end
}
class Decoration{
	attribute val : kermeta::standard::String
}</programlisting>



			</section>

			<section>
				<title>Example 2: merge with feature redefinition</title>

				<para>This sample shows that if the signature are strictly
					equivalent,
					then you can redefine the
					same structural feature
					(attribute,
					reference) in several aspect class.
				</para>

				<para>In addition, if an operation can be extended to addpre or post
					conditions to a given
					operation.
				</para>
				<note>
					<title>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="gfx/fire.png" contentdepth="2em" />
							</imageobject>
						</inlinemediaobject>
						New in Kermeta 2
					</title>
					<para>
						In kermeta 1, and abstract operation was used to define an
						operation with no body as a support
						for operation extensions. In
						kermeta 2 we suppose that if the developper has defined the
						operation abstract then his intents is that the operation must be
						overriden via a sub class. So
						now, the abstract keyword cannot be
						used for that. We use the
						<literal>void</literal>
						keyword instead.
					</para>
				</note>
				<para>
					Currently, (v1.0.0) the
					<link linkend="section_derived_properties.link">derived properties</link>
					cannot be redefined in several aspect classes.
				</para>

				<programlisting language="kermeta">aspect class A {
	//the feature is equivalent to the one define in the base class, so this is legal
	attribute name : kermeta::standard::String	
	
	// the operation has the same signature and has no body (ie. void)
	operation getQualifiedName() : kermeta::standard::String 
		post resultNotVoid is not result == Void
		is void
}</programlisting>

				<programlisting language="kermeta">package pack;
class A {

	attribute name : kermeta::standard::String
	operation getQualifiedName() : kermeta::standard::String is do
		result := name
	end
}</programlisting>
			</section>

			<section>
				<title>Example 3: merge with overload of operation from ecore
					genmodel
				</title>

				<para>
					In ecore, it is possible to define some operation with body. this
					is acheived either via the
					<literal>generated NOT</literal>
					comment in the generated java file or via a specific annotation in
					the ecore file (Please refer
					to EMF documentation and book for
					details on that). By default, kermeta will reuse these
					operations
					and allows to call this code. However, in some situations, you may
					want to overload
					this code by your own in kermeta. This can be done
					as follow:
				</para>

				<programlisting language="kermeta">package pack;
require kermeta
aspect class A {	
	@overloadable "true"
	operation getQualifiedName() : kermeta::standard::String 
		post notVoid is not result == Void
		is abstract
}</programlisting>

				<programlisting language="kermeta">package pack;
require kermeta
aspect class A {	
	@overloadable "true"
	operation getQualifiedName() : kermeta::standard::String is do
		raise kermeta::exceptions::NotImplementedException.new
	end
}</programlisting>

				<programlisting language="kermeta">class A {
	attribute name : kermeta::standard::String
	operation getQualifiedName() : kermeta::standard::String is do
		result := name
	end
}</programlisting>

				<para>In this sample, the first declaration of the operation is adds
					a
					post condition to the
					operation. As it is abstract, it isn't in
					conflict with the other declarations.
				</para>

				<para>The second declaration, has a body. It implements a kind of
					default behavior for the
					operation that will be used if no other
					body
					is declared for this operation. this is useful when
					converting
					ecore
					models into Kermeta for example.
				</para>

				<para>The last definition is the one that will be used in this
					context.
				</para>

				<para></para>
			</section>
			<section>
				<title>Aspect and inheritance</title>

				<para>If you define some inheritance in one of your aspects, all the
					aspects that require this
					aspect will have access to it. You
					don't
					need to redefine it. However, if it helps to clarify the
					code to
					write it again, it will behave the same way.
				</para>
			</section>
			<section>
				<title>Aspect and abstract</title>

				<para>In Kermeta textual syntax, the keyword aspect must be placed
					before the keyword abstract.
				</para>
				<para>Example :</para>
				<programlisting language="kermeta">package pack;
require kermeta
aspect abstract class A {	
	// add something
}</programlisting>

			</section>
			<section>
				<title>Aspect without common base</title>

				<para>A special case of the use of AOP in Kermeta is having a
					ClassDefinition A defined in 2
					separately
					modeling units (*.kmt)
					with the keyword aspect. But the two modeling units
					does not
					require
					another kmt or ecore file containing the base
					definition of A.
					Now if
					there is a new
					Modeling Unit that requires the two previous one
					the
					available definition of A is the composition
					of the 2 defined
					aspects.
				</para>
			</section>
		</section>

		<section id="section_modeltype.link">
			<title id="section_modeltype.title.link">Model type</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<warning>
				<para>
					In current version of Kermeta(v1.1.0), ModelType is still a
					prototype. Any help, feedback,
					contribution is welcome to help us
					to finalize it.
				</para>
			</warning>

			<para>Kermeta is clearly a model oriented language, one of its first
				concept is a model element,
				because they are the manipulated
				objects.
				However, we often need to organise them and manipulate
				them
				as a set : a
				model. A common way to do that is to simply use a set,
				and a
				resource
				(used for
				load and save) is just a set. This approach
				is not type safe
				enough.
			</para>

			<para>So, Kermeta implements a clear notion of model type, in order
				to be
				able to typecheck this
				kind of model. A model type is simply
				the set of
				the type of all allowed model elements.
			</para>

			<para>In addition, it introduce a mechanism of conformance between
				modeltype that helps to reuse
				code from one metamodel to another.
			</para>

			<section>
				<title>Definition of a model type</title>

				<para>A model type is simply a set of metaclasses. Expressed in
					Kermeta, this is a collection of
					Kermeta classes.
				</para>

				<programlisting language="kermeta">
package aMetamodel;
// let's define some normal classes 
class C1 {
	attribute name : String
	attribute aC2 : C2#aC1
}
class C2 {
	reference aC1 : C1#aC2
}

// then defining a modeltype is just listing the classes of this modeltype
// here, the model type is composed of two metaclasses, C1 and C2
modeltype MainMT { aMetamodel::C1, aMetamodel::C2}
      	</programlisting>

				<tip>
					<para>
						You can use all classic way to define classes, in kmt, but
						you can
						also require an ecore
						file that will contain your class
						definition
						(see require section ???)
					</para>
				</tip>
			</section>

			<section>
				<title>Using Model types variables</title>

				<para>Now that you have defined a ModelType, you can use it to
					declare
					model variables.
				</para>

				<programlisting language="kermeta">
	var aMainMT : MainMT init MainMT.new
      	</programlisting>

				<para>
					But, your model is still empty. As its contents is a
					(constrained)
					Set you simply have to fill it
					with your model element
					using
					typechecked operations like
					<literal>add</literal>
					, or using
					filtered operation like
					<literal>addCompatible</literal>
					and
					<literal>addAllCompatible</literal>
					(with this one you can pass any
					collection, only compatible objects
					will be added to the
					model).
				</para>

				<programlisting language="kermeta">
    // create a model element
	var newC1 : aMetamodel::C1 init aMetamodel::C1.new()
	newC1.name := "hello"
	// then add it to the model
	aMainMT.add(newC1)
      	</programlisting>
			</section>

			<section>
				<title>Model type serialisation</title>

				<para>
					As a model type is based on "normal" class definitions, loading
					and
					saving models mostly relies
					on the normal way to load resource
					(see
					<xref linkend="section_loadingsaving_models.link" />
					)
				</para>

				<para>
					A simple approach for loading is to load with the classical
					approach, then to use the operations
					<literal>addAllCompatible</literal>
					with the content of the resource
					or
					<literal>resourceToModel</literal>
					with the resource. That will
					fill the model with compatible objects.
				</para>

				<programlisting language="kermeta">
	// load a resource with model elements
	var res : EMFRepository init EMFRepository.new
	var resource : Resource init res.createResource(modelFileName, ecoreMetamodelFileName)
	resource.load()
       	    
	// then add them to the model
	aMainMT.addAllCompatible(resource.contents)
	// alternative
	// aMainMT.resourceToModel(resource)
      	</programlisting>

				<para>TODO sample of saving (how to put root objects of the model
					into
					a resource)
				</para>
			</section>

			<section>
				<title>Model type conformance</title>

				<para>TODO explain how Modeltype helps to reuse existing code from a
					metamodel to another
				</para>

				<para>Model types use a notion of conformance that allows to
					determine
					if a metamodel is
					conformant to another. The goal is to be
					able to
					write code that will be valid not only for
					models of a given
					metamodel, but will be valid for models of conformant
					metamodels.
				</para>

				<para>In order to be flexible, the conformity between metamodel is
					based on the properties
					offered by the metaclasses. It ignores the
					name of the metaclasses.
				</para>

				<para>As a sample, let's define a mini metamodel and its
					corresponding
					model type :
				</para>

				<programlisting language="kermeta">
      	</programlisting>

				<note>
					<para>We could also define a modeltype directly on top of the
						previous metamodel (and restrain
						it to some of its metaclasses),
						but
						the sample would have been less general and wouldn't have
						illustrated the fact that the name of metaclasses are
						ignored.
					</para>

					<programlisting language="kermeta">
 modeltype MiniMT_2 { aMetamodel::C1 }
      		</programlisting>
				</note>

				<warning>
					<para>
						The current implementation works only when there is no
						ambiguity, if
						there is ambiguity
						between two metamodels, then they
						are
						considered as not conformant. A future version, may
						eventually
						introduce a binding mechanism that would allows to remove those
						ambiguity. (See Jim
						Steel Phd thesis for more details ???)
					</para>
				</warning>
			</section>

			<section>
				<title>Using Model types in generic classes/operations</title>

				<para>TODO</para>
			</section>

			<section>
				<title>A more complex example of conformance : FSM variants</title>

				<para>TODO reuse JM slides and the conformity table</para>
			</section>
		</section>

		<section id="section_java_code.link">
			<title id="section_java_code.title.link">Using existing java code in
				Kermeta
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>If you have existing code that you want to run in a Kermeta
				program, you can use one of
				those two mechanisms : extern call or
				seamless require.
			</para>

			<para>The extern call is currently the more robust approach as it is
				used internally by Kermeta to
				implement some part of its framework.
				It
				also helps to clearly specify the border between java and
				Kermeta.
			</para>

			<para>The seamless java require is more straitghforward to use (no
				wrapper to write) but is still
				in prototype (v0.4.2) and still have
				several limitations.
			</para>

			<section id="section_extern_java_code.link">
				<title id="section_extern_java_code.title.link">Using extern to call
					java code
				</title>

				<para>The extern allows you to call a java static method from
					Kermeta.
					But, to do that, you will
					have firstly to create a Java
					wrapper, that
					will be able to manipulate correctly the Java
					objects,
					and secondly
					to
					add this wrapper in your java global classpath.
				</para>

				<para role="lineBreak">Then, from this method you can access all your
					java
					libraries. One task of the
					static method will be to convert the
					basic types like Integer or String.
				</para>

				<para>You'll need to refer to the Javadoc of the interpreter in
					order
					to know how to access the
					internal RuntimeObject of Kermeta.
				</para>

				<para>
					<emphasis role="strong">Example 1</emphasis>
					: sample of Kermeta
					code using extern (io.kmt):
				</para>

				<programlisting><emphasis>/** * An implementation of a StdIO class in Kermeta using existing Java: standard * input/output */</emphasis>
<emphasis role="strong">class</emphasis> StdIO
{
 <emphasis>/**</emphasis> <emphasis>* write the object to standard output</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> write(object : Object) : Void <emphasis
					role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
   <emphasis role="strong">result</emphasis> ?= <emphasis role="strong">extern </emphasis>fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.write(object)
 <emphasis role="strong">end</emphasis>
 
 <emphasis>/**</emphasis> <emphasis>* writeln the object to standard output</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> writeln(object : Object) : Void <emphasis
					role="strong">is do</emphasis>
   <emphasis role="strong">result</emphasis> ?= <emphasis role="strong">extern</emphasis> fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.writeln(object)
 <emphasis role="strong">end</emphasis>
 
 <emphasis>/**</emphasis> <emphasis>* read an object from standard input</emphasis> <emphasis>*/</emphasis> 
 <emphasis role="strong">operation</emphasis> read(prompt : String) : String <emphasis
					role="strong">is do</emphasis>
 <emphasis role="strong">  result</emphasis> ?= <emphasis role="strong">extern</emphasis> fr::irisa::triskell::kermeta::runtime::basetypes::StdIO.read(prompt)
 <emphasis role="strong">end</emphasis>

}
</programlisting>

				<para>
					<emphasis role="strong">Example 2</emphasis>
					: sample of Java
					code ("wrapper") called by the Kermeta extern:
				</para>

				<programlisting><emphasis>/** Implementation of input and output methods */</emphasis>
   <emphasis role="strong">public</emphasis> <emphasis role="strong">class</emphasis> StdIO{ 
      // Implementation of method write called as :
      // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.write(output) 
      <emphasis role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject write(RuntimeObject output) {
         output.getFactory().getKermetaIOStream().print(output.getData().get("StringValue")); 
      <emphasis role="strong">return</emphasis> output.getFactory().getMemory().voidINSTANCE; 
      } 
      // Implementation of method writeln called as : // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.writeln(output) 
      <emphasis role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject writeln(RuntimeObject output) {
         <emphasis>write</emphasis>(output); 
         output.getFactory().getKermetaIOStream().print("\n"); 
      <emphasis role="strong">return</emphasis> output.getFactory().getMemory().voidINSTANCE; 
      } 
      // Implementation of method writeln called as : // extern fr::irisa::triskell::kermeta::runtime::basetypes::Io.read(output) 
      <emphasis role="strong">public</emphasis> <emphasis role="strong">static</emphasis> RuntimeObject read(RuntimeObject prompt) {
         java.lang.String input = <emphasis role="strong">null</emphasis>; 
         // We also have our own String wrapper 
      <emphasis role="strong">if</emphasis> (String.<emphasis>getValue</emphasis>(prompt).length()&gt;0) 
         prompt.getFactory().getKermetaIOStream().print(String.<emphasis>getValue</emphasis>(prompt)); 
      // <emphasis role="strong">FIXME</emphasis> : dirty cast.. read returns a String or could return smthg else? 
      input = (java.lang.String)prompt.getFactory().getKermetaIOStream().read( String.<emphasis>getValue</emphasis>(prompt)); 
      RuntimeObject result = String.<emphasis>create</emphasis>(input, prompt.getFactory()); 
      <emphasis role="strong">return</emphasis> result; 
   }</programlisting>

				<tip>
					<para>
						This method is used to implement Kermeta framework. You'll
						find much
						more code samples of
						extern call in its sources.
					</para>
				</tip>
			</section>

			<section id="section_seamless_java_code.link">


				<title id="section_seamless_java_code.title.link">Requiring jar file
					to call java code
				</title>



				<warning>
					<para>This feature is still a prototype and still have many
						limitations. The first version is
						already available but any help
						is
						welcome to help us to improve it.
					</para>
				</warning>



				<para>The basic principle, is to simply require your jar file.
				</para>



				<programlisting language="kermeta"> require "yourjar.jar" </programlisting>



				<para>Then Kermeta automatically retreive the class definition it
					contains to be used from
					Kermeta code. However, as java and Kermeta
					have different language constraints, some adaptation
					are
					automatically
					made.
				</para>

				<para>If there is several operations with the same name (as this is
					legal in Java but not in
					Kermeta) they are renamed. (Please use the
					outline to find the new name of the operation you
					want)
				</para>

				<para>Java contructors are generated as "initialize" operation.
				</para>

				<para>When creating a new java object from Kermeta, a call to new is
					not enough, you also need to
					call one of the "initialize" operation
					in
					order to correctly create it.
				</para>

				<para>
					In order to get the standard library direclty from your running
					java, you can
					<literal>require java_rt_jar</literal>
					but as this
					library is really big and as you probably don't need all
					java from
					Kermeta ;-) then
					you must use the includeFilter and
					excludeFilter.
				</para>

				<para>Sample using java.io from java Standard library</para>
				<para />

				<programlisting language="kermeta"> 
require kermeta

require java_rt_jar includeFilter ("java::io")   // the filter ensure we don't get all java

using java::io
using kermeta::kunit
class testRequireJava inherits kermeta::kunit::TestCase
{
	operation main() : Void is do
		var tr : TestRunner init TestRunner.new
		tr.run(testRequireJava)
		tr.printTestResult
	end	
	
	operation testmain() : Void is do 
	
		// create and initialize a File with the String
		var f : File init File.new.initialize_String("c:/temp/test.txt")
		var f2 : File
		// create and initialize a FileWriter with the File
		var fwriter : FileWriter init FileWriter.new.initialize_File(f)
		if (f.exists) then 
			stdio.writeln(f.toString + " already exists")
		else
			stdio.writeln(f.createNewFile.toString)
		end
		fwriter.write_String("Hello world") 
		fwriter.close
		stdio.writeln("file written")
		stdio.writeln(fwriter.toString)
	    	    
		stdio.writeln(f.getPath)
		stdio.writeln(f.separator)
		f2 := f
		stdio.writeln(f2.createNewFile.toString)
		stdio.writeln((f2.equals(f)).toString)
		assert( f2.equals(f))
	    
		var fwriter2 : FileWriter
		fwriter2 :=  fwriter
		stdio.writeln((fwriter2.equals(fwriter)).toString)
		assert( fwriter2.equals(fwriter))
	    
		stdio.writeln(f.getPath)
		stdio.writeln(f.toString)
		stdio.writeln("End")
	end
} 
      		</programlisting>



				<para>
					<literal>includeFilter</literal>
					and
					<literal>excludeFilter</literal>
					accept a comma separated list of
					qualified name.
					<literal>includeFilter</literal>
					adds only elements
					whose qualified name start with one of the list.
					<literal>excludeFilter</literal>
					removes elements whose qualified name
					start with one of the list. If
					you use a combinaison of
					<literal>includeFilter</literal>
					and
					<literal>excludeFilter</literal>
					,
					then the
					<literal>includeFilter</literal>
					is applied before the
					<literal>excludeFilter</literal>
					(that'll remove element from the
					included one.
				</para>

				<para>Currently known limitations: no support for java5 generics
					(they
					are ignored), requiring
					very big jar like the full java
					library end up
					with out of memory error (you need to use the
					includefilter and
					excludeFilter), some bugs with some primitives
					types
					(double/float)
				</para>


			</section>
		</section>

		<section>
			<title>
				Cloning objects
				<phrase id="section_cloning"></phrase>
			</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>
				As we saw in previous sections, class properties can be defined as
				attribute or reference. An
				attribute cannot be shared between two or
				more objects whereas a reference can be. Let's consider
				a class
				"
				<literal>Family</literal>
				" with a property "
				<literal>father</literal>
				"
				(of type "
				<literal>Person</literal>
				") defined as an attribute. In the
				following example, we defined two
				objects of type
				<literal>Family</literal>
				and we want to define the
				<literal>father</literal>
				attribute of the second with the
				<literal>father</literal>
				of the first. To do that, we need to clone the
				object Person which
				represents the father of
				"
				<literal>family1</literal>
				" because, as said in
				<xref linkend="section_assignment_behavior_4_attribute.link" />
				, it could not
				be shared between the two objects, by definition of
				attribute (in
				"technical" words,
				an object cannot be contained by 2
				containers).
			</para>

			<programlisting><emphasis role="strong">class</emphasis> Person 
{
     <emphasis role="strong">attribute</emphasis> name : String
}</programlisting>

			<programlisting><emphasis role="strong">class</emphasis> Family
{
    <emphasis role="strong">attribute</emphasis> father : Person
}

<emphasis role="strong">class</emphasis> Main
{
    <emphasis role="strong">operation</emphasis> run() <emphasis role="strong">is</emphasis>
    <emphasis role="strong">do var</emphasis> family1 : Family <emphasis role="strong">init</emphasis> Family.new
       <emphasis role="strong">var</emphasis> p1 : Person <emphasis role="strong">init</emphasis> Person.new
       p1.name := "Robert"
       family1.father := p1
 <emphasis role="strong">var</emphasis> family2 : Family <emphasis role="strong">init</emphasis> Family.new

       <emphasis>// ERROR 1 : this assigns p1 to family2.father, which 
       // is already owned by family1.father, so it unsets family1.father 
       // family2.father := p1</emphasis>

       <emphasis>// ERROR 2 : this assigns family1.father's value to family2.father, 
       // so it unsets family1.father 
       // family2.father := family1.father</emphasis>

       <emphasis>// This is correct! family2.father keeps its value</emphasis>
       family2.father := Person.clone(p1)
    <emphasis role="strong">end</emphasis>
}</programlisting>

			<para>
				The "
				<literal>clone</literal>
				" method creates a copy of the object
				that it receives as input. If
				it is a complex object, a deep
				clone is
				performed for each attribute
				of its meta-class and a shallow clone
				is
				performed for each
				reference.
			</para>

			<caution>
				<para>
					Reminder : be very careful with the use of the assignment
					operator on
					object. Most of the
					time, you need to use the "clone"
					feature.
					Using assignment on attributes break the previous link
					between
					objects. So, In the previous example, p1 has no more name
					after the
					assignment !There is
					one exception to this behavior : when
					the type
					of attributes are DataType, i.e, in Kermeta,
					String,
					Integer,
					Boolean, the assignment behaves as if those entities were
					defined
					as references.
				</para>
			</caution>
		</section>
	</chapter>

	<chapter id="section_kermeta_metamodel.link">
		<title id="section_kermeta_metamodel.title.link">
			Kermeta Metamodel
			<phrase id="chapter_kermeta_mm"></phrase>
		</title>
		<warning>
			<title>Text not verified for kermeta 2</title>
			<para></para>
		</warning>
		<para>As Kermeta is designed to be used in a model driven environment,
			its
			structure is given as a
			model. This section presents the metamodel
			of
			Kermeta which corresponds to the abstract syntax of
			Kermeta.
		</para>

		<para>This metamodel may be useful for many use cases. For example,
			you
			can use it to manipulate
			your Kermeta code for analysis or even
			generate
			some Kermeta code. This may be useful to understand
			how
			Kermeta works
			too.
		</para>

		<note>
			<para>
				All the code samples in this section are for illustration of
				the given
				concepts.
			</para>
		</note>

		<para>The goal of the Kermeta language is to provide an action
			language
			for MOF models. The idea is
			to start from MOF, which provides
			the
			structure of the language, and to add an action model. Using
			the
			MOF
			to
			define the structure of the Kermeta language has an important
			impact on
			the language. In
			fact, as MOF concepts are Object-Oriented
			concepts,
			Kermeta includes most of the classical
			Object-Oriented
			mechanisms.
			Yet,
			MOF only defines structures, and the operational
			semantic
			corresponding
			to
			MOF concepts has to be defined in Kermeta.
			For instance MOF does not
			provide a
			semantic for behavior inheritance
			(concepts like method
			redefinition, abstract method, etc does not
			have
			any sense in the
			MOF).
		</para>

		<section id="section_architecture.link">
			<title id="section_architecture.title.link">Architecture</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>Kermeta has been designed to be fully compatible with the OMG
				standard meta-data language
				EMOF. The metamodel of Kermeta is
				divided
				into two packages :
			</para>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis>structure</emphasis>
						which corresponds to
						EMOF
					</para>
				</listitem>

				<listitem>
					<para>
						<emphasis>behavior</emphasis>
						which corresponds to the
						actions. This section gives an overview of
						these two packages and
						their
						relationships.
					</para>
				</listitem>
			</itemizedlist>

			<para>Thanks to this reuse, Kermeta is fully compatible with EMOF.
				This
				is useful in the promotion
				of Kermeta as a metalanguage.
			</para>

			<figure id="refIllustration1">
				<title>EMOF extension and Kermeta promotion</title>

				<mediaobject>
					<imageobject>
						<imagedata fileref="Kermeta-Manual_figures/kermeta_emof_promotion.png" />
					</imageobject>
				</mediaobject>
			</figure>

			<note>
				<para>
					This weaving of behavior into MOF has been explained in

					<ulink url="http://www.kermeta.org/documents/articles/Muller05a">Pierre-Alain
						Muller, Franck Fleurey, and Jean-Marc
						Jézéquel. -- Weaving
						executability into object-oriented
						meta-languages. -- In S. Kent L.
						Briand, editor, Proceedings
						of
						MODELS/UML'2005, volume 3713 of LNCS,
						pages 264--278, Montego Bay,
						Jamaica, October 2005.
						Springer.
					</ulink>
				</para>
			</note>

			<para>
				The link between structure and behavior is made through the
				property
				<literal>body</literal>
				of class
				<literal>Operation</literal>
				which allows to define the behavior of an operation using a Kermeta
				expression.
			</para>

			<para>A more detailed description of the architecture of Kermeta is
				presented in next sections.
			</para>
		</section>

		<section>
			<title>Structure package</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<figure id="refIllustration10">
				<title>Structure package</title>

				<mediaobject>
					<imageobject>
						<imagedata
							fileref="external_figures/org.kermeta.language.model_ecore/kermeta_language_structure_PackageView.png" />
					</imageobject>
				</mediaobject>
			</figure>

			<para>This figure presents the main classes of the structure package.
				To
				design this package, we
				started from EMOF and completed it to
				build the
				Kermeta language. The choice of EMOF is motivated
				by two
				main
				reasons :
				firstly it is standardized by the OMG and secondly is
				is well-supported
				by
				tools such as Eclipse/EMF.
			</para>

			<para>
				As MOF is not initially designed to be executable, several
				concepts
				have to be completed and
				slightly modified to build an
				executable
				language. The first and most important modification is to
				add
				the
				ability to define the behavior of operations. To achieve this we
				define an action language
				in the package
				<literal>behavior</literal>
				<emphasis>
				</emphasis>
				of Kermeta. The class
				hierarchy of the package behavior is presented
				on
				<xref linkend="refIllustration11" />
				. In practice, Kermeta expressions have
				been designed by adding model
				modification capabilities
				(like assignment
				of properties for
				instance) to OCL expressions.
			</para>

			<para>This represents the static part of the metamodel.</para>

			<para>As a reminder, the structure of Kermeta is derived from EMOF
				from
				the OMG. During the build
				process, we merge and connect it with
				the
				behavior part.
			</para>

			<para>So all the meaning of those metaclasses are very close to those
				described in the OMG
				standard specification.
			</para>
			<section>
				<title>NamedElement view</title>

				<figure id="refIllustrationNamedElementView">
					<title>NamedElement class diagram</title>
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="external_figures/org.kermeta.language.model_ecore/kermeta_language_named_elements.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para>This figure presents the element in the structure package that
					have a name.
					Kermeta relies
					on in various situation (For example in
					the typechecking
					process).
					The containment hierarchy is
					also
					presented since it is used in the
					identification process.
				</para>
				<para>Class is a bit special, since its name is a derived property.
				</para>
			</section>
			<section>
				<title>Type system view</title>

				<figure id="refIllustrationTypeSystemBigPictureView">
					<title>Kermeta type system class diagram (the big picture)</title>
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="external_figures/org.kermeta.language.model_ecore/kermeta_language_complete_type_system.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para>This figure presents the global view of all the metaclasses
					involved in Kermeta type
					system.
				</para>
				<para>Basically, you can notice the split between Type and
					TypeDefinion needed in order to handle
					generics.
				</para>
				<para>The containment is also represented here.</para>
				<para>
					Please note that there is both
					<literal>Type</literal>
					and
					<literal>TypeDefinition</literal>
					. This is needed
					because of the support of the generics. For example
					in
				</para>
				<programlisting language="kermeta">var mycoll : Collection&lt;String&gt;</programlisting>
				<para>
					mycoll is a VariableDecl which point to a
					<literal>Class</literal>
					whose typeDefinition is the ClassDefinition
					<literal>Collection</literal>
					and has a TypeVariableBinding that lead to String.
				</para>
				<para>TODO add an object diagram or a figure to illustrate.</para>
				<para>TODO : if time : provide a set of small diagrams that focus of
					some elements of the type
					system.
				</para>
				<section>
					<title>ModelType and ModelType adaptation view</title>

					<figure id="refIllustrationModelTypeView">
						<title>Kermeta ModelType system class diagram</title>
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="external_figures/org.kermeta.language.model_ecore/kermeta_language_model_type.png" />
							</imageobject>
						</mediaobject>
					</figure>

					<para>This figure presents the global view of the main metaclasses
						involved in Kermeta
						ModelType.
					</para>

					<figure id="refIllustrationModelTypeAdaptationView">
						<title>Kermeta ModelType adaptation class diagram</title>
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="external_figures/org.kermeta.language.model_ecore/kermeta_language_model_type_adaptation.png" />
							</imageobject>
						</mediaobject>
					</figure>

					<para>This figure presents the view of the main metaclasses
						used by
						the ModelType adaptation.
					</para>
				</section>
			</section>
		</section>

		<section>
			<title>Behavior package</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<figure id="refIllustrationkermeta_language_behavior_packageView">
				<title>Behavior package</title>

				<mediaobject>
					<imageobject>
						<imagedata
							fileref="external_figures/org.kermeta.language.model_ecore/kermeta_language_behavior_packageView.png" />
					</imageobject>
				</mediaobject>
			</figure>
			<figure id="refIllustrationkermeta_language_behavior">
				<title>Behavior main metaclasses</title>

				<mediaobject>
					<imageobject>
						<imagedata fileref="external_figures/org.kermeta.language.model_ecore/kermeta_language_behavior.png" />
					</imageobject>
				</mediaobject>
			</figure>

			<para></para>

			<section>
				<title>Control Structures</title>

				<para>Kermeta provides basic control structures : block, conditional
					branch, loop, and exception
					handling. Here there an excerpt of the
					Meta-model describing control structures. Each basic
					control
					structures derives from the Expression concept.
				</para>

				<figure id="refIllustration12">
					<title>Control structure</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/kermeta_control_struct.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para></para>
			</section>

			<section>
				<title>Variables</title>

				<figure id="refIllustration13">
					<title>Use of variables</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/kermeta_var_expressions.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para></para>
			</section>

			<section>
				<title>Call Expressions</title>

				<figure id="refIllustration14">
					<title>use of exceptions</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/kermeta_call_expressions.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para></para>

				<section>
					<title>CallSuperOperation</title>

					<para>
						In the following example, the type of
						<emphasis>super(element)</emphasis>
						is
						<emphasis>CallSuperOperation</emphasis>
						:
					</para>

					<programlisting><emphasis role="strong">class</emphasis> ParentClass {
    <emphasis role="strong">operation</emphasis> op(element : Integer) : Integer <emphasis
						role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := element + 1
    <emphasis role="strong">end</emphasis>

}

<emphasis role="strong">class</emphasis> ChildClass {
    <emphasis role="strong">method</emphasis> op(element : Integer) : Integer <emphasis
						role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := <emphasis role="strong">super</emphasis>(element)
    <emphasis role="strong">end</emphasis>
}</programlisting>
				</section>

				<section>
					<title>CallVariable</title>

					<para>
						The type of
						<emphasis>callvar</emphasis>
						, below, is CallVariable:
					</para>

					<programlisting>
var myvar : Integer
var callvar : Integer init 4
// 
myvar := callvar </programlisting>

					<para>
						A special case, when calling a lambda expression : the type of
						<emphasis>lf</emphasis>
						in the assignment of res, is
						CallVariable.
					</para>

					<programlisting language="kermeta">
var lf : &lt;Integer-&gt;Integer&gt;
var res : Integerlf := function  { i : Integer | i.plus(1) }
// The type of lf, below, is CallVariable
res := lf(4)
          </programlisting>
				</section>

				<section>
					<title>CallResult</title>

					<para>
						The type of
						<emphasis>result</emphasis>
						is
						<emphasis>CallResult</emphasis>
					</para>

					<programlisting><emphasis role="strong">operation</emphasis> op() : Integer <emphasis
						role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
    <emphasis role="strong">result</emphasis> := 61
<emphasis role="strong">end</emphasis></programlisting>
				</section>

				<section>
					<title>CallFeature and SelfExpression</title>

					<itemizedlist>
						<listitem>
							<para>
								The type of
								<emphasis>self</emphasis>
								is a
								SelfExpression!
							</para>
						</listitem>

						<listitem>
							<para>
								The type of
								<emphasis>attr</emphasis>
								in the body of the
								operation myoperation is
								<emphasis>CallFeature</emphasis>
								<emphasis role="strong">
								</emphasis>
								(a callfeature on
								<emphasis>self</emphasis>
								), and so
								is the type of
								<emphasis>myoperation(4)</emphasis>
								(a
								callfeature on
								<emphasis role="strong">a</emphasis>
								).
							</para>
						</listitem>
					</itemizedlist>

					<programlisting><emphasis role="strong">class</emphasis> A {
    <emphasis role="strong">attribute</emphasis> attr : Integer
    <emphasis role="strong">operation</emphasis> myoperation(param : Integer) : Integer <emphasis
						role="strong">is</emphasis> <emphasis role="strong">do</emphasis>
        <emphasis role="strong">result</emphasis> := <emphasis role="strong">self</emphasis>.attr + param
    <emphasis role="strong">end</emphasis>
}
<emphasis role="strong">class</emphasis> B {
    <emphasis role="strong">operation</emphasis> anotheroperation() : Integer <emphasis
						role="strong">is do</emphasis>
        <emphasis role="strong">var</emphasis> a : A
        <emphasis role="strong">result</emphasis> := a.myoperation(4)
    <emphasis role="strong">end</emphasis>
}</programlisting>
				</section>
			</section>

			<section>
				<title>Assignment</title>

				<figure id="refIllustration15">
					<title>Kermeta assignment expression</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/kermeta_assign_expressions.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para></para>

				<para>
					In the following example,
					<emphasis>thetarget</emphasis>
					is of
					type
					<emphasis>CallExpression </emphasis>
					and
					<emphasis>thevalue</emphasis>
					is of type
					<emphasis>Expression</emphasis>
					.
				</para>

				<programlisting><emphasis role="strong">var</emphasis> num : Numeric
<emphasis role="strong">var</emphasis> thetarget : Integer
<emphasis role="strong">var</emphasis> thevalue : Integer
// assignment : <emphasis role="strong">thetarget-&gt;</emphasis><emphasis>target</emphasis>, <emphasis
					role="strong">thevalue-&gt;</emphasis><emphasis>value</emphasis>
thetarget := thevalue
// casting : <emphasis role="strong">a</emphasis> is casted into the type of <emphasis
					role="strong">num</emphasis> which is Numeric.
num ?= a</programlisting>
			</section>

			<section>
				<title>Literals</title>

				<figure id="refIllustration16">
					<title>Kermeta Literal Expression</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/kermeta_literal_expressions.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para></para>

				<programlisting><emphasis role="strong">var</emphasis> i : Integer
i := 5    <emphasis>// 5 is a IntegerLiteral</emphasis>
<emphasis role="strong">var</emphasis> s : String 
s := "I am a string" <emphasis>// "I am a string" is a StringLiteral</emphasis></programlisting>
			</section>

			<section id="section_lambda_expression_mm.link">
				<title id="section_lambda_expression_mm.title.link">
					Lambda
					Expression
					<phrase id="section_lambda_expression_mm"></phrase>
				</title>

				<figure id="refIllustration17">
					<title>Kermeta lambda expressions</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="Kermeta-Manual_figures/kermeta_lambda_expressions.png" />
						</imageobject>
					</mediaobject>
				</figure>
			</section>
		</section>
		<section>
			<title>Unresolved view</title>
			<note>
				<title>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="gfx/fire.png" contentdepth="2em" />
						</imageobject>
					</inlinemediaobject>
					New in Kermeta 2
				</title>
				<para></para>
			</note>
			<para>
				In Kermeta 2, in order to delegate the resolution work to the tool,
				it use a specific internal
				structure based on
				<literal>Unresolved</literal>
				metaclass. The resolver will transform every
				<literal>Unresolved</literal>
				into the final real
				ModelElement. This allow to
				build transformations that generate valid km
				models without the difficulty of dealing with the
				framework default types and the resolving of km
				model splitted in several files.
				All Kermeta 2 internal transformations like kmt2km, ecore2km,
				qvt2km use this mechanism.
			</para>
			<figure id="refIllustration_kermeta_language_unresolved">
				<title>Unresolved view</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="external_figures/org.kermeta.language.model_ecore/kermeta_language_unresolved.png" />
					</imageobject>
				</mediaobject>
			</figure>
		</section>
		<section>
			<title>Viewing Kermeta metamodel</title>
			<warning>
				<title>Text not verified for kermeta 2</title>
				<para></para>
			</warning>
			<para>In Kermeta, you can view its metamodel by several ways.</para>

			<para>First, the ecore file kermeta_java.ecore is available in the
				lib
				folder of Kermeta main
				plugin.It is used when saving a Kermeta
				program
				in XMI ("Compile to XMI" function on *.kmt files).
				You can
				then load
				Kermeta program as a model, typically to transform it.
			</para>

			<warning>
				<para>
					You should not try to execute operations on Kermeta models
					you've just
					dynamically created
					unless you froze it. This is a
					feature which
					has not been completly tested.
				</para>
			</warning>

			<para>
				Another typical way to access to a Kermeta model and Kermeta
				metamodel is to use the reflection.
				All objects inherits from Object
				that defines the
				<literal>getMetaClass</literal>
				operation. This use is
				used in one of the samples of
				<xref linkend="section_dynamic_expressions.link" />
				(when it selects an
				operation to be executed).
			</para>

			<para>
				At last, the parse method on dynamic expression presented in
				section
				<xref endterm="section_dynamic_expressions.title.link" linkend="section_dynamic_expressions.link" />
				can give you some way to
				access a Kermeta model as it parses a
				Kermeta text and provides the
				corresponding model.
			</para>
		</section>
	</chapter>

	<chapter>
		<title>
			Kermeta framework
			<phrase id="chapter_framework"></phrase>
		</title>
		<warning>
			<title>Text not verified for kermeta 2</title>
			<para></para>
		</warning>
		<para>Kermeta is bundled with a framework that provides the base
			functionalities for metamodel
			engineering.
		</para>

		<tip>
			<para>
				When you write
				<literal>require kermeta</literal>
				at the head of your file, you are importing the file framework.km
				located in the Kermeta plugin.
			</para>
		</tip>

		<para>Currently, it provides the following packages :</para>

		<variablelist>
			<title>Packages in Kermeta framework</title>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename role="strong">kermeta::interpreter</filename>
					</emphasis>
				</term>

				<listitem>
					<para>
						This package defines some classes related to Kermeta
						interpreter
						and also to Kermeta surface
						syntax. Some uses of this
						package are
						illustrated in
						<xref linkend="section_dynamic_expressions.link" />
						.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::persistence</filename>
					</emphasis>
				</term>

				<listitem>
					<para>
						This package defines the notion required to serialize and
						deserialize models. This is
						illustrated in
						<xref linkend="section_loadingsaving_models.link" />
						and in the EMF
						tutorial document (
						<ulink type="" url="http://www.kermeta.org/documents/emfTutorial/">http://www.kermeta.org/documents/emfTutorial/
						</ulink>
						)
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::kunit</filename>
					</emphasis>
				</term>

				<listitem>
					<para>This is a basic support for unitary tests (like Junit but for
						Kermeta).
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::language::structure</filename>
					</emphasis>
				</term>

				<listitem>
					<para>It contains the classes of Kermeta structure. Note that it
						slightly differs from the
						kermeta_java.ecore due to an inheritance
						to the classes in Kermeta::reflexion. However, it
						proposes the
						very
						same functionalities.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::language::behavior</filename>
					</emphasis>
				</term>

				<listitem>
					<para>It contains the classes for the behavior of Kermeta.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::exceptions</filename>
					</emphasis>
				</term>

				<listitem>
					<para>It defines various exceptions that you can use in Kermeta.
						Inheriting from
						kermeta::exceptions::Exception allows to give more
						information to the end user because it will
						also provide a stack
						trace (which would not be available otherwise).
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::io</filename>
					</emphasis>
				</term>

				<listitem>
					<para>This package provides basic support for input/output with
						Kermeta. It is voluntary minimal
						because that not the main role of
						Kermeta to provide such primitives. In the future, this
						package
						may
						even disappear and be replaced by the ability to directly call
						Java
						libraries.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::reflection</filename>
					</emphasis>
				</term>

				<listitem>
					<para>This package contains all the abstract classes needed for the
						reflexivity of Kermeta. The
						concrete implementation are in
						kermeta::standard or kermeta::structure.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::utils</filename>
					</emphasis>
				</term>

				<listitem>
					<para>This package defines various tool classes that cannot be part
						of the core of the language,
						but are important enough to be part
						of
						the framework.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>
					<emphasis role="strong">
						<filename>kermeta::standard</filename>
					</emphasis>
				</term>

				<listitem>
					<para>This package defines all the basic objects needed for a
						typical Kermeta application. For
						example, it defines data types,
						collections, etc.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<note>
			<para>
				For more details about the content of these packages, please look at
				the generated documentation
				available on line:
				<ulink type="" url="http://www.kermeta.org/docs/KermetaFramework/framework.km.html">http://www.kermeta.org/docs/KermetaFramework/framework.km.html
				</ulink>
			</para>
		</note>
	</chapter>

	<appendix id="appendix_keywords.link">
		<title id="appendix_keywords.title.link">Language keywords</title>
		<warning>
			<title>Text not verified for kermeta 2</title>
			<para></para>
		</warning>
		<para>The following keywords are used by Kermeta textual syntax.
		</para>

		<note>
			<para>
				If you want to name some class or property using those names,
				you'll
				need to escape them using the
				~ (tilda).Ex:
				<literal>class ~class
					{}
				</literal>
			</para>

			<para>
				(See
				<xref linkend="section_reserved_keywords.link" />
				)
			</para>
		</note>

		<informaltable>
			<tgroup cols="2">
				<colspec colname="c1" colwidth="1*" />

				<colspec colname="c2" colwidth="3*" />

				<thead>
					<row>
						<entry align="left">
							<para>Keyword</para>
						</entry>

						<entry align="left">
							<para>Usage</para>
						</entry>
					</row>
				</thead>

				<tbody>
					<row>
						<entry>
							<para>@pre</para>
						</entry>

						<entry align="left">
							<para>
								Represents self before the call to this
								operation in the scope of
								a post condition. See
								<xref linkend="section_pre_post_syntax.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>abstract</para>
						</entry>

						<entry align="left">
							<para>Modifier for class or
								operation
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>alias</para>
						</entry>
						<entry>
							<para>Definition of a primitive type</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>and</para>
						</entry>

						<entry>
							<para>Boolean expression</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>aspect</para>
						</entry>
						<entry>
							<para>
								Modifier for class. Indicates that the class reopen another class. See
								<xref linkend="section_weaving.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>attribute</para>
						</entry>

						<entry>
							<para>Definition of an attribute</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>bag</para>
						</entry>

						<entry align="left">
							<para>
								See
								<xref linkend="section_collections.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>class</para>
						</entry>

						<entry align="left">
							<para>Definition of a class</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>do</para>
						</entry>

						<entry align="left">
							<para>Beginning of a block</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>else</para>
						</entry>

						<entry align="left">
							<para>Else part of a conditional
								instruction
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>end</para>
						</entry>

						<entry align="left">
							<para>End of a block</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>enumeration</para>
						</entry>

						<entry>
							<para>Definition of an enumeration</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>extern</para>
						</entry>

						<entry align="left">
							<para>Call of a java static
								operation
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>false</para>
						</entry>

						<entry>
							<para>Boolean literal</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>from</para>
						</entry>

						<entry align="left">
							<para>Loop instruction</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>function</para>
						</entry>

						<entry align="left">
							<para>Declares a local function</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>getter</para>
						</entry>

						<entry>
							<para>Declaration of a property getter</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>if</para>
						</entry>

						<entry align="left">
							<para>Conditional instruction</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>inherits</para>
						</entry>

						<entry align="left">
							<para>Declartion of the super classes of the
								class
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>init</para>
						</entry>

						<entry>
							<para>
								Initialization of a variable. In Kermeta 2, this can be replaced by
								<literal>:=</literal>
							</para>
						</entry>
					</row>

					<row>
						<entry align="left">
							<para>inv</para>
						</entry>

						<entry align="left">
							<para>
								Declaration of an invariant. See
								<xref linkend="section_inv_syntax.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>is</para>
						</entry>

						<entry align="left">
							part of the declaration of an operation or
							method. See
							<xref linkend="section_defining_operations.link" />
						</entry>
					</row>

					<row>
						<entry>
							<para>loop</para>
						</entry>

						<entry align="left">
							<para>Loop instruction</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>method</para>
						</entry>

						<entry align="left">
							<para>
								Redefinition of an operation. See
								<xref linkend="section_defining_operations.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>modeltype</para>
						</entry>

						<entry align="left">
							<para>Definition of a
								modeltype.
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>not</para>
						</entry>

						<entry>
							<para>Boolean expression</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>operation</para>
						</entry>

						<entry align="left">
							<para>
								Declaration of an operation. See
								<xref linkend="section_defining_operations.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>or</para>
						</entry>

						<entry>
							<para>Boolean expression</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>oset</para>
						</entry>

						<entry align="left">
							<para>
								See
								<xref linkend="section_collections.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>package</para>
						</entry>

						<entry>
							<para>Declaration of package</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>post</para>
						</entry>

						<entry>
							<para>
								Declaration of a postcondition. See
								<xref linkend="section_pre_post_syntax.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry align="left">
							<para>pre</para>
						</entry>

						<entry align="left">
							<para>
								Declaration of a precondition. See
								<xref linkend="section_pre_post_syntax.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>property</para>
						</entry>

						<entry>
							<para>Declaration of a derived property</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>raise</para>
						</entry>

						<entry align="left">
							<para>Throw an exception</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>raises</para>
						</entry>

						<entry>
							<para>Declares the exception that an operation can
								throw
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>readonly</para>
						</entry>

						<entry>
							<para>Modifier for properties</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>reference</para>
						</entry>

						<entry align="left">
							<para>Declaration of a
								reference
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>rescue</para>
						</entry>

						<entry align="left">
							<para>Catch an excetion</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>result</para>
						</entry>

						<entry>
							<para>
								Special variable used for the return value of an
								operation. See
								<xref linkend="section_defining_operations.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>setter</para>
						</entry>

						<entry>
							<para>Declaration of property setter</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>self</para>
						</entry>

						<entry align="left">
							<para>Special varaible representing this
								instances
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>set </para>
						</entry>

						<entry align="left">
							<para>
								See
								<xref linkend="section_collections.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>seq</para>
						</entry>

						<entry align="left">
							<para>
								See
								<xref linkend="section_collections.link" />
							</para>
						</entry>
					</row>
					<row>
						<entry>
							<para>singleton</para>
						</entry>
						<entry align="left">
							<para>
								Definition of a singleton class. See
								<xref linkend="section_singleton_class.link" />
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>super </para>
						</entry>

						<entry align="left">
							<para>Call to the super
								operation
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>then</para>
						</entry>

						<entry align="left">
							<para>Then part of a conditional
								instruction
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>true</para>
						</entry>

						<entry align="left">
							<para>Boolean literal</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>until</para>
						</entry>

						<entry align="left">
							<para>Loop condition</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>using</para>
						</entry>

						<entry>
							<para>Shortcut used to avoid to write the full qualified
								name
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>value</para>
						</entry>

						<entry align="left">
							<para>Special variable used in getter and
								setter to represent the
								actual value of the
								property
							</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>var</para>
						</entry>

						<entry>
							<para>Declaration of a variable</para>
						</entry>
					</row>

					<row>
						<entry>
							<para>void</para>
						</entry>

						<entry>
							<para>Void literal</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
	</appendix>
	<appendix id="appendix_knowntags.link">
		<title id="appendix_knowntags.title.link">Known Kermeta tags</title>
		<warning>
			<title>Text not verified for kermeta 2</title>
			<para></para>
		</warning>
		<para>This annex collect the use of known tags.
			They are generally used
			as an extension on Kermeta
			in these typically
			uses :
		</para>
		<itemizedlist>
			<listitem>
				<simpara>supporting Ecore compatibility,</simpara>
			</listitem>
			<listitem>
				<simpara>preparing a future language improvement,</simpara>
			</listitem>
			<listitem>
				<simpara>supporting a specific need that isn't part of the language
					core.
				</simpara>
			</listitem>
		</itemizedlist>
		<note>
			<para>TODO : finish this by looking into kermeta2ecore transformation
			</para>
		</note>
		<variablelist>
			<title>Kown tags :</title>
			<varlistentry>
				<term>
					<varname>aspect</varname>
				</term>
				<listitem>
					<formalpara>
						<title>Possible values</title>
						<para>"true", case insensitive, any other value is considered as
							"false".
						</para>
					</formalpara>
					<formalpara>
						<title>Context</title>
						<para>Class
						</para>
					</formalpara>
					<formalpara>
						<title>Use description</title>
						<para>Old way to indicate that a Class must be reopened as an
							aspect of another Class and
							then
							merging its features. We now
							prefer to use the dedicated
							keyword.
						</para>
					</formalpara>
					<formalpara>
						<title>Use sample</title>
						<para>
							<programlisting language="kermeta">@aspect "true"
class MyClas {
// ...
}</programlisting>
						</para>
					</formalpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<varname>ecoreUri</varname>
				</term>
				<listitem>
					<formalpara>
						<title>Possible values</title>
						<para>An nsURI.
						</para>
					</formalpara>
					<formalpara>
						<title>Context</title>
						<para>Package
						</para>
					</formalpara>
					<formalpara>
						<title>Use description</title>
						<para>Indicates the nsUri for the given package when it is
							transformed in Ecore.
						</para>
					</formalpara>
					<formalpara>
						<title>Use sample</title>
						<para>
							<programlisting language="kermeta">@ecoreUri "http://myPackage/1.0/"
package myPackage;
</programlisting>
						</para>
					</formalpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<varname>mainClass</varname>
				</term>
				<listitem>
					<formalpara>
						<title>Possible values</title>
						<para>Qualified name of a class in the Kermeta program.
						</para>
					</formalpara>
					<formalpara>
						<title>Context</title>
						<para>ModelingUnit
						</para>
					</formalpara>
					<formalpara>
						<title>Use description</title>
						<para>Indicates a preferred class from which the run configuration
							should try to start the
							Kermeta program.
							This helps to create a
							default run configuration.
							Must be used with the
							mainOperation
							tag.
						</para>
					</formalpara>
					<formalpara>
						<title>Use sample</title>
						<para>
							<programlisting language="kermeta">@mainClass "myPackage::MyMainClass"
@mainOperation "main"

package myPackage;

require kermeta
class MyMainClass
{
	operation main() : Void is do 
		// TODO: implement 'main' operation
	end
}</programlisting>
						</para>
					</formalpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<varname>mainOperation</varname>
				</term>
				<listitem>
					<formalpara>
						<title>Possible values</title>
						<para>name of an operation in the main class.
						</para>
					</formalpara>
					<formalpara>
						<title>Context</title>
						<para>ModelingUnit
						</para>
					</formalpara>
					<formalpara>
						<title>Use description</title>
						<para>Indicates a preferred operation from which the run
							configuration should try to start the
							Kermeta program.
							This helps
							to create a default run configuration.
							Must be used with the
							mainClass tag. The operation must : either have
							no parameter, or
							have string parameters.
						</para>
					</formalpara>
					<formalpara>
						<title>Use sample</title>
						<para>
							<programlisting language="kermeta">@mainClass "myPackage::MyMainClass"
@mainOperation "main"

package myPackage;

require kermeta
class MyMainClass
{
	operation main() : Void is do 
		// TODO: implement 'main' operation
	end
}</programlisting>
						</para>
					</formalpara>
				</listitem>
			</varlistentry>
		</variablelist>

	</appendix>

	<appendix id="appendix_KermetaEcore.link">
		<title id="appendix_KermetaEcore.title.link">Kermeta / Ecore mapping</title>
		<warning>
			<title>Text not verified for kermeta 2</title>
			<para></para>
		</warning>
		<para>Kermeta natively integrates Ecore defintions, however it uses an
			internal mapping in order to
			import ecore model as Kermeta models.
			In
			the other way round a Kermeta model can be translated into
			a pure
			ecore model. (for example in the compiler)
		</para>
		<para>This annex indicates how Kermeta models are translated into
			Ecore models and vice versa.
		</para>
		<note>
			<para>TODO : finish this by looking into kermeta2ecore transformation
				and the compiler
				specifications.
			</para>
		</note>
		<informaltable>
			<tgroup cols="3" align="left">
				<colspec colname="c1" colwidth="1*" align="left" />
				<colspec colname="c2" colwidth="1*" align="left" />
				<colspec colname="c3" colwidth="3*" align="left" />
				<thead>
					<row>
						<entry align="left">
							<para>Kermeta concept</para>
						</entry>
						<entry align="left">
							<para>Ecore concept</para>
						</entry>
						<entry align="left">
							<para>Notes</para>
						</entry>
					</row>
				</thead>

				<tbody valign="top">
					<row>
						<entry>
							<para>Class</para>
						</entry>
						<entry>
							<para>EClass</para>
						</entry>
						<entry>
							<para></para>
						</entry>
					</row>
					<row>
						<entry>
							<para>Constraint (invariant)</para>
						</entry>
						<entry>
							<para>EAnnotation(source="kermeta.inv") + DetailEntry</para>
						</entry>
						<entry>
							<para></para>
						</entry>
					</row>
					<row>
						<entry>
							<para>Constraint (precondition|postcondition)</para>
						</entry>
						<entry>
							<para>EAnnotation(source="kermeta.pre"|"kermeta.post") +
								DetailEntry
							</para>
						</entry>
						<entry>
							<para></para>
						</entry>
					</row>
					<row>
						<entry>
							<para>Constraint (postcondition)</para>
						</entry>
						<entry>
							<para>EAnnotation(source="") + DetailEntry</para>
						</entry>
						<entry>
							<para></para>
						</entry>
					</row>
					<row>
						<entry>
							<para>Operation</para>
						</entry>
						<entry>
							<para>EOperation</para>
						</entry>
						<entry>
							<para></para>
						</entry>
					</row>
					<row>
						<entry>
							<para>Tag (general case)</para>
						</entry>
						<entry>
							<para>EAnnotation(source="kermeta") + DetailEntry</para>
						</entry>
						<entry>
							<para>
								Most Tags are translated into an EAnnotation with
								source="kermeta" and one DetailEntry with
								key=
								<replaceable>NameOfTheTag</replaceable>
								and value=
								<replaceable>ValueOfTheTag</replaceable>
								.
								If this is a /** */ comment, the name of the tag is
								"documentation".
							</para>
						</entry>
					</row>
					<row>
						<entry>
							<para>Tag (applied on Constraint)</para>
						</entry>
						<entry>
							<para>EAnnotation(source="kermeta.inv.doc") + DetailEntry</para>
						</entry>
						<entry>
							<para>
								EAnnotation.references points to the EAnnotation
								representing the
								Constraints. DetailEntry
								with key=
								<replaceable>NameOfTheTag</replaceable>
								and value=
								<replaceable>ValueOfTheTag</replaceable>
								.
								If this is a /** */ comment, the name of the tag is
								"documentation".
							</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
	</appendix>
</book>