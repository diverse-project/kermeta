package imperativeocl;


using root_package

/**
* iteration on a collection similar to collect or select
* TODO : what if there are more iterator ?
*/
aspect class ImperativeIterateExp {

method range2domain(context : Qvt2KermetaContext) : Void is do
	if output==void then
		
		//stdio.writeln("ImperativeIterateExp")
	
		var iterateCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		
		if (name =="xcollect") 
		then
			iterateCall.name:="collect"
		else
			if name == "xselect" then
				iterateCall.name:="select"
			else
				if name == "selectOne" then
					iterateCall.name:="detect"
				else
					iterateCall.name:=name
					stdio.writeln("name : "+name)
				end
			end
		end
		
		var lambdaExp : kermeta::language::behavior::LambdaExpression init kermeta::language::behavior::LambdaExpression.new
		
		iterator.each{x|x.toLambdaParameter() lambdaExp.parameters.add(x.output.asType(kermeta::language::behavior::LambdaParameter))}
		iterateCall.parameters.add(lambdaExp)
		if body!=void then
			body.range2domain(context)
			lambdaExp.body?=body.output
		end
		
		
		//if condition is instance of TypeExp, then the condition is a type check
		if condition!=void then
			
			condition.range2domain(context)
			if condition.isInstanceOf(essentialocl::TypeExp) then 
				var typeCheckCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				typeCheckCall.name:="isInstanceOf"
				typeCheckCall.parameters.add(condition.output.asType(kermeta::language::behavior::Expression))
				typeCheckCall.target:=kermeta::language::behavior::CallVariable.new.initName(lambdaExp.parameters.one.name)
				lambdaExp.body:=typeCheckCall
				
			else
				lambdaExp.body?=condition.output
			end
		end
		
		source.range2domain(context)
		iterateCall.target?=source.output
		
		if 	name != "selectOne" and
			(condition!=void)
			.andThen{x|condition.isInstanceOf(essentialocl::TypeExp)} then
			
			//a sequence<X> cannot be casted as a sequence<Y> even if X>Y
			//hence we created the deferred sequences
			
			var deferredcast : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			deferredcast.name:="fromSeq"
			
			var dSeqInit : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			deferredcast.target:=dSeqInit
			dSeqInit.name:="new"
			
			var dseqCD : kermeta::language::structure::ClassDefinition 
			dseqCD?=context.kmtContext.getFromQualifiedName("kermeta::standard::DeferredSequence")
			
			var paramTypeCD : kermeta::language::structure::ClassDefinition
			condition.asType(essentialocl::TypeExp).referredType.range2domain(context)
			paramTypeCD?=condition.asType(essentialocl::TypeExp).referredType.output
			
			var dseqLit : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
			dSeqInit.target:=dseqLit
			dseqLit.typeref:=dseqCD.generateParameterizedTypeRef(paramTypeCD)
			
			deferredcast.parameters.add(iterateCall)
			
			output:=deferredcast
			
			/*
			var castCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			castCall.name := "asType"
			var castLit : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
			
			var paramTypeCD : kermeta::language::structure::ClassDefinition
			condition.asType(essentialocl::TypeExp).referredType.range2domain()
			paramTypeCD?=condition.asType(essentialocl::TypeExp).referredType.output
			
			var seqCD : kermeta::language::structure::ClassDefinition
			seqCD?=KmtLib.getDefault.asType(KmtLib).getFromQualifiedName("kermeta::standard::Sequence")
			
			castLit.typeref:=seqCD.generateParameterizedTypeRef(paramTypeCD)
		
			castCall.parameters.add(castLit)
			castCall.target:=iterateCall
			output:=castCall
				*/		
		else
			output:=iterateCall
		end 
		
	end
end

}

aspect class AssignExp {


operation isMulti(x : essentialocl::OclExpression) : kermeta::standard::Boolean is do
	var t : emof::Type init x.type
	
	result:=t.isInstanceOf(essentialocl::CollectionType)
	
	
end


	/** depends on multivaluation of left expression*/
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then 
			stdio.writeln("AssignExp  -left type : "+left.getMetaClass.name)
		
			if left.isInstanceOf(essentialocl::PropertyCallExp)
					.andThen{x|left.asType(essentialocl::PropertyCallExp).referredProperty.upper != 1} then 
					//or
				//left.isInstanceOf(essentialocl::VariableExp).andThen{x| left.asType(essentialocl::VariableExp).referredVariable.representedParameter.upper  != 1} 
				
				var out : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				output:=out
				
				left.range2domain(context)
				out.target?=left.output
				
				self.~value.each{x|x.range2domain(context)}
				//TODO take care of multivalued assignement
				stdio.writeln("value size : "+~value.size.toString)
				out.parameters.add(self.~value.one.output.asType(kermeta::language::behavior::Expression))
				if isMulti(self.~value.one) then
					if isReset() then
						out.name:="clearAndAddAll"
					else
						out.name:="qvtAddAll"
					end
				else
					if isReset() then
						out.name:="clearAndAdd"
					else
						out.name:="add"
					end
				end
			else		
				
				
					
				var out : kermeta::language::behavior::Assignment init kermeta::language::behavior::Assignment.new
				output:=out
				
				
				//should be an add if type of left is a declared collection
				left.range2domain(context)
				out.target?=left.output
				self.~value.each{x|x.range2domain(context)}
				//TODO take care of multivalued assignement
				stdio.writeln("value size : "+~value.size.toString)
				out.~value?=self.~value.one.output
				
			end
		end
	end


}

aspect class VariableInitExp {

/*TODO
	check withResult

*/

	method range2domain(context : Qvt2KermetaContext) : Void from kermeta::language::structure::Object is do
		if output==void then
			var out : kermeta::language::behavior::VariableDecl
			out:=referredVariable.toVariableDecl(context)
			output:=out
		end
	end

}

aspect class LogExp {
	method range2domain(context : Qvt2KermetaContext) : Void from kermeta::language::structure::Object is do
		if output==void then
			//check condition if exists
			var out : kermeta::language::behavior::Conditional init kermeta::language::behavior::Conditional.new
			output:=out
			if condition==void then
				var condition : kermeta::language::behavior::BooleanLiteral init kermeta::language::behavior::BooleanLiteral.new
				condition.~value:=true
				out.condition:=condition
			else
				condition.range2domain(context)
				out.condition?=condition.output
			end
			var block : kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
			out.thenBody:=block
			
			
			//print the message
			var writelnFeature : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			block.statement.add(writelnFeature)
			if argument.size>1 then
				writelnFeature.name:="write"
			else
				writelnFeature.name:="writeln"
			end
			
			var stdioVar : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
			writelnFeature.target:=stdioVar
			stdioVar.name:="stdio"
			
			argument.one.range2domain(context)
			writelnFeature.parameters.add(argument.one.output.asType(kermeta::language::behavior::Expression))
			
			//print the second argument
			if argument.size>1 then
				var writelnFeature2 : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				block.statement.add(writelnFeature2)
				writelnFeature2.name:="writeln"
				
				var stdioVar2 : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
				writelnFeature2.target:=stdioVar2
				stdioVar2.name:="stdio"
				
				var toStringFeature : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				writelnFeature2.parameters.add(toStringFeature)
				toStringFeature.name:="toString"
				argument.elementAt(2).range2domain(context)
				toStringFeature.target?=argument.elementAt(2).output
			end
		end
	end

}

aspect class ReturnExp {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
				var out : kermeta::language::behavior::Raise init kermeta::language::behavior::Raise.new
				output:=out
				
				var newExp : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				newExp.name:="new"

				var exceptionLiteral : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
				newExp.target:=exceptionLiteral
				var exceptionCD : kermeta::language::structure::ClassDefinition
				
				exceptionCD?= context.kmtContext.getFromQualifiedName("root_package::ReturnException")
				exceptionLiteral.typeref:=exceptionCD.generateTypeRef()
				
				
			if ~value!=void then
				var returnValueAssign : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				out.expression:=returnValueAssign
				returnValueAssign.name:="returnWithValue"
				returnValueAssign.target:=newExp
				~value.range2domain(context)
				returnValueAssign.parameters.add(~value.output.asType(kermeta::language::behavior::Expression))
			else
				out.expression:=newExp				
			end
		end
	end


}

aspect class BreakExp {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
				var out : kermeta::language::behavior::Raise init kermeta::language::behavior::Raise.new
				output:=out
				
				var newExp : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				newExp.name:="new"

				var exceptionLiteral : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
				newExp.target:=exceptionLiteral
				var exceptionCD : kermeta::language::structure::ClassDefinition
				
				exceptionCD?= context.kmtContext.getFromQualifiedName("root_package::BreakException")
				exceptionLiteral.typeref:=exceptionCD.generateTypeRef()
				
				out.expression:=newExp				
			
		end
	end


}

aspect class ContinueExp {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
				var out : kermeta::language::behavior::Raise init kermeta::language::behavior::Raise.new
				output:=out
				
				var newExp : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				newExp.name:="new"

				var exceptionLiteral : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
				newExp.target:=exceptionLiteral
				var exceptionCD : kermeta::language::structure::ClassDefinition
				
				exceptionCD?= context.kmtContext.getFromQualifiedName("root_package::ContinueException")
				exceptionLiteral.typeref:=exceptionCD.generateTypeRef()
				
				out.expression:=newExp				
			
		end
	end


}


/**todo : gérer les break ?*/
aspect class SwitchExp{

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			var out : kermeta::language::behavior::Conditional init kermeta::language::behavior::Conditional.new
			output:=out
			
			var currentCondition : kermeta::language::behavior::Conditional init out
			from var iter : kermeta::standard::Iterator<AltExp> init alternativePart.iterator
			until iter.isOff
			loop
				var alternative : AltExp init iter.next
				alternative.body.range2domain(context)
				alternative.condition.range2domain(context)
				currentCondition.condition?=alternative.condition.output
				currentCondition.thenBody?=alternative.body.output
				
				if not iter.isOff then
					var newCondition : kermeta::language::behavior::Conditional init kermeta::language::behavior::Conditional.new
					currentCondition.elseBody:=newCondition
					currentCondition:=newCondition
				else
					elsePart.range2domain(context)
					
					currentCondition.elseBody?=elsePart.output
				end
			end
		end
	end
}


aspect class CatchExp {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			var out : kermeta::language::behavior::Rescue init kermeta::language::behavior::Rescue.new
			output := out
			if body.empty then 
				out.body.add(kermeta::language::behavior::VoidLiteral.new)
			else
				body.each{x|x.range2domain(context)
				out.body.add(x.output.asType(kermeta::language::behavior::Expression))
				}
			end
			
			//todo what if many exceptions ?
			exception.one.range2domain(context)
			out.exceptionType:=exception.one.generateType(context).generateTypeRef()
		end
	end
	

}

aspect class BlockExp {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			var out : kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
			output:=out
			body.each{x|x.range2domain(context)
				out.statement.add(x.output.asType(kermeta::language::behavior::Expression))
				}
			//in qvtop a block return a void
			out.statement.add(kermeta::language::behavior::VoidLiteral.new)
			
		end
	end

}


aspect class DictLiteralExp {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then 
			var out : kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
			output:=out
			//generate declaration
			var varDec : kermeta::language::behavior::VariableDecl init kermeta::language::behavior::VariableDecl.new
			out.statement.add(varDec)
			varDec.identifier:=self.name
			
			varDec.type:=self.type.generateType(context).generateTypeRef()
			
			//add values
			
			part.each{ p|
				var callPut : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				out.statement.add(callPut)
				callPut.name:="put"
				var callTable : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
				callPut.target:=callPut
				callTable.name:=varDec.identifier
				p.key.range2domain(context)
				callPut.parameters.add(p.key.output.asType(kermeta::language::behavior::Expression))
				p.~value.range2domain(context)
				callPut.parameters.add(p.~value.output.asType(kermeta::language::behavior::Expression))
			}
			
			
			
			
		end
	end 


}

aspect class DictionaryType {
	
	method generateType(context : Qvt2KermetaContext) : kermeta::language::structure::Type is do
		result?=output
	end
	
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then 
			var out : kermeta::language::structure::Class init kermeta::language::structure::Class.new
			output:=out
			var cd : kermeta::language::structure::ClassDefinition
			cd?=context.kmtContext.getFromQualifiedName("kermeta::utils::Hashtable")
			out.typeDefinition:=cd 
			var tvarBinding1 : kermeta::language::structure::TypeVariableBinding init kermeta::language::structure::TypeVariableBinding.new
			tvarBinding1.variable :=cd.typeParameter.one
			out.typeParamBinding.add(tvarBinding1)
			
			elementType.range2domain(context)
			tvarBinding1.type:=elementType.generateType(context)
			
			if tvarBinding1.type.container==void then 
				tvarBinding1.containedType.add(tvarBinding1.type)
			end
			var tvarBinding2 : kermeta::language::structure::TypeVariableBinding init kermeta::language::structure::TypeVariableBinding.new
			tvarBinding2.variable :=cd.typeParameter.elementAt(1)
			out.typeParamBinding.add(tvarBinding2)
			
			keyType.range2domain(context)
			tvarBinding2.type:=keyType.generateType(context)
			
			if tvarBinding1.type.container==void then 
				tvarBinding1.containedType.add(tvarBinding1.type)
			end

		end
	end
	

}

/*
aspect class ComputeExp { 

	method range2domain() : Void is do
		if output==void then
			var out : kermeta::language::behavior::VarDecl init kermeta::language::behavior::VarDecl.new
			output:=out
			out.name:=returnedElement.identifier
			
			
		
		end
	end

}*/
