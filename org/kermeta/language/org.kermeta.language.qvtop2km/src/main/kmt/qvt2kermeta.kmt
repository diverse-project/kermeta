

package root_package;


using kermeta::persistence
using kermeta::standard
using kermeta::io
using kermeta::emfpersistence
using kermeta::exceptions
using kermeta::utils


class Qvt2KermetaContext {

	reference frameworkOperationMap : Hashtable<String,String>

	reference qvtContext : QvtLib
	
	reference kmtContext : KmtLib
	
	reference tuplePool : TuplePool
	reference rootMU : org::kermeta::language::structure::ModelingUnit
	
	reference transfoContextCD : org::kermeta::language::structure::ClassDefinition

	operation initialize() : Qvt2KermetaContext is do
		
		qvtContext:=QvtLib.new
		kmtContext:=KmtLib.new
		tuplePool:= TuplePool.new
		result:=self
	
	end

	
}


class Qvt2Kermeta{

reference srcModel : Resource
reference tgtModel : Resource

operation main() : Void is do
		do
		var context : Qvt2KermetaContext init Qvt2KermetaContext.new.initialize()
		
		//getMetaClass.typeDefinition.asType(org::kermeta::language::structure::ClassDefinition).defaultObject:=self
		
		StdIO.writeln("qvt->kermeta")
		
		
		var sourceRepository     : ResourceSet init ResourceSet.new
		
		//srcModel := sourceRepository.createResource("../test/Book2Publication2.qvtoperational", "../models/api2.ecore")
		//srcModel := sourceRepository.createResource("../test/Ecore2EMOF.qvtoperational", "../models/api2.ecore")
		//srcModel := sourceRepository.createResource("../test/UML2RDBMS.qvtoperational", "../models/api2.ecore")
		//srcModel := sourceRepository.createResource("../../org.topcased.simulation.sam.control/transformation/org.topcased.simulation.sam.control.sam2samdynamic.qvtoperational", "../models/api2.ecore")
		StdIO.writeln("0")
		srcModel := sourceRepository.createResource("platform:/resource/org.kermeta.language.qvtop2km/tests/transfo-qvt/book2pub1/Book2Publication.qvtoperational", "platform:/resource/org.kermeta.language.qvtop2km/ecore/QVTOperational.ecore")
		StdIO.writeln("00")
		srcModel.load(void)
		sourceRepository.resolveAllProxies()
		sourceRepository.getResources().each{r|StdIO.writeln(r.asType(Resource).getURI().toString())}
		StdIO.writeln("1")
		
		context.qvtContext.load(sourceRepository.getResource("platform:/plugin/fr.tm.elibel.smartqvt.qvt/models/essentialocl/oclstdlib.essentialocl",true))
		StdIO.writeln("2")
		context.qvtContext.load(sourceRepository.getResource("platform:/plugin/fr.tm.elibel.smartqvt.qvt/model/PrimitiveTypes.emof",true))
		StdIO.writeln("3")
		context.qvtContext.load(sourceRepository.getResource("platform:/plugin/fr.tm.elibel.smartqvt.qvt/models/qvtoperational/qvtstdlib.qvtoperational",true))
		StdIO.writeln("4")
		context.qvtContext.load(sourceRepository.getResource("platform:/plugin/fr.tm.elibel.smartqvt.external/ecore/ecore.emof",true))
		StdIO.writeln("5")
		
		var targetRepository : ResourceSet init ResourceSet.new
        //tgtModel := targetRepository.createResource("../test/Book2Publication.km" , "http://www.kermeta.org/kermeta/1_2_0//kermeta")
        //tgtModel := targetRepository.createResource("../test/Ecore2EMOF.km" , "http://www.kermeta.org/kermeta/1_2_0//kermeta")
		//tgtModel := targetRepository.createResource("../test/UML2RDBMS.km" , "http://www.kermeta.org/kermeta/1_2_0//kermeta")
		tgtModel := targetRepository.createResource("platform:/resource/org.kermeta.language.qvtop2km/tests/transfo-km/book2pub1/Book2Publication.km" , "http://www.kermeta.org/kermeta/2_0_0/")
		StdIO.writeln("6")
		
		
		//var kmtResource : Resource init targetRepository.createResource("platform:/plugin/fr.irisa.triskell.kermeta.io/src/kermeta/framework.km","http://www.kermeta.org/kermeta/1_2_0//kermeta")
		//kmtResource.load(void)
		//var transfoContextResource : Resource init targetRepository.createResource("platform:/resource/qvt-kermeta/transformation/kmt-transfocontext/TransfoContext.km","http://www.kermeta.org/kermeta/1_2_0//kermeta")
		//transfoContextResource.load(void) 
		//var sequenceCastResource : Resource init targetRepository.createResource("platform:/resource/qvt-kermeta/transformation/collectioncast/SequenceCast.km","http://www.kermeta.org/kermeta/1_2_0//kermeta")
		//sequenceCastResource.load(void) 
		
		
		//context.kmtContext.load(transfoContextResource)
		//context.kmtContext.load(kmtResource)
		//context.kmtContext.load(sequenceCastResource)

		mapFrameworks(context)
		StdIO.writeln("7")
		transform(context)
		StdIO.writeln("8")
		//StdIO.writeln("tgtModel size " +tgtModel.size().toString())

		
		
		tgtModel.save(void)
		StdIO.writeln("done")
		//rescue (x:Exception)
		//StdIO.writeln("there has been an error") 
		rescue (y : CallOnVoidTarget)
		StdIO.writeln("null pointer exception") 
		end
end




operation transform(context : Qvt2KermetaContext) : Void is do
	StdIO.writeln("t1")
	var kRoot : org::kermeta::language::structure::ModelingUnit
	var emofTransfo : qvtoperational::OperationalTransformation
	
	
	StdIO.writeln("t2")
	srcModel.getContents().select{x|x.isInstanceOf(qvtoperational::ModelType)}.each{x|StdIO.writeln(x.getMetaClass.typeDefinition.name) x.asType(emof::Object).range2domain(context) tgtModel.getContents().add(x.asType(emof::Object).output)}
	StdIO.writeln("t3")
	emofTransfo?= srcModel.getContents().detect{x|x.isInstanceOf(qvtoperational::OperationalTransformation)}
	StdIO.writeln("t4")
	emofTransfo.range2domain(context)
	StdIO.writeln("t5")
	kRoot?=emofTransfo.output
	context.rootMU :=kRoot
	StdIO.writeln("t6")
	emofTransfo.genClassDefinition(context)
	StdIO.writeln("t7")
	emofTransfo.ownedOperation.each{op| if (op!=void).andThen{x|op.isInstanceOf(qvtoperational::MappingOperation)} then op.range2domain(context) end }
	emofTransfo.ownedOperation.each{op| if (op!=void).andThen{x|op.isInstanceOf(qvtoperational::Helper)} then op.range2domain(context) end }
	emofTransfo.ownedOperation.each{op| if (op!=void).andThen{x|op.isInstanceOf(qvtoperational::EntryOperation)} then op.range2domain(context) end }
	var kmtRequire : org::kermeta::language::structure::Require init org::kermeta::language::structure::Require.new
	StdIO.writeln("t8")
	kmtRequire.uri:="kermeta"
	kRoot.requires.add(kmtRequire)
	
	//generate the default primitive types
	var ptPack : org::kermeta::language::structure::Package 
	var emofPtPack : emof::Package
	emofPtPack?=context.qvtContext.getFromQVTID("primitivetypes")
	emofPtPack.range2domain(context)
	ptPack ?=emofPtPack.output
	StdIO.writeln("ptPack "+ptPack.ownedTypeDefinition.size.toString())
	ptPack.ownedTypeDefinition.each{x|StdIO.write(x.name+" "+x.toString+" ")}
	StdIO.writeln("")
	kRoot.packages.add(ptPack)
	
	//transform the package ecore from platform:/plugin/fr.tm.elibel.smartqvt.external/ecore/ecore.emof
	var ecorePack : emof::Package init context.qvtContext.getFromQVTID("ecore").asType(emof::Package)
	ecorePack.range2domain(context)
	//tgtModel.add(ecorePack.output)
	kRoot.packages.add(ecorePack.output.asType(org::kermeta::language::structure::Package))
	
	
	//var extensionRequire : org::kermeta::language::structure::Require init org::kermeta::language::structure::Require.new
	//extensionRequire.uri:="platform:/resource/qvt-kermeta/transformation/framework_extension/collection_extension.kmt"
	//kRoot.requires.add(extensionRequire)
	var transfoContextRequire : org::kermeta::language::structure::Require init org::kermeta::language::structure::Require.new
	transfoContextRequire.uri := "platform:/resource/qvt-kermeta/transformation/kmt-transfocontext/TransfoContext.kmt"
	kRoot.requires.add(transfoContextRequire)
	
	var deferredColRequire : org::kermeta::language::structure::Require init org::kermeta::language::structure::Require.new
	deferredColRequire.uri := "platform:/resource/qvt-kermeta/transformation/collectioncast/SequenceCast.kmt"
	kRoot.requires.add(deferredColRequire)
	
	tgtModel.getContents().add(kRoot)
	
	mergeMU(tgtModel)
end


operation mergeMU(r : Resource) : Void is do
	var uniqueRoot: org::kermeta::language::structure::ModelingUnit init org::kermeta::language::structure::ModelingUnit.new
	
	tgtModel.getContents().each{x| 
		if x.isInstanceOf(org::kermeta::language::structure::ModelingUnit) 
		then 
			uniqueRoot.packages.addAll(x.asType(org::kermeta::language::structure::ModelingUnit).packages)
			uniqueRoot.requires.addAll(x.asType(org::kermeta::language::structure::ModelingUnit).requires)
		end }
	
	tgtModel.getContents().clear
	tgtModel.getContents().add(uniqueRoot)
	
	
end


//TODO mapping between the 2 frameworks
operation mapFrameworks(context : Qvt2KermetaContext) : Void is do 

	context.frameworkOperationMap := Hashtable<String,String>.new
	
	context.frameworkOperationMap.put("OclLib::String::concat","kermeta::standard::String::plus")
	
	context.frameworkOperationMap.put("OclLib::OclAny::=","kermeta::standard::Object::equals")
	context.frameworkOperationMap.put("OclLib::OclObject::=","kermeta::standard::Object::equals")
	context.frameworkOperationMap.put("OclLib::OclAny::oclIsKindOf","kermeta::standard::Object::isInstanceOf")
	context.frameworkOperationMap.put("::QvtLib::OclElement::isKindOf","kermeta::standard::Object::isInstanceOf" )
	context.frameworkOperationMap.put("::QvtLib::OclElement::asType","kermeta::standard::Object::asType")
	
	context.frameworkOperationMap.put("OclLib::Collection::isEmpty","kermeta::standard::Collection::isEmpty")
	context.frameworkOperationMap.put("OclLib::Sequence::asOrderedSet","kermeta::standard::Collection::asOrderedSet")
	context.frameworkOperationMap.put("OclLib::Sequence::first","kermeta::standard::OrderedCollection::first")
	context.frameworkOperationMap.put("OclLib::Boolean::and","kermeta::standard::Boolean::and")
	context.frameworkOperationMap.put("OclLib::Boolean::not","kermeta::standard::Boolean::not")
end
/* TODO code mort
operation map2FrameworkObjects(source: String, target : String, context : Qvt2KermetaContext) : Void is do

var sourceObject : Object

sourceObject := context.qvtContext.getFromQVTID(source)

var targetObject : Object

targetObject := context.kmtContext.getFromQualifiedName(target)
sourceObject.asType(emof::Object).output:=targetObject




end
*/


}

class QvtNotImplementedException inherits kermeta::exceptions::Exception {

attribute notImplementedPart : String


	operation initialize(missingPart : String) : QvtNotImplementedException is do
		message:=missingPart + " not yet implemented, wait for the final version."
		result:=self
	end

}

