

package root_package;


using kermeta::persistence
using kermeta::standard
using kermeta::io
using kermeta::emfpersistence


class Qvt2KermetaContext {



	reference qvtContext : QvtLib
	
	reference kmtContext : KmtLib
	
	reference tuplePool : TuplePool
	reference rootMU : org::kermeta::language::structure::ModelingUnit
	
	reference transfoContextCD : org::kermeta::language::structure::ClassDefinition

	operation initialize() : Qvt2KermetaContext is do
		
		qvtContext:=QvtLib.new
		kmtContext:=KmtLib.new
		tuplePool:= TuplePool.new
		result:=self
	
	end

	
}


class Qvt2Kermeta{

reference srcModel : Resource
reference tgtModel : Resource

operation main() : Void is do

		var context : Qvt2KermetaContext init Qvt2KermetaContext.new.initialize()
		
		//getMetaClass.typeDefinition.asType(org::kermeta::language::structure::ClassDefinition).defaultObject:=self
		
		StdIO.writeln("qvt->kermeta")
		
		
		var sourceRepository     : ResourceSet init ResourceSet.new
		
		//srcModel := sourceRepository.createResource("../test/Book2Publication2.qvtoperational", "../models/api2.ecore")
		//srcModel := sourceRepository.createResource("../test/Ecore2EMOF.qvtoperational", "../models/api2.ecore")
		//srcModel := sourceRepository.createResource("../test/UML2RDBMS.qvtoperational", "../models/api2.ecore")
		srcModel := sourceRepository.createResource("../../org.topcased.simulation.sam.control/transformation/org.topcased.simulation.sam.control.sam2samdynamic.qvtoperational", "../models/api2.ecore")
		srcModel.load(void)
		sourceRepository.getResources().each{r|StdIO.writeln(r.asType(Resource).getURI().toString())}
		
		
		context.qvtContext.load(sourceRepository.getResource("pathmap://models/essentialocl/oclstdlib.essentialocl",true))
		context.qvtContext.load(sourceRepository.getResource("platform:/plugin/fr.tm.elibel.smartqvt.qvt/model/PrimitiveTypes.emof",true))
		context.qvtContext.load(sourceRepository.getResource("pathmap://models/qvtoperational/qvtstdlib.qvtoperational",true))
		context.qvtContext.load(sourceRepository.getResource("platform:/plugin/fr.tm.elibel.smartqvt.external/ecore/ecore.emof",true))
		
		
		var targetRepository : ResourceSet init ResourceSet.new
        //tgtModel := targetRepository.createResource("../test/Book2Publication.km" , "http://www.kermeta.org/kermeta/1_2_0//kermeta")
        //tgtModel := targetRepository.createResource("../test/Ecore2EMOF.km" , "http://www.kermeta.org/kermeta/1_2_0//kermeta")
		//tgtModel := targetRepository.createResource("../test/UML2RDBMS.km" , "http://www.kermeta.org/kermeta/1_2_0//kermeta")
		tgtModel := targetRepository.createResource("../test/sam2samdyn.km" , "http://www.kermeta.org/kermeta/1_2_0//kermeta")
		
		
		
		var kmtResource : Resource init targetRepository.createResource("platform:/plugin/fr.irisa.triskell.kermeta.io/src/kermeta/framework.km","http://www.kermeta.org/kermeta/1_2_0//kermeta")
		kmtResource.load(void)
		var transfoContextResource : Resource init targetRepository.createResource("platform:/resource/qvt-kermeta/transformation/kmt-transfocontext/TransfoContext.km","http://www.kermeta.org/kermeta/1_2_0//kermeta")
		transfoContextResource.load(void) 
		var sequenceCastResource : Resource init targetRepository.createResource("platform:/resource/qvt-kermeta/transformation/collectioncast/SequenceCast.km","http://www.kermeta.org/kermeta/1_2_0//kermeta")
		sequenceCastResource.load(void) 
		
		
		context.kmtContext.load(transfoContextResource)
		context.kmtContext.load(kmtResource)
		context.kmtContext.load(sequenceCastResource)
		
		
		mapFrameworks(context)
		transform(context)
		
		//StdIO.writeln("tgtModel size " +tgtModel.size().toString())

		
		
		tgtModel.save(void)
		StdIO.writeln("done")
end




operation transform(context : Qvt2KermetaContext) : Void is do
	var kRoot : org::kermeta::language::structure::ModelingUnit
	var emofTransfo : qvtoperational::OperationalTransformation
	
	
	
	srcModel.getContents().select{x|x.isInstanceOf(qvtoperational::ModelType)}.each{x|x.asType(emof::Object).range2domain(context) tgtModel.getContents().add(x.asType(emof::Object).output)}
	
	emofTransfo?= srcModel.getContents().detect{x|x.isInstanceOf(qvtoperational::OperationalTransformation)}
	emofTransfo.range2domain(context)
	kRoot?=emofTransfo.output
	context.rootMU :=kRoot
	emofTransfo.genClassDefinition(context)
	emofTransfo.ownedOperation.each{op| if (op!=void).andThen{x|op.isInstanceOf(qvtoperational::MappingOperation)} then op.range2domain(context) end }
	emofTransfo.ownedOperation.each{op| if (op!=void).andThen{x|op.isInstanceOf(qvtoperational::Helper)} then op.range2domain(context) end }
	emofTransfo.ownedOperation.each{op| if (op!=void).andThen{x|op.isInstanceOf(qvtoperational::EntryOperation)} then op.range2domain(context) end }
	var kmtRequire : org::kermeta::language::structure::Require init org::kermeta::language::structure::Require.new
	
	kmtRequire.uri:="kermeta"
	kRoot.requires.add(kmtRequire)
	
	//generate the default primitive types
	var ptPack : org::kermeta::language::structure::Package 
	var emofPtPack : emof::Package
	emofPtPack?=context.qvtContext.getFromQVTID("primitivetypes")
	emofPtPack.range2domain(context)
	ptPack ?=emofPtPack.output
	StdIO.writeln("ptPack "+ptPack.ownedTypeDefinition.size.toString())
	ptPack.ownedTypeDefinition.each{x|StdIO.write(x.name+" "+x.toString+" ")}
	StdIO.writeln("")
	kRoot.packages.add(ptPack)
	
	//transform the package ecore from platform:/plugin/fr.tm.elibel.smartqvt.external/ecore/ecore.emof
	var ecorePack : emof::Package init context.qvtContext.getFromQVTID("ecore").asType(emof::Package)
	ecorePack.range2domain(context)
	//tgtModel.add(ecorePack.output)
	kRoot.packages.add(ecorePack.output.asType(org::kermeta::language::structure::Package))
	
	
	//var extensionRequire : org::kermeta::language::structure::Require init org::kermeta::language::structure::Require.new
	//extensionRequire.uri:="platform:/resource/qvt-kermeta/transformation/framework_extension/collection_extension.kmt"
	//kRoot.requires.add(extensionRequire)
	var transfoContextRequire : org::kermeta::language::structure::Require init org::kermeta::language::structure::Require.new
	transfoContextRequire.uri := "platform:/resource/qvt-kermeta/transformation/kmt-transfocontext/TransfoContext.kmt"
	kRoot.requires.add(transfoContextRequire)
	
	var deferredColRequire : org::kermeta::language::structure::Require init org::kermeta::language::structure::Require.new
	deferredColRequire.uri := "platform:/resource/qvt-kermeta/transformation/collectioncast/SequenceCast.kmt"
	kRoot.requires.add(deferredColRequire)
	
	tgtModel.getContents().add(kRoot)
	
	mergeMU(tgtModel)
end


operation mergeMU(r : Resource) : Void is do
	var uniqueRoot: org::kermeta::language::structure::ModelingUnit init org::kermeta::language::structure::ModelingUnit.new
	
	tgtModel.getContents().each{x| 
		if x.isInstanceOf(org::kermeta::language::structure::ModelingUnit) 
		then 
			uniqueRoot.packages.addAll(x.asType(org::kermeta::language::structure::ModelingUnit).packages)
			uniqueRoot.requires.addAll(x.asType(org::kermeta::language::structure::ModelingUnit).requires)
		end }
	
	tgtModel.getContents().clear
	tgtModel.getContents().add(uniqueRoot)
	
	
end


//TODO mapping between the 2 frameworks
operation mapFrameworks(context : Qvt2KermetaContext) : Void is do 


map2FrameworkObjects("OclLib::String::concat","kermeta::standard::String::plus", context)
map2FrameworkObjects("OclLib::OclAny::=","kermeta::standard::Object::equals", context)
map2FrameworkObjects("OclLib::OclObject::=","kermeta::standard::Object::equals", context)
map2FrameworkObjects("OclLib::OclAny::oclIsKindOf","kermeta::standard::Object::isInstanceOf", context)
map2FrameworkObjects("::QvtLib::OclElement::isKindOf","kermeta::standard::Object::isInstanceOf" , context)
map2FrameworkObjects("::QvtLib::OclElement::asType","kermeta::standard::Object::asType", context)

map2FrameworkObjects("OclLib::Collection::isEmpty","kermeta::standard::Collection::isEmpty", context)
map2FrameworkObjects("OclLib::Sequence::asOrderedSet","kermeta::standard::Collection::asOrderedSet", context)
map2FrameworkObjects("OclLib::Sequence::first","kermeta::standard::OrderedCollection::first", context)
map2FrameworkObjects("OclLib::Boolean::and","kermeta::standard::Boolean::and", context)
map2FrameworkObjects("OclLib::Boolean::not","kermeta::standard::Boolean::not", context)
end

operation map2FrameworkObjects(source: String, target : String, context : Qvt2KermetaContext) : Void is do

var sourceObject : Object

sourceObject := context.qvtContext.getFromQVTID(source)

var targetObject : Object

targetObject := context.kmtContext.getFromQualifiedName(target)
sourceObject.asType(emof::Object).output:=targetObject




end



}

class QvtNotImplementedException inherits kermeta::exceptions::Exception {

attribute notImplementedPart : String


	operation initialize(missingPart : String) : QvtNotImplementedException is do
		message:=missingPart + " not yet implemented, wait for the final version."
		result:=self
	end

}

