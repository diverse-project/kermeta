package essentialocl;
using root_package
using kermeta::standard
using kermeta::io
using org::kermeta::language
aspect class CollectionItem {
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			var out : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new
			output:=out
			out.name:="add"
			
			
			var collection : essentialocl::CollectionLiteralExp
			collection ?=container
			
			var collectionVar : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
			out.target:=collectionVar
			collectionVar.name:=collection.collectionTmpId
			item.range2domain(context)
			out.parameters.add(item.output.asType(org::kermeta::language::behavior::Expression))
			
			
		
		end
	end

}
	
	
	
/** definition inlined of a collection in qvt*/
aspect class CollectionLiteralExp {
	
	reference collectionTmpId : kermeta::standard::String
	
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			var out : org::kermeta::language::behavior::Block init org::kermeta::language::behavior::Block.new
			output:=out
			out.addDocumentationTag("gen from essentialocl::CollectionLiteralExp")
			
			//variable declaration of the Collection
			var vDecl : org::kermeta::language::behavior::VariableDecl init org::kermeta::language::behavior::VariableDecl.new
			out.statement.add(vDecl)
						//TODO find a way to generate random identifiers that won't collide with existing identifiers
			vDecl.identifier:="collectionliteral"
			collectionTmpId:=vDecl.identifier
			type.range2domain(context)
			var seqClass : org::kermeta::language::structure::Class
			seqClass?=type.output
			
			vDecl.containedType.add(seqClass)
			/*	TODO remove if the following call to generateTypeRef works well 
			var tRef : org::kermeta::language::behavior::TypeReference init org::kermeta::language::behavior::TypeReference.new
			tRef.lower:=0
			tRef.upper:=1
			tRef.type?=type.output
			if (tRef.type.isInstanceOf(org::kermeta::language::structure::Class)) then
				tRef.name:=tRef.type.asType(org::kermeta::language::structure::Class).name
			end*/
			
			vDecl.type:=type.output.asType(org::kermeta::language::structure::Type).generateTypeRef
			
			//init
			
			var callNew : org::kermeta::language::behavior::CallOperation init org::kermeta::language::behavior::CallOperation.new
			vDecl.initialization:=callNew
			callNew.name:="new"
			var typeLit : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
			callNew.target:=typeLit
			
			typeLit.typeref:=seqClass.cloneClass.generateTypeRef			
			

			
			
			
			//add all the collection items
			part.each{x|
					x.range2domain(context)
					out.statement.add(x.output.asType(org::kermeta::language::behavior::Expression))
					}
				
			var returnVariable : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
			returnVariable.name:=collectionTmpId
			
			out.statement.add(returnVariable)
			
			//var vnew : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
				
				
		end
	end
	
}





/**call to a Property*/
aspect class PropertyCallExp{

	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do
		StdIO.writeln("PropertyCallExp::range2domain")
		var out : org::kermeta::language::behavior::CallProperty init org::kermeta::language::behavior::CallProperty.new
		referredProperty.range2domain(context)
		out.staticProperty?=referredProperty.output
		out.name:=referredProperty.name
		
		source.range2domain(context)
		out.target?=source.output
		output:=out
		StdIO.writeln("PropertyCallExp::range2domain-end")
	end

}



aspect class IteratorExp {

	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do
		if output==void then
		
		
		var out : org::kermeta::language::behavior::CallOperation init org::kermeta::language::behavior::CallOperation.new
		
		output:=out
		if name =="collect" then
			out.name:="collect"
		else
			if name == "select" then
				out.name:="select"
			else
				if name == "selectOne" then
					out.name:="detect"
				else
					out.name:=name
					StdIO.writeln("name : "+name)
				end
			end
		end
		
		var lambdaExp : org::kermeta::language::behavior::LambdaExpression init org::kermeta::language::behavior::LambdaExpression.new
		
		out.parameters.add(lambdaExp)
	
		if body!=void then
			body.range2domain(context)
			lambdaExp.body?=body.output
		end
		
		
		source.range2domain(context)
		out.target?=source.output
		
		iterator.each{x|x.toLambdaParameter() lambdaExp.parameters.add(x.output.asType(org::kermeta::language::behavior::LambdaParameter))}
		
		end
	end

}


aspect class OperationCallExp {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do
		if output==void then
			StdIO.writeln("OperationCallExp::range2domain")
			//either the operation is coming from the initial framework
			var out : org::kermeta::language::behavior::CallOperation init org::kermeta::language::behavior::CallOperation.new
			output:=out
			StdIO.writeln("OperationCallExp::range2domain-0")
			if context.qvtContext.libs.contains(referredOperation.containingResource()) and referredOperation.output==void then
				StdIO.writeln("OperationCallExp::range2domain-1")
				//in kermeta the flatten operation from sequence return a bag of objects
				//should return flatten.asSequence.asType(Sequence<X>) where X is the type of the flatten operation in qvt
				//unfortunately, this kind of cast is not possible in kermeta and must be simulated using deferredsequence
				if referredOperation.getQVTID()=="OclLib::Sequence::flatten" then
					
					var operationType : essentialocl::SequenceType init self.type.asType(essentialocl::SequenceType)
					operationType.elementType.range2domain(context)

					var asSeqType : behavior::UnresolvedCall init behavior::UnresolvedCall.new.createProxySequence(operationType.elementType.generateType(context))
					
					var flattenFeature : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("flatten",true)
					asSeqType.target :=flattenFeature
					
					source.range2domain(context)
					flattenFeature.target?=source.output
					
					/*var deferredcast : org::kermeta::language::behavior::CallOperation
					deferredcast:=out
					deferredcast.name:="fromSeq"
			
					var dSeqInit : org::kermeta::language::behavior::CallOperation init org::kermeta::language::behavior::CallOperation.new
					deferredcast.target:=dSeqInit
					dSeqInit.name:="new"
					
					var dseqCD : org::kermeta::language::structure::ClassDefinition 
					dseqCD?=context.kmtContext.getFromQualifiedName("kermeta::standard::DeferredSequence")
					
					StdIO.writeln("OperationCallExp::range2domain-2")*/
					/*
					//here the sequence type is transformed in a class with the appropriated generic type so we shouldn't use
					//the generateTypeRef method
					var operationTypeTR : org::kermeta::language::behavior::TypeReference init org::kermeta::language::behavior::TypeReference.new
					typeLit.typeref:= operationTypeTR
					
					operationTypeTR.type:=operationType.generateType()
					operationTypeTR.containedType.add(operationTypeTR.type)
					operationTypeTR.upper:=1
					operationTypeTR.lower:=0
					operationTypeTR.isUnique:=false
					
					*/
					
					
					
					
					
					
					/*var dseqLit : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
					dSeqInit.target:=dseqLit
					dseqLit.typeref:=dseqCD.generateParameterizedTypeRef(operationType.elementType.output.asType(org::kermeta::language::structure::ClassDefinition))

					var asSequenceFeature : org::kermeta::language::behavior::CallOperation init org::kermeta::language::behavior::CallOperation.new
					deferredcast.parameters.add(asSequenceFeature)
					asSequenceFeature.name:="asSequence"
					
					var flattenFeature : org::kermeta::language::behavior::CallOperation init org::kermeta::language::behavior::CallOperation.new
					asSequenceFeature.target :=flattenFeature
					flattenFeature.name:="flatten"
					source.range2domain(context)
					flattenFeature.target?=source.output
					flattenFeature.staticOperation:=context
											.kmtContext
											.getFromQualifiedName("kermeta::standard::Sequence::flatten")
											.asType(org::kermeta::language::structure::Operation)
					*/
					//get the parameter from the type of the operation which is a sequenceType
					
					/*var typeLit : org::kermeta::language::behavior::TypeLiteral init org::kermeta::language::behavior::TypeLiteral.new
					out.parameters.add(typeLit)
					operationType.range2domain()*/
				end
				//why this qvtid starts with :: is still a mystery
				if referredOperation.getQVTID()=="::QvtLib::Model::objects" then
					out.name:="extent"
					source.range2domain(context)
					out.target?=source.output
				end
				StdIO.writeln("OperationCallExp::range2domain-3")
				if referredOperation.getQVTID() =="::QvtLib::Model::objectsOfType" then
					out.name:="objectsOfType"
					source.range2domain(context)
					out.target?=source.output
					argument.each{x|
						x.range2domain(context) 
						if x.output!=void then 
							out.parameters.add(x.output.asType(org::kermeta::language::behavior::Expression)) 
						else 
							//StdIO.writeln("output is void for a : "+ x.getMetaClass.name) 
						end
						}
				end
				
	
				StdIO.write("THIS IS A STANDARD METHOD")
				StdIO.writeln(" referredOperation name : "+ referredOperation.getQVTID)
			else
				//or not
				StdIO.writeln("OperationCallExp::range2domain-4")
				
				//if there is a source model
				if source!=void then
					source.range2domain(context)
					out.target?=source.output
				else
					var transfoCall : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new.callToTransfoContextSingleton(context)
					out.target:=transfoCall
				end
				StdIO.writeln("OperationCallExp::range2domain-5")
				if (referredOperation !=void) then
					
					referredOperation.range2domain(context)
					out.staticOperation?=referredOperation.output
					if out.staticOperation==void then
						out.name:=referredOperation.name
					else
						out.name:=out.staticOperation.name
					end
					StdIO.writeln("referredOperation name : "+ referredOperation.name)
				end
				StdIO.writeln("OperationCallExp::range2domain-6")
				argument.each{x|
						x.range2domain(context) 
						if x.output!=void then 
							out.parameters.add(x.output.asType(org::kermeta::language::behavior::Expression)) 
						else 
							//StdIO.writeln("output is void for a : "+ x.getMetaClass.name) 
						end
						}
				
			end
		end
	end
	
}
	
	
aspect abstract class OclExpression {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do
		//StdIO.writeln("oclexpression metaclass "+self.getMetaClass.name)
		output:=void
	end
	
}
	

	
aspect class VariableExp {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do
		var out: org::kermeta::language::behavior::Expression
		if (referredVariable.name=="result") then
			 out:= org::kermeta::language::behavior::CallResult.new
		else
			if (referredVariable.name=="self") then
				out:= org::kermeta::language::behavior::SelfExpression.new
			else
				if referredVariable.isInstanceOf(qvtoperational::ModelParameter) then
					var transfoContext : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new.callToTransfoContextSingleton(context)
					out := org::kermeta::language::behavior::CallProperty.new
					out.asType(org::kermeta::language::behavior::CallProperty).target:=transfoContext
					referredVariable.range2domain(context)
					out.asType(org::kermeta::language::behavior::CallProperty).staticProperty?= referredVariable.output
					out.asType(org::kermeta::language::behavior::CallProperty).name:=out.asType(org::kermeta::language::behavior::CallProperty).staticProperty.name
					
				else
					out := org::kermeta::language::behavior::CallVariable.new
					out.asType(org::kermeta::language::behavior::CallVariable).name:=referredVariable.name
				end
				
			end
		end
		output:=out
	end
}
	
/**Variables are used in 2 different contexts, as lambda parameters and as variable that need to be declared in kermeta those are represented by 2 different classes*/
aspect class Variable {
	
	operation toLambdaParameter() : Void is do
		if output==void then
			var out : org::kermeta::language::behavior::LambdaParameter init org::kermeta::language::behavior::LambdaParameter.new
			output:=out
			out.name:=name
		end
	
	end
	
	
	/** return the variable declaration corresponding to the self Variable */
	operation toVariableDecl(context : Qvt2KermetaContext) : org::kermeta::language::behavior::VariableDecl is do
		var out : org::kermeta::language::behavior::VariableDecl init org::kermeta::language::behavior::VariableDecl.new
		result:=out
		out.identifier:=name
		
		//first, put a type
		
		
		
		
		if (initExpression!=void) then
			initExpression.range2domain(context)
			out.initialization?=initExpression.output
			out.addDocumentationTag("initialized from initExpression does it need a new ?")
		else
			//initialization of the variable
			var newFeat : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new
			var typeLit : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
			
			out.initialization:=newFeat
			newFeat.name:="new"
			newFeat.target:=typeLit
			type.range2domain(context)
			if type.output.isInstanceOf(org::kermeta::language::structure::ClassDefinition) then
				typeLit.typeref:=type.output.asType(org::kermeta::language::structure::ClassDefinition).generateTypeRef()
			else
				if type.output.isInstanceOf(org::kermeta::language::structure::PrimitiveType) then
					typeLit.typeref:=type.output.asType(org::kermeta::language::structure::PrimitiveType).generateTypeRef()
				else
					if type.output.isInstanceOf(org::kermeta::language::structure::Class) then
					typeLit.typeref:=org::kermeta::language::behavior::TypeReference.new
					typeLit.typeref.type?=type.output
					typeLit.typeref.containedType.add(type.output.asType(org::kermeta::language::structure::Class))
					end
				end
			end
		end
		
		type.range2domain(context)
		if type.output.isInstanceOf(org::kermeta::language::structure::ClassDefinition) then
			out.type:=type.output.asType(org::kermeta::language::structure::ClassDefinition).generateTypeRef()
		else
			if type.output.isInstanceOf(org::kermeta::language::structure::PrimitiveType) then
				out.type:=type.output.asType(org::kermeta::language::structure::PrimitiveType).generateTypeRef()
			else
				if type.output.isInstanceOf(org::kermeta::language::structure::Class) then
					out.type?=type.output.asType(org::kermeta::language::structure::Class).generateTypeRef()
					//type is already a container…					
					//out.containedType.add(type.output.asType(org::kermeta::language::structure::Class))
				end
			end
		end
		
	end
}
	




/**definition inlined of a tuple in qvt*/
aspect class TupleLiteralExp {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		
		if output==void then 
			//create a signature
			var tupleparts : Set<root_package::TuplePartPair> init Set<root_package::TuplePartPair>.new
			
			part.each{ p |
					var pair : root_package::TuplePartPair init root_package::TuplePartPair.new
					pair.name:= (p.~attribute.name)
					pair.type?=p.~attribute.~class.generateType(context)
					tupleparts.add(pair)
				}
			var tupleSign : root_package::TupleSignature init root_package::TupleSignature.new.initialize(tupleparts)
			//retrieve the type corresponding to the tuple
			
			var tupleClassDef: org::kermeta::language::structure::ClassDefinition 
				init context.tuplePool.getTupleTypeDefinition(tupleSign)
			
			//declare the tuple
			var out : org::kermeta::language::behavior::Block init org::kermeta::language::behavior::Block.new
			output:=out
			
			var varDec : org::kermeta::language::behavior::VariableDecl init org::kermeta::language::behavior::VariableDecl.new
			out.statement.add(varDec)
			varDec.identifier:=name
			
			var tupleTypeRef : org::kermeta::language::behavior::TypeReference init tupleClassDef.generateTypeRef()
			varDec.type:=tupleTypeRef
			
			//assign each part
			part.each{p |
				var assign : org::kermeta::language::behavior::Assignment init org::kermeta::language::behavior::Assignment.new
				out.statement.add(assign)
				var callProp : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new
				assign.target:=callProp
				callProp.name:=p.~attribute.name
				var callvar : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
				callvar.name:=name
				
				p.~value.range2domain(context)
				assign.~value?=p.~value.output
				}
				
			//return the instance of the tuple
			var returnVar : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
			out.statement.add(returnVar)
			returnVar.name:=name
			
		end
	end

}




	
/** type created for calling a sequence*/
aspect class SequenceType {
	
	method generateType(context : Qvt2KermetaContext) : org::kermeta::language::structure::Type is do
		result?=output
	end
	
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then 
			var out : org::kermeta::language::structure::Class init org::kermeta::language::structure::Class.new
			output:=out
			var cd : org::kermeta::language::structure::ClassDefinition
			cd?=context.kmtContext.getFromQualifiedName("kermeta::standard::Sequence")
			out.typeDefinition:=cd 
			var tvarBinding : org::kermeta::language::structure::TypeVariableBinding init org::kermeta::language::structure::TypeVariableBinding.new
			tvarBinding.variable :=cd.typeParameter.one
			out.typeParamBinding.add(tvarBinding)
			
			elementType.range2domain(context)
			tvarBinding.type:=elementType.generateType(context)
			
			if tvarBinding.type.container==void then 
				tvarBinding.containedType.add(tvarBinding.type)
			end
			
		end
	end
}
	
	
/** type created for calling a bag*/
aspect class BagType {
	
	method generateType(context : Qvt2KermetaContext) : org::kermeta::language::structure::Type is do
		result?=output
	end
	
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then 
			var out : org::kermeta::language::structure::Class init org::kermeta::language::structure::Class.new
			output:=out
			var cd : org::kermeta::language::structure::ClassDefinition
			cd?=context.kmtContext.getFromQualifiedName("kermeta::standard::Bag")
			out.typeDefinition:=cd 
			var tvarBinding : org::kermeta::language::structure::TypeVariableBinding init org::kermeta::language::structure::TypeVariableBinding.new
			tvarBinding.variable :=cd.typeParameter.one
			out.typeParamBinding.add(tvarBinding)
			
			elementType.range2domain(context)
			tvarBinding.type:=elementType.generateType(context)
			
			if tvarBinding.type.container==void then 
				tvarBinding.containedType.add(tvarBinding.type)
			end
			
		end
	end
}


/** type created for calling a set*/
aspect class SetType {
	
	method generateType(context : Qvt2KermetaContext) : org::kermeta::language::structure::Type is do
		result?=output
	end
	
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then 
			var out : org::kermeta::language::structure::Class init org::kermeta::language::structure::Class.new
			output:=out
			var cd : org::kermeta::language::structure::ClassDefinition
			cd?=context.kmtContext.getFromQualifiedName("kermeta::standard::Set")
			out.typeDefinition:=cd 
			var tvarBinding : org::kermeta::language::structure::TypeVariableBinding init org::kermeta::language::structure::TypeVariableBinding.new
			tvarBinding.variable :=cd.typeParameter.one
			out.typeParamBinding.add(tvarBinding)
			
			elementType.range2domain(context)
			tvarBinding.type:=elementType.generateType(context)
			
			if tvarBinding.type.container==void then 
				tvarBinding.containedType.add(tvarBinding.type)
			end
			
		end
	end
}

/** type created for calling a orderedset*/
aspect class OrderedSetType {
	
	method generateType(context : Qvt2KermetaContext) : org::kermeta::language::structure::Type is do
		result?=output
	end
	
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then 
			var out : org::kermeta::language::structure::Class init org::kermeta::language::structure::Class.new
			output:=out
			var cd : org::kermeta::language::structure::ClassDefinition
			cd?=context.kmtContext.getFromQualifiedName("kermeta::standard::OrderedSet")
			out.typeDefinition:=cd 
			var tvarBinding : org::kermeta::language::structure::TypeVariableBinding init org::kermeta::language::structure::TypeVariableBinding.new
			tvarBinding.variable :=cd.typeParameter.one
			out.typeParamBinding.add(tvarBinding)
			
			elementType.range2domain(context)
			tvarBinding.type:=elementType.generateType(context)
			
			if tvarBinding.type.container==void then 
				tvarBinding.containedType.add(tvarBinding.type)
			end
			
		end
	end
}


	
/** TypeExp is a call to a type for iskindof for instance*/
aspect class TypeExp {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do
		if output==void then
			var out : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
			output:=out
		
			referredType.range2domain(context)
			if referredType.output.isInstanceOf(org::kermeta::language::structure::ClassDefinition) then
				out.typeref:=referredType.output.asType(org::kermeta::language::structure::ClassDefinition).generateTypeRef()
			else
				if referredType.output.isInstanceOf(org::kermeta::language::structure::PrimitiveType) then
					out.typeref:=referredType.output.asType(org::kermeta::language::structure::PrimitiveType).generateTypeRef()
				end
			end
		end
	end

}



/** Real literals, they don't exists in kermeta*/
aspect class RealLiteralExp {

	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do
		if output==void then
			var out : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new
			output:=out
			out.name:="toReal"
			
			var realValue : org::kermeta::language::behavior::StringLiteral init org::kermeta::language::behavior::StringLiteral.new
			out.target:=realValue
			realValue.~value:=realSymbol.toString
		
	
		end
	end


}

