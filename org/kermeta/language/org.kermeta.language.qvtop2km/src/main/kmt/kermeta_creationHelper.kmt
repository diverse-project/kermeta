package org::kermeta;


using org::kermeta::language::behavior
using org::kermeta::language::structure
using org::kermeta::language
using kermeta::standard
using kermeta::io
using root_package
package language{

package structure{

	aspect class KermetaModelElement{
	
		operation addDocumentationTag(text:String) : Void is do
			var kTag : org::kermeta::language::structure::Tag init org::kermeta::language::structure::Tag.new
			kTag.name:="documentation"
			kTag.~value:=text
			self.kOwnedTags.add(kTag)
			self.kTag.add(kTag)
		end
	
	}
	
	aspect class Type {
		operation generateTypeRef() : org::kermeta::language::behavior::TypeReference is abstract
	
	}
	
	aspect class UnresolvedType {
	
		operation initialize(ti : String) : UnresolvedType is do
			result:=self
			self.typeIdentifier:=ti
		
		end
	
		method generateTypeRef() : org::kermeta::language::behavior::TypeReference is do
			result:=org::kermeta::language::behavior::TypeReference.new
			result.lower:=0
			result.upper:=1
			result.isUnique:=true
			result.type:=self
			result.containedType.add(self)
			
		
		end
		//TODO this doesn't allow to use parameterized type as parameter
		operation generateParameterizedTypeRef(parameter : ClassDefinition) : org::kermeta::language::behavior::TypeReference is do
			result:= generateTypeRef()
			
			//var varBinding : TypeVariableBinding init TypeVariableBinding.new
			//result.type.asType(ParameterizedType).typeParamBinding.add(varBinding)
			//varBinding.variable:=self.typeParameter.one
			var paramType : Class init Class.new
			paramType.typeDefinition:=parameter
			
			//varBinding.type:=paramType
			self.generics.add(paramType)
			self.containedType.add(paramType)
			//varBinding.containedType.add(paramType)
		
		end
	}
	
	aspect class Class{
	
		method generateTypeRef() : org::kermeta::language::behavior::TypeReference is do
			result:=org::kermeta::language::behavior::TypeReference.new
			result.lower:=0
			result.upper:=1
			result.isUnique:=true
			result.type:=self
			result.containedType.add(self)
			result.name:=self.name
		
		end
		
		operation cloneClass() : Class is do
			
			result:=Class.new
			result.typeDefinition:=typeDefinition
			typeParamBinding.each{binding|
				var newBinding : TypeVariableBinding init TypeVariableBinding.new
				result.typeParamBinding.add(newBinding)
				if binding.type.isInstanceOf(Class) then
					newBinding.type:=binding.type.asType(Class).cloneClass()
					newBinding.containedType.add(newBinding.type)
				else
					newBinding.type:=binding.type
				end
				newBinding.variable:=binding.variable
			}
		
		end
		
	}
	
	aspect class ClassDefinition {
		operation generateTypeRef() : org::kermeta::language::behavior::TypeReference is do
			result:=org::kermeta::language::behavior::TypeReference.new
			result.lower:=0
			result.upper:=1
			result.isUnique:=true
			var c : org::kermeta::language::structure::Class init org::kermeta::language::structure::Class.new
			c.typeDefinition:=self
			result.type:=c
			result.containedType.add(c)
			result.name:=c.name

		end
		
		//TODO this doesn't allow to use parameterized type as parameter
		operation generateParameterizedTypeRef(parameter : ClassDefinition) : org::kermeta::language::behavior::TypeReference is do
			result:= generateTypeRef()
			
			var varBinding : TypeVariableBinding init TypeVariableBinding.new
			result.type.asType(ParameterizedType).typeParamBinding.add(varBinding)
			varBinding.variable:=self.typeParameter.one
			var paramType : Class init Class.new
			paramType.typeDefinition:=parameter
			
			varBinding.type:=paramType
			varBinding.containedType.add(paramType)
		
		end
	}
	
	aspect class PrimitiveType {
		method generateTypeRef() : org::kermeta::language::behavior::TypeReference is do
			result:=org::kermeta::language::behavior::TypeReference.new
			result.lower:=0
			result.upper:=1
			result.isUnique:=true
			result.type:=self
			result.name:=self.name
		end
	
	
	}
}


package behavior {
	aspect class CallVariable {
	
		operation initName(n : String) : org::kermeta::language::behavior::CallVariable is do
			name:=n
			result:=self
		end
	}
	
	aspect class UnresolvedCall {
	
		//generate a call to the singleton transformationtionContext
		//root_package::TransformationContext.getDefault.asType(root_package::TransformationContext)
		operation callToTransfoContextSingleton(context : Qvt2KermetaContext) : org::kermeta::language::behavior::UnresolvedCall is do
			StdIO.writeln("CallFeature::callToTransfoContextSingleton")
			result:= self
			
			result.name:="asType"
			
			//var transfoContextCD : org::kermeta::language::structure::ClassDefinition
			//transfoContextCD ?= context
			//		.kmtContext
			//		.getFromQualifiedName("root_package::TransformationContext")
			
			var tl_tracetype : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new
			result.parameters.add(tl_tracetype)
			//tl_tracetype.typeref:=transfoContextCD.generateTypeRef()
			tl_tracetype.name:="root_package::TransformationContext"
			var cf_getDefault : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new
			result.target:=cf_getDefault
			cf_getDefault.name:="getDefault"
			
			var tl_getDefault : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::UnresolvedCall.new
			cf_getDefault.target:=tl_getDefault
			//tl_getDefault.typeref:=transfoContextCD.generateTypeRef()
			tl_getDefault.name:="root_package::TransformationContext"
			StdIO.writeln("CallFeature::callToTransfoContextSingleton-end")
		end
		
		
		operation initialize (name : String , isCalledWithParenthesis:Boolean): UnresolvedCall is do
			result:=self
			self.isCalledWithParenthesis := isCalledWithParenthesis
			self.name:=name
		
		end
		
		
		operation createProxySequence(t: Type) : behavior::UnresolvedCall is do
			result:=self
			self.name:="asSequenceType"
			self.generics.add(t)
			self.containedType.add(t)
		
		end
	
	}

}

}
