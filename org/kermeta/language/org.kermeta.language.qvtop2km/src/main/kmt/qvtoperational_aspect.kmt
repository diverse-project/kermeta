package qvtoperational;

using root_package
using kermeta::standard
using kermeta::io

aspect class ObjectExp {

	/* beware ! it will work if body is not modified anywhere else*/
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			//StdIO.writeln("ObjectExp::range2domain")
			var out : org::kermeta::language::behavior::Block
			body.range2domain(context)
			out?=body.output
			if out==void then
				out:=org::kermeta::language::behavior::Block.new
			end
			output:=out
			//this call variable is added for the objectexp block to return the object once created
			//TODO workaround for result
			
			var cv : org::kermeta::language::behavior::CallVariable 
			if referredObject.name=="result" then
				cv:=org::kermeta::language::behavior::CallResult.new
			else		
				cv:=org::kermeta::language::behavior::CallVariable.new
			end
			cv.name:=referredObject.name
			out.statement.add(cv)
			//StdIO.writeln("ObjectExp::range2domain-end")
		end
	end
}



aspect class ConstructorBody {

	method range2domain(context : Qvt2KermetaContext)  : Void from emof::Object is do
		if output==void then
			//StdIO.writeln("ConstructorBody::range2domain")
			var out : org::kermeta::language::behavior::Block init org::kermeta::language::behavior::Block.new
			output:=out
			variable.each{v|
					out.statement.add(v.toVariableDecl(context))
					}
			content.each{oclexp|
					oclexp.range2domain(context)
					if not oclexp.output.isVoid() then 
						out.statement.add(oclexp.output.asType(org::kermeta::language::behavior::Expression) )
					else
						StdIO.writeln( "a statement in content is void")
					end
					}
			//StdIO.writeln("ConstructorBody::range2domain-end")
		end
	end

}

aspect class EntryOperation {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is
		do
			if output==void then
				var out : org::kermeta::language::structure::Operation init org::kermeta::language::structure::Operation.new
				output:=out
				out.name:="main"
				out.lower:=lower
				out.upper:=upper
				out.isOrdered:=isOrdered
				out.isUnique:=isUnique
				
				//there is no parameters to an entry operation
				//there is no result parameter either
				
				//set owning class of output operation
				
				out.owningClass:=context.transfoContextCD
				
				//set body of output operation
				body.range2domain(context)
				out.body?=body.output
				out.addDocumentationTag("gen from an entry operation")
			end
		end
}


aspect class OperationBody {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			//StdIO.writeln("OperationBody::range2domain")
			var out : org::kermeta::language::behavior::Block init org::kermeta::language::behavior::Block.new
			output:=out
			
			if ~operation.isInstanceOf(Helper)
					.andThen{x|~operation.asType(Helper).isQuery==void}
					.andThen{x|content.size==1} then
				content.one.range2domain(context)
				var resAssign : org::kermeta::language::behavior::Assignment init org::kermeta::language::behavior::Assignment.new
				resAssign.target:=org::kermeta::language::behavior::CallResult.new
				resAssign.~value?=content.one.output
				out.statement.add(resAssign)
			
			else
			content.each{oclexp|
					oclexp.range2domain(context)
					if not oclexp.output.isVoid() then 
						out.statement.add(oclexp.output.asType(org::kermeta::language::behavior::Expression) )
					else
						StdIO.writeln( "a statement in content is void")
					end
					}
			genDefaultRescues(context)
			end
			//StdIO.writeln("OperationBody::range2domain-end")
		end
	end

	operation genDefaultRescues(context : Qvt2KermetaContext) : Void is do
		var bodyBlock : org::kermeta::language::behavior::Block
		bodyBlock?=output
		//rescue for return
		do 
			var returnRescue : org::kermeta::language::behavior::Rescue init org::kermeta::language::behavior::Rescue.new
			bodyBlock.rescueBlock.add(returnRescue)
			returnRescue.exceptionName := "e"
			var returnExpCD : org::kermeta::language::structure::ClassDefinition
			returnExpCD?=context.kmtContext.getFromQualifiedName("root_package::ReturnException")
			returnRescue.exceptionType:=returnExpCD.generateTypeRef()
			
			var voidTest : org::kermeta::language::behavior::Conditional init org::kermeta::language::behavior::Conditional.new
			returnRescue.body.add(voidTest)
			var hasValueCall : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
			voidTest.condition:=hasValueCall
			hasValueCall.name:="hasValue"
			hasValueCall.target:=org::kermeta::language::behavior::CallVariable.new.initName("e")
			
			var assignResult : org::kermeta::language::behavior::Assignment init org::kermeta::language::behavior::Assignment.new
			voidTest.thenBody:=assignResult
			assignResult.isCast:=true
			assignResult.target:=org::kermeta::language::behavior::CallResult.new
			
			var callresultValue :org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
			assignResult.~value:=callresultValue
			callresultValue.name:="returnValue"
			callresultValue.target:=org::kermeta::language::behavior::CallVariable.new.initName("e")
		end
		
		
	end
}


aspect class MappingParameter {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			//StdIO.writeln("MappingParameter::range2domain")
			var out : org::kermeta::language::structure::Parameter init org::kermeta::language::structure::Parameter.new
			output:=out
			
			out.name:=name
			out.upper:=upper
			out.lower:=lower
			out.isUnique:=isUnique
			out.isOrdered:=isOrdered
		
			type.range2domain(context)
			out.type:=type.generateType(context)
			if out.type.isInstanceOf(org::kermeta::language::structure::Class) then
				out.containedType.add(out.type)
			end
			//StdIO.writeln("MappingParameter::range2domain-end")
		end
	end
}


aspect class ImperativeOperation {

	operation getTransformation() : OperationalTransformation is do
		//StdIO.writeln("MappingOperation::getTransformation")
		var o : kermeta::standard::Object
		
		/*from  o:=self.container
		until o.isInstanceOf(OperationalTransformation) or o==void
		loop
		    o:=o.container
		end

		result?=o*/
		//StdIO.writeln("MappingOperation::getTransformation-end")
	end

}


/**
for a mapping between qvtoperational::MappingOperation and org::kermeta::language::structure::Operation
context.type -- owningClass.type
result.type -- type
body.init -- body
body.content -- ??

TODO If the guard succeeds, the relation trace is checked to find out whether the relation already holds. If so, the out
parameters are populated using the corresponding trace tuples of the relation and the value associated to the result
parameters is returned.

*/
aspect class MappingOperation {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			//StdIO.writeln("MappingOperation::range2domain")
			StdIO.writeln("\nmapping operation "+name+" id "+oid.toString)
			var out : org::kermeta::language::structure::Operation init org::kermeta::language::structure::Operation.new
			output:=out
			out.name:=name
			out.lower:=lower
			out.upper:=upper
			out.isOrdered:=isOrdered
			out.isUnique:=isUnique
			
			//parameters
			ownedParameter.each{x|x.range2domain(context) out.ownedParameter.add(x.output.asType(org::kermeta::language::structure::Parameter))}
			
			//two parameters should be added : the result parameter, that can be used for mapping inheritance
			//the isStrict parameter that should tell the behavior of the guard
			if (self.~result != void) then
				
				
				//TODO check if it is still useful
				if self.~result.one.type.output==void then
					StdIO.writeln("createTypedefinition "+self.~result.one.type.name)
					getTransformation().createTypeDefinition(self.~result.one.type,context)
				
				end
				
				var resParam : org::kermeta::language::structure::Parameter init org::kermeta::language::structure::Parameter.new
				out.ownedParameter.add(resParam)
				resParam.name:="result"
				resParam.lower:=~result.one.lower
				resParam.upper:=~result.one.upper
				resParam.isOrdered:=~result.one.isOrdered
				resParam.isUnique:=~result.one.isUnique
				resParam.type:=self.~result.one.type.generateType(context)
				resParam.containedType.add(resParam.type)
			end
			
			
			var resStrict : org::kermeta::language::structure::Parameter init org::kermeta::language::structure::Parameter.new
			out.ownedParameter.add(resStrict)
			resStrict.name:="isStrict"
			resStrict.lower:=0
			resStrict.upper:=1
			//resStrict.isOrdered:=true
			//resStrict.isUnique:=false
			var boolType : org::kermeta::language::structure::Class init org::kermeta::language::structure::Class.new
			resStrict.type:=boolType
			boolType.typeDefinition?=context.kmtContext.getFromQualifiedName("kermeta::standard::Boolean")
			resStrict.containedType.add(boolType)
			
			
			//set owning class of output operation
			if (self.context!=void).andThen{x|self.context.type.isInstanceOf(emof::Class)} then
				out.owningClass?=self.context.type.output
			else
				out.owningClass:=context.transfoContextCD
			end
			
			//set return type of output operation
			if (self.~result != void) then
				
				if self.~result.size>1 then
					raise QvtNotImplementedException.new.initialize("Mappings with multiple results")
				end
				
				
				out.type:=self.~result.one.type.generateType(context)
				out.containedType.add(out.type)
				/* org::kermeta::language::structure::Class.new
				out.containedType.add(out.type)
				out.type.asType(org::kermeta::language::structure::ParameterizedType).typeDefinition?=self.~result.one.type.output*/
			end
			
			//set body of output operation
			body.range2domain(context)
			out.body?=body.output
			
			out.addDocumentationTag("gen from a MappingOperation")
			//StdIO.writeln("MappingOperation::range2domain-end")	
		end	
	end
	
	
}

aspect class Helper
{
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is
		do
			if output==void then
				//StdIO.writeln("MappingOperation::range2domain")
				StdIO.writeln("\nhelper "+name+" id "+oid.toString)
				var out : org::kermeta::language::structure::Operation init org::kermeta::language::structure::Operation.new
				output:=out
				out.name:=name
				out.lower:=lower
				out.upper:=upper
				out.isOrdered:=isOrdered
				out.isUnique:=isUnique
				
				//parameters
				ownedParameter.each{x|x.range2domain(context) out.ownedParameter.add(x.output.asType(org::kermeta::language::structure::Parameter))}
				
				//set owning class of output operation
				if (context!=void).andThen{x|self.context.type.isInstanceOf(emof::Class)} then
					out.owningClass?=self.context.type.output
				end
				
				//set return type of output operation
				if (self.~result != void) then
					
					if self.~result.size>1 then
						raise QvtNotImplementedException.new.initialize("Helpers with multiple results")
					end
					
					if self.~result.one.type.output==void then
						StdIO.writeln("createTypedefinition "+self.~result.one.type.name)
						getTransformation().createTypeDefinition(self.~result.one.type, context)
					
					end
					out.type:=self.~result.one.type.generateType(context)
					if  self.~result.one.type.isInstanceOf(emof::Class) then
						out.containedType.add(out.type)
					end
				end
				
				//set body of output operation
				body.range2domain(context)
				out.body?=body.output
				
				out.addDocumentationTag("gen from a helper")
			end
		end
}

/**
* it's the list of operation in a mapping, 
*	with initSection and endSection
*/

aspect class MappingBody {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
		
		if output==void then
			StdIO.writeln("MappingBody::range2domain")
			var out : org::kermeta::language::behavior::Block init org::kermeta::language::behavior::Block.new
			output:=out
			
			StdIO.writeln("MappingBody::range2domain-0")
			//before initialization, the guard should be checked
			if ~operation.asType(MappingOperation).when!=void then
				var whenCond : org::kermeta::language::behavior::Conditional init org::kermeta::language::behavior::Conditional.new
				out.statement.add(whenCond)
				~operation.asType(MappingOperation).when.range2domain(context)
				var notCall : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
				notCall.name:="not"
				notCall.target?=~operation.asType(MappingOperation).when.output
				whenCond.condition:=notCall
				
				//call violated guard exception
				var raiseExcep : org::kermeta::language::behavior::Raise init org::kermeta::language::behavior::Raise.new
				
				var newCall : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
				raiseExcep.expression:=newCall
				newCall.name:="new"

				var exceptionLiteral : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
				newCall.target:=exceptionLiteral
				var exceptionCD : org::kermeta::language::structure::ClassDefinition
				
				exceptionCD?= context.kmtContext.getFromQualifiedName("root_package::ViolatedGuardException")
				exceptionLiteral.typeref:=exceptionCD.generateTypeRef()
				
				whenCond.thenBody:=raiseExcep
			end
			StdIO.writeln("MappingBody::range2domain-1")
			
			//before initialization, result should get its value from the result parameter in case of inherit call
			do 
				var initRes : org::kermeta::language::behavior::Assignment init org::kermeta::language::behavior::Assignment.new
				out.statement.add(initRes)
				initRes.target:=org::kermeta::language::behavior::CallResult.new
				
				var resultVar : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
				initRes.~value:=resultVar
				resultVar.name:="result"
			end
			StdIO.writeln("MappingBody::range2domain-2")
			//start initialization section
			do
				var initBlock : org::kermeta::language::behavior::Block init org::kermeta::language::behavior::Block.new
				StdIO.writeln("MappingBody::range2domain-200")
				out.statement.add(initBlock)
				StdIO.writeln("MappingBody::range2domain-201"+initSection.toString)
				StdIO.writeln("size"+initSection.size.toString)
				initSection.each{oclexp|
					StdIO.writeln("MappingBody::range2domain-20")
					oclexp.range2domain(context)
					StdIO.writeln("MappingBody::range2domain-21")
					if not oclexp.output.isVoid() then
						initBlock.statement.add(oclexp.output.asType(org::kermeta::language::behavior::Expression) )
					else
						//StdIO.writeln( "a statement in initSection is void "+oclexp.getMetaClass().name)
					end
					}
				initBlock.addDocumentationTag("initSection")
				//init parameters that are still null
				out.statement.add(createInit(context))
			end
			StdIO.writeln("MappingBody::range2domain-3")
			//add inheritance calls
			do
				~operation.asType(MappingOperation).inherited.each{
					op|
					var callInheritedOp : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
					out.statement.add(callInheritedOp)	
					callInheritedOp.target:=org::kermeta::language::behavior::SelfExpression.new
					callInheritedOp.name:=op.name
					~operation.ownedParameter.each{param|
						var callParam : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
						callParam.name:=param.name
						callInheritedOp.parameters.add(callParam)}
					callInheritedOp.parameters.add(org::kermeta::language::behavior::CallResult.new)
					var isStrictVal : org::kermeta::language::behavior::BooleanLiteral init org::kermeta::language::behavior::BooleanLiteral.new
					isStrictVal.~value:=false
					callInheritedOp.parameters.add(isStrictVal)
				}
			end
			StdIO.writeln("MappingBody::range2domain-4")
			//create trace
			do
				var trace : org::kermeta::language::behavior::Expression init createTrace(context)
				out.statement.add(trace)
				trace.addDocumentationTag("trace generation")
			end
			StdIO.writeln("MappingBody::range2domain-5")
			//create all content
			content.each{oclexp|
				oclexp.range2domain(context)
				if not oclexp.output.isVoid() then 
				out.statement.add(oclexp.output.asType(org::kermeta::language::behavior::Expression) )
				else
				StdIO.writeln( "a statement in content is void")
				end
				}
			//generate the usual rescues
			genDefaultRescues(context)
			StdIO.writeln("MappingBody::range2domain-end")
		end	
	end


	method genDefaultRescues(context : Qvt2KermetaContext) : Void is do
		
		super(context)		
		var bodyBlock : org::kermeta::language::behavior::Block
		bodyBlock?=output
		//rescue for violated guard
		do
			var violatedGuardRescue : org::kermeta::language::behavior::Rescue init org::kermeta::language::behavior::Rescue.new
			bodyBlock.rescueBlock.add(violatedGuardRescue)
			violatedGuardRescue.exceptionName:="e"
			var violatedGuardCD : org::kermeta::language::structure::ClassDefinition
			violatedGuardCD?=context.kmtContext.getFromQualifiedName("root_package::ViolatedGuardException")
			violatedGuardRescue.exceptionType := violatedGuardCD.generateTypeRef()
			
			var strictTest : org::kermeta::language::behavior::Conditional init org::kermeta::language::behavior::Conditional.new
			violatedGuardRescue.body.add(strictTest)
			var isStrictCall : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
			strictTest.condition:=isStrictCall
			isStrictCall.name:="isStrict"
			
			
		end
		
	end


	//generate the trace of the mapping
	operation createTrace(context : Qvt2KermetaContext) : org::kermeta::language::behavior::Expression is do
		//StdIO.writeln("MappingBody::createTrace")
		var cf_trace :  org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		result := cf_trace
		cf_trace.name:="addTrace"

		var call_source : org::kermeta::language::behavior::SelfExpression init org::kermeta::language::behavior::SelfExpression.new
		cf_trace.parameters.add(call_source)
		//var call_source : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
		//call_source.name:="self"
		
		var call_target : org::kermeta::language::behavior::CallResult init org::kermeta::language::behavior::CallResult.new
		cf_trace.parameters.add(call_target)
		//var call_target : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
		//call_target.name:="result"

		var traceContext : org::kermeta::language::behavior::StringLiteral init org::kermeta::language::behavior::StringLiteral.new
		traceContext.~value:=~operation.name
		cf_trace.parameters.add(traceContext)
		
		cf_trace.target:=org::kermeta::language::behavior::CallFeature.new.callToTransfoContextSingleton(context)
		
		/*var cf_cast : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		cf_cast.name:="asType"
		
		var transfoContextCD : org::kermeta::language::structure::ClassDefinition
		transfoContextCD ?= KmtLib
				.getDefault
				.asType(root_package::KmtLib)
				.getFromQualifiedName("root_package::TransformationContext")
		
		var tl_tracetype : org::kermeta::language::behavior::TypeLiteral init org::kermeta::language::behavior::TypeLiteral.new
		cf_cast.parameters.add(tl_tracetype)
		tl_tracetype.typeref:=transfoContextCD.generateTypeRef()
		
		var cf_getDefault : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		cf_cast.target:=cf_getDefault
		cf_getDefault.name:="getDefault"
		
		var tl_getDefault : org::kermeta::language::behavior::TypeLiteral init org::kermeta::language::behavior::TypeLiteral.new
		cf_getDefault.target:=tl_getDefault
		tl_getDefault.typeref:=transfoContextCD.generateTypeRef()
		//StdIO.writeln("MappingBody::createTrace-end")
		*/
	end
	
	
	/**
		initialize a mapping parameter if it is void and add it to the right model
	*/
	operation initializeFromParameter(vp : qvtoperational::VarParameter, context : Qvt2KermetaContext) : org::kermeta::language::behavior::Expression is do 
		if vp!=void then 
			
			//create condition
			var voidCondition  : org::kermeta::language::behavior::Conditional init org::kermeta::language::behavior::Conditional.new
			result :=voidCondition
			var callEquals : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
			voidCondition.condition:=callEquals
			callEquals.name:="equals"
			var callX : org::kermeta::language::behavior::CallVariable 
			if vp.name!="result" then
				callX:=org::kermeta::language::behavior::CallVariable.new
				callX.name:=vp.name
			else
				callX:=org::kermeta::language::behavior::CallResult.new
			end	
			callEquals.target:=callX
			callEquals.parameters.add(org::kermeta::language::behavior::VoidLiteral.new)

			//then block
			var thenBlock : org::kermeta::language::behavior::Block init org::kermeta::language::behavior::Block.new
			voidCondition.thenBody:=thenBlock
			
			//add assignment
			var assign : org::kermeta::language::behavior::Assignment init org::kermeta::language::behavior::Assignment.new
			thenBlock.statement.add(assign)

			var callAssignee : org::kermeta::language::behavior::CallVariable 
			if vp.name!="result" then
				callAssignee:=org::kermeta::language::behavior::CallVariable.new
				callAssignee.name:=vp.name
			else
				callAssignee:= org::kermeta::language::behavior::CallResult.new
			end
			
			assign.target:=callAssignee
			
			var newFeat : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
			var typeLit : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
			var typeR : org::kermeta::language::behavior::TypeReference init org::kermeta::language::behavior::TypeReference.new
		
			assign.~value:=newFeat
			newFeat.name:="new"
			newFeat.target:=typeLit
			
			if vp.name == "result" then
				if ~operation.upper==1 then
					typeR.type:=~operation.type.generateType(context)
					if typeR.type.isInstanceOf(org::kermeta::language::structure::Class) then
						typeR.containedType.add(typeR.type)
						typeR.name:=typeR.type.asType(org::kermeta::language::structure::Class).name
					else
						typeR.name:=typeR.type.asType(org::kermeta::language::structure::NamedElement).name
					end
					
					typeR.upper:=1//~operation.upper
					typeR.lower:=0//~operation.lower 
				else
					typeR:=resultType(context)
				end
			else
				typeR.type:=vp.type.generateType(context)
				if typeR.type.isInstanceOf(org::kermeta::language::structure::Class) then
					typeR.containedType.add(typeR.type)
					typeR.name:=typeR.type.asType(org::kermeta::language::structure::Class).name
				else
					typeR.name:=typeR.type.asType(org::kermeta::language::structure::NamedElement).name
				end
				typeR.upper:=1
				typeR.lower:=0
			end
			
			
			typeLit.typeref:=typeR
			
			//add to the model type if extent is completed
			if vp.isInstanceOf(qvtoperational::MappingParameter).andThen{x|vp.asType(qvtoperational::MappingParameter).extent!=void} then
				var mp : qvtoperational::MappingParameter
				mp?=vp
				mp.extent.range2domain(context)
				var callModelParam : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
				callModelParam.name:=mp.extent.output.asType(org::kermeta::language::structure::Property).name
				callModelParam.target := org::kermeta::language::behavior::CallFeature.new.callToTransfoContextSingleton(context)
				var callExtent : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
				callExtent.name:="extent"
				callExtent.target:=callModelParam
				
				var callAddInstance : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
				callAddInstance.target:=callExtent
				callAddInstance.name:="add"
				
				var callInstance : org::kermeta::language::behavior::CallVariable 
				if vp.name!="result" then
					callInstance:=org::kermeta::language::behavior::CallVariable.new
					callInstance.name:=vp.name
				else
					callInstance:= org::kermeta::language::behavior::CallResult.new
				end
				callAddInstance.parameters.add(callInstance)
				thenBlock.statement.add(callAddInstance)
			end
		end
	end
	
	
	//implicit assignment of result 
	/**
		after initialization section, and before population section, there is an implicit initialization of
		all the out parameters declared in the mapping that still don't have value
	*/
	
	operation createInit(context : Qvt2KermetaContext) : org::kermeta::language::behavior::Block is do
		//StdIO.writeln("MappingBody::createInit")
		
		var block: org::kermeta::language::behavior::Block init org::kermeta::language::behavior::Block.new
		
		
		~operation.ownedParameter.each{x|
					var vp : qvtoperational::VarParameter
					vp?=x
					if (not x.type.isInstanceOf(emof::Class))
							.orElse{y|not x.type.asType(emof::Class).isAbstract} then
						block.statement.add(initializeFromParameter(vp,context))
					end
					}
		
		~operation.~result.each{vp|	
					
					if (not vp.type.isInstanceOf(emof::Class))
							.orElse{y|not vp.type.asType(emof::Class).isAbstract} then
					block.statement.add(initializeFromParameter(vp, context))
					end
					}
		
		
		result:=block
		//StdIO.writeln("MappingBody::createInit-end")
	end
	
	//return the equivalent of the operation return type in terms of collection depending on the cardinality, unicity and order
	operation resultType(context : Qvt2KermetaContext) : org::kermeta::language::behavior::TypeReference is do
			//StdIO.writeln("MappingBody::resultType") 
			result:=org::kermeta::language::behavior::TypeReference.new
			result.lower:=0
			result.upper:=1
			var classdef : org::kermeta::language::structure::ClassDefinition
			
			if (~operation.isOrdered and ~operation.isUnique) then
				//orderedset
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::OrderedSet")	
			end
			if (~operation.isOrdered and not ~operation.isUnique) then
				//sequence
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Sequence")
			end
			if (not ~operation.isOrdered and ~operation.isUnique) then
				//set
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Set")
			end
			if (not ~operation.isOrdered and not ~operation.isUnique) then
				//bag
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Bag")
			end
			
			var collectionClass : org::kermeta::language::structure::Class init org::kermeta::language::structure::Class.new
			result.type:=collectionClass
			result.containedType.add(result.type)
			collectionClass.typeDefinition:=classdef
			
			var tvarBinding : org::kermeta::language::structure::TypeVariableBinding init org::kermeta::language::structure::TypeVariableBinding.new
			collectionClass.typeParamBinding.add(tvarBinding)		
			tvarBinding.variable:=classdef.typeParameter.one
			tvarBinding.type:=~operation.type.generateType(context)
			if tvarBinding.type.isInstanceOf(org::kermeta::language::structure::Class) then 
				tvarBinding.containedType.add(tvarBinding.type)
			end
			//StdIO.writeln("MappingBody::resultType-end")
	end
}





/**
in qvt operations are separated from classes definition which is not the case in kermeta
so it is needed to recreate the class hierarchy in kermeta to add operations
*/

aspect class OperationalTransformation {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then 
			var out : org::kermeta::language::structure::ModelingUnit init org::kermeta::language::structure::ModelingUnit.new
			output:=out
			
			//creation of package where will be stored all needed elements to run the transformation
			var execEnvPack : org::kermeta::language::structure::Package init org::kermeta::language::structure::Package.new			
			out.packages.add(execEnvPack)
			execEnvPack.name:="root_package"
			
			var transfoContextCD : org::kermeta::language::structure::ClassDefinition init org::kermeta::language::structure::ClassDefinition.new
			context.transfoContextCD:=transfoContextCD
			execEnvPack.ownedTypeDefinition.add(transfoContextCD)
			transfoContextCD.name:="TransformationContext"
			transfoContextCD.isAspect:=true
			
			modelParameter.each{x|
				x.range2domain(context)
				transfoContextCD.ownedAttribute.add(x.output.asType(org::kermeta::language::structure::Property))
			}
		
		end
	end


	operation genClassDefinition(context : Qvt2KermetaContext) : Void is do
		//StdIO.writeln("OperationalTransformation::genClassDefinition") 
		ownedOperation.each{op | 
				StdIO.writeln("genClassDef")
				if op.isInstanceOf(qvtoperational::ImperativeOperation)
					.andThen{x|op.asType(ImperativeOperation).context!=void} then
					createTypeDefinition(op.asType(ImperativeOperation).context.type, context) 
				end 
				}
		//StdIO.writeln("OperationalTransformation::genClassDefinition-end")
	end

	operation createTypeDefinition(type : emof::Type, context : Qvt2KermetaContext) : Void is do 
		StdIO.writeln("OperationalTransformation::createTypeDefinition")
		StdIO.writeln("createContext "+type.toString)
		StdIO.writeln("name"+type.name)
		createPackage(type.container.asType(emof::Package), context)
		type.range2domain(context)
		type.container.asType(emof::Package).output.asType(org::kermeta::language::structure::Package).ownedTypeDefinition.add(type.output.asType(org::kermeta::language::structure::TypeDefinition))
		StdIO.writeln("OperationalTransformation::createTypeDefinition-end")
	end

	operation createPackage(pack : emof::Package, context : Qvt2KermetaContext) : Void is do
		if pack.output==void then
			//StdIO.writeln("OperationalTransformation::createPackage")
			pack.range2domain(context)
			if pack.container.isInstanceOf(kermeta::emfpersistence::Resource) then
				output.asType(org::kermeta::language::structure::ModelingUnit).packages.add(pack.output.asType(org::kermeta::language::structure::Package))
			else
				if (pack.container.asType(emof::Object).output==void).andThen{x|pack.container.isInstanceOf(emof::Package)} then
					createPackage(pack.container.asType(emof::Package),context)
					pack.container.asType(emof::Object).output.asType(org::kermeta::language::structure::Package).nestedPackage
						.add(pack.output.asType(org::kermeta::language::structure::Package))
				end
			end
			//StdIO.writeln("OperationalTransformation::createPackage-end")
		end
	end
	
	
}

aspect class ModelParameter {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output == void then 
			var out : org::kermeta::language::structure::Property init org::kermeta::language::structure::Property.new
			output:=out
			out.isUnique:=true
			out.lower:=0
			out.upper:=1
			out.isComposite:=true
			out.name:=name
			var classDef : org::kermeta::language::structure::ClassDefinition
			classDef?=context.kmtContext.getFromQualifiedName("root_package::ModelParameter")
			
			out.type:= org::kermeta::language::structure::Class.new
			out.type.asType(org::kermeta::language::structure::Class).typeDefinition:=classDef
			out.containedType.add(out.type)
			
		
		
		end
	end

}



/**
* resolveExp is the operation that can require a link of traceability
* TODO : implement deferred resolution 
*/
aspect class ResolveExp {

method range2domain(context : Qvt2KermetaContext) : Void is do
	if output==void then
		//StdIO.writeln("ResolveExp::range2domain")
		var cf_resolve :  org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		//if one is true and there is no condition then it's simply a detect on the type of target
		//if one is false then it's a select on the type that should return a sequence of the type

			var detectCall : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		
		//type of the found object
		if one then
			var detectCast : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
			output:=detectCast
			detectCast.name:="asType"
			target.type.range2domain(context)
			var castLiteral : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
		
			castLiteral.typeref:=target.type.output.asType(org::kermeta::language::structure::ClassDefinition).generateTypeRef()
			detectCast.parameters.add(castLiteral)
			detectCast.target:=detectCall
			detectCall.name:="detect"
		else
			var deferredcast : org::kermeta::language::behavior::CallFeature  init org::kermeta::language::behavior::CallFeature.new
			output:=deferredcast
			deferredcast.name:="fromSeq"
	
			var dSeqInit : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
			deferredcast.target:=dSeqInit
			dSeqInit.name:="new"
			
			var dseqCD : org::kermeta::language::structure::ClassDefinition 
			dseqCD?=context.kmtContext.getFromQualifiedName("kermeta::standard::DeferredSequence")
			
			var dseqLit : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
			dSeqInit.target:=dseqLit
			dseqLit.typeref:=dseqCD.generateParameterizedTypeRef(self.target.type.output.asType(org::kermeta::language::structure::ClassDefinition))
			
			deferredcast.parameters.add(detectCall)
			detectCall.name:="select"
			
		end
		
		var lambdaExp : org::kermeta::language::behavior::LambdaExpression init org::kermeta::language::behavior::LambdaExpression.new
		detectCall.parameters.add(lambdaExp)
		var lambdaParam : org::kermeta::language::behavior::LambdaParameter init org::kermeta::language::behavior::LambdaParameter.new	
		lambdaExp.parameters.add(lambdaParam)
		lambdaParam.name:=target.name
		
		
		
		var andCall : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		lambdaExp.body:=andCall
		andCall.name:="and"
		var typeTestCall : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		andCall.target:=typeTestCall
		typeTestCall.name:="isInstanceOf"
		
					
		var boolClass: org::kermeta::language::structure::Class init org::kermeta::language::structure::Class.new
		typeTestCall.staticType:=boolClass
		typeTestCall.containedType.add(boolClass)
		boolClass.typeDefinition?=context.kmtContext.getFromQualifiedName("kermeta::standard::Boolean")
		
		var xCall : org::kermeta::language::behavior::CallVariable init org::kermeta::language::behavior::CallVariable.new
		typeTestCall.target:=xCall
		xCall.name:=target.name
		
		if condition==void then
			var truelit : org::kermeta::language::behavior::BooleanLiteral init org::kermeta::language::behavior::BooleanLiteral.new
			andCall.parameters.add(truelit)
			truelit.~value:=true
		else
			var exp : org::kermeta::language::behavior::Expression 
			condition.range2domain(context)
			exp?=condition.output
			andCall.parameters.add(exp)
		end
		
		var typeToTest : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
		
		typeToTest.typeref:=target.type.output.asType(org::kermeta::language::structure::ClassDefinition).generateTypeRef() //range2domain already done earlier
		typeTestCall.parameters.add(typeToTest)
		
		detectCall.target:=cf_resolve
		
		if isInverse then
			cf_resolve.name:="resolveAllSource"
		else
			cf_resolve.name:="resolveAllTargets"
		end
		
		source.range2domain(context)
		cf_resolve.parameters.add(source.output.asType(org::kermeta::language::behavior::Expression))
		
		//target.toVariableDecl()
		//cf_resolve.parameters.add(target.output.asType(org::kermeta::language::behavior::Expression))
		
		var cf_cast : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		cf_resolve.target:=cf_cast
		
		cf_cast.name:="asType"
		
		var tl_tracetype : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
		cf_cast.parameters.add(tl_tracetype)
		
		
		tl_tracetype.typeref:=context.kmtContext
			.getFromQualifiedName("root_package::TransformationContext")
			.asType(org::kermeta::language::structure::ClassDefinition)
			.generateTypeRef()
		
		
		var cf_getDefault : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature.new
		cf_cast.target:=cf_getDefault
		
		
		cf_getDefault.name:="getDefault"
		
		
		var tl_getDefault : org::kermeta::language::behavior::CallTypeLiteral init org::kermeta::language::behavior::CallTypeLiteral.new
		cf_getDefault.target:=tl_getDefault
		
		
		tl_getDefault.typeref:=context.kmtContext
			.getFromQualifiedName("root_package::TransformationContext")
			.asType(org::kermeta::language::structure::ClassDefinition)
			.generateTypeRef()
		
		//StdIO.writeln("ResolveExp::range2domain-end")
		
		//var out : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature
		//var out : org::kermeta::language::behavior::VoidLiteral  init org::kermeta::language::behavior::VoidLiteral.new
		//output:=out
		//out.addDocumentationTag("ResolveExp mapping to be implemented")
	end
end

}

/**
*	ModelTypes in qvt are the metamodels of the transformation
*	they consist in packages
*/
aspect class ModelType {

method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
	if output==void then
		StdIO.writeln("ModelType::range2domain")
		
		var out : org::kermeta::language::structure::ModelingUnit init org::kermeta::language::structure::ModelingUnit.new
		output:=out
		StdIO.writeln("mt1")
		metamodel.each{x|
				x.asType(emof::Object).range2domain(context) 
				StdIO.writeln("mt2")
				out.packages.add(x.output.asType(org::kermeta::language::structure::Package))
				}
		StdIO.writeln("ModelType::range2domain-end")
	end	

end
}

aspect class ContextualProperty
{
	/* TODO implement "initExpression" and "overriden" */
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
		if output==void then
			//StdIO.writeln("ContextualProperty::range2domain")
			var out : org::kermeta::language::structure::Property init org::kermeta::language::structure::Property.new
			output := out
			out.default := default
			out.isComposite := isComposite
			out.isReadOnly := isReadOnly
			out.isID := isID
			out.isDerived := isDerived
			out.name := name
			out.lower := lower
			out.upper := upper
			
			self.context.range2domain(context)
			out.owningClass?=self.context.output
			
			if opposite.isNotEqual(void) then
				opposite.range2domain(context)
				out.opposite ?= opposite.output
			end

			if type.isNotEqual(void) then
				out.type := type.generateType(context)
				if (out.type!=void) then
					out.containedType.add(out.type)
					StdIO.writeln("create a type "+type.name )
				else
					StdIO.writeln("type not created for "+type.name+ type.isInstanceOf(emof::DataType).toString)
				end
				
			end
			//StdIO.writeln("ContextualProperty::range2domain-end")
		end
	end

}

/**Mapping Call Exp behaves differently from OperationCallExp in two ways :
*	1) It requires to add a parameter giving an init value for the result of the mapping (usually this value will be void)
*	2) It requires a boolean parameter to state if the call to the mapping is strict or not
*/

aspect class MappingCallExp
{
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			var out : org::kermeta::language::behavior::CallOperation init org::kermeta::language::behavior::CallOperation.new
			output:=out
			
			//if there is a source model
			if source!=void then
				source.range2domain(context)
				out.target?=source.output
			else
				var transfoCall : org::kermeta::language::behavior::UnresolvedCall init org::kermeta::language::behavior::CallOperation.new.callToTransfoContextSingleton(context)
				out.target:=transfoCall
			end
			if (referredOperation !=void) then
				referredOperation.range2domain(context)
				out.staticOperation?=referredOperation.output
				if out.staticOperation==void then
					out.name:=referredOperation.name
				else
					out.name:=out.staticOperation.name
				end
				StdIO.writeln("referredOperation name : "+ referredOperation.name)
			end
			argument.each{x|
					x.range2domain(context) 
					if x.output!=void then 
						out.parameters.add(x.output.asType(org::kermeta::language::behavior::Expression)) 
					else 
						//StdIO.writeln("output is void for a : "+ x.getMetaClass.name) 
					end
					}
			//add result value
			var resultVal : org::kermeta::language::behavior::VoidLiteral init org::kermeta::language::behavior::VoidLiteral.new
			out.parameters.add(resultVal)
			
			//add isStrict value
			var isStrict : org::kermeta::language::behavior::BooleanLiteral init org::kermeta::language::behavior::BooleanLiteral.new
			isStrict.~value:=self.isStrict
			out.parameters.add(isStrict)
			
		end
	end
}



