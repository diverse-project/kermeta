package qvtoperational;

using root_package
using kermeta::standard
using kermeta::io

using org::kermeta::language




aspect class ConstructorBody {

	method range2domain(context : Qvt2KermetaContext)  : Void from emof::Object is do
		if output==void then
			//StdIO.writeln("ConstructorBody::range2domain")
			var out : behavior::Block init behavior::Block.new
			output:=out
			variable.each{v|
					out.statement.add(v.toVariableDecl(context))
					}
			content.each{oclexp|
					oclexp.range2domain(context)
					if not oclexp.output.isVoid() then 
						out.statement.add(oclexp.output.asType(behavior::Expression) )
					else
						StdIO.writeln( "a statement in content is void")
					end
					}
			//StdIO.writeln("ConstructorBody::range2domain-end")
		end
	end

}


aspect class ContextualProperty
{
	/* TODO implement "initExpression" and "overriden" */
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
		if output==void then
			//StdIO.writeln("ContextualProperty::range2domain")
			var out : structure::Property init structure::Property.new
			output := out
			out.default := default
			out.isComposite := isComposite
			out.isReadOnly := isReadOnly
			out.isID := isID
			out.isDerived := isDerived
			out.name := name
			out.lower := lower
			out.upper := upper
			
			self.context.range2domain(context)
			out.owningClass?=self.context.output
			
			if opposite.isNotEqual(void) then
				opposite.range2domain(context)
				out.opposite ?= opposite.output
			end

			if type.isNotEqual(void) then
				out.type := type.generateType(context)
				if (out.type!=void) then
					out.containedType.add(out.type)
					StdIO.writeln("create a type "+type.name )
				else
					StdIO.writeln("type not created for "+type.name+ type.isInstanceOf(emof::DataType).toString)
				end
				
			end
			//StdIO.writeln("ContextualProperty::range2domain-end")
		end
	end

}


aspect class EntryOperation {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is
		do
			if output==void then
				var out : structure::Operation init structure::Operation.new
				output:=out
				out.name:="main"
				out.lower:=lower
				out.upper:=upper
				out.isOrdered:=isOrdered
				out.isUnique:=isUnique
				
				//there is no parameters to an entry operation
				//there is no result parameter either
				
				//set owning class of output operation
				
				out.owningClass:=context.transfoContextCD
				
				//set body of output operation
				body.range2domain(context)
				out.body?=body.output
				out.addDocumentationTag("gen from an entry operation")
			end
		end
}




aspect class MappingParameter {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			//StdIO.writeln("MappingParameter::range2domain")
			var out : structure::Parameter init structure::Parameter.new
			output:=out
			
			out.name:=name
			out.upper:=upper
			out.lower:=lower
			out.isUnique:=isUnique
			out.isOrdered:=isOrdered
		
			type.range2domain(context)
			out.type:=type.generateType(context)
			if out.type.isInstanceOf(structure::Class) then
				out.containedType.add(out.type)
			end
			//StdIO.writeln("MappingParameter::range2domain-end")
		end
	end
}


aspect class ImperativeOperation {

	operation getTransformation() : OperationalTransformation is do
		//StdIO.writeln("MappingOperation::getTransformation")
		var o : kermeta::standard::Object
		result:=void
		/*from  o:=self.container
		until o.isInstanceOf(OperationalTransformation) or o==void
		loop
		    o:=o.container
		end

		result?=o*/
		//StdIO.writeln("MappingOperation::getTransformation-end")
	end

}


/**
for a mapping between qvtoperational::MappingOperation and org::kermeta::language::structure::Operation
context.type -- owningClass.type
result.type -- type
body.init -- body
body.content -- ??

TODO If the guard succeeds, the relation trace is checked to find out whether the relation already holds. If so, the out
parameters are populated using the corresponding trace tuples of the relation and the value associated to the result
parameters is returned.

*/
aspect class MappingOperation {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			//StdIO.writeln("MappingOperation::range2domain")
			StdIO.writeln("\nmapping operation "+name+" id "+oid.toString)
			var out : structure::Operation init structure::Operation.new
			output:=out
			out.name:=name
			out.lower:=lower
			out.upper:=upper
			out.isOrdered:=isOrdered
			out.isUnique:=isUnique
			
			//parameters
			ownedParameter.each{x|x.range2domain(context) out.ownedParameter.add(x.output.asType(structure::Parameter))}
			
			//two parameters should be added : the result parameter, that can be used for mapping inheritance
			//the isStrict parameter that should tell the behavior of the guard
			if (self.~result != void) then
				
				//TODO check if it is still useful
				/*if self.~result.one.type.output==void then
					StdIO.writeln("createTypedefinition "+self.~result.one.type.name)
					getTransformation().createTypeDefinition(self.~result.one.type,context)
				
				end*/
				 
				var resParam : structure::Parameter init structure::Parameter.new
				out.ownedParameter.add(resParam)
				resParam.name:="result"
				resParam.lower:=~result.one.lower
				resParam.upper:=~result.one.upper
				resParam.isOrdered:=~result.one.isOrdered
				resParam.isUnique:=~result.one.isUnique
				resParam.type:=self.~result.one.type.generateType(context)
				resParam.containedType.add(resParam.type)
			end
			
			var resStrict : structure::Parameter init structure::Parameter.new
			out.ownedParameter.add(resStrict)
			resStrict.name:="isStrict"
			resStrict.lower:=0
			resStrict.upper:=1
			resStrict.type:=structure::UnresolvedType.new.initialize("kermeta::standard::Boolean")
			resStrict.containedType.add(resStrict.type)
			
			
			//set owning class of output operation
			if (self.context!=void).andThen{x|self.context.type.isInstanceOf(emof::Class)} then
				out.owningClass?=self.context.type.output
			else
				out.owningClass:=context.transfoContextCD
			end
			
			//set return type of output operation
			if (self.~result != void) then
				
				if self.~result.size>1 then
					raise QvtNotImplementedException.new.initialize("Mappings with multiple results")
				end
				out.type:=self.~result.one.type.generateType(context)
				out.containedType.add(out.type)
			end
			
			//set body of output operation
			body.range2domain(context)
			out.body?=body.output
			
			out.addDocumentationTag("gen from a MappingOperation")
			//StdIO.writeln("MappingOperation::range2domain-end")	
		end	
	end
	
	
}

aspect class Helper
{
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is
		do
			if output==void then
				//StdIO.writeln("MappingOperation::range2domain")
				StdIO.writeln("\nhelper "+name+" id "+oid.toString)
				var out : structure::Operation init structure::Operation.new
				output:=out
				out.name:=name
				out.lower:=lower
				out.upper:=upper
				out.isOrdered:=isOrdered
				out.isUnique:=isUnique
				
				//parameters
				ownedParameter.each{x|x.range2domain(context) out.ownedParameter.add(x.output.asType(structure::Parameter))}
				
				//set owning class of output operation
				if (context!=void).andThen{x|self.context.type.isInstanceOf(emof::Class)} then
					out.owningClass?=self.context.type.output
				end
				
				//set return type of output operation
				if (self.~result != void) then
					
					if self.~result.size>1 then
						raise QvtNotImplementedException.new.initialize("Helpers with multiple results")
					end
					
					/*if self.~result.one.type.output==void then
						StdIO.writeln("createTypedefinition "+self.~result.one.type.name)
						getTransformation().createTypeDefinition(self.~result.one.type, context)
					
					end*/
					out.type:=self.~result.one.type.generateType(context)
					if  self.~result.one.type.isInstanceOf(emof::Class) or out.type.isInstanceOf(structure::UnresolvedType) then
						out.containedType.add(out.type)
					end
				end
				
				//set body of output operation
				body.range2domain(context)
				out.body?=body.output
				
				out.addDocumentationTag("gen from a helper")
			end
		end
}

/**
* it's the list of operation in a mapping, 
*	with initSection and endSection
*/

aspect class MappingBody {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
		
		if output==void then
			StdIO.writeln("MappingBody::range2domain")
			var out : behavior::Block init behavior::Block.new
			output:=out
			
			StdIO.writeln("MappingBody::range2domain-0")
			//before initialization, the guard should be checked
			if ~operation.asType(MappingOperation).when!=void then
				var whenCond : behavior::Conditional init behavior::Conditional.new
				out.statement.add(whenCond)
				~operation.asType(MappingOperation).when.range2domain(context)
				var notCall : behavior::CallFeature init behavior::CallFeature.new
				notCall.name:="not"
				notCall.target?=~operation.asType(MappingOperation).when.output
				whenCond.condition:=notCall
				
				//call violated guard exception
				var raiseExcep : behavior::Raise init behavior::Raise.new
				
				var newCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("new",false)
				//raiseExcep.expression:=newCall
				//newCall.name:="new"

				newCall.target:=behavior::UnresolvedCall.new.initialize("root_package::ViolatedGuardException", false)
				//var exceptionLiteral : behavior::CallTypeLiteral init behavior::CallTypeLiteral.new
				//newCall.target:=exceptionLiteral
				//var exceptionCD : structure::ClassDefinition
				
				//exceptionCD?= context.kmtContext.getFromQualifiedName("root_package::ViolatedGuardException")
				//exceptionLiteral.typeref:=exceptionCD.generateTypeRef()
				
				whenCond.thenBody:=raiseExcep
			end
			StdIO.writeln("MappingBody::range2domain-1")
			
			//before initialization, result should get its value from the result parameter in case of inherit call
			do 
				var initRes : behavior::Assignment init behavior::Assignment.new
				out.statement.add(initRes)
				initRes.target:=behavior::CallResult.new
				
				var resultVar : behavior::CallVariable init behavior::CallVariable.new
				initRes.~value:=resultVar
				resultVar.name:="result"
			end
			StdIO.writeln("MappingBody::range2domain-2")
			
			//start initialization section
			do
				var initBlock : behavior::Block init behavior::Block.new
				StdIO.writeln("MappingBody::range2domain-200")
				out.statement.add(initBlock)
				StdIO.writeln("MappingBody::range2domain-201"+initSection.toString)
				StdIO.writeln("size"+initSection.size.toString)
				initSection.each{oclexp|
					StdIO.writeln("MappingBody::range2domain-20")
					oclexp.range2domain(context)
					StdIO.writeln("MappingBody::range2domain-21")
					if not oclexp.output.isVoid() then
						initBlock.statement.add(oclexp.output.asType(behavior::Expression) )
					else
						//StdIO.writeln( "a statement in initSection is void "+oclexp.getMetaClass().name)
					end
					}
				StdIO.writeln("MappingBody::range2domain-22")
				initBlock.addDocumentationTag("initSection")
				StdIO.writeln("MappingBody::range2domain-23")
				//init parameters that are still null
				out.statement.add(createInit(context))
				StdIO.writeln("MappingBody::range2domain-24")
			end
			StdIO.writeln("MappingBody::range2domain-3")
			
			//add inheritance calls
			do
				~operation.asType(MappingOperation).inherited.each{
					op|
					var callInheritedOp : behavior::CallFeature init behavior::CallFeature.new
					out.statement.add(callInheritedOp)	
					callInheritedOp.target:=behavior::SelfExpression.new
					callInheritedOp.name:=op.name
					~operation.ownedParameter.each{param|
						var callParam : behavior::CallVariable init behavior::CallVariable.new
						callParam.name:=param.name
						callInheritedOp.parameters.add(callParam)}
					callInheritedOp.parameters.add(behavior::CallResult.new)
					var isStrictVal : behavior::BooleanLiteral init behavior::BooleanLiteral.new
					isStrictVal.~value:=false
					callInheritedOp.parameters.add(isStrictVal)
				}
			end
			StdIO.writeln("MappingBody::range2domain-4")
			
			//create trace
			do
				var trace : behavior::Expression init createTrace(context)
				out.statement.add(trace)
				trace.addDocumentationTag("trace generation")
			end
			
			StdIO.writeln("MappingBody::range2domain-5")
			//create all content
			content.each{oclexp|
				oclexp.range2domain(context)
				if not oclexp.output.isVoid() then 
				out.statement.add(oclexp.output.asType(behavior::Expression) )
				else
				StdIO.writeln( "a statement in content is void")
				end
				}
			//generate the usual rescues
			genDefaultRescues(context)
			StdIO.writeln("MappingBody::range2domain-end")
		end	
	end


	method genDefaultRescues(context : Qvt2KermetaContext) : Void is do
		
		super(context)		
		var bodyBlock : behavior::Block
		bodyBlock?=output
		//rescue for violated guard
		do
			var violatedGuardRescue : behavior::Rescue init behavior::Rescue.new
			bodyBlock.rescueBlock.add(violatedGuardRescue)
			violatedGuardRescue.exceptionName:="e"
			var violatedGuardType : structure::UnresolvedType init structure::UnresolvedType.new
			violatedGuardType.typeIdentifier:="root_package::ViolatedGuardException"
			violatedGuardRescue.exceptionType := violatedGuardType.generateTypeRef()
			
			var strictTest : behavior::Conditional init behavior::Conditional.new
			violatedGuardRescue.body.add(strictTest)
			var isStrictCall : behavior::CallVariable init behavior::CallVariable.new
			strictTest.condition:=isStrictCall
			isStrictCall.name:="isStrict"
		end
	end


	//generate the trace of the mapping
	operation createTrace(context : Qvt2KermetaContext) : behavior::Expression is do
		//StdIO.writeln("MappingBody::createTrace")
		var cf_trace :  behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("addTrace", true)
		result := cf_trace
		

		var call_source : behavior::SelfExpression init behavior::SelfExpression.new
		cf_trace.parameters.add(call_source)
		
		var call_target : behavior::CallResult init behavior::CallResult.new
		cf_trace.parameters.add(call_target)
		
		var traceContext : behavior::StringLiteral init behavior::StringLiteral.new
		traceContext.~value:=~operation.name
		cf_trace.parameters.add(traceContext)
		
		cf_trace.target:=behavior::UnresolvedCall.new.callToTransfoContextSingleton(context)
		
		
	end
	
	
	/**
		initialize a mapping parameter if it is void and add it to the right model
	*/
	operation initializeFromParameter(vp : qvtoperational::VarParameter, context : Qvt2KermetaContext) : behavior::Expression is do 
		StdIO.writeln("MappingBody::initializeFromParameter")
		result:=void
		if vp!=void then 
			
			//create condition
			var voidCondition  : behavior::Conditional init behavior::Conditional.new
			result :=voidCondition
			var callEquals : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("equals", true)
			voidCondition.condition:=callEquals
			var callX : behavior::CallExpression
			if vp.name!="result" then
				callX:=behavior::UnresolvedCall.new.initialize(vp.name,false)
			else
				callX:=behavior::CallResult.new
			end	
			callEquals.target:=callX
			callEquals.parameters.add(behavior::VoidLiteral.new)

			//then block
			var thenBlock : behavior::Block init behavior::Block.new
			voidCondition.thenBody:=thenBlock
			
			//add assignment
			var assign : behavior::Assignment init behavior::Assignment.new
			thenBlock.statement.add(assign)

			var callAssignee : behavior::CallVariable 
			if vp.name!="result" then
				callAssignee:=behavior::CallVariable.new
				callAssignee.name:=vp.name
			else
				callAssignee:= behavior::CallResult.new
			end
			
			assign.target:=callAssignee
			
			var newFeat : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("new",false)
			var typeLit : behavior::CallTypeLiteral init behavior::CallTypeLiteral.new
			var typeR : behavior::TypeReference init behavior::TypeReference.new
		
			assign.~value:=newFeat
			//newFeat.name:="new"
			newFeat.target:=typeLit
			
			if vp.name == "result" then
				if ~operation.upper==1 then
					typeR.type:=~operation.type.generateType(context)
					if typeR.type.isInstanceOf(structure::Class) then
						typeR.containedType.add(typeR.type)
						typeR.name:=typeR.type.asType(structure::NamedElement).name
					else
						if typeR.type.isInstanceOf(structure::UnresolvedType) then
							typeR.containedType.add(typeR.type)
						else
							typeR.name:=typeR.type.asType(structure::NamedElement).name
						end
					end
					
					typeR.upper:=1//~operation.upper
					typeR.lower:=0//~operation.lower 
				else
					typeR:=resultType(context)
				end
			else
				typeR.type:=vp.type.generateType(context)
				if typeR.type.isInstanceOf(structure::Class) then
					typeR.containedType.add(typeR.type)
					typeR.name:=typeR.type.asType(structure::Class).name
				else
					if typeR.type.isInstanceOf(structure::UnresolvedType) then
						typeR.containedType.add(typeR.type)
					else
						typeR.name:=typeR.type.asType(structure::NamedElement).name
					end
				end
				typeR.upper:=1
				typeR.lower:=0
			end
			
			
			typeLit.typeref:=typeR
			
			//add to the model type if extent is completed
			if vp.isInstanceOf(qvtoperational::MappingParameter).andThen{x|vp.asType(qvtoperational::MappingParameter).extent!=void} then
				var mp : qvtoperational::MappingParameter
				mp?=vp
				mp.extent.range2domain(context)
				var callModelParam : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize(mp.extent.output.asType(structure::Property).name,false)
				callModelParam.target := behavior::UnresolvedCall.new.callToTransfoContextSingleton(context)
				var callExtent : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("extent",false)
				callExtent.target:=callModelParam
				
				var callAddInstance : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("add",true)
				callAddInstance.target:=callExtent
				
				var callInstance : behavior::CallExpression
				if vp.name!="result" then
					callInstance:=behavior::UnresolvedCall.new.initialize(vp.name,false)
				else
					callInstance:= behavior::CallResult.new
				end
				callAddInstance.parameters.add(callInstance)
				thenBlock.statement.add(callAddInstance)
			end
		end
		StdIO.writeln("MappingBody::initializeFromParameter-end")
	end
	
	
	//implicit assignment of result 
	/**
		after initialization section, and before population section, there is an implicit initialization of
		all the out parameters declared in the mapping that still don't have value
	*/
	
	operation createInit(context : Qvt2KermetaContext) : behavior::Block is do
		StdIO.writeln("MappingBody::createInit")
		
		var block: behavior::Block init behavior::Block.new
		
		
		~operation.ownedParameter.each{x|
					var vp : qvtoperational::VarParameter
					vp?=x
					if (not x.type.isInstanceOf(emof::Class))
							.orElse{y|not x.type.asType(emof::Class).isAbstract} then
						block.statement.add(initializeFromParameter(vp,context))
					end
					}
		
		~operation.~result.each{vp|	
					
					if (not vp.type.isInstanceOf(emof::Class))
							.orElse{y|not vp.type.asType(emof::Class).isAbstract} then
					block.statement.add(initializeFromParameter(vp, context))
					end
					}
		
		result:=block
		StdIO.writeln("MappingBody::createInit-end")
	end
	
	/**return the equivalent of the operation return type in terms of collection depending on the cardinality, unicity and order*/
	operation resultType(context : Qvt2KermetaContext) : behavior::TypeReference is do
			//StdIO.writeln("MappingBody::resultType") 
			result:=behavior::TypeReference.new
			result.lower:=0
			result.upper:=1
			var classdef : structure::ClassDefinition
			
			if (~operation.isOrdered and ~operation.isUnique) then
				//orderedset
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::OrderedSet")	
			end
			if (~operation.isOrdered and not ~operation.isUnique) then
				//sequence
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Sequence")
			end
			if (not ~operation.isOrdered and ~operation.isUnique) then
				//set
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Set")
			end
			if (not ~operation.isOrdered and not ~operation.isUnique) then
				//bag
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Bag")
			end
			
			var collectionClass : structure::Class init structure::Class.new
			result.type:=collectionClass
			result.containedType.add(result.type)
			collectionClass.typeDefinition:=classdef
			
			var tvarBinding : structure::TypeVariableBinding init structure::TypeVariableBinding.new
			collectionClass.typeParamBinding.add(tvarBinding)		
			tvarBinding.variable:=classdef.typeParameter.one
			tvarBinding.type:=~operation.type.generateType(context)
			if tvarBinding.type.isInstanceOf(structure::Class) then 
				tvarBinding.containedType.add(tvarBinding.type)
			end
			//StdIO.writeln("MappingBody::resultType-end")
	end
}


/**
*	ModelTypes in qvt are the metamodels of the transformation
*	they consist in packages
*/
aspect class ModelType {

method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
	if output==void then
		StdIO.writeln("ModelType::range2domain")
		
		var out : structure::ModelingUnit init structure::ModelingUnit.new
		output:=out
		StdIO.writeln("mt1")
		metamodel.each{x|
				x.asType(emof::Object).range2domain(context) 
				StdIO.writeln("mt2")
				out.packages.add(x.output.asType(structure::Package))
				}
		StdIO.writeln("ModelType::range2domain-end")
	end	

end
}

/**Mapping Call Exp behaves differently from OperationCallExp in two ways :
*	1) It requires to add a parameter giving an init value for the result of the mapping (usually this value will be void)
*	2) It requires a boolean parameter to state if the call to the mapping is strict or not
*/

aspect class MappingCallExp
{
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			var out : behavior::CallOperation init behavior::CallOperation.new
			output:=out
			
			//if there is a source model
			if source!=void then
				source.range2domain(context)
				out.target?=source.output
			else
				var transfoCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new.callToTransfoContextSingleton(context)
				out.target:=transfoCall
			end
			if (referredOperation !=void) then
				referredOperation.range2domain(context)
				out.staticOperation?=referredOperation.output
				if out.staticOperation==void then
					out.name:=referredOperation.name
				else
					out.name:=out.staticOperation.name
				end
				StdIO.writeln("referredOperation name : "+ referredOperation.name)
			end
			argument.each{x|
					x.range2domain(context) 
					if x.output!=void then 
						out.parameters.add(x.output.asType(behavior::Expression)) 
					else 
						//StdIO.writeln("output is void for a : "+ x.getMetaClass.name) 
					end
					}
			//add result value
			var resultVal : behavior::VoidLiteral init behavior::VoidLiteral.new
			out.parameters.add(resultVal)
			
			//add isStrict value
			var isStrict : behavior::BooleanLiteral init behavior::BooleanLiteral.new
			isStrict.~value:=self.isStrict
			out.parameters.add(isStrict)
			
		end
	end
}






aspect class ObjectExp {

	/* beware ! it will work if body is not modified anywhere else*/
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			//StdIO.writeln("ObjectExp::range2domain")
			var out : behavior::Block
			body.range2domain(context)
			out?=body.output
			if out==void then
				out:=behavior::Block.new
			end
			output:=out
			//this call variable is added for the objectexp block to return the object once created
			//TODO workaround for result
			
			var cv : behavior::CallVariable 
			if referredObject.name=="result" then
				cv:=behavior::CallResult.new
			else		
				cv:=behavior::CallVariable.new
			end
			cv.name:=referredObject.name
			out.statement.add(cv)
			//StdIO.writeln("ObjectExp::range2domain-end")
		end
	end
}

aspect class OperationBody {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			StdIO.writeln("OperationBody::range2domain")
			var out : behavior::Block init behavior::Block.new
			output:=out
			
			if ~operation.isInstanceOf(Helper)
					.andThen{x|~operation.asType(Helper).isQuery==void}
					.andThen{x|content.size==1} then
				content.one.range2domain(context)
				var resAssign : behavior::Assignment init behavior::Assignment.new
				resAssign.target:=behavior::CallResult.new
				resAssign.~value?=content.one.output
				out.statement.add(resAssign)
			
			else
			content.each{oclexp|
					oclexp.range2domain(context)
					if not oclexp.output.isVoid() then 
						out.statement.add(oclexp.output.asType(behavior::Expression) )
					else
						StdIO.writeln( "a statement in content is void")
					end
					}
			genDefaultRescues(context)
			end
			StdIO.writeln("OperationBody::range2domain-end")
		end
	end

	operation genDefaultRescues(context : Qvt2KermetaContext) : Void is do
		StdIO.writeln("OperationBody::genDefaultRescues")
		var bodyBlock : behavior::Block
		bodyBlock?=output
		StdIO.writeln("OperationBody::genDefaultRescues-0")
		
		//rescue for return
		do 
			var returnRescue : behavior::Rescue init behavior::Rescue.new
			bodyBlock.rescueBlock.add(returnRescue)
			returnRescue.exceptionName := "e"
			
			var returnExpType: structure::UnresolvedType init structure::UnresolvedType.new 
			returnExpType.typeIdentifier:="root_package::ReturnException"
			//var returnExpCD : org::kermeta::language::structure::ClassDefinition
			//returnExpCD?=context.kmtContext.getFromQualifiedName("root_package::ReturnException")
			StdIO.writeln("OperationBody::genDefaultRescues-01")
			StdIO.writeln("exceptionType"+returnRescue.exceptionType.toString)
			returnRescue.exceptionType:=returnExpType.generateTypeRef()
			StdIO.writeln("OperationBody::genDefaultRescues-1")
		
			var voidTest : behavior::Conditional init behavior::Conditional.new
			returnRescue.body.add(voidTest)
			var hasValueCall : behavior::CallFeature init behavior::CallFeature.new
			voidTest.condition:=hasValueCall
			hasValueCall.name:="hasValue"
			hasValueCall.target:=behavior::CallVariable.new.initName("e")
			StdIO.writeln("OperationBody::genDefaultRescues-2")
		
			var assignResult : behavior::Assignment init behavior::Assignment.new
			voidTest.thenBody:=assignResult
			assignResult.isCast:=true
			assignResult.target:=behavior::CallResult.new
			StdIO.writeln("OperationBody::genDefaultRescues-3")
		
			var callresultValue :behavior::CallFeature init behavior::CallFeature.new
			assignResult.~value:=callresultValue
			callresultValue.name:="returnValue"
			callresultValue.target:=behavior::CallVariable.new.initName("e")
		end
		
		StdIO.writeln("OperationBody::genDefaultRescues-end")
	end
}

aspect class ModelParameter {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output == void then 
			var out : structure::Property init structure::Property.new
			output:=out
			out.isUnique:=true
			out.lower:=0
			out.upper:=1
			out.isComposite:=true
			out.name:=name
			//var classDef : org::kermeta::language::structure::ClassDefinition
			//classDef?=context.kmtContext.getFromQualifiedName("root_package::ModelParameter")
			
			//out.type:= org::kermeta::language::structure::Class.new
			//out.type.asType(org::kermeta::language::structure::Class).typeDefinition:=classDef
			out.type:=structure::UnresolvedType.new.initialize("root_package::ModelParameter")
			out.containedType.add(out.type)
			
		
		
		end
	end

}

/**
in qvt operations are separated from classes definition which is not the case in kermeta
so it is needed to recreate the class hierarchy in kermeta to add operations
*/

aspect class OperationalTransformation {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then 
			var out : structure::ModelingUnit init structure::ModelingUnit.new
			output:=out
			
			//creation of package where will be stored all needed elements to run the transformation
			var execEnvPack : structure::Package init structure::Package.new			
			out.packages.add(execEnvPack)
			execEnvPack.name:="root_package"
			
			var transfoContextCD : structure::ClassDefinition init structure::ClassDefinition.new
			context.transfoContextCD:=transfoContextCD
			execEnvPack.ownedTypeDefinition.add(transfoContextCD)
			transfoContextCD.name:="TransformationContext"
			transfoContextCD.isAspect:=true
			transfoContextCD.isSingleton:=true
			
			modelParameter.each{x|
				x.range2domain(context)
				transfoContextCD.ownedAttribute.add(x.output.asType(structure::Property))
			}
			
			transfoContextCD.ownedOperation.add(generateInitOperation(context))
		
		end
	end


	operation genClassDefinition(context : Qvt2KermetaContext) : Void is do
		//StdIO.writeln("OperationalTransformation::genClassDefinition") 
		ownedOperation.each{op | 
				StdIO.writeln("genClassDef")
				if op.isInstanceOf(qvtoperational::ImperativeOperation)
					.andThen{x|op.asType(ImperativeOperation).context!=void} then
					createTypeDefinition(op.asType(ImperativeOperation).context.type, context) 
				end 
				}
		//StdIO.writeln("OperationalTransformation::genClassDefinition-end")
	end

	operation createTypeDefinition(type : emof::Type, context : Qvt2KermetaContext) : Void is do 
		StdIO.writeln("OperationalTransformation::createTypeDefinition")
		StdIO.writeln("createContext "+type.toString)
		StdIO.writeln("name"+type.name)
		createPackage(type.container.asType(emof::Package), context)
		type.range2domain(context)
		type.container.asType(emof::Package).output.asType(structure::Package).ownedTypeDefinition.add(type.output.asType(structure::TypeDefinition))
		StdIO.writeln("OperationalTransformation::createTypeDefinition-end")
	end

	operation createPackage(pack : emof::Package, context : Qvt2KermetaContext) : Void is do
		if pack.output==void then
			//StdIO.writeln("OperationalTransformation::createPackage")
			pack.range2domain(context)
			if pack.container.isInstanceOf(kermeta::emfpersistence::Resource) then
				output.asType(structure::ModelingUnit).packages.add(pack.output.asType(structure::Package))
			else
				if (pack.container.asType(emof::Object).output==void).andThen{x|pack.container.isInstanceOf(emof::Package)} then
					createPackage(pack.container.asType(emof::Package),context)
					pack.container.asType(emof::Object).output.asType(structure::Package).nestedPackage
						.add(pack.output.asType(structure::Package))
				end
			end
			//StdIO.writeln("OperationalTransformation::createPackage-end")
		end
	end
	
	
	/**
	create the main operation of the transformation which load the parameters of the transformations
	
	*/
	
	operation generateInitOperation(context : Qvt2KermetaContext) : structure::Operation is do
		var initOp : structure::Operation init structure::Operation.new
		initOp.name := "kermetaInit"
		initOp.upper:=1
		initOp.type:=structure::UnresolvedType.new.initialize("kermeta::standard::Void")
		initOp.containedType.add(initOp.type)

		
		
		//each modelParameter correspond to 2 parameters, one for the path to the model, the other for the path to the metamodel
		var paramNumber : Integer init 1
		modelParameter.each{param|
			var model : structure::Parameter init structure::Parameter.new
			model.name := "model" + paramNumber.toString
			model.upper := 1
			model.type:=structure::UnresolvedType.new.initialize("kermeta::standard::String")
			model.containedType.add(model.type)
			initOp.ownedParameter.add(model)
			

			var metaModel : structure::Parameter init structure::Parameter.new
			metaModel.name := "mmodel" + paramNumber.toString
			metaModel.type:=structure::UnresolvedType.new.initialize("kermeta::standard::String")
			metaModel.containedType.add(metaModel.type)
			initOp.ownedParameter.add(metaModel)
			paramNumber:=paramNumber+1
		}
		var opBlock : behavior::Block init behavior::Block.new
		initOp.body:=opBlock
		
		//initialize the traceregistry root_package::TransformationContext:=traceability::TraceRegistry.new
		var assignRegistry : behavior::Assignment init behavior::Assignment.new
		var newRegistry : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("new",false)
		newRegistry.target:=behavior::UnresolvedCall.new.initialize("traceability::TraceRegistry",false)
		assignRegistry.~value := newRegistry
		
		var registryCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("traceRegistry",false)
		registryCall.target:=behavior::UnresolvedCall.new.initialize("root_package::TransformationContext",false)
		assignRegistry.target := registryCall
		opBlock.statement.add(assignRegistry)
		
		
		//create var decl for the resourceset ofeach model
		paramNumber:=1
		modelParameter.each{param|
			var rSetDecl : behavior::VariableDecl init behavior::VariableDecl.new
			
			rSetDecl.identifier:= "rSet"+paramNumber
			rSetDecl.type:=structure::UnresolvedType.new.initialize("kermeta::emfpersistence::ResourceSet").generateTypeRef()
			
		
			var rSetInitCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("new",false)
			rSetInitCall.target:=behavior::UnresolvedCall.new.initialize("kermeta::emfpersistence::ResourceSet",false)
			
			rSetDecl.initialization:=rSetInitCall
			opBlock.statement.add(rSetDecl)
			
			paramNumber:=paramNumber+1
		}
		
		//create a resource for each parameter
		paramNumber:=1
		modelParameter.each{param|
			
			//rSet$x.createResource(model$x,metaModel$x)
			var callCreateResource : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("createResource",true)
			callCreateResource.target:= behavior::UnresolvedCall.new.initialize("rSet"+paramNumber,false)
			callCreateResource.parameters.add(behavior::UnresolvedCall.new.initialize("model"+paramNumber,false))
			callCreateResource.parameters.add(behavior::UnresolvedCall.new.initialize("mmodel"+paramNumber,false))
			
			//$modelParameter := root_package::ModelParameter.new.initialize($callCreateResource)
			var assign : behavior::Assignment init behavior::Assignment.new
			
			var currentModelParam : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize(param.name,false)
			currentModelParam.target:=behavior::UnresolvedCall.new.initialize("root_package::TransformationContext",false)
			assign.target:=currentModelParam
			
			var initializeCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("initialize",true)
			initializeCall.target := behavior::UnresolvedCall.new.initialize("new",false)
			initializeCall.target.asType(behavior::UnresolvedCall).target := behavior::UnresolvedCall.new.initialize("root_package::ModelParameter",false)
			initializeCall.parameters.add(callCreateResource)
			assign.~value:=initializeCall
			
			opBlock.statement.add(assign)
			paramNumber:=paramNumber+1
		}
		//load parameters which are input parameters
		//root_package::TransformationContext.$(param.name).load()
		paramNumber:=1
		modelParameter.each{param|
			//TODO change the test when enumeration from ecore are fixed
			//if param.kind==DirectionKind.in or param.kind==DirectionKind.inout then
			if param.kind.toString=="in" or param.kind.toString=="inout" then
				StdIO.writeln("DirectionKind "+param.kind.toString+" "+(param.kind==DirectionKind.in).toString)
				var callLoad : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("load",true)
				callLoad.target:= behavior::UnresolvedCall.new.initialize(param.name,false)
				callLoad.target.asType(behavior::UnresolvedCall).target:= behavior::UnresolvedCall.new.initialize("root_package::TransformationContext",false)
				//callLoad.parameters.add(behavior::VoidLiteral.new)
				opBlock.statement.add(callLoad)
			end
			StdIO.writeln("DirectionKind "+param.kind.toString+" "+(param.kind==DirectionKind.in).toString)
			paramNumber:=paramNumber+1
		}
		
		opBlock.statement.add(behavior::UnresolvedCall.new.initialize("main",true))
		
		//save parameters which are out parameters
		//root_package::TransformationContext.$(param.name).load()
		modelParameter.each{param|
			//TODO change the test when enumeration from ecore are fixed
			//if param.kind==DirectionKind.out or param.kind==DirectionKind.inout then
			if param.kind.toString=="out" or param.kind.toString=="inout" then
				var callSave : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("save",true)
				callSave.target:= behavior::UnresolvedCall.new.initialize(param.name,false)
				callSave.target.asType(behavior::UnresolvedCall).target:= behavior::UnresolvedCall.new.initialize("root_package::TransformationContext",false)
				//callSave.parameters.add(behavior::VoidLiteral.new)
				opBlock.statement.add(callSave)
			end
			
			paramNumber:=paramNumber+1
		}
		result:=initOp
	end
	
}




/**
* resolveExp is the operation that can require a link of traceability
* TODO : implement deferred resolution 
*/
aspect class ResolveExp {

method range2domain(context : Qvt2KermetaContext) : Void is do
	if output==void then
		//StdIO.writeln("ResolveExp::range2domain")
		var cf_resolve :  behavior::CallFeature init behavior::CallFeature.new
		//if one is true and there is no condition then it's simply a detect on the type of target
		//if one is false then it's a select on the type that should return a sequence of the type

			var detectCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new
		
		//type of the found object
		if one then
			var detectCast : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("asType",true)
			output:=detectCast
			target.type.range2domain(context)
						
			detectCast.parameters.add(behavior::UnresolvedCall.new.initialize(target.type.getQVTID,false))
			detectCast.target:=detectCall
			detectCall.name:="detect"
		else
			/*var deferredcast : behavior::CallFeature  init behavior::CallFeature.new
			output:=deferredcast
			deferredcast.name:="fromSeq"
	
			var dSeqInit : behavior::CallFeature init behavior::CallFeature.new
			deferredcast.target:=dSeqInit
			dSeqInit.name:="new"
			
			var dseqCD : structure::ClassDefinition 
			dseqCD?=context.kmtContext.getFromQualifiedName("kermeta::standard::DeferredSequence")
			
			var dseqLit : behavior::CallTypeLiteral init behavior::CallTypeLiteral.new
			dSeqInit.target:=dseqLit
			dseqLit.typeref:=dseqCD.generateParameterizedTypeRef(self.target.type.output.asType(structure::ClassDefinition))
			
			deferredcast.parameters.add(detectCall)
			detectCall.name:="select"*/
			
			var seqProxy : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("asSequenceType",false)
			seqProxy.target:=detectCall
			var generic : structure::Type init self.target.type.generateType(context)
			seqProxy.generics.add(generic)
			seqProxy.containedType.add(generic)
			detectCall.name:="select"
		end
		
		var lambdaExp : behavior::LambdaExpression init behavior::LambdaExpression.new
		detectCall.parameters.add(lambdaExp)
		var lambdaParam : behavior::LambdaParameter init behavior::LambdaParameter.new	
		lambdaExp.parameters.add(lambdaParam)
		lambdaParam.name:=target.name
		
		
		
		var andCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("and",true)
		lambdaExp.body:=andCall
		var typeTestCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("isInstanceOf",true)
		andCall.target:=typeTestCall

		
					
		/*var boolClass: structure::Class init structure::Class.new
		typeTestCall.staticType:=boolClass
		typeTestCall.containedType.add(boolClass)
		boolClass.typeDefinition?=context.kmtContext.getFromQualifiedName("kermeta::standard::Boolean")
		*/
		var xCall : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize(target.name, false)
		typeTestCall.target:=xCall
		
		
		if condition==void then
			var truelit : behavior::BooleanLiteral init behavior::BooleanLiteral.new
			andCall.parameters.add(truelit)
			truelit.~value:=true
		else
			var exp : behavior::Expression 
			condition.range2domain(context)
			exp?=condition.output
			andCall.parameters.add(exp)
		end
		
		var typeToTest : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize(target.type.getQVTID,false)
		
		//typeToTest.typeref:=target.type.output.asType(structure::ClassDefinition).generateTypeRef() //range2domain already done earlier
		typeTestCall.parameters.add(typeToTest)
		
		detectCall.target:=cf_resolve
		
		if isInverse then
			cf_resolve.name:="resolveAllSource"
		else
			cf_resolve.name:="resolveAllTargets"
		end
		
		source.range2domain(context)
		cf_resolve.parameters.add(source.output.asType(behavior::Expression))
		
		//target.toVariableDecl()
		//cf_resolve.parameters.add(target.output.asType(org::kermeta::language::behavior::Expression))
		
		var cf_cast : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("asType",true)
		cf_resolve.target:=cf_cast
		
		
		
		var tl_tracetype : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("root_package::TransformationContext",false)
		cf_cast.parameters.add(tl_tracetype)
		
		
		/*tl_tracetype.typeref:=context.kmtContext
			.getFromQualifiedName("root_package::TransformationContext")
			.asType(structure::ClassDefinition)
			.generateTypeRef()*/
		
		
		var cf_getDefault : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("getDefault",true)
		cf_cast.target:=cf_getDefault
		
		
		//cf_getDefault.name:="getDefault"
		
		
		var tl_getDefault : behavior::UnresolvedCall init behavior::UnresolvedCall.new.initialize("root_package::TransformationContext",false)
		cf_getDefault.target:=tl_getDefault
		
		
		/*tl_getDefault.typeref:=context.kmtContext
			.getFromQualifiedName("root_package::TransformationContext")
			.asType(structure::ClassDefinition)
			.generateTypeRef()*/
		
		//StdIO.writeln("ResolveExp::range2domain-end")
		
		//var out : org::kermeta::language::behavior::CallFeature init org::kermeta::language::behavior::CallFeature
		//var out : org::kermeta::language::behavior::VoidLiteral  init org::kermeta::language::behavior::VoidLiteral.new
		//output:=out
		//out.addDocumentationTag("ResolveExp mapping to be implemented")
	end
end

}
