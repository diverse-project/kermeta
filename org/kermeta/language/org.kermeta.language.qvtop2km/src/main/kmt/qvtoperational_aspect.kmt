package qvtoperational;

using root_package
using kermeta::standard
using kermeta::io

aspect class ObjectExp {

	/* beware ! it will work if body is not modified anywhere else*/
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			//StdIO.writeln("ObjectExp::range2domain")
			var out : kermeta::language::behavior::Block
			body.range2domain(context)
			out?=body.output
			if out==void then
				out:=kermeta::language::behavior::Block.new
			end
			output:=out
			//this call variable is added for the objectexp block to return the object once created
			//TODO workaround for result
			
			var cv : kermeta::language::behavior::CallVariable 
			if referredObject.name=="result" then
				cv:=kermeta::language::behavior::CallResult.new
			else		
				cv:=kermeta::language::behavior::CallVariable.new
			end
			cv.name:=referredObject.name
			out.statement.add(cv)
			//StdIO.writeln("ObjectExp::range2domain-end")
		end
	end
}



aspect class ConstructorBody {

	method range2domain(context : Qvt2KermetaContext)  : Void from emof::Object is do
		if output==void then
			//StdIO.writeln("ConstructorBody::range2domain")
			var out : kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
			output:=out
			variable.each{v|
					out.statement.add(v.toVariableDecl(context))
					}
			content.each{oclexp|
					oclexp.range2domain(context)
					if not oclexp.output.isVoid() then 
						out.statement.add(oclexp.output.asType(kermeta::language::behavior::Expression) )
					else
						StdIO.writeln( "a statement in content is void")
					end
					}
			//StdIO.writeln("ConstructorBody::range2domain-end")
		end
	end

}

aspect class EntryOperation {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is
		do
			if output==void then
				var out : kermeta::language::structure::Operation init kermeta::language::structure::Operation.new
				output:=out
				out.name:="main"
				out.lower:=lower
				out.upper:=upper
				out.isOrdered:=isOrdered
				out.isUnique:=isUnique
				
				//there is no parameters to an entry operation
				//there is no result parameter either
				
				//set owning class of output operation
				
				out.owningClass:=context.transfoContextCD
				
				//set body of output operation
				body.range2domain(context)
				out.body?=body.output
				out.addDocumentationTag("gen from an entry operation")
			end
		end
}


aspect class OperationBody {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			//StdIO.writeln("OperationBody::range2domain")
			var out : kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
			output:=out
			
			if ~operation.isInstanceOf(Helper)
					.andThen{x|~operation.asType(Helper).isQuery==void}
					.andThen{x|content.size==1} then
				content.one.range2domain(context)
				var resAssign : kermeta::language::behavior::Assignment init kermeta::language::behavior::Assignment.new
				resAssign.target:=kermeta::language::behavior::CallResult.new
				resAssign.~value?=content.one.output
				out.statement.add(resAssign)
			
			else
			content.each{oclexp|
					oclexp.range2domain(context)
					if not oclexp.output.isVoid() then 
						out.statement.add(oclexp.output.asType(kermeta::language::behavior::Expression) )
					else
						StdIO.writeln( "a statement in content is void")
					end
					}
			genDefaultRescues(context)
			end
			//StdIO.writeln("OperationBody::range2domain-end")
		end
	end

	operation genDefaultRescues(context : Qvt2KermetaContext) : Void is do
		var bodyBlock : kermeta::language::behavior::Block
		bodyBlock?=output
		//rescue for return
		do 
			var returnRescue : kermeta::language::behavior::Rescue init kermeta::language::behavior::Rescue.new
			bodyBlock.rescueBlock.add(returnRescue)
			returnRescue.exceptionName := "e"
			var returnExpCD : kermeta::language::structure::ClassDefinition
			returnExpCD?=context.kmtContext.getFromQualifiedName("root_package::ReturnException")
			returnRescue.exceptionType:=returnExpCD.generateTypeRef()
			
			var voidTest : kermeta::language::behavior::Conditional init kermeta::language::behavior::Conditional.new
			returnRescue.body.add(voidTest)
			var hasValueCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			voidTest.condition:=hasValueCall
			hasValueCall.name:="hasValue"
			hasValueCall.target:=kermeta::language::behavior::CallVariable.new.initName("e")
			
			var assignResult : kermeta::language::behavior::Assignment init kermeta::language::behavior::Assignment.new
			voidTest.thenBody:=assignResult
			assignResult.isCast:=true
			assignResult.target:=kermeta::language::behavior::CallResult.new
			
			var callresultValue :kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			assignResult.~value:=callresultValue
			callresultValue.name:="returnValue"
			callresultValue.target:=kermeta::language::behavior::CallVariable.new.initName("e")
		end
		
		
	end
}


aspect class MappingParameter {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			//StdIO.writeln("MappingParameter::range2domain")
			var out : kermeta::language::structure::Parameter init kermeta::language::structure::Parameter.new
			output:=out
			
			out.name:=name
			out.upper:=upper
			out.lower:=lower
			out.isUnique:=isUnique
			out.isOrdered:=isOrdered
		
			type.range2domain(context)
			out.type:=type.generateType(context)
			if out.type.isInstanceOf(kermeta::language::structure::Class) then
				out.containedType.add(out.type)
			end
			//StdIO.writeln("MappingParameter::range2domain-end")
		end
	end
}


aspect class ImperativeOperation {

	operation getTransformation() : OperationalTransformation is do
		//StdIO.writeln("MappingOperation::getTransformation")
		var o : kermeta::language::structure::Object
		
		from  var x : kermeta::language::structure::Object init o:=self.container
		until o.isInstanceOf(OperationalTransformation) or o==void
		loop
		    o:=o.container
		end

		result?=o
		//StdIO.writeln("MappingOperation::getTransformation-end")
	end

}


/**
for a mapping between qvtoperational::MappingOperation and kermeta::language::structure::Operation
context.type -- owningClass.type
result.type -- type
body.init -- body
body.content -- ??

TODO If the guard succeeds, the relation trace is checked to find out whether the relation already holds. If so, the out
parameters are populated using the corresponding trace tuples of the relation and the value associated to the result
parameters is returned.

*/
aspect class MappingOperation {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then
			//StdIO.writeln("MappingOperation::range2domain")
			StdIO.writeln("\nmapping operation "+name+" id "+oid.toString)
			var out : kermeta::language::structure::Operation init kermeta::language::structure::Operation.new
			output:=out
			out.name:=name
			out.lower:=lower
			out.upper:=upper
			out.isOrdered:=isOrdered
			out.isUnique:=isUnique
			
			//parameters
			ownedParameter.each{x|x.range2domain(context) out.ownedParameter.add(x.output.asType(kermeta::language::structure::Parameter))}
			
			//two parameters should be added : the result parameter, that can be used for mapping inheritance
			//the isStrict parameter that should tell the behavior of the guard
			if (self.~result != void) then
				
				
				//TODO check if it is still useful
				if self.~result.one.type.output==void then
					StdIO.writeln("createTypedefinition "+self.~result.one.type.name)
					getTransformation().createTypeDefinition(self.~result.one.type,context)
				
				end
				
				var resParam : kermeta::language::structure::Parameter init kermeta::language::structure::Parameter.new
				out.ownedParameter.add(resParam)
				resParam.name:="result"
				resParam.lower:=~result.one.lower
				resParam.upper:=~result.one.upper
				resParam.isOrdered:=~result.one.isOrdered
				resParam.isUnique:=~result.one.isUnique
				resParam.type:=self.~result.one.type.generateType(context)
				resParam.containedType.add(resParam.type)
			end
			
			
			var resStrict : kermeta::language::structure::Parameter init kermeta::language::structure::Parameter.new
			out.ownedParameter.add(resStrict)
			resStrict.name:="isStrict"
			resStrict.lower:=0
			resStrict.upper:=1
			//resStrict.isOrdered:=true
			//resStrict.isUnique:=false
			var boolType : kermeta::language::structure::Class init kermeta::language::structure::Class.new
			resStrict.type:=boolType
			boolType.typeDefinition?=context.kmtContext.getFromQualifiedName("kermeta::standard::Boolean")
			resStrict.containedType.add(boolType)
			
			
			//set owning class of output operation
			if (self.context!=void).andThen{x|self.context.type.isInstanceOf(emof::Class)} then
				out.owningClass?=self.context.type.output
			else
				out.owningClass:=context.transfoContextCD
			end
			
			//set return type of output operation
			if (self.~result != void) then
				
				if self.~result.size>1 then
					raise QvtNotImplementedException.new.initialize("Mappings with multiple results")
				end
				
				
				out.type:=self.~result.one.type.generateType(context)
				out.containedType.add(out.type)
				/* kermeta::language::structure::Class.new
				out.containedType.add(out.type)
				out.type.asType(kermeta::language::structure::ParameterizedType).typeDefinition?=self.~result.one.type.output*/
			end
			
			//set body of output operation
			body.range2domain(context)
			out.body?=body.output
			
			out.addDocumentationTag("gen from a MappingOperation")
			//StdIO.writeln("MappingOperation::range2domain-end")	
		end	
	end
	
	
}

aspect class Helper
{
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is
		do
			if output==void then
				//StdIO.writeln("MappingOperation::range2domain")
				StdIO.writeln("\nhelper "+name+" id "+oid.toString)
				var out : kermeta::language::structure::Operation init kermeta::language::structure::Operation.new
				output:=out
				out.name:=name
				out.lower:=lower
				out.upper:=upper
				out.isOrdered:=isOrdered
				out.isUnique:=isUnique
				
				//parameters
				ownedParameter.each{x|x.range2domain(context) out.ownedParameter.add(x.output.asType(kermeta::language::structure::Parameter))}
				
				//set owning class of output operation
				if (context!=void).andThen{x|self.context.type.isInstanceOf(emof::Class)} then
					out.owningClass?=self.context.type.output
				end
				
				//set return type of output operation
				if (self.~result != void) then
					
					if self.~result.size>1 then
						raise QvtNotImplementedException.new.initialize("Helpers with multiple results")
					end
					
					if self.~result.one.type.output==void then
						StdIO.writeln("createTypedefinition "+self.~result.one.type.name)
						getTransformation().createTypeDefinition(self.~result.one.type, context)
					
					end
					out.type:=self.~result.one.type.generateType(context)
					if  self.~result.one.type.isInstanceOf(emof::Class) then
						out.containedType.add(out.type)
					end
				end
				
				//set body of output operation
				body.range2domain(context)
				out.body?=body.output
				
				out.addDocumentationTag("gen from a helper")
			end
		end
}

/**
* it's the list of operation in a mapping, 
*	with initSection and endSection
*/

aspect class MappingBody {
	
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
		
		if output==void then
			//StdIO.writeln("MappingBody::range2domain")
			var out : kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
			output:=out
			
			
			//before initialization, the guard should be checked
			if ~operation.asType(MappingOperation).when!=void then
				var whenCond : kermeta::language::behavior::Conditional init kermeta::language::behavior::Conditional.new
				out.statement.add(whenCond)
				~operation.asType(MappingOperation).when.range2domain(context)
				var notCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				notCall.name:="not"
				notCall.target?=~operation.asType(MappingOperation).when.output
				whenCond.condition:=notCall
				
				//call violated guard exception
				var raiseExcep : kermeta::language::behavior::Raise init kermeta::language::behavior::Raise.new
				
				var newCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				raiseExcep.expression:=newCall
				newCall.name:="new"

				var exceptionLiteral : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
				newCall.target:=exceptionLiteral
				var exceptionCD : kermeta::language::structure::ClassDefinition
				
				exceptionCD?= context.kmtContext.getFromQualifiedName("root_package::ViolatedGuardException")
				exceptionLiteral.typeref:=exceptionCD.generateTypeRef()
				
				whenCond.thenBody:=raiseExcep
			end
			
			
			//before initialization, result should get its value from the result parameter in case of inherit call
			do 
				var initRes : kermeta::language::behavior::Assignment init kermeta::language::behavior::Assignment.new
				out.statement.add(initRes)
				initRes.target:=kermeta::language::behavior::CallResult.new
				
				var resultVar : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
				initRes.~value:=resultVar
				resultVar.name:="result"
			end
			
			//start initialization section
			do
				var initBlock : kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
				out.statement.add(initBlock)
				initSection.each{oclexp|
					oclexp.range2domain(context)
					if not oclexp.output.isVoid() then
						initBlock.statement.add(oclexp.output.asType(kermeta::language::behavior::Expression) )
					else
						//StdIO.writeln( "a statement in initSection is void "+oclexp.getMetaClass().name)
					end
					}
				initBlock.addDocumentationTag("initSection")
				//init parameters that are still null
				out.statement.add(createInit(context))
			end
			//add inheritance calls
			do
				~operation.asType(MappingOperation).inherited.each{
					op|
					var callInheritedOp : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
					out.statement.add(callInheritedOp)	
					callInheritedOp.target:=kermeta::language::behavior::SelfExpression.new
					callInheritedOp.name:=op.name
					~operation.ownedParameter.each{param|
						var callParam : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
						callParam.name:=param.name
						callInheritedOp.parameters.add(callParam)}
					callInheritedOp.parameters.add(kermeta::language::behavior::CallResult.new)
					var isStrictVal : kermeta::language::behavior::BooleanLiteral init kermeta::language::behavior::BooleanLiteral.new
					isStrictVal.~value:=false
					callInheritedOp.parameters.add(isStrictVal)
				}
			end
			
			//create trace
			do
				var trace : kermeta::language::behavior::Expression init createTrace(context)
				out.statement.add(trace)
				trace.addDocumentationTag("trace generation")
			end
			//create all content
			content.each{oclexp|
				oclexp.range2domain(context)
				if not oclexp.output.isVoid() then 
				out.statement.add(oclexp.output.asType(kermeta::language::behavior::Expression) )
				else
				StdIO.writeln( "a statement in content is void")
				end
				}
			//generate the usual rescues
			genDefaultRescues(context)
			
		end	
	end


	method genDefaultRescues(context : Qvt2KermetaContext) : Void is do
		
		super(context)		
		var bodyBlock : kermeta::language::behavior::Block
		bodyBlock?=output
		//rescue for violated guard
		do
			var violatedGuardRescue : kermeta::language::behavior::Rescue init kermeta::language::behavior::Rescue.new
			bodyBlock.rescueBlock.add(violatedGuardRescue)
			violatedGuardRescue.exceptionName:="e"
			var violatedGuardCD : kermeta::language::structure::ClassDefinition
			violatedGuardCD?=context.kmtContext.getFromQualifiedName("root_package::ViolatedGuardException")
			violatedGuardRescue.exceptionType := violatedGuardCD.generateTypeRef()
			
			var strictTest : kermeta::language::behavior::Conditional init kermeta::language::behavior::Conditional.new
			violatedGuardRescue.body.add(strictTest)
			var isStrictCall : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
			strictTest.condition:=isStrictCall
			isStrictCall.name:="isStrict"
			
			
		end
		
	end


	//generate the trace of the mapping
	operation createTrace(context : Qvt2KermetaContext) : kermeta::language::behavior::Expression is do
		//StdIO.writeln("MappingBody::createTrace")
		var cf_trace :  kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		result := cf_trace
		cf_trace.name:="addTrace"

		var call_source : kermeta::language::behavior::SelfExpression init kermeta::language::behavior::SelfExpression.new
		cf_trace.parameters.add(call_source)
		//var call_source : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
		//call_source.name:="self"
		
		var call_target : kermeta::language::behavior::CallResult init kermeta::language::behavior::CallResult.new
		cf_trace.parameters.add(call_target)
		//var call_target : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
		//call_target.name:="result"

		var traceContext : kermeta::language::behavior::StringLiteral init kermeta::language::behavior::StringLiteral.new
		traceContext.~value:=~operation.name
		cf_trace.parameters.add(traceContext)
		
		cf_trace.target:=kermeta::language::behavior::CallFeature.new.callToTransfoContextSingleton(context)
		
		/*var cf_cast : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		cf_cast.name:="asType"
		
		var transfoContextCD : kermeta::language::structure::ClassDefinition
		transfoContextCD ?= KmtLib
				.getDefault
				.asType(root_package::KmtLib)
				.getFromQualifiedName("root_package::TransformationContext")
		
		var tl_tracetype : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
		cf_cast.parameters.add(tl_tracetype)
		tl_tracetype.typeref:=transfoContextCD.generateTypeRef()
		
		var cf_getDefault : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		cf_cast.target:=cf_getDefault
		cf_getDefault.name:="getDefault"
		
		var tl_getDefault : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
		cf_getDefault.target:=tl_getDefault
		tl_getDefault.typeref:=transfoContextCD.generateTypeRef()
		//StdIO.writeln("MappingBody::createTrace-end")
		*/
	end
	
	
	/**
		initialize a mapping parameter if it is void and add it to the right model
	*/
	operation initializeFromParameter(vp : qvtoperational::VarParameter, context : Qvt2KermetaContext) : kermeta::language::behavior::Expression is do 
		if vp!=void then 
			
			//create condition
			var voidCondition  : kermeta::language::behavior::Conditional init kermeta::language::behavior::Conditional.new
			result :=voidCondition
			var callEquals : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			voidCondition.condition:=callEquals
			callEquals.name:="equals"
			var callX : kermeta::language::behavior::CallVariable 
			if vp.name!="result" then
				callX:=kermeta::language::behavior::CallVariable.new
				callX.name:=vp.name
			else
				callX:=kermeta::language::behavior::CallResult.new
			end	
			callEquals.target:=callX
			callEquals.parameters.add(kermeta::language::behavior::VoidLiteral.new)

			//then block
			var thenBlock : kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
			voidCondition.thenBody:=thenBlock
			
			//add assignment
			var assign : kermeta::language::behavior::Assignment init kermeta::language::behavior::Assignment.new
			thenBlock.statement.add(assign)

			var callAssignee : kermeta::language::behavior::CallVariable 
			if vp.name!="result" then
				callAssignee:=kermeta::language::behavior::CallVariable.new
				callAssignee.name:=vp.name
			else
				callAssignee:= kermeta::language::behavior::CallResult.new
			end
			
			assign.target:=callAssignee
			
			var newFeat : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			var typeLit : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
			var typeR : kermeta::language::behavior::TypeReference init kermeta::language::behavior::TypeReference.new
		
			assign.~value:=newFeat
			newFeat.name:="new"
			newFeat.target:=typeLit
			
			if vp.name == "result" then
				if ~operation.upper==1 then
					typeR.type:=~operation.type.generateType(context)
					if typeR.type.isInstanceOf(kermeta::language::structure::Class) then
						typeR.containedType.add(typeR.type)
						typeR.name:=typeR.type.asType(kermeta::language::structure::Class).name
					else
						typeR.name:=typeR.type.asType(kermeta::language::structure::NamedElement).name
					end
					
					typeR.upper:=1//~operation.upper
					typeR.lower:=0//~operation.lower 
				else
					typeR:=resultType(context)
				end
			else
				typeR.type:=vp.type.generateType(context)
				if typeR.type.isInstanceOf(kermeta::language::structure::Class) then
					typeR.containedType.add(typeR.type)
					typeR.name:=typeR.type.asType(kermeta::language::structure::Class).name
				else
					typeR.name:=typeR.type.asType(kermeta::language::structure::NamedElement).name
				end
				typeR.upper:=1
				typeR.lower:=0
			end
			
			
			typeLit.typeref:=typeR
			
			//add to the model type if extent is completed
			if vp.isInstanceOf(qvtoperational::MappingParameter).andThen{x|vp.asType(qvtoperational::MappingParameter).extent!=void} then
				var mp : qvtoperational::MappingParameter
				mp?=vp
				mp.extent.range2domain(context)
				var callModelParam : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				callModelParam.name:=mp.extent.output.asType(kermeta::language::structure::Property).name
				callModelParam.target := kermeta::language::behavior::CallFeature.new.callToTransfoContextSingleton(context)
				var callExtent : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				callExtent.name:="extent"
				callExtent.target:=callModelParam
				
				var callAddInstance : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
				callAddInstance.target:=callExtent
				callAddInstance.name:="add"
				
				var callInstance : kermeta::language::behavior::CallVariable 
				if vp.name!="result" then
					callInstance:=kermeta::language::behavior::CallVariable.new
					callInstance.name:=vp.name
				else
					callInstance:= kermeta::language::behavior::CallResult.new
				end
				callAddInstance.parameters.add(callInstance)
				thenBlock.statement.add(callAddInstance)
			end
		end
	end
	
	
	//implicit assignment of result 
	/**
		after initialization section, and before population section, there is an implicit initialization of
		all the out parameters declared in the mapping that still don't have value
	*/
	
	operation createInit(context : Qvt2KermetaContext) : kermeta::language::behavior::Block is do
		//StdIO.writeln("MappingBody::createInit")
		
		var block: kermeta::language::behavior::Block init kermeta::language::behavior::Block.new
		
		
		~operation.ownedParameter.each{x|
					var vp : qvtoperational::VarParameter
					vp?=x
					if (not x.type.isInstanceOf(emof::Class))
							.orElse{y|not x.type.asType(emof::Class).isAbstract} then
						block.statement.add(initializeFromParameter(vp,context))
					end
					}
		
		~operation.~result.each{vp|	
					
					if (not vp.type.isInstanceOf(emof::Class))
							.orElse{y|not vp.type.asType(emof::Class).isAbstract} then
					block.statement.add(initializeFromParameter(vp, context))
					end
					}
		
		
		result:=block
		//StdIO.writeln("MappingBody::createInit-end")
	end
	
	//return the equivalent of the operation return type in terms of collection depending on the cardinality, unicity and order
	operation resultType(context : Qvt2KermetaContext) : kermeta::language::behavior::TypeReference is do
			//StdIO.writeln("MappingBody::resultType") 
			result:=kermeta::language::behavior::TypeReference.new
			result.lower:=0
			result.upper:=1
			var classdef : kermeta::language::structure::ClassDefinition
			
			if (~operation.isOrdered and ~operation.isUnique) then
				//orderedset
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::OrderedSet")	
			end
			if (~operation.isOrdered and not ~operation.isUnique) then
				//sequence
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Sequence")
			end
			if (not ~operation.isOrdered and ~operation.isUnique) then
				//set
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Set")
			end
			if (not ~operation.isOrdered and not ~operation.isUnique) then
				//bag
				classdef ?= context.kmtContext.getFromQualifiedName("kermeta::standard::Bag")
			end
			
			var collectionClass : kermeta::language::structure::Class init kermeta::language::structure::Class.new
			result.type:=collectionClass
			result.containedType.add(result.type)
			collectionClass.typeDefinition:=classdef
			
			var tvarBinding : kermeta::language::structure::TypeVariableBinding init kermeta::language::structure::TypeVariableBinding.new
			collectionClass.typeParamBinding.add(tvarBinding)		
			tvarBinding.variable:=classdef.typeParameter.one
			tvarBinding.type:=~operation.type.generateType(context)
			if tvarBinding.type.isInstanceOf(kermeta::language::structure::Class) then 
				tvarBinding.containedType.add(tvarBinding.type)
			end
			//StdIO.writeln("MappingBody::resultType-end")
	end
}





/**
in qvt operations are separated from classes definition which is not the case in kermeta
so it is needed to recreate the class hierarchy in kermeta to add operations
*/

aspect class OperationalTransformation {

	method range2domain(context : Qvt2KermetaContext) : Void is do 
		if output==void then 
			var out : kermeta::language::structure::ModelingUnit init kermeta::language::structure::ModelingUnit.new
			output:=out
			
			//creation of package where will be stored all needed elements to run the transformation
			var execEnvPack : kermeta::language::structure::Package init kermeta::language::structure::Package.new			
			out.packages.add(execEnvPack)
			execEnvPack.name:="root_package"
			
			var transfoContextCD : kermeta::language::structure::ClassDefinition init kermeta::language::structure::ClassDefinition.new
			context.transfoContextCD:=transfoContextCD
			execEnvPack.ownedTypeDefinition.add(transfoContextCD)
			transfoContextCD.name:="TransformationContext"
			transfoContextCD.isAspect:=true
			
			modelParameter.each{x|
				x.range2domain(context)
				transfoContextCD.ownedAttribute.add(x.output.asType(kermeta::language::structure::Property))
			}
		
		end
	end


	operation genClassDefinition(context : Qvt2KermetaContext) : Void is do
		//StdIO.writeln("OperationalTransformation::genClassDefinition") 
		ownedOperation.each{op | 
				if op.isInstanceOf(qvtoperational::ImperativeOperation)
					.andThen{x|op.asType(ImperativeOperation).context!=void} then
					createTypeDefinition(op.asType(ImperativeOperation).context.type, context) 
				end 
				}
		//StdIO.writeln("OperationalTransformation::genClassDefinition-end")
	end

	operation createTypeDefinition(type : emof::Type, context : Qvt2KermetaContext) : Void is do 
		//StdIO.writeln("OperationalTransformation::createTypeDefinition")
		//StdIO.writeln("createContext "+type.name)
		createPackage(type.container.asType(emof::Package), context)
		type.range2domain(context)
		type.container.asType(emof::Package).output.asType(kermeta::language::structure::Package).ownedTypeDefinition.add(type.output.asType(kermeta::language::structure::TypeDefinition))
		//StdIO.writeln("OperationalTransformation::createTypeDefinition-end")
	end

	operation createPackage(pack : emof::Package, context : Qvt2KermetaContext) : Void is do
		if pack.output==void then
			//StdIO.writeln("OperationalTransformation::createPackage")
			pack.range2domain(context)
			if pack.container.isInstanceOf(kermeta::emfpersistence::Resource) then
				output.asType(kermeta::language::structure::ModelingUnit).packages.add(pack.output.asType(kermeta::language::structure::Package))
			else
				if (pack.container.asType(emof::Object).output==void).andThen{x|pack.container.isInstanceOf(emof::Package)} then
					createPackage(pack.container.asType(emof::Package),context)
					pack.container.asType(emof::Object).output.asType(kermeta::language::structure::Package).nestedPackage
						.add(pack.output.asType(kermeta::language::structure::Package))
				end
			end
			//StdIO.writeln("OperationalTransformation::createPackage-end")
		end
	end
	
	
}

aspect class ModelParameter {

	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output == void then 
			var out : kermeta::language::structure::Property init kermeta::language::structure::Property.new
			output:=out
			out.isUnique:=true
			out.lower:=0
			out.upper:=1
			out.isComposite:=true
			out.name:=name
			var classDef : kermeta::language::structure::ClassDefinition
			classDef?=context.kmtContext.getFromQualifiedName("root_package::ModelParameter")
			
			out.type:= kermeta::language::structure::Class.new
			out.type.asType(kermeta::language::structure::Class).typeDefinition:=classDef
			out.containedType.add(out.type)
			
		
		
		end
	end

}



/**
* resolveExp is the operation that can require a link of traceability
* TODO : implement deferred resolution 
*/
aspect class ResolveExp {

method range2domain(context : Qvt2KermetaContext) : Void is do
	if output==void then
		//StdIO.writeln("ResolveExp::range2domain")
		var cf_resolve :  kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		//if one is true and there is no condition then it's simply a detect on the type of target
		//if one is false then it's a select on the type that should return a sequence of the type

			var detectCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		
		//type of the found object
		if one then
			var detectCast : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			output:=detectCast
			detectCast.name:="asType"
			target.type.range2domain(context)
			var castLiteral : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
		
			castLiteral.typeref:=target.type.output.asType(kermeta::language::structure::ClassDefinition).generateTypeRef()
			detectCast.parameters.add(castLiteral)
			detectCast.target:=detectCall
			detectCall.name:="detect"
		else
			var deferredcast : kermeta::language::behavior::CallFeature  init kermeta::language::behavior::CallFeature.new
			output:=deferredcast
			deferredcast.name:="fromSeq"
	
			var dSeqInit : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			deferredcast.target:=dSeqInit
			dSeqInit.name:="new"
			
			var dseqCD : kermeta::language::structure::ClassDefinition 
			dseqCD?=context.kmtContext.getFromQualifiedName("kermeta::standard::DeferredSequence")
			
			var dseqLit : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
			dSeqInit.target:=dseqLit
			dseqLit.typeref:=dseqCD.generateParameterizedTypeRef(self.target.type.output.asType(kermeta::language::structure::ClassDefinition))
			
			deferredcast.parameters.add(detectCall)
			detectCall.name:="select"
			
		end
		
		var lambdaExp : kermeta::language::behavior::LambdaExpression init kermeta::language::behavior::LambdaExpression.new
		detectCall.parameters.add(lambdaExp)
		var lambdaParam : kermeta::language::behavior::LambdaParameter init kermeta::language::behavior::LambdaParameter.new	
		lambdaExp.parameters.add(lambdaParam)
		lambdaParam.name:=target.name
		
		
		
		var andCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		lambdaExp.body:=andCall
		andCall.name:="and"
		var typeTestCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		andCall.target:=typeTestCall
		typeTestCall.name:="isInstanceOf"
		
					
		var boolClass: kermeta::language::structure::Class init kermeta::language::structure::Class.new
		typeTestCall.staticType:=boolClass
		typeTestCall.containedType.add(boolClass)
		boolClass.typeDefinition?=context.kmtContext.getFromQualifiedName("kermeta::standard::Boolean")
		
		var xCall : kermeta::language::behavior::CallVariable init kermeta::language::behavior::CallVariable.new
		typeTestCall.target:=xCall
		xCall.name:=target.name
		
		if condition==void then
			var truelit : kermeta::language::behavior::BooleanLiteral init kermeta::language::behavior::BooleanLiteral.new
			andCall.parameters.add(truelit)
			truelit.~value:=true
		else
			var exp : kermeta::language::behavior::Expression 
			condition.range2domain(context)
			exp?=condition.output
			andCall.parameters.add(exp)
		end
		
		var typeToTest : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
		
		typeToTest.typeref:=target.type.output.asType(kermeta::language::structure::ClassDefinition).generateTypeRef() //range2domain already done earlier
		typeTestCall.parameters.add(typeToTest)
		
		detectCall.target:=cf_resolve
		
		if isInverse then
			cf_resolve.name:="resolveAllSource"
		else
			cf_resolve.name:="resolveAllTargets"
		end
		
		source.range2domain(context)
		cf_resolve.parameters.add(source.output.asType(kermeta::language::behavior::Expression))
		
		//target.toVariableDecl()
		//cf_resolve.parameters.add(target.output.asType(kermeta::language::behavior::Expression))
		
		var cf_cast : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		cf_resolve.target:=cf_cast
		
		cf_cast.name:="asType"
		
		var tl_tracetype : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
		cf_cast.parameters.add(tl_tracetype)
		
		
		tl_tracetype.typeref:=context.kmtContext
			.getFromQualifiedName("root_package::TransformationContext")
			.asType(kermeta::language::structure::ClassDefinition)
			.generateTypeRef()
		
		
		var cf_getDefault : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
		cf_cast.target:=cf_getDefault
		
		
		cf_getDefault.name:="getDefault"
		
		
		var tl_getDefault : kermeta::language::behavior::TypeLiteral init kermeta::language::behavior::TypeLiteral.new
		cf_getDefault.target:=tl_getDefault
		
		
		tl_getDefault.typeref:=context.kmtContext
			.getFromQualifiedName("root_package::TransformationContext")
			.asType(kermeta::language::structure::ClassDefinition)
			.generateTypeRef()
		
		//StdIO.writeln("ResolveExp::range2domain-end")
		
		//var out : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature
		//var out : kermeta::language::behavior::VoidLiteral  init kermeta::language::behavior::VoidLiteral.new
		//output:=out
		//out.addDocumentationTag("ResolveExp mapping to be implemented")
	end
end

}

/**
*	ModelTypes in qvt are the metamodels of the transformation
*	they consist in packages
*/
aspect class ModelType {

method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
	if output==void then
		//StdIO.writeln("ModelType::range2domain")
		
		var out : kermeta::language::structure::ModelingUnit init kermeta::language::structure::ModelingUnit.new
		output:=out
		metamodel.each{x|
				x.asType(emof::Object).range2domain(context) 
				out.packages.add(x.output.asType(kermeta::language::structure::Package))
				}
		//StdIO.writeln("ModelType::range2domain-end")
	end	

end
}

aspect class ContextualProperty
{
	/* TODO implement "initExpression" and "overriden" */
	method range2domain(context : Qvt2KermetaContext) : Void from emof::Object is do 
		if output==void then
			//StdIO.writeln("ContextualProperty::range2domain")
			var out : kermeta::language::structure::Property init kermeta::language::structure::Property.new
			output := out
			out.default := default
			out.isComposite := isComposite
			out.isReadOnly := isReadOnly
			out.isID := isID
			out.isDerived := isDerived
			out.name := name
			out.lower := lower
			out.upper := upper
			
			self.context.range2domain(context)
			out.owningClass?=self.context.output
			
			if opposite.isNotEqual(void) then
				opposite.range2domain(context)
				out.opposite ?= opposite.output
			end

			if type.isNotEqual(void) then
				out.type := type.generateType(context)
				if (out.type!=void) then
					out.containedType.add(out.type)
					StdIO.writeln("create a type "+type.name )
				else
					StdIO.writeln("type not created for "+type.name+ type.isInstanceOf(emof::DataType).toString)
				end
				
			end
			//StdIO.writeln("ContextualProperty::range2domain-end")
		end
	end

}

/**Mapping Call Exp behaves differently from OperationCallExp in two ways :
*	1) It requires to add a parameter giving an init value for the result of the mapping (usually this value will be void)
*	2) It requires a boolean parameter to state if the call to the mapping is strict or not
*/

aspect class MappingCallExp
{
	method range2domain(context : Qvt2KermetaContext) : Void is do
		if output==void then
			var out : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new
			output:=out
			
			//if there is a source model
			if source!=void then
				source.range2domain(context)
				out.target?=source.output
			else
				var transfoCall : kermeta::language::behavior::CallFeature init kermeta::language::behavior::CallFeature.new.callToTransfoContextSingleton(context)
				out.target:=transfoCall
			end
			if (referredOperation !=void) then
				referredOperation.range2domain(context)
				out.staticOperation?=referredOperation.output
				if out.staticOperation==void then
					out.name:=referredOperation.name
				else
					out.name:=out.staticOperation.name
				end
				StdIO.writeln("referredOperation name : "+ referredOperation.name)
			end
			argument.each{x|
					x.range2domain(context) 
					if x.output!=void then 
						out.parameters.add(x.output.asType(kermeta::language::behavior::Expression)) 
					else 
						//StdIO.writeln("output is void for a : "+ x.getMetaClass.name) 
					end
					}
			//add result value
			var resultVal : kermeta::language::behavior::VoidLiteral init kermeta::language::behavior::VoidLiteral.new
			out.parameters.add(resultVal)
			
			//add isStrict value
			var isStrict : kermeta::language::behavior::BooleanLiteral init kermeta::language::behavior::BooleanLiteral.new
			isStrict.~value:=self.isStrict
			out.parameters.add(isStrict)
			
		end
	end
}



