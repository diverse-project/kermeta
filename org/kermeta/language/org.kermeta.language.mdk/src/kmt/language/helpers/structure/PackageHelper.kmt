/* $Id: PackageHelper.kmt,v 1.1 2008-12-09 14:26:05 dvojtise Exp $
 * Creation date: May 19, 2008
 * License: EPL
 * Copyright: IRISA / INRIA / Universite Rennes 1
 * Authors: 
 *		Cyril Faucher <cfaucher@irisa.fr>
 */
package org::kermeta::language::structure;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"

using kermeta::standard

aspect class Package {
	operation getAllSubPackages() : OrderedSet<Package> is do
		result := OrderedSet<Package>.new()
				
		self.nestedPackage.each{ p |
			result.add(p)
			result.addAll(p.getAllSubPackages())
		}
	end
	
	/**
	 * search in this Package a relative Qualified name representing a TypeDefinition
	 * ie. a name that might contains :: in order to search in sub packages 
	 */ 
	operation getTypeDefinitionByRelativeQName(qname : String) : TypeDefinition is do
		
		// stdio.writeln( "        searching " + qname + " in " +self.name)
		/*var set_qname : Sequence<String> init qname.split("::")
		if set_qname.size()==1 then
			result := self.ownedTypeDefinition.detect{ c | c.name == qname}
		else
			var subpack : Package init self.nestedPackage.detect{ p |
				p.name == set_qname.at(0)
			}
			if not subpack.isVoid then
				from var i : Integer init 1
				until i>=(set_qname.size()-1)
				loop
					subpack := subpack.nestedPackage.detect{ p |
						p.name == set_qname.at(i)
					}
					i := i + 1
				end
				
				result := subpack.ownedTypeDefinition.detect{ c |
					c.name == set_qname.at(set_qname.size()-1)
				}
			else			 
				result := void
			end
		end*/
		var set_qname : Sequence<String> init qname.split("::")
		result := getTypeDefinitionByRelativeSetQName(set_qname)
	end

	operation getTypeDefinitionByRelativeSetQName(set_qname : Sequence<String>) : TypeDefinition is do
		var foundTypeDef : TypeDefinition
		var mtContainer : ModelType
		var nextPackage : Package
		//If set_qname only contains one identifier, the TypeDefinition must be in this package
		if set_qname.size()==1 then
			foundTypeDef := self.ownedTypeDefinition.detect{td|
				td.name == set_qname.at(0)
			}
		else
			//If set_qname only contains two identifiers, the TypeDefinition may be referenced by a ModelType contained by this package
			if set_qname.size() == 2 then
				mtContainer := self.ownedTypeDefinition.detect{td|
					td.name == set_qname.at(0) and td.isInstanceOf(ModelType)
				}.asType(ModelType)
				foundTypeDef := mtContainer.typeDefinitions.detect{td|
					td.name == set_qname.at(1)
				}
			end
			//Otherwise, the TypeDefinition is contained by a nested package
			if foundTypeDef.isVoid() then
				nextPackage := self.nestedPackage.detect{p|p.name == set_qname.at(0)}
				if (not nextPackage.isVoid()) then
					var nextQName : Sequence<String> init set_qname
					nextQName.removeAt(0)
					foundTypeDef := nextPackage.getTypeDefinitionByRelativeSetQName(nextQName)
				end
			end
		end
		result := foundTypeDef
	end
}
}
