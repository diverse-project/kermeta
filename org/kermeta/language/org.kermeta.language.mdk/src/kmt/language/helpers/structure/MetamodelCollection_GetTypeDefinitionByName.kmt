/* $Id:$ 
 * Creation : October 23, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            cguy
 */

package kmt::language::helpers::structure;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/MetamodelHelper_structure_aspect.kmt"


using org::kermeta::language::structure
using kermeta::standard
using kermeta::exceptions

class TypeDefinitionFinder {
	/**
	 * retrieves the TypeDefinition with the given full qualified name (ie. must include the metamodel name)
	 */	
	operation getTypeDefinitionByQualifiedName(qname : String, metamodels : Collection<Metamodel>) : TypeDefinition is do
		if qname.contains("#") then
			var mmName : String init qname.split("#").at(0)
			var partialName : String init qname.split("#").at(1)
			var metamodel : Metamodel init metamodels.detect{mm|mm.name.equals(mmName)}
			result := metamodel.getTypeDefinitionByQualifiedName(qname)
		else
			stdio.writeln("TypeDefinitionFinder.getTypeDefinitionByQualifiedName expects a qualified name (i.e., qualified name including metamodel name, followed by \"#\"), but was called on: " + qname)
			/*stdio.writeln("Creating an exception")
			var e : Exception init Exception.new
			e.message := "getTypeDefinitionByQualifiedName expects a qualified name (i.e., qualified name including metamodel name, followed by \"#\"), but was called on: " + qname
			stdio.writeln("Raising the exception")
			raise e*/
		end
	end
	
	/**
	 * retrieves the TypeDefinition with the given qualified name, the name can be partial or full
	 * (partial in the sense that it doesn't use the #)
	 */
	operation getFirstTypeDefinitionByName(name : String,  metamodels : Collection<Metamodel>) : TypeDefinition is do
		result := void
		//If the name is a qualified name (including metamodel name followed by #)
		if name.contains("#") then
			var mmName : String init name.split("#").at(0)
			var metamodel : Metamodel init metamodels.detect{mm|mm.name.equals(mmName)}
			result := metamodel.getTypeDefinitionByQualifiedName(name)
		//If the name is a partial name (without metamodel name nor #)
		else
			//We look for the first metamodel containing a type definition corresponding to the partial name
			var metamodel : Metamodel init metamodels.detect{mm|not mm.getTypeDefinitionByPartialName(name).isVoid}
			if(not metamodel.isVoid) then
				result := metamodel.getTypeDefinitionByPartialName(name)
			else
				stdio.errorln("FAILED to find " + name + " in " +metamodels.size.toString + " metamodels")
				stdio.writeln("FAILED to find " + name + " in " +metamodels.size.toString + " metamodels")
			end
		end
		
	end
	
	/**
	 * retrieves the first metamodel in the collection that contains a TypeDefinition with the given partial qualified name
	 * (partial in the sense that it doesn't use the #)
	 */
	operation getFirstMetamodelWithTypeDefinition(partialQName : String,  metamodels : Collection<Metamodel>) : Metamodel is do
		result := metamodels.detect{mm| not mm.getTypeDefinitionByPartialName(partialQName).isVoid}
	end

	/*
	 * Get a TypeDefinition contained in the current Metamodel by name (either qualified or partial)
	 * and taking into account a set of Usings
	 * and optionally looking in the current Package (if not void)
	 */
	 
	operation getTypeDefinitionByNameAndUsings( lookingForName : String, usings : Collection<Using>, currentMetamodel : Metamodel, optionalCurrentPackage : Package) : TypeDefinition is do
		
		var metamodels : Collection<Metamodel> init currentMetamodel.getNeighbours()
		
		if lookingForName.contains("#") then
			var set_name : Sequence<String> init lookingForName.split("#")
	 		if not set_name.at(0).equals("") then
	 			
	 		else
	 			result := currentMetamodel.getTypeDefinitionByQualifiedName(currentMetamodel.name + lookingForName)
	 		end
			// search the exact qualified name
			result := getTypeDefinitionByQualifiedName(lookingForName, metamodels)
			
		else
			if (not optionalCurrentPackage.isVoid) then
				// search this qualified name in the current Package
				result := optionalCurrentPackage.getTypeDefinitionByPartialName(lookingForName)
			end	
			
			if (result.isVoid and not usings.isEmpty) then
				
				from var iterator :Iterator<Using> init usings.iterator
				until (not result.isVoid) or iterator.isOff
				loop
					var currentUsing : Using init iterator.next
					
					//If the using does not define an alias
					if (currentUsing.toName.isVoid() or currentUsing.toName == "") then
						//We now look for a type which the same name and which qualifiedPath is the fromQName
						var newName : String init currentUsing.fromQName.replace("*", lookingForName)
						result := getTypeDefinitionByQualifiedName(newName, metamodels)
					else
						if lookingForName.startsWith(currentUsing.toName) then
							var newName : String init lookingForName.replace(currentUsing.toName, currentUsing.fromQName)
							result := getTypeDefinitionByQualifiedName(newName, metamodels)
						end			
					end
				end
			end
		end
	end
}
