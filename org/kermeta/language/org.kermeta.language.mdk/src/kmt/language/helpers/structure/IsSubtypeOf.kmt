/* $Id:$ 
 * Creation : January 11, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            jfalcou
 */
package org::kermeta::language::structure;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/TypeEquality_structure_aspect.kmt"

// use Kermeta MDK to retrive qualified names
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetQualifiedName_structure_aspect.kmt"

using kermeta::standard
using kermeta::utils

aspect class Type {

	//if the current type from expectedType is a type variable, then add the binding
	//if not, it's only important if self is a class or a function type
	operation compareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type>) is do
		//stdio.writeln("compare a type with something")
			
		if expectedType.isInstanceOf(TypeVariable).andThen{x|typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} then
			typeVariableToSet.put(expectedType.asType(TypeVariable), self)
			
		end
			
	end

	//structural comparison is used when types are supposed to be equals
	operation structurallyCompareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type>) is do
		//stdio.writeln("compare a type with something")
			
		if expectedType.isInstanceOf(TypeVariable).andThen{x|
			typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} 
		then
			typeVariableToSet.put(expectedType.asType(TypeVariable), self)
			
		end
			
	end
	
	operation isSubTypeOf(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type>) : Boolean is do
		result:=true
	end
}

aspect class FunctionType
{
	method isSubTypeOf(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type>) : Boolean is do

		// ( <A->C> inherits <B->D> ) <=> ( ( C inherits D ) and ( B inherits A )

		//stdio.writeln("------------------------------\nisSubTypeOf for a FunctionType")
		
		//var hash : Hashtable<TypeVariable, Type> init Hashtable<TypeVariable, Type>.new
		result:=true

		if (expectedType.isInstanceOf(FunctionType))
		then // else false
			// First, compare return types
			// C->D
			//stdio.writeln("-expectedType is a FunctionType -> OK")
			var expectedFunctionType : FunctionType init expectedType.asType(FunctionType)
			
			result:=self.right.isSubTypeOf(expectedFunctionType.right,typeVariableToSet)
			
			// Then compare left 
			if (result)
			then
				if (self.left.isVoid)
				then
					//stdio.writeln("self.left.isVoid")
					//expectedType.left must be void
					if not(expectedFunctionType.left.isVoid)
					then // else it is ok, since return types are ok
						// expectedFunctionType.left might be an empty ProductType
						if (expectedFunctionType.left.isInstanceOf(ProductType))
						then
							//in this case it mustn't contain any type
							result :=  (expectedFunctionType.left.asType(ProductType).type.size==0)
						else
							result:=false
						end
					end
				else
					// expectedType.left must be a subtype of self.left
					//stdio.writeln("self.left.is not Void")
					//stdio.writeln("expectedType.left:"+expectedFunctionType.left.toString)
					result:= expectedFunctionType.left.isSubTypeOf(self.left, typeVariableToSet) 
				end
			end
		else
			result:=false
		end
		
	end
}

aspect class ProductType {
	
	method isSubTypeOf(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type>) : Boolean is do
		//result:=false
		
		//stdio.writeln(" - isSubTypeOf for productType")
		//stdio.writeln("  --> self     : " + self.toString)
		//stdio.writeln("  --> expected : " + expectedType.toString)
		
		
		if(expectedType.isInstanceOf(ProductType))
		then
			// No problem, just compare the types inside both ProductTypes
			// Check the cardinalities...
			//stdio.writeln("    expected is a productType -> OK")
			var expectedProductType : ProductType init expectedType.asType(ProductType)
			//stdio.writeln("     card self      : " + self.type.size.toString())
			//stdio.writeln("     card expected  : " + expectedProductType.type.size.toString)
			
			if ( self.type.size != expectedProductType.type.size)
			then
				result:=false
			else
				var bool : Boolean init true
				from var i : Integer init 0
				until i == self.type.size
				loop
					//stdio.writeln("      i="+i.toString+", bool=" + bool.toString)
					//stdio.writeln("       self.at(i) : " + self.type.elementAt(i).toString)
					//stdio.writeln("       expe.at(i) : " + expectedProductType.type.elementAt(i).toString)
					bool := ( bool and self.type.elementAt(i).isSubTypeOf(expectedProductType.type.elementAt(i),typeVariableToSet) )
    				i := i + 1
				end
				result:=bool
			end
		else
			// Special checks in case self with a ProductType with 0 or 1 types inside
			if (self.type.size == 0)
			then
				result:=expectedType.isVoid
			else
				if (self.type.size == 1)
				then
					result:= self.type.elementAt(0).isSubTypeOf(expectedType, typeVariableToSet)
				else
					result:=false
				end
			end
		end	
	end
}

aspect class Enumeration
{

	method isSubTypeOf(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type>) : Boolean is do
		
		//stdio.writeln("isSubTypeOf for a Enumeration")
		result:=false
		if (expectedType.isInstanceOf(Enumeration))
		then
			result:=(self.equals(expectedType))
		end
		
	end
}

aspect class Class
{


	/**
	 *	returns the sequence of typedefinition separing self to typeToSearch in the Type hierarchy
	 */
	operation findPathToType(typeToSearch : ClassDefinition, typeDefAlreadyVisited : Sequence<ClassDefinition>) : Sequence<Class> is do
		result:=void
		typeDefAlreadyVisited.add(self.typeDefinition.asType(ClassDefinition))
		
		if ( typeToSearch==self.typeDefinition.asType(ClassDefinition) )
		then
			result:=Sequence<Class>.new
			result.add(self)
		else
			self.typeDefinition.superType.detect{ t |
				if not typeDefAlreadyVisited.contains(t.asType(Class).typeDefinition.asType(ClassDefinition)) 
				then
					result:= t.asType(Class).findPathToType(typeToSearch,typeDefAlreadyVisited)
					if not result.isVoid then
						result.addAt(0, self)
					end
				end
					//stop condition
				result.isVoid.~not()
				
			}
		end
	end

	/**
	 * returns a clone of the current class but with the type of the different 
	 * bindings replaced according to the parameter bindings
	 */
	operation cloneWithBindings ( bindings : OrderedSet<TypeVariableBinding>) : Class is do
	
		result:= Class.new
		result.typeDefinition:=self.typeDefinition
		self.typeParamBinding.each{tvb|
			var newTVB : TypeVariableBinding init TypeVariableBinding.new
			newTVB.variable:=tvb.variable
			if tvb.type.isInstanceOf(TypeVariable) then
				var binding : TypeVariableBinding init bindings.detect{b|b.variable==tvb.type}
				if binding.isVoid.~not then
					newTVB.type:=binding.type
				end
			else 
				if tvb.type.isInstanceOf(Class) then
					newTVB.type:=tvb.type.asType(Class).cloneWithBindings(bindings)
				end
			end
			result.typeParamBinding.add(newTVB)
		}

	end

	/**
	 * returns a class that is structurally comparable to typeExpected
	 */
	operation getComparableClass(typeExpected : Class) : Class is do 
		
//		stdio.writeln(">> getComparableClass for " + self.typeDefinition.name + ", expected is " + typeExpected.typeDefinition.name)
		
		var inheritancePath : Sequence<Class>
		inheritancePath:=findPathToType(typeExpected.typeDefinition.asType(ClassDefinition), Sequence<ClassDefinition>.new)
		result:=void
		if inheritancePath.isVoid then
			//result remains void, because self cannot be a subtype of typeExpected
			//
		else
			//the supertype of the current Class that is of the same level than typeExpected 
			var selfSuperType : Class init inheritancePath.elementAt(0)
			from var i : Integer init 0
			until i == inheritancePath.size - 1
			loop
				var superSuperType : Class 
				superSuperType:=inheritancePath.elementAt(i+1).cloneWithBindings(selfSuperType.typeParamBinding)
				
				selfSuperType:=superSuperType
				i:=i+1
			end
			result:=selfSuperType
		end

//		stdio.writeln("<< getComparableClass for " + self.typeDefinition.name + ", expected is " + typeExpected.typeDefinition.name)
			
	end
	
	
	method isSubTypeOf(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type>) : Boolean is do
		
		// First of all, check if self is kermeta::standard::void 
		if (self.getQualifiedName.equals("kermeta::standard::Void"))
		then
			result:=true
		else
			result:=true			
			if ( expectedType.isInstanceOf(Class) ) 
			then
				//stdio.writeln("ifSubTypeOf for class " + self.typeDefinition.name + ", compare with " + expectedType.asType(Class).typeDefinition.name)
					
				//stdio.writeln("expectedType isInstanceOf Class")
				var comparableClass : Class init self.getComparableClass(expectedType.asType(Class))
				//comparableClass := self.getComparableClass(expectedType.asType(Class))
			
			
				if (comparableClass.isVoid)
				then
					result:=false
				else
					result:= comparableClass.typeEquals(expectedType.asType(Class))
				end
			
			else
				//stdio.writeln("expectedType is not InstanceOf Class")
				//Check if the expectedType is a ProductType with just one type
				if ( expectedType.isInstanceOf(ProductType) )
				then
					var expectedProductType : ProductType init expectedType.asType(ProductType)
					if (expectedProductType.type.size != 1)
					then
						result:=false
					else
						if (expectedProductType.type.one.isInstanceOf(Class))
						then
							var comparableClass : Class init self.getComparableClass(expectedProductType.type.one.asType(Class))
							if (comparableClass.isVoid)
							then
								result:=false
							else
								result:=comparableClass.typeEquals(expectedProductType.type.one.asType(Class))
							end
						else
							result:=false
						end	
						
					end
				else
					result:=false
				end
			end
			
			/*
			stdio.writeln("isSubTypeOf result = " + result.toString)
			stdio.writeln(" -> typeVariableToSet.size : " + typeVariableToSet.size.toString)
			typeVariableToSet.keys.each{ k |
				stdio.writeln("   - key : " + k.toString)
				stdio.writeln("     val : " + typeVariableToSet.getValue(k).toString) 
			}
			*/
		
		end
		//stdio.writeln(" -> result : " + result.toString)
	end

	method structurallyCompareToExpectedType(expectedType : Type,  typeVariableToSet : Hashtable<TypeVariable, Type> ) is do
		
		//stdio.writeln("compare a class with something")
		//stdio.writeln("is it a typeVariable ? "+expectedType.isInstanceOf(TypeVariable).toString)
		// It should not be a typeVariable ...
			
			/*if expectedType.isInstanceOf(TypeVariable).andThen{x| stdio.writeln("is it an operation typeVariable ? "+typeVariableToSet.containsKey(expectedType.asType(TypeVariable)).toString) typeVariableToSet.containsKey(expectedType.asType(TypeVariable))} then
				typeVariableToSet.put(expectedType.asType(TypeVariable), self)
				
			else*/
		
		if expectedType.isInstanceOf(Class) 
		then
			// they are both of type class with the same number of type parameters, then all type parameters should be checked
			// the resolver only try to find the bindings, but it's the checker which will have to tell if the type is different from the expectedType
			if	self.typeParamBinding.size==expectedType.asType(Class).typeParamBinding.size
			then
				from var i : Integer init 0
				until i==self.typeParamBinding.size
				loop
					self.typeParamBinding.elementAt(i).type.structurallyCompareToExpectedType(expectedType.asType(Class).typeParamBinding.elementAt(i).type
																							,typeVariableToSet
																							/*,context*/)
					i:=i+1
				end
			end
							
		end
	end
			
	
	
}