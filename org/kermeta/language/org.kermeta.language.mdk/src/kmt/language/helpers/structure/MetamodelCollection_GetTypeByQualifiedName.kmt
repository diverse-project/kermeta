/* $Id:$ 
 * Creation : October 23, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            cguy
 */

package kmt::language::helpers::structure;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/MetamodelHelper_structure_aspect.kmt"


using org::kermeta::language::structure
using kermeta::standard
using kermeta::exceptions

class TypeDefinitionFinder {
	/**
	 * retrieves the TypeDefinition with the given full qualified name (ie. must include the metamodel name)
	 */	
	operation getTypeDefinitionByQualifiedName(qname : String, metamodels : Collection<Metamodel>) : TypeDefinition is do
		if qname.contains("#") then
			var mmName : String init qname.split("#").at(0)
			var partialName : String init qname.split("#").at(1)
			var metamodel : Metamodel init metamodels.detect{mm|mm.name.equals(mmName)}
			result := metamodel.getTypeDefinitionByQualifiedName(partialName)
		else
			var e : Exception init RuntimeError.new
			e.message := "getTypeDefinitionByQualifiedName expects a qualified name (i.e., qualified name including metamodel name, followed by \"#\"), but was called on: " + qname
			raise e
		end
	end
	
	/**
	 * retrieves the TypeDefinition with the given qualified name, the name can be partial or full
	 * (partial in the sense that it doesn't use the #)
	 */
	operation getFirstTypeDefinitionByName(name : String,  metamodels : Collection<Metamodel>) : TypeDefinition is do
		result := void
		//If the name is a qualified name (including metamodel name followed by #)
		if name.contains("#") then
			var mmName : String init name.split("#").at(0)
			var metamodel : Metamodel init metamodels.detect{mm|mm.name.equals(mmName)}
			result := metamodel.getTypeDefinitionByQualifiedName(name)
		//If the name is a partial name (without metamodel name nor #)
		else
			//We look for the first metamodel containing a type definition corresponding to the partial name
			var metamodel : Metamodel init metamodels.detect{mm|not mm.getTypeDefinitionByPartialName(name).isVoid}
			if(not metamodel.isVoid) then
				result := metamodel.getTypeDefinitionByPartialName(name)
			else
				stdio.errorln("FAILED to find " + name + " in " +metamodels.size.toString + " metamodels")
				stdio.writeln("FAILED to find " + name + " in " +metamodels.size.toString + " metamodels")
			end
		end
		
	end
	
	/**
	 * retrieves the first metamodel in the collection that contains a TypeDefinition with the given partial qualified name
	 * (partial in the sense that it doesn't use the #)
	 */
	operation getFirstMetamodelWithTypeDefinition(partialQName : String,  metamodels : Collection<Metamodel>) : Metamodel is do
		result := metamodels.detect{mm| not mm.getTypeDefinitionByPartialName(partialQName).isVoid}
	end

	/**
	 * Get a TypeDefinition contained in the current Metamodel by name (either qualified or partial)
	 * and taking into account a set of Usings
	 * and optionally looking in the current Package (if not void)
	 */
	operation getTypeDefinitionByNameAndUsings( name : String, usings : Collection<Using>, metamodels : Collection<Metamodel>, optionalCurrentPackage : Package) : TypeDefinition is do
		
		if name.contains("#") then
			// search the exact qualified name
			result := getTypeDefinitionByQualifiedName(name, metamodels)
		else
			if (not optionalCurrentPackage.isVoid) then
				// search this qualified name in the current Package
				result := optionalCurrentPackage.getTypeDefinitionByPartialName(name)
			end	
			
			if (result.isVoid and not usings.isEmpty) then
				
				from var iterator :Iterator<Using> init usings.iterator
				until (not result.isVoid) or iterator.isOff
				loop
					var currentUsing : Using init iterator.next
					
					//If the using does not define an alias
					if (currentUsing.toName.isVoid() or currentUsing.toName == "") then
						//We now look for a type which the same name and which qualifiedPath is the fromQName
						var newName : String init currentUsing.fromQName.replace("*", name)
						result := getTypeDefinitionByQualifiedName(newName, metamodels)
					else
						if name.startsWith(currentUsing.toName) then
							var newName : String init name.replace(currentUsing.toName, currentUsing.fromQName)
							result := getTypeDefinitionByQualifiedName(newName, metamodels)
						end			
					end
				end
			end
		end
	end
}
