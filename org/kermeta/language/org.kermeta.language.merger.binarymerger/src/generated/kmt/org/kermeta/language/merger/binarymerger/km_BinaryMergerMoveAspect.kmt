package org;

require kermeta
require "platform:/resource/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "platform:/lookup/org.kermeta.ecore.binarymergergenerator/src/main/kermeta/org/kermeta/ecore/binarymerger/BinaryMergerContext.kmt"
require "platform:/lookup/org.kermeta.ecore.binarymergergenerator/src/main/kermeta/org/kermeta/ecore/binarymerger/Mergeable.kmt"
require "platform:/resource/org.kermeta.language.merger.binarymerger/src/generated/kmt/org/kermeta/language/merger/binarymerger/km_BinaryMergerAspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/eachOwnedElement_kermeta_aspect.kmt"
require "platform:/lookup/org.kermeta.language.merger.binarymerger/src/main/kmt/org/kermeta/language/merger/binarymerger/km_BinaryMergerSignatureAspect.kmt"
require "platform:/lookup/org.kermeta.language.merger.binarymerger/src/main/kmt/org/kermeta/language/merger/binarymerger/km_BinaryMergerPropertyResolverAspect.kmt"

using kermeta::language::structure
using org::kermeta::ecore::binarymerger

package kermeta {
	package language {
		package behavior {
			aspect class Assignment inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Assignment
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::Assignment)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Assignment")
							mergedModelElement.target ?= self.selectUnaryProperty("target", self.target, mergedModelElement.target)
							mergedModelElement.~value ?= self.selectUnaryProperty("~value", self.~value, mergedModelElement.~value)
							// select value for unary attribute
							mergedModelElement.isCast ?= self.selectUnaryProperty("isCast", self.isCast, mergedModelElement.isCast)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Expression inherits org::kermeta::language::structure::KermetaModelElement, org::kermeta::language::structure::TypeContainer {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::behavior::Expression
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::Expression)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Expression")
							// if it has some reference (staticType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallExpression inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::CallExpression
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallExpression)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallExpression")
							self.parameters.each{aspect_parameters | 
								var equivalent_parameters : org::kermeta::language::behavior::Expression
								equivalent_parameters := mergedModelElement.parameters.detect{ merged_parameters |
									aspect_parameters.localMatch(merged_parameters)
								}
								if (not equivalent_parameters.isVoid) then
									// mark them as similar
									aspect_parameters.similarElementInMergedModel := equivalent_parameters
								else
									// move it in merged model
									mergedModelElement.parameters.add(aspect_parameters)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_parameters.asType(Mergeable))
								end
							}
							// if it has some reference (staticTypeVariableBindings) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Block inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Block
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::Block)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Block")
							self.statement.each{aspect_statement | 
								var equivalent_statement : org::kermeta::language::behavior::Expression
								equivalent_statement := mergedModelElement.statement.detect{ merged_statement |
									aspect_statement.localMatch(merged_statement)
								}
								if (not equivalent_statement.isVoid) then
									// mark them as similar
									aspect_statement.similarElementInMergedModel := equivalent_statement
								else
									// move it in merged model
									mergedModelElement.statement.add(aspect_statement)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_statement.asType(Mergeable))
								end
							}
							self.rescueBlock.each{aspect_rescueBlock | 
								var equivalent_rescueBlock : org::kermeta::language::behavior::Rescue
								equivalent_rescueBlock := mergedModelElement.rescueBlock.detect{ merged_rescueBlock |
									aspect_rescueBlock.localMatch(merged_rescueBlock)
								}
								if (not equivalent_rescueBlock.isVoid) then
									// mark them as similar
									aspect_rescueBlock.similarElementInMergedModel := equivalent_rescueBlock
								else
									// move it in merged model
									mergedModelElement.rescueBlock.add(aspect_rescueBlock)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_rescueBlock.asType(Mergeable))
								end
							}
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallVariable inherits org::kermeta::language::behavior::CallExpression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::CallExpression is do
					var mergedModelElement : org::kermeta::language::behavior::CallVariable
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallVariable)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallVariable")
							// select value for unary attribute
							mergedModelElement.isAtpre ?= self.selectUnaryProperty("isAtpre", self.isAtpre, mergedModelElement.isAtpre)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallFeature inherits org::kermeta::language::behavior::CallExpression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::CallExpression is do
					var mergedModelElement : org::kermeta::language::behavior::CallFeature
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallFeature)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallFeature")
							mergedModelElement.target ?= self.selectUnaryProperty("target", self.target, mergedModelElement.target)
							// select value for unary attribute
							mergedModelElement.isAtpre ?= self.selectUnaryProperty("isAtpre", self.isAtpre, mergedModelElement.isAtpre)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallSuperOperation inherits org::kermeta::language::behavior::CallOperation {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::CallOperation is do
					var mergedModelElement : org::kermeta::language::behavior::CallSuperOperation
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallSuperOperation)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallSuperOperation")
							// if it has some reference (superType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallResult inherits org::kermeta::language::behavior::CallVariable {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::CallVariable is do
					var mergedModelElement : org::kermeta::language::behavior::CallResult
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallResult)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallResult")
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallValue inherits org::kermeta::language::behavior::CallExpression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::CallExpression is do
					var mergedModelElement : org::kermeta::language::behavior::CallValue
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallValue)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallValue")
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Conditional inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Conditional
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::Conditional)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Conditional")
							mergedModelElement.thenBody ?= self.selectUnaryProperty("thenBody", self.thenBody, mergedModelElement.thenBody)
							mergedModelElement.elseBody ?= self.selectUnaryProperty("elseBody", self.elseBody, mergedModelElement.elseBody)
							mergedModelElement.condition ?= self.selectUnaryProperty("condition", self.condition, mergedModelElement.condition)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Raise inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Raise
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::Raise)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Raise")
							mergedModelElement.expression ?= self.selectUnaryProperty("expression", self.expression, mergedModelElement.expression)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Rescue inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::behavior::Rescue
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::Rescue)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Rescue")
							self.body.each{aspect_body | 
								var equivalent_body : org::kermeta::language::behavior::Expression
								equivalent_body := mergedModelElement.body.detect{ merged_body |
									aspect_body.localMatch(merged_body)
								}
								if (not equivalent_body.isVoid) then
									// mark them as similar
									aspect_body.similarElementInMergedModel := equivalent_body
								else
									// move it in merged model
									mergedModelElement.body.add(aspect_body)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_body.asType(Mergeable))
								end
							}
							mergedModelElement.exceptionType ?= self.selectUnaryProperty("exceptionType", self.exceptionType, mergedModelElement.exceptionType)
							// select value for unary attribute
							mergedModelElement.exceptionName ?= self.selectUnaryProperty("exceptionName", self.exceptionName, mergedModelElement.exceptionName)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class TypeReference inherits org::kermeta::language::structure::MultiplicityElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::behavior::TypeReference
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::TypeReference)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a TypeReference")
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Literal inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Literal
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::Literal)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Literal")
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class EmptyExpression inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::EmptyExpression
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::EmptyExpression)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a EmptyExpression")
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class JavaStaticCall inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::JavaStaticCall
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::JavaStaticCall)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a JavaStaticCall")
							self.parameters.each{aspect_parameters | 
								var equivalent_parameters : org::kermeta::language::behavior::Expression
								equivalent_parameters := mergedModelElement.parameters.detect{ merged_parameters |
									aspect_parameters.localMatch(merged_parameters)
								}
								if (not equivalent_parameters.isVoid) then
									// mark them as similar
									aspect_parameters.similarElementInMergedModel := equivalent_parameters
								else
									// move it in merged model
									mergedModelElement.parameters.add(aspect_parameters)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_parameters.asType(Mergeable))
								end
							}
							// select value for unary attribute
							mergedModelElement.jclass ?= self.selectUnaryProperty("jclass", self.jclass, mergedModelElement.jclass)
							// select value for unary attribute
							mergedModelElement.jmethod ?= self.selectUnaryProperty("jmethod", self.jmethod, mergedModelElement.jmethod)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class LambdaExpression inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::LambdaExpression
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::LambdaExpression)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a LambdaExpression")
							self.parameters.each{aspect_parameters | 
								var equivalent_parameters : org::kermeta::language::behavior::LambdaParameter
								equivalent_parameters := mergedModelElement.parameters.detect{ merged_parameters |
									aspect_parameters.localMatch(merged_parameters)
								}
								if (not equivalent_parameters.isVoid) then
									// mark them as similar
									aspect_parameters.similarElementInMergedModel := equivalent_parameters
								else
									// move it in merged model
									mergedModelElement.parameters.add(aspect_parameters)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_parameters.asType(Mergeable))
								end
							}
							mergedModelElement.body ?= self.selectUnaryProperty("body", self.body, mergedModelElement.body)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class LambdaParameter inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::behavior::LambdaParameter
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::LambdaParameter)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a LambdaParameter")
							mergedModelElement.type ?= self.selectUnaryProperty("type", self.type, mergedModelElement.type)
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class IntegerLiteral inherits org::kermeta::language::behavior::Literal {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::IntegerLiteral
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::IntegerLiteral)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a IntegerLiteral")
							// select value for unary attribute
							mergedModelElement.~value ?= self.selectUnaryProperty("~value", self.~value, mergedModelElement.~value)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class StringLiteral inherits org::kermeta::language::behavior::Literal {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::StringLiteral
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::StringLiteral)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a StringLiteral")
							// select value for unary attribute
							mergedModelElement.~value ?= self.selectUnaryProperty("~value", self.~value, mergedModelElement.~value)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class BooleanLiteral inherits org::kermeta::language::behavior::Literal {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::BooleanLiteral
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::BooleanLiteral)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a BooleanLiteral")
							// select value for unary attribute
							mergedModelElement.~value ?= self.selectUnaryProperty("~value", self.~value, mergedModelElement.~value)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallTypeLiteral inherits org::kermeta::language::behavior::Literal {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::CallTypeLiteral
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallTypeLiteral)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallTypeLiteral")
							mergedModelElement.typeref ?= self.selectUnaryProperty("typeref", self.typeref, mergedModelElement.typeref)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class VoidLiteral inherits org::kermeta::language::behavior::Literal {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Literal is do
					var mergedModelElement : org::kermeta::language::behavior::VoidLiteral
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::VoidLiteral)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a VoidLiteral")
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Loop inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::Loop
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::Loop)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Loop")
							mergedModelElement.initialization ?= self.selectUnaryProperty("initialization", self.initialization, mergedModelElement.initialization)
							mergedModelElement.body ?= self.selectUnaryProperty("body", self.body, mergedModelElement.body)
							mergedModelElement.stopCondition ?= self.selectUnaryProperty("stopCondition", self.stopCondition, mergedModelElement.stopCondition)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class SelfExpression inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::SelfExpression
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::SelfExpression)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a SelfExpression")
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class VariableDecl inherits org::kermeta::language::behavior::Expression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::Expression is do
					var mergedModelElement : org::kermeta::language::behavior::VariableDecl
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::VariableDecl)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a VariableDecl")
							mergedModelElement.initialization ?= self.selectUnaryProperty("initialization", self.initialization, mergedModelElement.initialization)
							mergedModelElement.type ?= self.selectUnaryProperty("type", self.type, mergedModelElement.type)
							// select value for unary attribute
							mergedModelElement.identifier ?= self.selectUnaryProperty("identifier", self.identifier, mergedModelElement.identifier)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UnresolvedCall inherits org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::behavior::CallExpression, org::kermeta::language::structure::TypeContainer {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::UnresolvedReference is do
					var mergedModelElement : org::kermeta::language::behavior::UnresolvedCall
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::UnresolvedCall)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UnresolvedCall")
							self.usings.each{aspect_usings | 
								var equivalent_usings : org::kermeta::language::structure::Using
								equivalent_usings := mergedModelElement.usings.detect{ merged_usings |
									aspect_usings.localMatch(merged_usings)
								}
								if (not equivalent_usings.isVoid) then
									// mark them as similar
									aspect_usings.similarElementInMergedModel := equivalent_usings
								else
									// move it in merged model
									mergedModelElement.usings.add(aspect_usings)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_usings.asType(Mergeable))
								end
							}
							mergedModelElement.target ?= self.selectUnaryProperty("target", self.target, mergedModelElement.target)
							// if it has some reference (targetParent) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (generics) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.isAtpre ?= self.selectUnaryProperty("isAtpre", self.isAtpre, mergedModelElement.isAtpre)
							// select value for unary attribute
							mergedModelElement.isCalledWithParenthesis ?= self.selectUnaryProperty("isCalledWithParenthesis", self.isCalledWithParenthesis, mergedModelElement.isCalledWithParenthesis)
							self.parameters.each{aspect_parameters | 
								var equivalent_parameters : org::kermeta::language::behavior::Expression
								equivalent_parameters := mergedModelElement.parameters.detect{ merged_parameters |
									aspect_parameters.localMatch(merged_parameters)
								}
								if (not equivalent_parameters.isVoid) then
									// mark them as similar
									aspect_parameters.similarElementInMergedModel := equivalent_parameters
								else
									// move it in merged model
									mergedModelElement.parameters.add(aspect_parameters)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_parameters.asType(Mergeable))
								end
							}
							// if it has some reference (staticTypeVariableBindings) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
							// if it has some reference (staticType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallOperation inherits org::kermeta::language::behavior::CallFeature {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::CallFeature is do
					var mergedModelElement : org::kermeta::language::behavior::CallOperation
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallOperation)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallOperation")
							// if it has some reference (staticOperation) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallProperty inherits org::kermeta::language::behavior::CallFeature {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::CallFeature is do
					var mergedModelElement : org::kermeta::language::behavior::CallProperty
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallProperty)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallProperty")
							// if it has some reference (staticProperty) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class CallEnumLiteral inherits org::kermeta::language::behavior::CallExpression {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::behavior::CallExpression is do
					var mergedModelElement : org::kermeta::language::behavior::CallEnumLiteral
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::behavior::CallEnumLiteral)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a CallEnumLiteral")
							// if it has some reference (staticEnumLiteral) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

		}


		package structure {


			aspect class KermetaModelElement inherits Mergeable  {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable is do
					var mergedModelElement : org::kermeta::language::structure::KermetaModelElement
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::KermetaModelElement)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a KermetaModelElement")
							// if it has some reference (kTag) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.kOwnedTags.each{aspect_kOwnedTags | 
								var equivalent_kOwnedTags : org::kermeta::language::structure::Tag
								equivalent_kOwnedTags := mergedModelElement.kOwnedTags.detect{ merged_kOwnedTags |
									aspect_kOwnedTags.localMatch(merged_kOwnedTags)
								}
								if (not equivalent_kOwnedTags.isVoid) then
									// mark them as similar
									aspect_kOwnedTags.similarElementInMergedModel := equivalent_kOwnedTags
								else
									// move it in merged model
									mergedModelElement.kOwnedTags.add(aspect_kOwnedTags)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_kOwnedTags.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					self.eachOwnedElement{ e | do 
					      e.asType(Mergeable).binaryMerger_MoveToMergedModel(context)
					   rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
					      context.errors.add(mergeException)
					   end
					   e
					}
					result := self
				end
			}


			aspect class Operation inherits org::kermeta::language::structure::MultiplicityElement, org::kermeta::language::structure::AbstractOperation {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::structure::Operation
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Operation)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Operation")
							// if it has some reference (raisedException) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.ownedParameter.each{aspect_ownedParameter | 
								var equivalent_ownedParameter : org::kermeta::language::structure::Parameter
								equivalent_ownedParameter := mergedModelElement.ownedParameter.detect{ merged_ownedParameter |
									aspect_ownedParameter.localMatch(merged_ownedParameter)
								}
								if (not equivalent_ownedParameter.isVoid) then
									// mark them as similar
									aspect_ownedParameter.similarElementInMergedModel := equivalent_ownedParameter
								else
									// move it in merged model
									mergedModelElement.ownedParameter.add(aspect_ownedParameter)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedParameter.asType(Mergeable))
								end
							}
							self.~pre.each{aspect_pre | 
								var equivalent_pre : org::kermeta::language::structure::Constraint
								equivalent_pre := mergedModelElement.~pre.detect{ merged_pre |
									aspect_pre.localMatch(merged_pre)
								}
								if (not equivalent_pre.isVoid) then
									// mark them as similar
									aspect_pre.similarElementInMergedModel := equivalent_pre
								else
									// move it in merged model
									mergedModelElement.~pre.add(aspect_pre)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_pre.asType(Mergeable))
								end
							}
							self.~post.each{aspect_post | 
								var equivalent_post : org::kermeta::language::structure::Constraint
								equivalent_post := mergedModelElement.~post.detect{ merged_post |
									aspect_post.localMatch(merged_post)
								}
								if (not equivalent_post.isVoid) then
									// mark them as similar
									aspect_post.similarElementInMergedModel := equivalent_post
								else
									// move it in merged model
									mergedModelElement.~post.add(aspect_post)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_post.asType(Mergeable))
								end
							}
							mergedModelElement.body ?= self.selectUnaryProperty("body", self.body, mergedModelElement.body)
							// if it has some reference (superOperation) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.ownedUnresolvedOperations.each{aspect_ownedUnresolvedOperations | 
								var equivalent_ownedUnresolvedOperations : org::kermeta::language::structure::UnresolvedOperation
								equivalent_ownedUnresolvedOperations := mergedModelElement.ownedUnresolvedOperations.detect{ merged_ownedUnresolvedOperations |
									aspect_ownedUnresolvedOperations.localMatch(merged_ownedUnresolvedOperations)
								}
								if (not equivalent_ownedUnresolvedOperations.isVoid) then
									// mark them as similar
									aspect_ownedUnresolvedOperations.similarElementInMergedModel := equivalent_ownedUnresolvedOperations
								else
									// move it in merged model
									mergedModelElement.ownedUnresolvedOperations.add(aspect_ownedUnresolvedOperations)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedUnresolvedOperations.asType(Mergeable))
								end
							}
							// if it has some reference (typeParameter) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.isAbstract ?= self.selectUnaryProperty("isAbstract", self.isAbstract, mergedModelElement.isAbstract)
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Property inherits org::kermeta::language::structure::MultiplicityElement, org::kermeta::language::structure::AbstractProperty {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::structure::Property
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Property)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Property")
							// if it has some reference (opposite) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							mergedModelElement.getterBody ?= self.selectUnaryProperty("getterBody", self.getterBody, mergedModelElement.getterBody)
							mergedModelElement.setterBody ?= self.selectUnaryProperty("setterBody", self.setterBody, mergedModelElement.setterBody)
							self.ownedUnresolvedProperties.each{aspect_ownedUnresolvedProperties | 
								var equivalent_ownedUnresolvedProperties : org::kermeta::language::structure::UnresolvedProperty
								equivalent_ownedUnresolvedProperties := mergedModelElement.ownedUnresolvedProperties.detect{ merged_ownedUnresolvedProperties |
									aspect_ownedUnresolvedProperties.localMatch(merged_ownedUnresolvedProperties)
								}
								if (not equivalent_ownedUnresolvedProperties.isVoid) then
									// mark them as similar
									aspect_ownedUnresolvedProperties.similarElementInMergedModel := equivalent_ownedUnresolvedProperties
								else
									// move it in merged model
									mergedModelElement.ownedUnresolvedProperties.add(aspect_ownedUnresolvedProperties)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedUnresolvedProperties.asType(Mergeable))
								end
							}
							// select value for unary attribute
							mergedModelElement.isReadOnly ?= self.selectUnaryProperty("isReadOnly", self.isReadOnly, mergedModelElement.isReadOnly)
							// select value for unary attribute
							mergedModelElement.default ?= self.selectUnaryProperty("default", self.default, mergedModelElement.default)
							// select value for unary attribute
							mergedModelElement.isComposite ?= self.selectUnaryProperty("isComposite", self.isComposite, mergedModelElement.isComposite)
							// select value for unary attribute
							mergedModelElement.isDerived ?= self.selectUnaryProperty("isDerived", self.isDerived, mergedModelElement.isDerived)
							// select value for unary attribute
							mergedModelElement.isID ?= self.selectUnaryProperty("isID", self.isID, mergedModelElement.isID)
							// select value for unary attribute
							mergedModelElement.isGetterAbstract ?= self.selectUnaryProperty("isGetterAbstract", self.isGetterAbstract, mergedModelElement.isGetterAbstract)
							// select value for unary attribute
							mergedModelElement.isSetterAbstract ?= self.selectUnaryProperty("isSetterAbstract", self.isSetterAbstract, mergedModelElement.isSetterAbstract)
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Type inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Type
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Type)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Type")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class TypeContainer inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::TypeContainer
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::TypeContainer)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a TypeContainer")
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class EnumerationLiteral inherits org::kermeta::language::structure::NamedElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::EnumerationLiteral
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::EnumerationLiteral)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a EnumerationLiteral")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class TypeVariableBinding inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::TypeVariableBinding
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::TypeVariableBinding)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a TypeVariableBinding")
							// if it has some reference (variable) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (type) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class MultiplicityElement inherits org::kermeta::language::structure::TypedElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypedElement is do
					var mergedModelElement : org::kermeta::language::structure::MultiplicityElement
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::MultiplicityElement)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a MultiplicityElement")
							// select value for unary attribute
							mergedModelElement.isOrdered ?= self.selectUnaryProperty("isOrdered", self.isOrdered, mergedModelElement.isOrdered)
							// select value for unary attribute
							mergedModelElement.isUnique ?= self.selectUnaryProperty("isUnique", self.isUnique, mergedModelElement.isUnique)
							// select value for unary attribute
							mergedModelElement.lower ?= self.selectUnaryProperty("lower", self.lower, mergedModelElement.lower)
							// select value for unary attribute
							mergedModelElement.upper ?= self.selectUnaryProperty("upper", self.upper, mergedModelElement.upper)
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class TypeDefinition inherits org::kermeta::language::structure::NamedElement, org::kermeta::language::structure::TypeContainer {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::TypeDefinition
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::TypeDefinition)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a TypeDefinition")
							// if it has some reference (superType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.isAspect ?= self.selectUnaryProperty("isAspect", self.isAspect, mergedModelElement.isAspect)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Class inherits org::kermeta::language::structure::ParameterizedType {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::ParameterizedType is do
					var mergedModelElement : org::kermeta::language::structure::Class
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Class)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Class")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class DataType inherits org::kermeta::language::structure::Type, org::kermeta::language::structure::ModelElementTypeDefinition {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::DataType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::DataType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a DataType")
							// if it has some reference (superType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.isAspect ?= self.selectUnaryProperty("isAspect", self.isAspect, mergedModelElement.isAspect)
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Enumeration inherits org::kermeta::language::structure::DataType {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::DataType is do
					var mergedModelElement : org::kermeta::language::structure::Enumeration
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Enumeration)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Enumeration")
							self.ownedLiteral.each{aspect_ownedLiteral | 
								var equivalent_ownedLiteral : org::kermeta::language::structure::EnumerationLiteral
								equivalent_ownedLiteral := mergedModelElement.ownedLiteral.detect{ merged_ownedLiteral |
									aspect_ownedLiteral.localMatch(merged_ownedLiteral)
								}
								if (not equivalent_ownedLiteral.isVoid) then
									// mark them as similar
									aspect_ownedLiteral.similarElementInMergedModel := equivalent_ownedLiteral
								else
									// move it in merged model
									mergedModelElement.ownedLiteral.add(aspect_ownedLiteral)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedLiteral.asType(Mergeable))
								end
							}
							// if it has some reference (superType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.isAspect ?= self.selectUnaryProperty("isAspect", self.isAspect, mergedModelElement.isAspect)
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class NamedElement inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::NamedElement
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::NamedElement)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a NamedElement")
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Package inherits org::kermeta::language::structure::NamedElement, org::kermeta::language::structure::ModelElementTypeDefinitionContainer {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::Package
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Package)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Package")
							self.nestedPackage.each{aspect_nestedPackage | 
								var equivalent_nestedPackage : org::kermeta::language::structure::Package
								equivalent_nestedPackage := mergedModelElement.nestedPackage.detect{ merged_nestedPackage |
									aspect_nestedPackage.localMatch(merged_nestedPackage)
								}
								if (not equivalent_nestedPackage.isVoid) then
									// mark them as similar
									aspect_nestedPackage.similarElementInMergedModel := equivalent_nestedPackage
								else
									// move it in merged model
									mergedModelElement.nestedPackage.add(aspect_nestedPackage)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_nestedPackage.asType(Mergeable))
								end
							}
							self.ownedAdaptationOperators.each{aspect_ownedAdaptationOperators | 
								var equivalent_ownedAdaptationOperators : org::kermeta::language::structure::AdaptationOperator
								equivalent_ownedAdaptationOperators := mergedModelElement.ownedAdaptationOperators.detect{ merged_ownedAdaptationOperators |
									aspect_ownedAdaptationOperators.localMatch(merged_ownedAdaptationOperators)
								}
								if (not equivalent_ownedAdaptationOperators.isVoid) then
									// mark them as similar
									aspect_ownedAdaptationOperators.similarElementInMergedModel := equivalent_ownedAdaptationOperators
								else
									// move it in merged model
									mergedModelElement.ownedAdaptationOperators.add(aspect_ownedAdaptationOperators)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedAdaptationOperators.asType(Mergeable))
								end
							}
							// select value for unary attribute
							mergedModelElement.uri ?= self.selectUnaryProperty("uri", self.uri, mergedModelElement.uri)
							self.ownedTypeDefinition.each{aspect_ownedTypeDefinition | 
								var equivalent_ownedTypeDefinition : org::kermeta::language::structure::ModelElementTypeDefinition
								equivalent_ownedTypeDefinition := mergedModelElement.ownedTypeDefinition.detect{ merged_ownedTypeDefinition |
									aspect_ownedTypeDefinition.localMatch(merged_ownedTypeDefinition)
								}
								if (not equivalent_ownedTypeDefinition.isVoid) then
									// mark them as similar
									aspect_ownedTypeDefinition.similarElementInMergedModel := equivalent_ownedTypeDefinition
								else
									// move it in merged model
									mergedModelElement.ownedTypeDefinition.add(aspect_ownedTypeDefinition)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedTypeDefinition.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Parameter inherits org::kermeta::language::structure::MultiplicityElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::MultiplicityElement is do
					var mergedModelElement : org::kermeta::language::structure::Parameter
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Parameter)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Parameter")
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class PrimitiveType inherits org::kermeta::language::structure::DataType {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::DataType is do
					var mergedModelElement : org::kermeta::language::structure::PrimitiveType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::PrimitiveType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a PrimitiveType")
							// if it has some reference (instanceType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (superType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.isAspect ?= self.selectUnaryProperty("isAspect", self.isAspect, mergedModelElement.isAspect)
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class TypedElement inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::NamedElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::TypedElement
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::TypedElement)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a TypedElement")
							// if it has some reference (type) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}


			aspect class Tag inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Tag
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Tag)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Tag")
							// if it has some reference (object) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
							// select value for unary attribute
							mergedModelElement.~value ?= self.selectUnaryProperty("~value", self.~value, mergedModelElement.~value)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class AbstractProperty inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::AbstractProperty
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::AbstractProperty)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a AbstractProperty")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Constraint inherits org::kermeta::language::structure::NamedElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::Constraint
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Constraint)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Constraint")
							mergedModelElement.body ?= self.selectUnaryProperty("body", self.body, mergedModelElement.body)
							// select value for unary attribute
							// workaround compiler bug, cannot pass an enumeration as an object ! default selection is hardcoded and not user changeable
							if (not self.stereotype.isVoid) and (mergedModelElement.stereotype.isVoid) then
								mergedModelElement.stereotype := self.stereotype
							end
							// select value for unary attribute
							// workaround compiler bug, cannot pass an enumeration as an object ! default selection is hardcoded and not user changeable
							if (not self.language.isVoid) and (mergedModelElement.language.isVoid) then
								mergedModelElement.language := self.language
							end
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}


			aspect class ClassDefinition inherits org::kermeta::language::structure::GenericTypeDefinition {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::GenericTypeDefinition is do
					var mergedModelElement : org::kermeta::language::structure::ClassDefinition
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ClassDefinition)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ClassDefinition")
							self.~inv.each{aspect_inv | 
								var equivalent_inv : org::kermeta::language::structure::Constraint
								equivalent_inv := mergedModelElement.~inv.detect{ merged_inv |
									aspect_inv.localMatch(merged_inv)
								}
								if (not equivalent_inv.isVoid) then
									// mark them as similar
									aspect_inv.similarElementInMergedModel := equivalent_inv
								else
									// move it in merged model
									mergedModelElement.~inv.add(aspect_inv)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_inv.asType(Mergeable))
								end
							}
							self.ownedAttribute.each{aspect_ownedAttribute | 
								var equivalent_ownedAttribute : org::kermeta::language::structure::Property
								equivalent_ownedAttribute := mergedModelElement.ownedAttribute.detect{ merged_ownedAttribute |
									aspect_ownedAttribute.localMatch(merged_ownedAttribute)
								}
								if (not equivalent_ownedAttribute.isVoid) then
									// mark them as similar
									aspect_ownedAttribute.similarElementInMergedModel := equivalent_ownedAttribute
								else
									// move it in merged model
									mergedModelElement.ownedAttribute.add(aspect_ownedAttribute)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedAttribute.asType(Mergeable))
								end
							}
							self.ownedOperation.each{aspect_ownedOperation | 
								var equivalent_ownedOperation : org::kermeta::language::structure::Operation
								equivalent_ownedOperation := mergedModelElement.ownedOperation.detect{ merged_ownedOperation |
									aspect_ownedOperation.localMatch(merged_ownedOperation)
								}
								if (not equivalent_ownedOperation.isVoid) then
									// mark them as similar
									aspect_ownedOperation.similarElementInMergedModel := equivalent_ownedOperation
								else
									// move it in merged model
									mergedModelElement.ownedOperation.add(aspect_ownedOperation)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedOperation.asType(Mergeable))
								end
							}
							// select value for unary attribute
							mergedModelElement.isAbstract ?= self.selectUnaryProperty("isAbstract", self.isAbstract, mergedModelElement.isAbstract)
							// select value for unary attribute
							mergedModelElement.isSingleton ?= self.selectUnaryProperty("isSingleton", self.isSingleton, mergedModelElement.isSingleton)
							// select value for unary attribute
							mergedModelElement.isFinal ?= self.selectUnaryProperty("isFinal", self.isFinal, mergedModelElement.isFinal)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}


			aspect class Metamodel inherits org::kermeta::language::structure::KermetaModelElement, org::kermeta::language::structure::NamedElement, org::kermeta::language::structure::TypeDefinition {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Metamodel
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Metamodel)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Metamodel")
							self.packages.each{aspect_packages | 
								var equivalent_packages : org::kermeta::language::structure::Package
								equivalent_packages := mergedModelElement.packages.detect{ merged_packages |
									aspect_packages.localMatch(merged_packages)
								}
								if (not equivalent_packages.isVoid) then
									// mark them as similar
									aspect_packages.similarElementInMergedModel := equivalent_packages
								else
									// move it in merged model
									mergedModelElement.packages.add(aspect_packages)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_packages.asType(Mergeable))
								end
							}
							self.referencedMetamodels.each{aspect_referencedMetamodels | 
								var equivalent_referencedMetamodels : org::kermeta::language::structure::FilteredMetamodelReference
								equivalent_referencedMetamodels := mergedModelElement.referencedMetamodels.detect{ merged_referencedMetamodels |
									aspect_referencedMetamodels.localMatch(merged_referencedMetamodels)
								}
								if (not equivalent_referencedMetamodels.isVoid) then
									// mark them as similar
									aspect_referencedMetamodels.similarElementInMergedModel := equivalent_referencedMetamodels
								else
									// move it in merged model
									mergedModelElement.referencedMetamodels.add(aspect_referencedMetamodels)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_referencedMetamodels.asType(Mergeable))
								end
							}
							// select value for unary attribute
							mergedModelElement.uri ?= self.selectUnaryProperty("uri", self.uri, mergedModelElement.uri)
							// select value for unary attribute
							mergedModelElement.isResolved ?= self.selectUnaryProperty("isResolved", self.isResolved, mergedModelElement.isResolved)
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
							// if it has some reference (superType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.isAspect ?= self.selectUnaryProperty("isAspect", self.isAspect, mergedModelElement.isAspect)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class ModelElementTypeDefinitionContainer inherits org::kermeta::language::structure::NamedElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::ModelElementTypeDefinitionContainer
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelElementTypeDefinitionContainer)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ModelElementTypeDefinitionContainer")
							self.ownedTypeDefinition.each{aspect_ownedTypeDefinition | 
								var equivalent_ownedTypeDefinition : org::kermeta::language::structure::ModelElementTypeDefinition
								equivalent_ownedTypeDefinition := mergedModelElement.ownedTypeDefinition.detect{ merged_ownedTypeDefinition |
									aspect_ownedTypeDefinition.localMatch(merged_ownedTypeDefinition)
								}
								if (not equivalent_ownedTypeDefinition.isVoid) then
									// mark them as similar
									aspect_ownedTypeDefinition.similarElementInMergedModel := equivalent_ownedTypeDefinition
								else
									// move it in merged model
									mergedModelElement.ownedTypeDefinition.add(aspect_ownedTypeDefinition)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedTypeDefinition.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class GenericTypeDefinition inherits org::kermeta::language::structure::ModelElementTypeDefinition {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::ModelElementTypeDefinition is do
					var mergedModelElement : org::kermeta::language::structure::GenericTypeDefinition
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::GenericTypeDefinition)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a GenericTypeDefinition")
							// if it has some reference (typeParameter) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class ParameterizedType inherits org::kermeta::language::structure::Type {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::ParameterizedType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ParameterizedType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ParameterizedType")
							self.virtualTypeBinding.each{aspect_virtualTypeBinding | 
								var equivalent_virtualTypeBinding : org::kermeta::language::structure::TypeVariableBinding
								equivalent_virtualTypeBinding := mergedModelElement.virtualTypeBinding.detect{ merged_virtualTypeBinding |
									aspect_virtualTypeBinding.localMatch(merged_virtualTypeBinding)
								}
								if (not equivalent_virtualTypeBinding.isVoid) then
									// mark them as similar
									aspect_virtualTypeBinding.similarElementInMergedModel := equivalent_virtualTypeBinding
								else
									// move it in merged model
									mergedModelElement.virtualTypeBinding.add(aspect_virtualTypeBinding)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_virtualTypeBinding.asType(Mergeable))
								end
							}
							self.typeParamBinding.each{aspect_typeParamBinding | 
								var equivalent_typeParamBinding : org::kermeta::language::structure::TypeVariableBinding
								equivalent_typeParamBinding := mergedModelElement.typeParamBinding.detect{ merged_typeParamBinding |
									aspect_typeParamBinding.localMatch(merged_typeParamBinding)
								}
								if (not equivalent_typeParamBinding.isVoid) then
									// mark them as similar
									aspect_typeParamBinding.similarElementInMergedModel := equivalent_typeParamBinding
								else
									// move it in merged model
									mergedModelElement.typeParamBinding.add(aspect_typeParamBinding)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_typeParamBinding.asType(Mergeable))
								end
							}
							// if it has some reference (typeDefinition) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class TypeVariable inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::Type, org::kermeta::language::structure::NamedElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::TypeVariable
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::TypeVariable)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a TypeVariable")
							// if it has some reference (supertype) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class ObjectTypeVariable inherits org::kermeta::language::structure::TypeVariable {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypeVariable is do
					var mergedModelElement : org::kermeta::language::structure::ObjectTypeVariable
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ObjectTypeVariable)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ObjectTypeVariable")
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class ModelTypeVariable inherits org::kermeta::language::structure::TypeVariable {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypeVariable is do
					var mergedModelElement : org::kermeta::language::structure::ModelTypeVariable
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelTypeVariable)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ModelTypeVariable")
							// if it has some reference (virtualType) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class VirtualType inherits org::kermeta::language::structure::ObjectTypeVariable {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::ObjectTypeVariable is do
					var mergedModelElement : org::kermeta::language::structure::VirtualType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::VirtualType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a VirtualType")
							// if it has some reference (classDefinition) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (metamodelVariable) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.typeParamBinding.each{aspect_typeParamBinding | 
								var equivalent_typeParamBinding : org::kermeta::language::structure::TypeVariableBinding
								equivalent_typeParamBinding := mergedModelElement.typeParamBinding.detect{ merged_typeParamBinding |
									aspect_typeParamBinding.localMatch(merged_typeParamBinding)
								}
								if (not equivalent_typeParamBinding.isVoid) then
									// mark them as similar
									aspect_typeParamBinding.similarElementInMergedModel := equivalent_typeParamBinding
								else
									// move it in merged model
									mergedModelElement.typeParamBinding.add(aspect_typeParamBinding)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_typeParamBinding.asType(Mergeable))
								end
							}
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Model inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Model
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Model)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Model")
							// if it has some reference (contents) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class AbstractOperation inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::AbstractOperation
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::AbstractOperation)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a AbstractOperation")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UnresolvedType inherits org::kermeta::language::structure::Type, org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::structure::TypeContainer {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::UnresolvedType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UnresolvedType")
							self.usings.each{aspect_usings | 
								var equivalent_usings : org::kermeta::language::structure::Using
								equivalent_usings := mergedModelElement.usings.detect{ merged_usings |
									aspect_usings.localMatch(merged_usings)
								}
								if (not equivalent_usings.isVoid) then
									// mark them as similar
									aspect_usings.similarElementInMergedModel := equivalent_usings
								else
									// move it in merged model
									mergedModelElement.usings.add(aspect_usings)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_usings.asType(Mergeable))
								end
							}
							// if it has some reference (generics) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.typeIdentifier ?= self.selectUnaryProperty("typeIdentifier", self.typeIdentifier, mergedModelElement.typeIdentifier)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UnresolvedReference inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedReference
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::UnresolvedReference)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UnresolvedReference")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UnresolvedProperty inherits org::kermeta::language::structure::AbstractProperty, org::kermeta::language::structure::UnresolvedReference {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::AbstractProperty is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedProperty
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::UnresolvedProperty)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UnresolvedProperty")
							// select value for unary attribute
							mergedModelElement.propertyIdentifier ?= self.selectUnaryProperty("propertyIdentifier", self.propertyIdentifier, mergedModelElement.propertyIdentifier)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UnresolvedOperation inherits org::kermeta::language::structure::AbstractOperation, org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::structure::TypeContainer {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::AbstractOperation is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedOperation
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::UnresolvedOperation)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UnresolvedOperation")
							// if it has some reference (~from) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.operationIdentifier ?= self.selectUnaryProperty("operationIdentifier", self.operationIdentifier, mergedModelElement.operationIdentifier)
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class Using inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::Using
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::Using)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a Using")
							// select value for unary attribute
							mergedModelElement.fromQName ?= self.selectUnaryProperty("fromQName", self.fromQName, mergedModelElement.fromQName)
							// select value for unary attribute
							mergedModelElement.toName ?= self.selectUnaryProperty("toName", self.toName, mergedModelElement.toName)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class ProductType inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::Type {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::ProductType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ProductType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ProductType")
							// if it has some reference (type) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class FunctionType inherits org::kermeta::language::structure::TypeContainer, org::kermeta::language::structure::Type {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypeContainer is do
					var mergedModelElement : org::kermeta::language::structure::FunctionType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::FunctionType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a FunctionType")
							// if it has some reference (left) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (right) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class VoidType inherits org::kermeta::language::structure::Type {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::VoidType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::VoidType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a VoidType")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UnresolvedInferredType inherits org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::structure::Type {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::UnresolvedReference is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedInferredType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::UnresolvedInferredType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UnresolvedInferredType")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UnresolvedTypeVariable inherits org::kermeta::language::structure::UnresolvedReference, org::kermeta::language::structure::TypeVariable {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::UnresolvedReference is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedTypeVariable
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::UnresolvedTypeVariable)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UnresolvedTypeVariable")
							// if it has some reference (supertype) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class MetamodelBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::MetamodelBinding
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::MetamodelBinding)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a MetamodelBinding")
							// if it has some reference (boundMetamodel) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.ownedClassDefinitionBindings.each{aspect_ownedClassDefinitionBindings | 
								var equivalent_ownedClassDefinitionBindings : org::kermeta::language::structure::ClassDefinitionBinding
								equivalent_ownedClassDefinitionBindings := mergedModelElement.ownedClassDefinitionBindings.detect{ merged_ownedClassDefinitionBindings |
									aspect_ownedClassDefinitionBindings.localMatch(merged_ownedClassDefinitionBindings)
								}
								if (not equivalent_ownedClassDefinitionBindings.isVoid) then
									// mark them as similar
									aspect_ownedClassDefinitionBindings.similarElementInMergedModel := equivalent_ownedClassDefinitionBindings
								else
									// move it in merged model
									mergedModelElement.ownedClassDefinitionBindings.add(aspect_ownedClassDefinitionBindings)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedClassDefinitionBindings.asType(Mergeable))
								end
							}
							self.usedAdaptationOperators.each{aspect_usedAdaptationOperators | 
								var equivalent_usedAdaptationOperators : org::kermeta::language::structure::UseAdaptationOperator
								equivalent_usedAdaptationOperators := mergedModelElement.usedAdaptationOperators.detect{ merged_usedAdaptationOperators |
									aspect_usedAdaptationOperators.localMatch(merged_usedAdaptationOperators)
								}
								if (not equivalent_usedAdaptationOperators.isVoid) then
									// mark them as similar
									aspect_usedAdaptationOperators.similarElementInMergedModel := equivalent_usedAdaptationOperators
								else
									// move it in merged model
									mergedModelElement.usedAdaptationOperators.add(aspect_usedAdaptationOperators)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_usedAdaptationOperators.asType(Mergeable))
								end
							}
							self.ownedEnumerationBindings.each{aspect_ownedEnumerationBindings | 
								var equivalent_ownedEnumerationBindings : org::kermeta::language::structure::EnumerationBinding
								equivalent_ownedEnumerationBindings := mergedModelElement.ownedEnumerationBindings.detect{ merged_ownedEnumerationBindings |
									aspect_ownedEnumerationBindings.localMatch(merged_ownedEnumerationBindings)
								}
								if (not equivalent_ownedEnumerationBindings.isVoid) then
									// mark them as similar
									aspect_ownedEnumerationBindings.similarElementInMergedModel := equivalent_ownedEnumerationBindings
								else
									// move it in merged model
									mergedModelElement.ownedEnumerationBindings.add(aspect_ownedEnumerationBindings)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedEnumerationBindings.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class ClassDefinitionBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::ClassDefinitionBinding
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ClassDefinitionBinding)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ClassDefinitionBinding")
							self.ownedPropertyBindings.each{aspect_ownedPropertyBindings | 
								var equivalent_ownedPropertyBindings : org::kermeta::language::structure::PropertyBinding
								equivalent_ownedPropertyBindings := mergedModelElement.ownedPropertyBindings.detect{ merged_ownedPropertyBindings |
									aspect_ownedPropertyBindings.localMatch(merged_ownedPropertyBindings)
								}
								if (not equivalent_ownedPropertyBindings.isVoid) then
									// mark them as similar
									aspect_ownedPropertyBindings.similarElementInMergedModel := equivalent_ownedPropertyBindings
								else
									// move it in merged model
									mergedModelElement.ownedPropertyBindings.add(aspect_ownedPropertyBindings)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedPropertyBindings.asType(Mergeable))
								end
							}
							self.ownedOperationBindings.each{aspect_ownedOperationBindings | 
								var equivalent_ownedOperationBindings : org::kermeta::language::structure::OperationBinding
								equivalent_ownedOperationBindings := mergedModelElement.ownedOperationBindings.detect{ merged_ownedOperationBindings |
									aspect_ownedOperationBindings.localMatch(merged_ownedOperationBindings)
								}
								if (not equivalent_ownedOperationBindings.isVoid) then
									// mark them as similar
									aspect_ownedOperationBindings.similarElementInMergedModel := equivalent_ownedOperationBindings
								else
									// move it in merged model
									mergedModelElement.ownedOperationBindings.add(aspect_ownedOperationBindings)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedOperationBindings.asType(Mergeable))
								end
							}
							// if it has some reference (source) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (target) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class EnumerationBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::EnumerationBinding
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::EnumerationBinding)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a EnumerationBinding")
							// if it has some reference (source) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (target) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class PropertyBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::PropertyBinding
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::PropertyBinding)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a PropertyBinding")
							// if it has some reference (source) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (target) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class OperationBinding inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::OperationBinding
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::OperationBinding)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a OperationBinding")
							// if it has some reference (source) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// if it has some reference (target) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class AdaptationOperator inherits org::kermeta::language::structure::NamedElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::NamedElement is do
					var mergedModelElement : org::kermeta::language::structure::AdaptationOperator
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::AdaptationOperator)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a AdaptationOperator")
							// if it has some reference (parameters) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UseAdaptationOperator inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::UseAdaptationOperator
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::UseAdaptationOperator)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UseAdaptationOperator")
							// if it has some reference (parameters) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							self.ownedUnresolved.each{aspect_ownedUnresolved | 
								var equivalent_ownedUnresolved : org::kermeta::language::structure::UnresolvedReference
								equivalent_ownedUnresolved := mergedModelElement.ownedUnresolved.detect{ merged_ownedUnresolved |
									aspect_ownedUnresolved.localMatch(merged_ownedUnresolved)
								}
								if (not equivalent_ownedUnresolved.isVoid) then
									// mark them as similar
									aspect_ownedUnresolved.similarElementInMergedModel := equivalent_ownedUnresolved
								else
									// move it in merged model
									mergedModelElement.ownedUnresolved.add(aspect_ownedUnresolved)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_ownedUnresolved.asType(Mergeable))
								end
							}
							// if it has some reference (usedOperator) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class PropertyAdaptationOperator inherits org::kermeta::language::structure::AdaptationOperator {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::AdaptationOperator is do
					var mergedModelElement : org::kermeta::language::structure::PropertyAdaptationOperator
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::PropertyAdaptationOperator)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a PropertyAdaptationOperator")
							// if it has some reference (target) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.~getter ?= self.selectUnaryProperty("~getter", self.~getter, mergedModelElement.~getter)
							// select value for unary attribute
							mergedModelElement.~setter ?= self.selectUnaryProperty("~setter", self.~setter, mergedModelElement.~setter)
							// select value for unary attribute
							mergedModelElement.adder ?= self.selectUnaryProperty("adder", self.adder, mergedModelElement.adder)
							// select value for unary attribute
							mergedModelElement.remover ?= self.selectUnaryProperty("remover", self.remover, mergedModelElement.remover)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class UnresolvedAdaptationOperator inherits org::kermeta::language::structure::AdaptationOperator, org::kermeta::language::structure::UnresolvedReference {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::AdaptationOperator is do
					var mergedModelElement : org::kermeta::language::structure::UnresolvedAdaptationOperator
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::UnresolvedAdaptationOperator)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a UnresolvedAdaptationOperator")
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class AdaptationParameter inherits org::kermeta::language::structure::TypedElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypedElement is do
					var mergedModelElement : org::kermeta::language::structure::AdaptationParameter
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::AdaptationParameter)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a AdaptationParameter")
							// select value for unary attribute
							mergedModelElement.name ?= self.selectUnaryProperty("name", self.name, mergedModelElement.name)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class OperationAdaptationOperator inherits org::kermeta::language::structure::AdaptationOperator {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::AdaptationOperator is do
					var mergedModelElement : org::kermeta::language::structure::OperationAdaptationOperator
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::OperationAdaptationOperator)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a OperationAdaptationOperator")
							// if it has some reference (target) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
							// select value for unary attribute
							mergedModelElement.body ?= self.selectUnaryProperty("body", self.body, mergedModelElement.body)
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class ModelElementTypeDefinition inherits org::kermeta::language::structure::TypeDefinition {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::TypeDefinition is do
					var mergedModelElement : org::kermeta::language::structure::ModelElementTypeDefinition
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelElementTypeDefinition)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ModelElementTypeDefinition")
							self.containedType.each{aspect_containedType | 
								var equivalent_containedType : org::kermeta::language::structure::Type
								equivalent_containedType := mergedModelElement.containedType.detect{ merged_containedType |
									aspect_containedType.localMatch(merged_containedType)
								}
								if (not equivalent_containedType.isVoid) then
									// mark them as similar
									aspect_containedType.similarElementInMergedModel := equivalent_containedType
								else
									// move it in merged model
									mergedModelElement.containedType.add(aspect_containedType)
									// mark moved element so its references could be fixed
									context.movedElementsNeedingReferenceFix.add(aspect_containedType.asType(Mergeable))
								end
							}
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class ModelType inherits org::kermeta::language::structure::Type {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::Type is do
					var mergedModelElement : org::kermeta::language::structure::ModelType
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::ModelType)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a ModelType")
							// if it has some reference (typeDefinition) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

			aspect class FilteredMetamodelReference inherits org::kermeta::language::structure::KermetaModelElement {
				method binaryMerger_MoveToMergedModel(context : BinaryMergerContext) : Mergeable from org::kermeta::language::structure::KermetaModelElement is do
					var mergedModelElement : org::kermeta::language::structure::FilteredMetamodelReference
					mergedModelElement := self.similarElementInMergedModel.asType(org::kermeta::language::structure::FilteredMetamodelReference)
					if (not mergedModelElement.isVoid) then
						do
							//stdio.writeln("Merging content of a FilteredMetamodelReference")
							// if it has some reference (metamodel) not involved in composition, these aspects elements will need to be passed to mergeReferences function
							context.elementsNeedingReferenceMerge.add(self)
							
						rescue (mergeException : org::kermeta::ecore::binarymerger::BinaryMergerException)
						   context.errors.add(mergeException)
						end
					end
					super(context)

					result := self
				end
			}

		}


	}


}

