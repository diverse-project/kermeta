/* $Id:$ 
 * Creation : November 27, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            ablouin
 */
package org::kermeta::language::structure;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "../km2llvm_aspectGenerator.kmt"
require "km2llvm_castFunctions.kmt"
require "../behaviour/km2llvm_calls.kmt"

using org::kermeta::language::km2llvm
using kermeta::standard
using kermeta::utils
using org::kermeta::language::llvm

aspect class KermetaModelElement inherits LLVMGenerator{}


aspect class Metamodel {
	method generateLLVM(ctx:Context) is do
		packages.each{pkg | pkg.generateLLVM(ctx)}
	end
	
	method preprocess4LLVM() is do
		packages.each{pkg | pkg.preprocess4LLVM}
	end
}


aspect class Type {
	operation llvmType(ctx:Context) : String is abstract
}


aspect class Class {
	method llvmType(ctx:Context) : String is do
		result := ctx.stdLibName.getValue(typeDefinition.qualifiedNameLLVM)
		
		if(result.isVoid) then
			result := "%\""+typeDefinition.qualifiedNameLLVM+"\""
		end
	end
}


aspect class FunctionType {
	method llvmType(ctx:Context) : String is do
		result := "i32"
	end
}


aspect class ObjectTypeVariable {
	method llvmType(ctx:Context) : String is do
		result := "FIXME_ObjectTypeVariable"
	end
}


aspect class Operation {
	// The ID that permits to differenciate operation having the same name.
	// Each llvm function will be postfixed with this ID.
	attribute id : Integer

	// The llvm name of the operation.
	attribute _llvmName : String
	
	
	operation llvmName(ctx:Context) : String is do
		if(_llvmName.isVoid) then
			if(owningClass.toIgnore) then// Class not compiled must not be renamed.
				_llvmName := "@"+getLLVMQualifiedName // no quote since clang does not generate quote.
			else
				// An ID must be added to the class to avoid several classes to have the same name
				// in the same class.
				id := ctx.nextId
				_llvmName := ctx.llvm.globalVar(getLLVMQualifiedName+id.toString)
			end
		end
		result :=  _llvmName
	end
	

	method generateLLVM(ctx:Context) is do
		var attrs : Sequence<String> init  Sequence<String>.new
		
		ctx.currentVarCpt := 1
		
		if(isMain) then
			ctx.operations.append(ctx.llvm.define(void, ctx.llvm.i32, "@main", attrs, void)).append("{\n")
			ctx.operations.append(ctx.llvm.call(llvmName(ctx), type.llvmType(ctx), attrs)).append("\n")
			ctx.operations.append(ctx.llvm.ret(ctx.llvm.i32, "0")).append("\n")
			ctx.operations.append("}\n")
		end

		ownedParameter.each{param | attrs.add(param.type.llvmType(ctx)+" "+ ctx.llvm.localVar(param.name)) }
		ctx.operations.append(ctx.llvm.define(LinkageType.internal, type.llvmType(ctx), llvmName(ctx), attrs, void)).append("{\n")
		body.generateLLVM(ctx)
		ctx.operations.append(ctx.llvm.ret(ctx.llvm.~void, void)).append("\n")
		ctx.operations.append("}\n")
	end


	operation isMain() : Boolean is do
		result := kOwnedTags.exists{t | t.name=="main"}
	end
}


aspect class Enumeration {
	method llvmType(ctx:Context) : String is do
		result := "%\""+qualifiedNameLLVM+"\""
	end
	
	method generateLLVM(ctx:Context) is do
		// Generating the type of the enumeration
		var attrs : Sequence<String> init  Sequence<String>.new
		var typeName : String init ctx.llvm.localVar(qualifiedNameLLVM)
		attrs.add("i8*")
		ctx.types.append(ctx.llvm.type(typeName, attrs)).append("\n")
		// For each literal, generating the singleton.
		ownedLiteral.each{lit |
			attrs.clear
			var stringVarName : String init ctx.getStringVarName(lit.name)
			attrs.add("i8* " + ctx.llvm.pointerString(lit.name, stringVarName))
			ctx.types.append(ctx.llvm.constStruct(typeName, ctx.llvm.globalVar(qualifiedNameLLVM+"#"+lit.name), attrs)).append("\n")
		}
	end
}


aspect class PrimitiveType {
	method llvmType(ctx:Context) : String is do
		result := name
		if(container.isKindOf(Package)) then
			result := container.asType(Package).getLLVMQualifiedName + "_" + result
		end
		result := "%\""+result+"\""
	end
}


aspect class ClassDefinition {
	attribute _toIgnore : Boolean
	
	operation toIgnore() : Boolean is do
		if(_toIgnore.isVoid) then
			_toIgnore := kOwnedTags.exists{t | t.name=="CompilerIgnore" }
		end
		result := _toIgnore
	end

	// Generates the LLVM code
	method generateLLVM(ctx:Context) is do
		if(not toIgnore) then
			generateLLVMType(ctx)
			generateLLVMConstructor(ctx)
			generateLLVMGetters(ctx)
			generateLLVMCast(ctx)
		end
	end
	
	
	operation generateLLVMGetters(ctx:Context) is do
		var params : Sequence<String> init  Sequence<String>.new
		var fctAttr: Sequence<FunctionAttr> init  Sequence<FunctionAttr>.new
		var typeCD : String init ctx.llvm.pointer(ctx.llvm.localVar(qualifiedNameLLVM))
		var selfVar : String init ctx.llvm.localVar("self")
		var returnVar : String init ctx.llvm.localVar("r")
		var tmpVar : String init ctx.llvm.localVar("t")
		var getterName : String
		var cpt : Integer init superTypes.size + lowerTypes.size
		var returnType : String
		
		params.add(typeCD + " " + selfVar)
		fctAttr.add(FunctionAttr.~readonly)
		fctAttr.add(FunctionAttr.inlinehint)
		
		ownedAttribute.each{attr |
			returnType := ctx.llvm.pointer(attr.type.llvmType(ctx))
			getterName := ctx.llvm.globalVar(qualifiedNameLLVM + ".#" + attr.name)
			ctx.getters.append(ctx.llvm.define(LinkageType.internal, returnType, getterName, params, fctAttr)).append("{\n")
			ctx.getters.append(ctx.llvm.assign(tmpVar, ctx.llvm.getelementptr(typeCD, selfVar, ctx.llvm.i32, 0, ctx.llvm.i32, cpt, false))).append("\n")
			ctx.getters.append(ctx.llvm.assign(returnVar, ctx.llvm.load(ctx.llvm.pointer(returnType), tmpVar))).append("\n")
			ctx.getters.append(ctx.llvm.ret(returnType, returnVar)).append("\n")
			ctx.getters.append("}\n")
			cpt := cpt + 1
		}
		
		ownedOperation.each{op | op.generateLLVM(ctx) }
	end
	
	
	// Generates the llvm type corresponding to the class.
	operation generateLLVMType(ctx:Context) is do
		// Creating the supertype parameters
		var list : Sequence<String> init superTypes.collect{st | ctx.llvm.pointer(ctx.llvm.localVar(st.qualifiedNameLLVM)) }
		// Creating the lowertype parameters
		list.addAll(lowerTypes.collect{st | ctx.llvm.pointer(ctx.llvm.localVar(st.qualifiedNameLLVM))})
		ownedAttribute.each{attr | list.add(ctx.llvm.pointer(attr.type.llvmType(ctx))) }
		ctx.types.append(ctx.llvm.type(ctx.llvm.localVar(qualifiedNameLLVM), list)).append("\n")
	end
	
	
	// Generates the contructor of the class.
	operation generateLLVMConstructor(ctx:Context) is do
	 	var typeName : String init ctx.llvm.pointer(ctx.llvm.localVar(qualifiedNameLLVM))
	 	var resultVar : String init "%r"
	 	ctx.constructors.append(ctx.llvm.define(LinkageType.internal, typeName, ctx.llvm.globalVar("create_" + qualifiedNameLLVM), void, void)).append("{\n")
		
		// Creation of the object.
		ctx.constructors.append(ctx.llvm.assign(resultVar, ctx.llvm.alloca(ctx.llvm.localVar(qualifiedNameLLVM)))).append("\n")
		
		// Creation of the super types.
		var i : Integer init 0
		var istr : String
		var ptrSuperType : String
		superTypes.each{st |
			istr := i.toString
			ptrSuperType := ctx.llvm.pointer(ctx.llvm.localVar(st.qualifiedNameLLVM))
			ctx.constructors.append(ctx.llvm.assign("%\""+istr+"\"", ctx.llvm.call("@\"create_"+st.qualifiedNameLLVM+"\"", ptrSuperType, void))).append("\n")
			ctx.constructors.append(ctx.llvm.assign("%\""+istr+istr+"\"",  ctx.llvm.getelementptr(typeName, resultVar, ctx.llvm.i32, 0, ctx.llvm.i32, i, false))).append("\n")
			ctx.constructors.append(ctx.llvm.store(ptrSuperType, "%\""+istr+"\"", "%\""+istr+istr+"\"")).append("\n")
			i := i + 1
		}

		// Returning the created object.
		ctx.constructors.append(ctx.llvm.ret(typeName, resultVar)).append("\n}\n")
	end
}


aspect class Package  {
	// Preprocessing useful for the compilation
	operation preprocess4LLVM() is do
		ownedTypeDefinition.each{td | td.preprocess4LLVM}
		nestedPackage.each{pkg | pkg.preprocess4LLVM}
	end

	// Generates the LLVM code
	method generateLLVM(ctx:Context) is do
		ownedTypeDefinition.each{td | td.generateLLVM(ctx)}
		nestedPackage.each{pkg | pkg.generateLLVM(ctx)}
	end
}


aspect class TypeDefinition {
	// Preprocessing useful for the compilation
	operation preprocess4LLVM() is do
		defineLowerSuperTypes
		qualifiedNameLLVM := getLLVMQualifiedName
	end
}
