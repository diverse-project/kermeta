/* $Id:$ 
 * Creation : November 27, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            ablouin
 */
package org::kermeta::language::structure;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "../km2llvmContext.kmt"
require "km2llvm_superLowerTypes.kmt"

using org::kermeta::language::km2llvm
using org::kermeta::language::llvm
using kermeta::standard
using kermeta::utils


aspect class ClassDefinition {
	// Generates cast functions: one for each super and lower types (direct and undirect).
	operation generateLLVMCast(ctx:Context) is do
		//TODO generate cast to all super/lower types
		generateLLVMDirectCast(ctx)
	end
	
	
	operation generateLLVMDirectCast(ctx:Context) is do
		var params : Sequence<String> init Sequence<String>.new
		var typeCD : String init ctx.llvm.pointer(ctx.llvm.localVar(qualifiedNameLLVM))
		var selfVar : String init ctx.llvm.localVar("self")
		var v0 : String init ctx.llvm.localVar("0")
		var v1 : String init ctx.llvm.localVar("1")
		var fctAttrs : Sequence<FunctionAttr> init Sequence<FunctionAttr>.new
		var i : Integer init 0
		params.add(typeCD + " " + selfVar)
		fctAttrs.add(FunctionAttr.~readonly)
		fctAttrs.add(FunctionAttr.inlinehint)
		
		// Creating a cast function for each direct super type.
		superTypes.each{st |
			ctx.casts.append(createCastFunction(ctx, qualifiedNameLLVM, v0, v1, params, fctAttrs, typeCD, selfVar, i))
			i := i + 1
		}
		// Creating a cast function for each direct lower type.
		lowerTypes.each{st |
			ctx.casts.append(createCastFunction(ctx, qualifiedNameLLVM, v0, v1, params, fctAttrs, typeCD, selfVar, i))
			i := i + 1
		}
	end
	
	
	// A private helper function. See generateLLVMDirectCast
	operation createCastFunction(ctx:Context, qn:String, v0:String, v1:String, params:Sequence<String>, fctAttrs:Sequence<FunctionAttr>, typeCD:String, selfVar:String, i:Integer):String is do
		var buf : StringBuffer init StringBuffer.new
		var stType : String init ctx.llvm.pointer(ctx.llvm.localVar(qualifiedNameLLVM))
		// Creating the function header
		buf.append(ctx.llvm.define(LinkageType.internal, stType, 
							ctx.llvm.globalVar("cast_"+qn+"_"+qualifiedNameLLVM), params, fctAttrs)).append("{\n")
		// Getting the pointer to the attribute
		buf.append(ctx.llvm.assign(v0, ctx.llvm.getelementptr(typeCD, selfVar, ctx.llvm.i32, 0, ctx.llvm.i32, i, false))).append("\n")
		// loading the value of the pointer
		buf.append(ctx.llvm.assign(v1, ctx.llvm.load(ctx.llvm.pointer(stType), v0))).append("\n")
		// Returing the value.
		buf.append(ctx.llvm.ret(stType, v1)).append("\n")
		buf.append("}\n")
		result := buf.toString
	end
}
