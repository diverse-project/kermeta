/* $Id:$ 
 * Creation : November 27, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            ablouin
 */
package org::kermeta::language::structure;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"
require "../km2llvmContext.kmt"
require "km2llvm_superLowerTypes.kmt"

using org::kermeta::language::km2llvm
using org::kermeta::language::llvm
using kermeta::standard
using kermeta::utils


aspect class ClassDefinition {
	// Generates cast functions: one for each super and lower types (direct and undirect).
	operation generateLLVMCast(ctx:Context) is do
		generateLLVMDirectCast(ctx)
	end
	
	
	operation generateLLVMIndirectCast(ctx:Context, types:Sequence<ClassDefinition>, initType:ClassDefinition, superType : Boolean) is do
		// self is the type to cast into the first type (i.e. initType)
		// All the elements of 'types' are the types necessary to incrementally convert self into initType
		var selfVarPtr : String init ctx.llvm.pointer(ctx.llvm.localVar(qualifiedNameLLVM))
		var initVar : String init ctx.llvm.localVar("self")
		var params : Sequence<String> init Sequence<String>.new
		var fctAttrs : Sequence<FunctionAttr> init Sequence<FunctionAttr>.new

		params.add(ctx.llvm.pointer(ctx.llvm.localVar(initType.qualifiedNameLLVM))+" "+initVar)
		fctAttrs.add(FunctionAttr.~readonly)
		// e.g. define internal %"A"* @"cast_C_A"(%"C"* %"self") readonly
		ctx.casts.append(ctx.llvm.define(LinkageType.internal, selfVarPtr, 
							ctx.llvm.globalVar("cast_"+initType.qualifiedNameLLVM+"_"+qualifiedNameLLVM), params, fctAttrs)).append("{\n")
		// explore the types to create code
		var prevType : ClassDefinition init initType
		var prevVar : String init initVar
		var currVar : String
		var i : Integer init 0
		
		types.add(self)
		
		types.each{t|
			currVar := ctx.llvm.localVar("v"+i.toString)
			params.clear
			params.add(ctx.llvm.pointer(ctx.llvm.localVar(prevType.qualifiedNameLLVM))+" "+prevVar)
			//e.g. %"v0" = call %"B"* @"cast_C_B"(%"C"* %"self")
			ctx.casts.append(ctx.llvm.assign(currVar, 
				ctx.llvm.call(ctx.llvm.globalVar("cast_"+prevType.qualifiedNameLLVM+"_"+t.qualifiedNameLLVM), 
				ctx.llvm.pointer(ctx.llvm.localVar(t.qualifiedNameLLVM)), params))).append("\n")
			prevType := t
			prevVar := currVar
			i := i + 1
		}
		//return
		ctx.casts.append(ctx.llvm.ret(selfVarPtr, currVar)).append("\n")
		ctx.casts.append("}\n")
		
		// Generation for the super types.
		if(superType) then
			superTypes.each{st | st.asType(ClassDefinition).generateLLVMIndirectCast(ctx, types, initType, superType) }
		else
			lowerTypes.each{st | st.asType(ClassDefinition).generateLLVMIndirectCast(ctx, types, initType, superType) }
		end
	end
	
	
	operation generateLLVMDirectCast(ctx:Context) is do
		var params : Sequence<String> init Sequence<String>.new
		var typeCD : String init ctx.llvm.pointer(ctx.llvm.localVar(qualifiedNameLLVM))
		var selfVar : String init ctx.llvm.localVar("self")
		var v0 : String init ctx.llvm.localVar("0")
		var v1 : String init ctx.llvm.localVar("1")
		var fctAttrs : Sequence<FunctionAttr> init Sequence<FunctionAttr>.new
		var alreadyGen:Hashtable<String,String> init Hashtable<String,String>.new
		var i : Integer init 0
		var types : Sequence<ClassDefinition> init Sequence<ClassDefinition>.new
		params.add(typeCD + " " + selfVar)
		fctAttrs.add(FunctionAttr.~readonly)
		fctAttrs.add(FunctionAttr.inlinehint)
		
		// Creating a cast function for each direct super type.
		superTypes.each{st |
			ctx.casts.append(createCastFunction(ctx, st, v0, v1, params, fctAttrs, typeCD, selfVar, i))
			st.superTypes.each{t |
				types.clear
				types.add(st.asType(ClassDefinition))
				t.asType(ClassDefinition).generateLLVMIndirectCast(ctx, types, self, true)
			}
			i := i + 1
		}
		// Creating a cast function for each direct lower type.
		lowerTypes.each{st |
			ctx.casts.append(createCastFunction(ctx, st, v0, v1, params, fctAttrs, typeCD, selfVar, i))
			st.lowerTypes.each{t |
				types.clear
				types.add(st.asType(ClassDefinition))
				t.asType(ClassDefinition).generateLLVMIndirectCast(ctx, types, self, false)
			}
			i := i + 1
		}
	end
	
	
	// A private helper function. See generateLLVMDirectCast
	operation createCastFunction(ctx:Context, td:TypeDefinition, v0:String, v1:String, params:Sequence<String>, fctAttrs:Sequence<FunctionAttr>, typeCD:String, selfVar:String, i:Integer):String is do
		var buf : StringBuffer init StringBuffer.new
		var tdType : String init ctx.llvm.pointer(ctx.llvm.localVar(td.qualifiedNameLLVM))
		// Creating the function header
		buf.append(ctx.llvm.define(LinkageType.internal, tdType, 
							ctx.llvm.globalVar("cast_"+qualifiedNameLLVM+"_"+td.qualifiedNameLLVM), params, fctAttrs)).append("{\n")
		// Getting the pointer to the attribute
		buf.append(ctx.llvm.assign(v0, ctx.llvm.getelementptr(typeCD, selfVar, ctx.llvm.i32, 0, ctx.llvm.i32, i, false))).append("\n")
		// loading the value of the pointer
		buf.append(ctx.llvm.assign(v1, ctx.llvm.load(ctx.llvm.pointer(tdType), v0))).append("\n")
		// Returing the value.
		buf.append(ctx.llvm.ret(tdType, v1)).append("\n")
		buf.append("}\n")
		result := buf.toString
	end
}
