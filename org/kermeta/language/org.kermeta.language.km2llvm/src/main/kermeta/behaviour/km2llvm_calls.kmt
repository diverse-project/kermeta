/* $Id:$ 
 * Creation : November 27, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            ablouin
 */
package org::kermeta::language::behavior;

require kermeta
require "../structure/km2llvm_structure.kmt"

using org::kermeta::language::km2llvm
using kermeta::standard
using kermeta::utils
using org::kermeta::language::llvm
using org::kermeta::language::structure


aspect class CallExpression {
	/**
		Returns the possible identifier of the expression.
		For instance with a CallVariable instance, the name is the variable.
	*/
	operation llvmIdentifier(ctx:Context) : String is do
		result := "FIXME llvmIdentifier: " + self.toString
	end
	
	
	/**
		Returns the type of the expression.
		For instance with a CallVariable instance, the type is the type of the variable.
	*/
	operation llvmType(ctx:Context) : String is do
		result := "FIXME llvmType: " + self.toString
	end
}


aspect class CallVariable {
	method llvmIdentifier(ctx:Context) : String is do
		result := ctx.llvm.localVar(name)
	end
	
	method llvmType(ctx:Context) : String is do
		result := staticType.llvmType(ctx)
	end


	method generateLLVMNoBuffer(ctx:Context) : String is do
		// The content of the variable (a pointer) is store into a temp var.
		var varName : String init ctx.nextOperationVar
		// The load operation is appended to the string buf while the name of the temp var is returned.
		ctx.operations.append(ctx.llvm.assign(varName, ctx.llvm.load(ctx.llvm.pointer(staticType.llvmType(ctx)), ctx.llvm.localVar(name)))).append("\n")
		result := varName
	end
}
	


aspect class CallSuperOperation {
	method generateLLVMNoBuffer(ctx:Context) : String is do
		// Looking for the super operation.
		var op : Operation init superType.getOperation(staticOperation)
		var attrs : Sequence<LLVMVar> init  Sequence<LLVMVar>.new
		// Getting the variable corresponding to the super type (will be the parameter of the super call).
		var varStr : String init ctx.nextOperationVar // Declaring a local variable.
		attrs.add(LLVMVar.new.initialise(staticType.llvmType(ctx), ctx.llvm.localVar("self"))) // The parameters of the call.
		ctx.operations.append(ctx.llvm.assign(varStr, 
				ctx.llvm.call("@cast_"+staticType.qualifiedNameLLVM+"_"+superType.qualifiedNameLLVM, superType.llvmType(ctx), attrs)
				)).append("\n") // Casting self into the super type.
		// Creating the super call.
		attrs.clear
		//TODO: put the other parameters of the operation.
		attrs.add(LLVMVar.new.initialise(superType.llvmType(ctx), varStr)) // The parameters of the call.
		result := ctx.llvm.call(op.llvmName(ctx), staticOperation.type.llvmType(ctx), attrs)
	end
}


aspect class CallOperation {
	// Generates the LLVM code corresponding to a call to the operation 'new'.
	operation _generateLLVM4New(ctx:Context) : String is do
		var varName : String init ctx.nextOperationVar
		// The call of the constructor is stored into a temp variable.
		ctx.operations.append(ctx.llvm.assign(varName, ctx.llvm.call(ctx.llvm.globalVar("create_"+staticType.qualifiedNameLLVM), staticType.llvmType(ctx), void))).append("\n")
		// The temp variable is returned.
		result := varName
	end


	// Generates the LLVM code corresponding to a standard call of an operation (i.e. not a new, etc.)
	operation _generateLLVM4StdCall(ctx:Context) : String is do
		// Each parameter expression is stored into a variable before the call.
		// The ordered list of these variables are temporary stored into ctx.currentOpCallParams.
		var params : Sequence<LLVMVar> init Sequence<LLVMVar>.new
		var i : Integer init 0
		var llvmVar : LLVMVar

		parameters.each{p|
			llvmVar := LLVMVar.new.initialise(staticOperation.ownedParameter.at(i).type.llvmType(ctx), p.generateLLVMNoBuffer(ctx))
			params.add(llvmVar)
			i := i + 1
		}
		
		// The last parameter is self.
		var clazz : Class init Class.new // Uses a class to get the llvm type name of the class definition owning the operation.
		clazz.typeDefinition := staticOperation.owningClass
		params.add(LLVMVar.new.initialise(clazz.llvmType(ctx), target.generateLLVMNoBuffer(ctx)))
		clazz.typeDefinition := void
		
		// Optimisation: some calls handling simple primitive type operations are shortened to their classical llvm use (e.g. operation plus in class Integer)
		var cmd : CallGeneratorCmd init ctx.stdLibCmd.getValue(staticOperation.llvmName(ctx)) // Getting the command from the list.
		if(cmd.isVoid) then // If no command
			// Generating the call.
			result := ctx.llvm.call(staticOperation.llvmName(ctx), staticOperation.type.llvmType(ctx), params)
		else // If one command
			result := cmd.generateCall(ctx, params)
		end
		
		// The call is appended to the buffer. If a value is returned, it is stored into a variable which is returned by the operation.
		if staticOperation.type.isVoidType(ctx) then
			ctx.operations.append(result).append("\n")
			result := ""
		else
			var varTmp : String init ctx.nextOperationVar
			ctx.operations.append(ctx.llvm.assign(varTmp, result)).append("\n")
			result := varTmp
		end
	end


	method generateLLVMNoBuffer(ctx:Context) : String is do
		if(name=="new") then
			result := _generateLLVM4New(ctx)
		else
			result := _generateLLVM4StdCall(ctx)
		end
	end
}



aspect class Block {
	method generateLLVM(ctx:Context) is do
		statement.each{s | s.generateLLVM(ctx)}
	end
}
