/* $Id:$ 
 * Creation : January 12, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            jfalcou
 */


package org::kermeta::language::behavior;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"

require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/IsSubtypeOf.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/TypeEquality_structure_aspect.kmt"

require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetRootContainer_object_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/ModelingUnitHelper_structure_aspect.kmt"


using kermeta::standard
using kermeta::utils
using org::kermeta::language::structure

aspect class CallOperation
{
	
	/**
	 * You are not allowed to call operations on a class which is not an singleton.
	 * Either make your class a singleton or use an instance.
	 */
	@Scope "RESOLVED"
	inv no_operation_calls_on_a_non_singleton_class is do
	
		if (not(self.name.equals("new")) and not(self.staticOperation.isVoid)) 
		//if self.staticOperation.isVoid, an error will be raised elsewhere ...
		then
			//Check that it is called on a Class
		  	var mu : ModelingUnit init self.getRootContainer.asType(ModelingUnit)
			var classTypeDef : TypeDefinition init mu.getTypeDefinitionByQualifiedName("org::kermeta::language::structure::Class")
			
			//stdio.writeln(" classTypeDef : " + classTypeDef.toString)
			if (self.staticOperation.owningClass.equals(classTypeDef))
			then
				if (self.target.isInstanceOf(CallTypeLiteral))
				then
					var classDef : ClassDefinition init
						self.target.asType(CallTypeLiteral).typeref.type.asType(Class).typeDefinition.asType(ClassDefinition)
					
					//is it a singleton
					classDef.isSingleton
				else
					true
				end
			else
				true
			end

		else
			true
		end
	
	end
	
	//TODO : this invariant should be merged with invariant
	//no_new_on_a_singleton once a customizable error message
	//will be in place for kermeta invariants 
	/**
	 * You are not allowed to instantiate an abstract class
	 */
	@Scope "RESOLVED"
	inv no_new_on_abstract_class is do
	
		if (self.name.equals("new") and not(self.staticOperation.isVoid)) 
		then
			// Check that it is called on a Class
		  	var mu : ModelingUnit init self.getRootContainer.asType(ModelingUnit)
			var classTypeDef : TypeDefinition init mu.getTypeDefinitionByQualifiedName("org::kermeta::language::structure::Class")

			if (self.staticOperation.owningClass.equals(classTypeDef))
			then
				// Now check that it is not an abstract class
				if (self.target.isInstanceOf(CallTypeLiteral))
				then
					if (self.target.asType(CallTypeLiteral).typeref.type.isInstanceOf(Class))
					then
						not(self.target.asType(CallTypeLiteral).typeref.type.asType(Class).typeDefinition.asType(ClassDefinition).isAbstract)
					else
						true
					end
				else
					true
				end
			else
				true
			end
			
		else
			true
		end
	
	end
	
	
	/**
	 * You are not allowed to call new on a singleton class
	 */
	@Scope "RESOLVED"
	inv no_new_on_a_singleton is do
	
		if (self.name.equals("new") and not(self.staticOperation.isVoid))
		then
			// Check that it is called on a Class
		  	var mu : ModelingUnit init self.getRootContainer.asType(ModelingUnit)
			var classTypeDef : TypeDefinition init mu.getTypeDefinitionByQualifiedName("org::kermeta::language::structure::Class")
			
			if (self.staticOperation.owningClass.equals(classTypeDef))
			then
				// Now check that it is not a singleton
				if (self.target.isInstanceOf(CallTypeLiteral))
				then
					if (self.target.asType(CallTypeLiteral).typeref.type.isInstanceOf(Class))
					then
						not(self.target.asType(CallTypeLiteral).typeref.type.asType(Class).typeDefinition.asType(ClassDefinition).isSingleton)
					else
						true
					end
				else
					true
				end
			else
				true
			end
		else
			true
		end
	
	end

	/**
	 * Type mismatch. The parameters' types are not those expected.
	 */
	@Scope "RESOLVED"
	inv callOperation_parameters_conformance is do 
		
		
		/*stdio.writeln("Checking callOperation_parameters_conformance for " + self.name)
		stdio.writeln(" self.parameters.size : " + self.parameters.size.toString)
		stdio.writeln(" self.staticOperation.ownedParameter.size : " + self.staticOperation.ownedParameter.size.toString)
		*/
		if (self.parameters.size != self.staticOperation.ownedParameter.size)
		then
			// Error
			false
		else
			var myresult : Boolean init true

			// Retrieve all the operation's and owning class type parameters' bindings
			var typesToSet : Hashtable<TypeVariable, Type> init Hashtable<TypeVariable, Type>.new			

			//stdio.writeln(" operation's type parameters ? " + self.staticOperation.typeParameter.size.toString)
			// Check wether the CallOperation's staticOperation has type parameters or not
			from var i : Integer init 0
			until i==self.staticOperation.typeParameter.size
			loop
				/*
				var tvb : TypeVariableBinding init TypeVariableBinding.new
				tvb.variable:=self.staticOperation.typeParameter.at(i)
				tvb.type:=self.staticTypeVariableBindings.at(i)
				stdio.writeln("  - " + tvb.variable.name + " : " + tvb.type.toString)
				*/
				typesToSet.put(self.staticOperation.typeParameter.at(i), self.staticTypeVariableBindings.at(i))
				i:=i+1
			end
			
			// The operation's owning class may have type parameters as well
			// Beware of CallSuperOperation that has no target (but in this case,
			// the target is self
			var lTarget : Expression
			if (not(self.isInstanceOf(CallSuperOperation)))
			then
				lTarget:=self.target
			else
				lTarget:=self
			end 
			
			if (lTarget.staticType.isInstanceOf(Class))
			then
			
				var cd : ClassDefinition init lTarget.staticType.asType(Class).typeDefinition.asType(ClassDefinition)
				//stdio.writeln(" owning class's type parameters ? " + cd.typeParameter.size.toString)
				from var i : Integer init 0
				until i == cd.typeParameter.size
				loop
					/*
					var tvb : TypeVariableBinding init TypeVariableBinding.new
					tvb.variable := self.target.staticType.asType(Class).typeParamBinding.at(i).variable
					tvb.type := self.target.staticType.asType(Class).typeParamBinding.at(i).type
					stdio.writeln("  - " + tvb.variable.name + " : " + tvb.type.toString)
					*/
					typesToSet.put(lTarget.staticType.asType(Class).typeParamBinding.at(i).variable,
								   lTarget.staticType.asType(Class).typeParamBinding.at(i).type)
				
					i:=i+1
				end
			end
			
			// Now for each parameter
			//stdio.writeln(" operation parameters ? " + self.parameters.size.toString)
			from var i : Integer init 0
			until i == self.parameters.size
			loop
				/*
				stdio.writeln(" - i=" + i.toString)
				stdio.writeln("   self.parameters.staticType :" + self.parameters.at(i).staticType.toString)
				stdio.writeln("   expected type              :" + self.staticOperation.ownedParameter.at(i).type.toString)
				*/
				myresult := myresult and (self.parameters.at(i).staticType.isSubTypeOf(self.staticOperation.ownedParameter.at(i).type, typesToSet) )							
				i:=i+1
							
			end
			
			//stdio.writeln("myresult="+myresult.toString)
			myresult
		end
	end
}