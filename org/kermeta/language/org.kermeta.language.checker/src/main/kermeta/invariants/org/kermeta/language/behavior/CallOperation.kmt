/* $Id:$ 
 * Creation : January 12, 2012
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            jfalcou
 */


package org::kermeta::language::behavior;

require kermeta
require "platform:/lookup/org.kermeta.language.model/src/main/ecore/kermeta.ecore"

require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/IsSubtypeOf.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/TypeEquality_structure_aspect.kmt"

require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/GetRootContainer_object_aspect.kmt"
require "platform:/lookup/org.kermeta.language.mdk/src/kmt/language/helpers/structure/ModelingUnitHelper_structure_aspect.kmt"


using kermeta::standard
using org::kermeta::language::structure

aspect class CallOperation
{
	
	/**
	 * You are not allowed to call operations on a class which is not an singleton.
	 * Either make your class a singleton or use an instance.
	 */
	@Scope "RESOLVED"
	inv no_operation_calls_on_a_non_singleton_class is do
	
		if (not(self.name.equals("new")) and not(self.staticOperation.isVoid)) 
		//if self.staticOperation.isVoid, an error will be raised elsewhere ...
		then
			//Check that it is called on a Class
		  	var mu : ModelingUnit init self.getRootContainer.asType(ModelingUnit)
			var classTypeDef : TypeDefinition init mu.getTypeDefinitionByQualifiedName("org::kermeta::language::structure::Class")
			
			//stdio.writeln(" classTypeDef : " + classTypeDef.toString)
			if (self.staticOperation.owningClass.equals(classTypeDef))
			then
				if (self.target.isInstanceOf(CallTypeLiteral))
				then
					var classDef : ClassDefinition init
						self.target.asType(CallTypeLiteral).typeref.type.asType(Class).typeDefinition.asType(ClassDefinition)
					
					//is it a singleton
					classDef.isSingleton
				else
					true
				end
			else
				true
			end

		else
			true
		end
	
	end
	
	//TODO : this invariant should be merged with invariant
	//no_new_on_a_singleton once a customizable error message
	//will be in place for kermeta invariants 
	/**
	 * You are not allowed to instantiate an abstract class
	 */
	@Scope "RESOLVED"
	inv no_new_on_abstract_class is do
	
		if (self.name.equals("new") and not(self.staticOperation.isVoid)) 
		then
			// Check that it is called on a Class
		  	var mu : ModelingUnit init self.getRootContainer.asType(ModelingUnit)
			var classTypeDef : TypeDefinition init mu.getTypeDefinitionByQualifiedName("org::kermeta::language::structure::Class")

			if (self.staticOperation.owningClass.equals(classTypeDef))
			then
				// Now check that it is not an abstract class
				if (self.target.isInstanceOf(CallTypeLiteral))
				then
					if (self.target.asType(CallTypeLiteral).typeref.type.isInstanceOf(Class))
					then
						not(self.target.asType(CallTypeLiteral).typeref.type.asType(Class).typeDefinition.asType(ClassDefinition).isAbstract)
					else
						true
					end
				else
					true
				end
			else
				true
			end
			
		else
			true
		end
	
	end
	
	
	/**
	 * You are not allowed to call new on a singleton class
	 */
	@Scope "RESOLVED"
	inv no_new_on_a_singleton is do
	
		if (self.name.equals("new") and not(self.staticOperation.isVoid))
		then
			// Check that it is called on a Class
		  	var mu : ModelingUnit init self.getRootContainer.asType(ModelingUnit)
			var classTypeDef : TypeDefinition init mu.getTypeDefinitionByQualifiedName("org::kermeta::language::structure::Class")
			
			if (self.staticOperation.owningClass.equals(classTypeDef))
			then
				// Now check that it is not a singleton
				if (self.target.isInstanceOf(CallTypeLiteral))
				then
					if (self.target.asType(CallTypeLiteral).typeref.type.isInstanceOf(Class))
					then
						not(self.target.asType(CallTypeLiteral).typeref.type.asType(Class).typeDefinition.asType(ClassDefinition).isSingleton)
					else
						true
					end
				else
					true
				end
			else
				true
			end
		else
			true
		end
	
	end

	/**
	 * Type mismatch. The parameters' types are not those expected.
	 */
	inv callOperation_parameters_conformance is do 
		
		if (self.parameters.size != self.staticOperation.ownedParameter.size)
		then
			// Error
			false
		else
			var myresult : Boolean init true
			// init a Sequence of TypeVariableBindings
			var typeVariableBindings : Sequence<TypeVariableBinding> init Sequence<TypeVariableBinding>.new 
			
		
			// Check wether the CallOperation's staticOperation has type parameters or not
			from var i : Integer init 0
			until i==self.staticOperation.typeParameter.size
			loop
				var tvb : TypeVariableBinding init TypeVariableBinding.new
				tvb.variable:=self.staticOperation.typeParameter.at(i)
				tvb.type:=self.staticTypeVariableBindings.at(i)
				typeVariableBindings.add(tvb)
				i:=i+1
			end
			
			// The operation's owning class may have type parameters as well
			var cd : ClassDefinition init self.target.staticType.asType(Class).typeDefinition.asType(ClassDefinition)
			from var i : Integer init 0
			until i == cd.typeParameter.size
			loop
				var tvb : TypeVariableBinding init TypeVariableBinding.new
				tvb.variable := self.target.staticType.asType(Class).typeParamBinding.at(i).variable
				tvb.type := self.target.staticType.asType(Class).typeParamBinding.at(i).type
			end
			
			// Now for each parameter
		
			from var i : Integer init 0
			until i == self.parameters.size
			loop
				var paramClass : Class init self.parameters.at(i).staticType.asType(Class)
							.getComparableClass(self.staticOperation.ownedParameter.at(i).type.asType(Class))
							
				//myresult := myresult and (paramClass.typeEquivalence(self.staticOperation.ownedParameter.at(i).type.asType(Class), typeVariableBindings) )							
							
			end
			
		
			true
		end
	end
}