/* $Id: Traceability.kmt $
 * Creation date: October 06, 2006
 * License:   EPL
 * Copyright: IRISA / INRIA / Universite de Rennes 1
 * Authors:
 * 		Didier Vojtisek
 *		David Touzet
 */

package org::kermeta::traceability::mdk;

require kermeta
require "MetaModel_org.kermeta.traceability.model.kmt"

using kermeta::standard


/**
 * This class represents a trace model.
 * This is a set of traces, references and messages.
 */
aspect class TracePackage {
	/** Boolean stating whether contained references are optimized */
	property readonly optimizedReferences : Boolean getter is do
		result := true

		var crtID : String
		var refIDs : set String[0..*] init Set<String>.new

		from var it : Iterator<Reference> init references.iterator
		until (not result or it.isOff) loop
			crtID := it.next.toString
			if(refIDs.contains(crtID)) then
				result := false
			else
				refIDs.add(crtID)
			end
		end
	end


	/**
	 * This operation adds a new trace to the trace model with references duplication,
	 * which breaks the trace model optimized status
	 */
	operation addTrace(trc : Trace) is do
		references.addAll(trc.sourceElem.asType(Collection<Reference>))
		references.addAll(trc.targetElem.asType(Collection<Reference>))
	end

	/**
	 * This operation adds a new trace to the trace model with references optimization
	 */
	operation addOptimizedTrace(trc: Trace) is do
		

		var srcRef : Reference init findReference(trc.sourceElem.asType(Reference))
		if(srcRef == void) then
			references.add(trc.sourceElem.asType(Reference))
			srcRef := trc.sourceElem.asType(Reference)
		else
			trc.sourceElem:=srcRef
		end
		
		var tgtRef : Reference init findReference(trc.targetElem.asType(Reference))
		if(tgtRef == void) then
			references.add(trc.targetElem.asType(Reference))
			tgtRef := trc.targetElem.asType(Reference)
		else
			trc.targetElem:=tgtRef
		end

	end

	/**
	 * This operation searches a reference among the set of references already
	 * contained by the trace model.
	 * Search is based on the isSameAs operation implemented by reference elements
	 */
	operation findReference(ref: Reference) : Reference is do
		result := void

		var found : Boolean init false
		from var ref_It : Iterator<Reference> init references.iterator
		until found or ref_It.isOff loop
			var crtRef : Reference init ref_It.next
			if(crtRef.equals(ref)) then
				found := true
				result := crtRef
			end
		end
	end

	/**
	 * This operation optimizes the set of contained references my merging simlar
	 * references into a single one.
	 * Concerned traces are updated consequently
	 */
	operation optimizeReferences() is do
		// Get the set of reference IDs
		var refIDs : set String[0..*] init Set<String>.new
		references.each{r | refIDs.add(r.toString)}

		// Get set of references sets according to their ID
		var refColls : set Set<Reference>[0..*] init Set<Set<Reference>>.new
		refIDs.each{rID |
			refColls.add(
				references.select{r | r.toString == rID}.asSet
			)
		}

		// Get list of new references
		var newRefs : set Reference[0..*] init Set<Reference>.new
		refColls.each{coll |
			var aRef : Reference init coll.one
			
			coll.each{oldRef|
				oldRef.source.each{trace | trace.targetElem := aRef}
				oldRef.target.each{trace | trace.sourceElem := aRef}
			}
			newRefs.add(aRef)
		}
		// Replace existing references by normalized references
		references.clear
		references.addAll(newRefs)
	end
}




/**
 * This class represents a reference to a concrete object contained by a file
 */
aspect abstract class FileReference inherits Reference {
	/**
	 * This operation defines equivalency between FileReference elements
	 */
	method equals(obj: Object) : Boolean is do
		result := false
		if(obj != void and FileReference.isInstance(obj)) then
			var fileRef : FileReference
			fileRef ?= obj
			result := self.fileURI == fileRef.fileURI
		end
	end
	
	method hashcode() : Integer is do
		result := fileURI.hashcode()
	end
	
}


/**
 * This class represents a reference to a textual file concrete object
 */
aspect class TextReference inherits FileReference {
	/**
	 * This operation defines equivalency between TextReference elements
	 */
	method equals(obj: Object) : Boolean from FileReference is do
		result := false
		if(obj != void and obj.getMetaClass == TextReference) then
			var txtRef : TextReference
			txtRef ?= obj
			result := super(obj) and
				self.charBeginOffset == txtRef.charBeginOffset and
				self.charEndOffset == txtRef.charEndOffset

		end
	end

	/** This method returns a string representation of the TextReference */
	method toString() : String is do
		result := fileURI + "#" + charBeginOffset.toString
			+ "#" + charEndOffset.toString
	end
}


/**
 * This class represents a reference to a XML concrete object
 */
aspect class XMLReference inherits FileReference {
	/**
	 * This operation defines equivalency between XMLReference elements
	 */
	method equals(obj: Object) : Boolean from FileReference is do
		result := false
		if(obj != void and obj.getMetaClass == XMLReference) then
			var xmlRef : XMLReference
			xmlRef ?= obj
			result := super(obj) and self.xPointer == xmlRef.xPointer
		end
	end

	/** This method returns a string representation of the XMLReference */
	method toString() : String is do
		result := fileURI + "#" + xPointer
	end
}


/**
 * This class represents a reference to a model element
 */
aspect class ModelReference inherits Reference {
	/**
	 * This operation defines equivalency between ModelReference elements
	 */
	method equals(obj: Object) : Boolean is do
		result := false
		if(obj != void and obj.getMetaClass == ModelReference) then
			var mdlRef : ModelReference
			mdlRef ?= obj
			result := self.refObject == mdlRef.refObject
		end
	end

	/** This method returns a string representation of the ModelReference */
	method toString() : String is do
		result := refObject.toString
	end
	
	method hashcode() : Integer is do 
		result := refObject.hashcode()
	end
}
