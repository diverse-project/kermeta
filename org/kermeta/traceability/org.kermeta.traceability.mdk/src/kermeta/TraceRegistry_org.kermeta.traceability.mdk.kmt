/* $Id:$ 
 * Creation : February 7, 2011
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            xdolques
 */
@mainClass "org::kermeta::traceability::TraceRegistry"
@mainOperation "size"


package org::kermeta::traceability;

require "Behavior_org.kermeta.traceability.model_aspect.kmt"

require kermeta
using kermeta::standard
using kermeta::utils
//using traceability
using kermeta::language::structure



class TraceRegistry
{	
	
	attribute registry : Hashtable<String,Reference>
	
	attribute traces : TracePackage
	
	//return the hashtable providing the link to the references with traces	
	operation getRegistry() : Hashtable<String,Reference> is do
		if registry==void then 
			self.registry:=Hashtable<String,Reference>.new
		end
		result := registry
	end
	
	operation getCorrespondingReference(initRef : Reference) : Reference is do
		if not getRegistry.containsKey(initRef.signature) then
			result:= cloneReference(initRef)
			result.target.clear
			getRegistry.put(result.signature,result)
			getTracePackage.references.add(result)
		else
			result:=getRegistry.getValue(initRef.signature)
		end
	end
	
	
	
	
	//add a trace from references
	operation addTraceFromReferences(source : Reference, target : Reference, context : Object) : Void is do
		var sourceRef : Reference init getCorrespondingReference(source)
		var targetRef : Reference init getCorrespondingReference(target)
		sourceRef.addTarget(context,targetRef)
	end
	
	//add trace while keeping optimized storage of references
	operation addTrace(trace : Trace) : Void is do
		
		var sourceRef : Reference init trace.sourceElem.asType(Reference)
		var targetRef : Reference init trace.targetElem.asType(Reference)
		var context : Object init trace.context
		
		var newTrace : Trace init Trace.clone(trace)
		
		getCorrespondingReference(sourceRef).target.add(newTrace)
		getCorrespondingReference(targetRef).source.add(newTrace)

	end
		 
	
	
	
	
	//return the tracepackage that stores all the traces
	operation getTracePackage() : TracePackage is do
		if traces==void then
			self.traces:=TracePackage.new
		end
		result:= traces
	end

	//utility operation for cloning a Reference depending on its type
	//TODO move as a clone() method to class Reference
	operation cloneReference(ref : Reference) : Reference is do
		if ref.isInstanceOf(ModelReference) then
			result := ModelReference.clone(ref.asType(ModelReference))
		else
			if ref.isInstanceOf(TextReference) then
				result:= TextReference.clone(ref.asType(TextReference))
			else
					if ref.isInstanceOf(XMLReference) then
					result:= XMLReference.clone(ref.asType(XMLReference))
				else
					if ref.isInstanceOf(QualifiedNameReference) then
						result:= QualifiedNameReference.clone(ref.asType(QualifiedNameReference))
					end
				end
			end
		end
	end 

	

	/**return the sources that created ref*/
	//TODO for efficiency should create a TraceRegistry, add all elements and return theTracePackage
	operation getRelatedSources(ref :Reference) : TracePackage is do
		result:= TracePackage.new
		var newRef : Reference init cloneReference(ref)
		result.references.add(newRef)
		getCorrespondingReference(ref).source.each{trc| 
			var sourceRef : Reference init result.findReference(trc.sourceElem.asType(Reference))
			
			if sourceRef == void then
				sourceRef := cloneReference(trc.sourceElem.asType(Reference))
				sourceRef.target.clear
				result.references.add(sourceRef)
			end
			sourceRef.addTarget(trc.context,newRef)
			}
	end

	/**return the targets created by ref*/
	operation getRelatedTargets(ref : Reference) : TracePackage is do
		result := TracePackage.new
		var newRef : Reference init cloneReference(getCorrespondingReference(ref))
		newRef.target.clear()
		result.references.add(newRef)
		
		getCorrespondingReference(ref).target.each{trc|
			var targetRef : Reference init result.findReference(trc.targetElem.asType(Reference))
			
			if targetRef == void then
				targetRef:=cloneReference(trc.targetElem.asType(Reference))
				result.references.add(targetRef)
			end
			newRef.addTarget(trc.context,targetRef)
		}
	end
	
	//add all the traces from aTracePackage 
	operation addAllTraces(aTracePackage : TracePackage) : Void is do
		
		aTracePackage.references.each{ref| ref.target.each{trc|addTrace(trc)}}
	
	end

	//return the number of traces
	operation size() : Integer is do 
		result:=0
		getTracePackage.references.each{ref| result := result + ref.target.size()} 
	end
}