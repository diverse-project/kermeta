/* $Id:$ 
 * Creation : February 7, 2011
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            xdolques
 */
@mainClass "org::kermeta::traceability::mdk::TraceRegistry"
@mainOperation "size"


package org::kermeta::traceability::mdk;

//require "MetaModel_org.kermeta.traceability.model.kmt"
require "Behavior_org.kermeta.traceability.model_aspect.kmt"

require kermeta
using kermeta::standard
using kermeta::utils

using kermeta::language::structure



class TraceRegistry
{	
	
	attribute registry : Hashtable<Reference,Reference>
	
	attribute traces : TracePackage
	
	//return the hashtable providing the link to the references with traces	
	operation getRegistry() : Hashtable<Reference,Reference> is do
		if registry==void then 
			self.registry:=Hashtable<Reference,Reference>.new
		end
		result := registry
	end
	
	operation getCorrespondingReference(initRef : Reference) : Reference is do
		if not getRegistry.containsKey(initRef) then
			result:= cloneReference(initRef)
			result.target.clear
			getRegistry.put(result,result)
			getTracePackage.references.add(result)
		else
			result:=getRegistry.getValue(initRef)
		end
	end
	
	
	
	
	//add a trace from references
	operation addTraceFromReferences(source : Reference, target : Reference, context : Object) : Void is do
		var sourceRef : Reference init getCorrespondingReference(source)
		var targetRef : Reference init getCorrespondingReference(target)
		sourceRef.addTarget(context,targetRef)
	end
	
	//add trace while keeping optimized storage of references
	operation addTrace(trace : Trace) : Void is do
		
		var sourceRef : Reference init trace.sourceElem.asType(Reference)
		var targetRef : Reference init trace.targetElem.asType(Reference)
		var context : Object init trace.context
		
		var newTrace : Trace init Trace.clone(trace)
		
		getCorrespondingReference(sourceRef).target.add(newTrace)
		getCorrespondingReference(targetRef).source.add(newTrace)

	end
		 
	
	
	
	//add a new trace from 2 objects and a context
	/*operation addObjectToObjectTrace(source : Object , target : Object , context : Object) : Void is do
		
		var sourceRef : ModelReference init getModelReference(source)
		var targetRef : ModelReference init getModelReference(target) 
		sourceRef.addTarget(context, targetRef)
	end*/
	/*
	//resolve all objects that have been created from source
	operation resolveAllTargets(source : Object) : Sequence<Object>  is do
		if not getObjectRegistry.containsKey(source) then
			result:=void
			else
			var sourceRef : ModelReference init objectRegistry.getValue(source)
			result:=sourceRef.resolveAll().collect{modelRef|modelRef.asType(ModelReference).refObject}.asType(Sequence<Object>)
		end
	end
	
	//resolve an object of type t that has been created from source
	operation resolveOneTarget(source : Object, t:Class) : Object is do
		if not getObjectRegistry.containsKey(source) then
			result:=void
		else
			var sourceRef : ModelReference init getObjectRegistry.getValue(source)
			if sourceRef==void then 
				stdio.writeln("sourceRef est void")
			end
			if sourceRef.resolveOne(t)==void then
				stdio.writeln("targetRef est void")
			end
			result:=sourceRef.resolveOne(t).asType(ModelReference).refObject
		end
	end
	
	//resolve the objects that have been created from source in aContext
	operation resolveTargetsIn(source : Object, aContext : Object) : Sequence<Object> is do
		if not getObjectRegistry.containsKey(source) then
			result:=void
		else
			var sourceRef : ModelReference init getObjectRegistry.getValue(source)
			result:=sourceRef.resolveIn(aContext).collect{modelRef|modelRef.asType(ModelReference).refObject}.asType(Sequence<Object>)
		end
	end
	
	
	// resolve all the creators of target
	operation resolveAllSources(target : Object) : Sequence<Object>  is do
		if not getObjectRegistry.containsKey(target) then
			result:=void
			else
			var targetRef : ModelReference init getObjectRegistry.getValue(target)
			result:=targetRef.invResolveAll().collect{modelRef|modelRef.asType(ModelReference).refObject}.asType(Sequence<Object>)
		end
	end
	
	// resolve one creator of target of type t
	operation resolveOneSource(target : Object, t:Class) : Object is do
		if not getObjectRegistry.containsKey(target) then
			result:=void
			else
			var targetRef : ModelReference init getObjectRegistry.getValue(target)
			result:=targetRef.invResolveOne(t).asType(ModelReference).refObject
		end
	end
	
	// resolve the creators of target in aContext
	operation resolveSourcesIn(target : Object,aContext : Object) : Sequence<Object> is do
		if not getObjectRegistry.containsKey(target) then
			result:=void
			else
			var targetRef : ModelReference init getObjectRegistry.getValue(target)
			result:=targetRef.invResolveIn(aContext).collect{modelRef|modelRef.asType(ModelReference).refObject}.asType(Sequence<Object>)
		end
	end
	*/
	//return the tracepackage that stores all the traces
	operation getTracePackage() : TracePackage is do
		if traces==void then
			self.traces:=TracePackage.new
		end
		result:= traces
	end

	operation cloneReference(ref : Reference) : Reference is do
		if ref.isInstanceOf(ModelReference) then
			result := ModelReference.clone(ref.asType(ModelReference))
		else
			if ref.isInstanceOf(TextReference) then
				result:= TextReference.clone(ref.asType(TextReference))
			else
					if ref.isInstanceOf(XMLReference) then
					result:= XMLReference.clone(ref.asType(XMLReference))
				else
					if ref.isInstanceOf(QualifiedNameReference) then
						result:= QualifiedNameReference.clone(ref.asType(QualifiedNameReference))
					end
				end
			end
		end
	end 

	

	//return the sources that created ref
	operation getRelatedSources(ref :Reference) : TracePackage is do
		result:= TracePackage.new
		var newRef : Reference init cloneReference(ref)
		result.references.add(newRef)
		getCorrespondingReference(ref).source.each{trc| 
			var sourceRef : Reference init result.findReference(trc.sourceElem.asType(Reference)) 
			if sourceRef == void then
				sourceRef := cloneReference(trc.sourceElem.asType(Reference))
				sourceRef.target.clear
				result.references.add(sourceRef)
			end
			sourceRef.addTarget(trc.context,newRef)
			}
	end

	//return the targets created by ref
	operation getRelatedTargets(ref : Reference) : TracePackage is do
		result := TracePackage.new
		var newRef : Reference init cloneReference(getCorrespondingReference(ref))
		newRef.target.clear()
		result.references.add(newRef)
		
		getCorrespondingReference(ref).target.each{trc|
			var targetRef : Reference init result.findReference(trc.targetElem.asType(Reference))
			if targetRef == void then
				targetRef:=cloneReference(trc.targetElem.asType(Reference))
				result.references.add(targetRef)
			end
			newRef.addTarget(trc.context,targetRef)
		}
	end
	
	//add all the traces from aTracePackage 
	operation addAllTraces(aTracePackage : TracePackage) : Void is do
		
		aTracePackage.references.each{ref| ref.target.each{trc|addTrace(trc)}}
	
	end

	//return the number of traces
	operation size() : Integer is do 
		result:=0
		getTracePackage.references.each{ref| result := result + ref.target.size()} 
	end
}