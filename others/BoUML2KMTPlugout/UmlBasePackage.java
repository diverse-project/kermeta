
//   Manage the packages
abstract class UmlBasePackage extends UmlItem {
  /** returns a new package named 'name' created under 'parent'
   * 
   *  In case it cannot be created (the name is already used or
   *  invalid, 'parent' cannot contain it etc ...) return 0 in C++
   *  and produce a RuntimeException in Java
   */
  public static UmlPackage create(UmlPackage parent, String name) throws RuntimeException
  {
    return (UmlPackage) parent.create_(anItemKind.aPackage, name);
  }

  //  returns the kind of the item
  public anItemKind kind() {
    return anItemKind.aPackage;
  }

  //  returns the optional associated diagram
  public UmlDiagram associatedDiagram() {
    read_if_needed_();
    
    return _assoc_diagram;
  }

  /** sets the associated diagram, arg may be null to unset it
   * 
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_AssociatedDiagram(UmlDiagram d) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setAssocDiagramCmd,
  		  d.identifier_());
    UmlCom.check();
    
    _assoc_diagram = d;
  
  }

  /** returns the path where the C++ source files are generated by the
   *  c++ generator.
   */
  public String cppSrcDir() {
    read_if_needed_();
    
    return _cpp_src_dir;
  }

  /** to set the path where the C++ source files are generated by the
   *  C++ generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_CppSrcDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setCppSrcDirCmd, s);
    UmlCom.check();
  
    _cpp_src_dir = s;
  }

  /** returns the path where the C++ header files are generated by the
   *  C++ generator.
   */
  public String cppHDir() {
    read_if_needed_();
    
    return _cpp_h_dir;
  }

  /** to set the path where the C++ header files are generated by the
   *  C++ generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_CppHDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setCppHDirCmd, s);
    UmlCom.check();
  
    _cpp_h_dir = s;
  }

  // returns the namespace name associed to the package
  public String cppNamespace() {
    read_if_needed_();
    
    return _cpp_namespace;
  }

  /**to set the namespace name associed to the package.
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_CppNamespace(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setCppNamespaceCmd, s);
    UmlCom.check();
  
    _cpp_namespace = s;
  }

  /** returns a sub package of the current one having the c++ namespace 'n'
   *  (including the current one), else 0/null
   */
  public UmlPackage findNamespace(String n) {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._findNamespaceCmd,
  		  identifier_(), n);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  /** returns the path where the JAVA files are generated by the
   *  JAVA generator.
   */
  public String javaDir() {
    read_if_needed_();
    
    return _java_dir;
  }

  /** to set the path where the JAVA files are generated by the
   *  JAVA generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_JavaDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setJavaDirCmd, s);
    UmlCom.check();
  
    _java_dir = s;
  }

  // returns the java package name associed to the package
  public String javaPackage() {
    read_if_needed_();
    
    return _java_package;
  }

  /** to set the java package name associed to the package.
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_JavaPackage(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setJavaPackageCmd, s);
    UmlCom.check();
  
    _java_package = s;
  }

  /** returns a sub package of the current one having the Java package 'n'
   *  (including the current one), else 0/null
   */
  public UmlPackage findPackage(String n) {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._findPackageCmd,
  		  identifier_(), n);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  /** returns the path where the IDL files are generated by the
   *  IDL generator.
   */
  public String idlDir() {
    read_if_needed_();
    
    return _idl_dir;
  }

  /** to set the path where the IDL files are generated by the
   *  IDL generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_IdlDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setIdlDirCmd, s);
    UmlCom.check();
  
    _idl_dir = s;
  }

  // returns the module name associed to the package
  public String idlModule() {
    read_if_needed_();
    
    return _idl_module;
  }

  /** to set the module name associed to the package.
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_IdlModule(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setIdlModuleCmd, s);
    UmlCom.check();
  
    _idl_module = s;
  }

  /** returns a sub package of the current one having the IDL module 'n'
   *  (including the current one), else 0/null
   */
  public UmlPackage findModule(String n) {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._findModuleCmd,
  		  identifier_(), n);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  //   Returns the project
  public static UmlPackage getProject()
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._getProjectCmd);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  // return TRUE in case something is modified (i.e. the project must be saved)
  
  public static boolean isProjectModified()
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._isProjectModifiedCmd);
    
    return UmlCom.read_bool();
  }

  // save the project if needed
  public static void saveProject()
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._saveProjectCmd);
  }

  /**Does nothing in case an edition is on going under BOUML. Else :
   * close the current project (in case it is not saved the last modifications are lost),
   * load the specified one, and all the communications with the plug-outs including the
   * current one are closed.
   */
  public static void loadProject(String p)
  {
    UmlCom.send_cmd(CmdFamily.miscGlobalCmd, MiscGlobalCmd._loadCmd, p);
  }

  /** to unload the object to free memory, it will be reloaded automatically
   *  if needed. Recursively done for the sub items if 'rec' is TRUE. 
   * 
   *  if 'del' is true the sub items are deleted in C++, and removed from the
   *  internal dictionnary in C++ and Java (to allow it to be garbaged),
   *  you will have to call Children() to re-access to them
   */
  public void unload(boolean rec, boolean del) {
    _assoc_diagram = null;
    _cpp_src_dir = null;
    _cpp_h_dir = null;
    _cpp_namespace = null;
    _java_dir = null;
    _java_package = null;
    _idl_dir = null;
    _idl_module = null;
    super.unload(rec, del);
  }

  private UmlDiagram _assoc_diagram;
  private String _cpp_src_dir;
  private String _cpp_h_dir;
  private String _cpp_namespace;

  private String _java_dir;
  private String _java_package;

  private String _idl_dir;
  private String _idl_module;

  // internal, do NOT use it
  
  protected void read_uml_() {
    _assoc_diagram = (UmlDiagram) UmlBaseItem.read_();
    super.read_uml_();
  }

  // internal, do NOT use it
  
  protected void read_cpp_() {
    _cpp_src_dir = UmlCom.read_string();
    _cpp_h_dir = UmlCom.read_string();
    _cpp_namespace = UmlCom.read_string();
  }

  // internal, do NOT use it
  
  protected void read_java_() {
    _java_dir = UmlCom.read_string();
    _java_package = UmlCom.read_string();
  }

  // internal, do NOT use it
  
  protected void read_idl_() {
    _idl_dir = UmlCom.read_string();
    _idl_module = UmlCom.read_string();
  }

  //  the constructor, do not call it yourself !!!!!!!!!!
  protected UmlBasePackage(long id, String n) { super(id, n); }

};
