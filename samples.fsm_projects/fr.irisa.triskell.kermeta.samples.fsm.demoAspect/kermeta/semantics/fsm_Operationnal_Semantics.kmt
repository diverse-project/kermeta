/* $Id: fsm_Operationnal_Semantics.kmt,v 1.3 2008-08-25 13:04:01 vmahe Exp $
 * Project    : fr.irisa.triskell.samples.fsm
 * File       : fsmmodel.kmt
 * License    : EPL
 * Copyright  : IRISA / INRIA / Universite de Rennes 1
 * -------------------------------------------------------------------
 * Creation date : 03 October. 2005
 * Modified By : 
 *        Waqas Ahmed Saeed <wahmedsa@irisa.fr>
 *        Cyril Faucher <cfaucher@irisa.fr>
 * Description : 
 *       Finite State Machine Sample with Behaviour implemented in Kermeta
 */


package fsm;

require kermeta
require "http://www.kermeta.org/fsm"
using fsm
using kermeta::standard
using kermeta::persistence
using kermeta::exceptions

 
 
aspect class FSM 
{


attribute ownedState : oset State[0..*]#owningFSM
	//reference initialState : Transition[1..*] 
	reference finalState : State[0..*]
	reference currentState : State
	
	 
	  
	// Operational semantic
	operation run() :  Void raises FSMException is do  
		// reset if there is no current state
		if self.currentState == void then self.currentState := self.initialState end
		self
		from var str : String init "init"
		until str == "quit"
		loop
			stdio.writeln("Current state : " + self.currentState.name)
			str := stdio.read("give me a letter : ")
			if str == "quit" then
				stdio.writeln("")
				stdio.writeln("quitting ...")
			else 
				if str == "print" then
					stdio.writeln("")
				else	
					stdio.writeln(str)			
					stdio.writeln("stepping...")
					do
						var textRes : String
						textRes := self.currentState.step(str)
						if( textRes == void or textRes == "" )
						then
							textRes := "NC"
						end
						
						stdio.writeln("string produced : " + textRes)
					
						rescue (err : ConstraintViolatedPre)
		            		stdio.writeln(err.toString)
		            		stdio.writeln(err.message)
		            		str := "quit"
		            	rescue (err : ConstraintViolatedPost)
	            			stdio.writeln(err.toString)
	            			stdio.writeln(err.message)
	            			str := "quit"
	            		
						rescue(err : NonDeterminism)
							stdio.writeln(err.toString)
							str := "quit"	
						rescue(err : NoTransition)
							stdio.writeln(err.toString)
							str := "quit"
	            	end
				end
			end
		end
	end
	
	/** Initialize a new automaton from an existing one 
	 *  param :
	 *    p_state : the initial state
	 *    isInitComb
	 */
	operation initialize(p_state : State, isInitComb : Boolean) is do
		var initState : State init p_state.copy
		ownedState.add(initState)
		initialState := initState 
		if (isInitComb == true) then initialState.combination := Set<State>.new end 
	end
	
}


aspect class State {
	
		reference combination : Set<State>
	

	// Go to the next state
	operation step(c : String) : String raises FSMException
	is do
		// Get the valid transitions
		var validTransitions : Collection<Transition> 
		validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
		// Check if there is one and only one valid transition
		if validTransitions.empty then raise NoTransition.new end
		if validTransitions.size > 1 then raise NonDeterminism.new end
		
		// Fire the transition
		result := validTransitions.one.fire
	end
	
	// Create a new state from self state
	operation copy() : State is do
		result := State.new
		result.name := String.clone(name)
		result.combination := Set<State>.new
	end
}



aspect class Transition 
{	
	
	// Fire the transition
	operation fire() : String is do
		// update FSM current state
		source.owningFSM.currentState := target
		result := output
	end
}



/*abstract class FSMException {}
class NonDeterminism inherits FSMException {}
class NoTransition inherits FSMException {}
class NoInitialStateException inherits FSMException{}*/

