<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book lang="en-US">
  <?ooogenerator OpenOffice.org/2.0$Linux OpenOffice.org_project/680m1$Build-8990?>
  <?oooversion?>
  <bookinfo>
    <pubdate>Build date: @BUILD.DATE@</pubdate>
    <author>
      <firstname>François Tanguy, Didier Vojtisek, Zoé Drey, Marie Gouyette</firstname>
      <firstname/>
    </author>
    <title>Kermeta tutorial</title>
    <date>2006-09-25T10:35:34</date>
    <keywordset>
      <keyword>Kermeta</keyword>
      <keyword>metamodeling</keyword>
      <keyword>language</keyword>
    </keywordset>
    <subtitle> FSM example</subtitle>
    <bibliomisc>Licence EPL</bibliomisc>
    <date>19/07/2006</date>
    <abstract>
      <para>This tutorial is part of a serie of tutorials that explain step by step the process
        explained in the  <ulink type="" url=""> Manual Process to build a DSL </ulink>. In this case, it rely on
        the classical Finite State Machine example. </para>
    </abstract>
    <publisher>
      <publishername>INRIA</publishername>
      <address>
        <state>France</state>
        <otheraddr>
          <ulink url="http://www.inria.fr">http://www.inria.fr</ulink>
        </otheraddr>
      </address>
    </publisher>
    <confgroup>
      <conftitle>title</conftitle>
      <confnum>Reference</confnum>
      <confsponsor>sponsor</confsponsor>
    </confgroup>
  </bookinfo>
  <preface>
    <?print-orientation portrait?>
    <title>Preface</title>
    <para>Kermeta is a Domain Specific Language dedicated to metamodel engineering. It fills the gap
      let by MOF which defines only the structure of metamodels, by adding a way to specify static
      semantic (similar to OCL) and dynamic semantic (using operational semantic in the operation of
      the metamodel). Kermeta uses the object-oriented paradigm like Java or Eiffel.This document
      presents various aspects of the language, including the textual syntax, the metamodel (which
      can be viewed as the abstract syntax) and some more advanced features typically included in
      its framework. </para>
    <important>
      <para> Kermeta is an evolving software and despite that we put a lot of attention to this
        document, it may contain errors (more likely in the code samples). If you find any error or
        have some information that improves this document, please send it to us using the bug
        tracker in the forge: <ulink type="" url="http://gforge.inria.fr/tracker/?group_id=32">
          <emphasis role="strong">
            <emphasis role="strong">
              <emphasis role="strong">http://gforge.inria.fr/tracker/?group_id=32</emphasis>
            </emphasis>
          </emphasis>
        </ulink>
        <emphasis role="strong">
          <emphasis role="strong">
            <emphasis role="strong"/>
          </emphasis>
        </emphasis> or using the developer mailing list (kermeta-developers@lists.gforge.inria.fr)
          <emphasis role="strong">
          <emphasis role="strong">
            <emphasis role="strong"/>
          </emphasis>
        </emphasis> Last check: v1.3.2 </para>
    </important>
    <tip>
      <para> The most update version of this document is available on line from <ulink type=""
          url="http://www.kermeta.org/">http://www.kermeta.org</ulink> . </para>
    </tip>
  </preface>
  <chapter>
    <title>Introduction</title>
    <para>This tutorial gives an overview of many concepts used through KerMeta project creation.
      You can retrieve all the steps defined in the <ulink type="" url=""> Manual Process to build a DSL </ulink> on which you can iterate in order to progress in your development. Following this
      tutorial should give you the knowledge : to create a meta model, check its invariants, run
      configurations, add pre and post conditions and add behaviour on it. To cover all this
      features, we decided to start from an existing example. Because it is a complete KerMeta
      project, you should use it as a reference guide. This example is about the finite state
      machine which acronym is FSM. Firstly, a section explains how to load files of the example in
      your Eclipse workspace. The next section is dedicated to the finite state machine we want to
      model. You will have access to every files. Then we present the features presented above.
      Moreover, we present here examples of graphical editors but this step comes only when the
      metamodel is stabilized. In this tutorial we will have access to the base project in order to
      follow it (cf section <link linkend="InstallFSMTutorial">Install FSM project</link>) . You can
      have also have access of the solution of this tutorial ( cf section <link
        linkend="InstallTutorialSolution">Install the tutorial 's solution</link> ) </para>
  </chapter>
  <chapter>
    <title>Installation</title>
    <section>
      <title> Prerequisites</title>
      <caution>
        <para>KerMeta must be installed (FSM tutorial is only available in this case). If not,
          please read the "<ulink type="" url="../KerMeta-How-to-install-KerMeta/index.html">How to
            install KerMeta</ulink>" tutorial.</para>
      </caution>
      <section>
        <title>Required knowledge<phrase id="knowledge"/></title>
        <orderedlist continuation="restarts">
          <listitem>
            <para>People who read this document need to have some knowledge about either EMOF or
              ECore metamodels</para>
          </listitem>
          <listitem>
            <para>Since ecore is used, people should have a minimal knowledge, as end-users, of
              Eclipse development environment.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section id="InstallFSMProject">
      <title> Install FSM project</title>
      <section id="InstallFSMTutorial">
        <title> Install FSM tutorial </title>
        <para>We start from the main Eclipse window.</para>
        <figure>
          <title> Eclipse window</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/main_window.png" width="20.00cm"
                depth="18.02cm"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Select : "File" &gt; "New"&gt;&gt; "Example.. A window appears. You are asked to
          choose a wizard for project creation. At the bottom of the list, you will find "Kermeta
          samples" item. Browse it and select "FSM tutorial Demo". The "Finish" button has been
          enabled. Click on it.</para>
        <figure>
          <title> Wizard for selection</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/wizard_selection.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Thanks to the wizard creation project, a project named<emphasis role="bold">
            "fr.irisa.triskell.kermeta.samples.fsm.demoAspect" </emphasis>appeared on the left side
          of Eclipse.</para>
        <figure>
          <title> View of the example project</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/main_window_fsm_loaded.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para> </para>
      </section>
      <section id="InstallTutorialSolution">
        <title>Install the tutorial 's solution </title>
        <para>If you directly want to see the results, the solutions are available into File -> New
          -> Example -> Kermeta Samples -> FSM Solutions.</para>
        <para> Now, you have the reference project and you can follow the tutorial.The next chapter
          presents the metamodel used in this tutorial.</para>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Define the FSM metamodel</title>
    <section>
      <title> Fsm metamodel presentation</title>
      <para>We want to represent IO/state machines. Inputs and outputs can be attached on each
        transition. To illustrate finite state machine, here is a simple example. This state machine
        recognizes the "hello!" motif and produces the "world!" motif. Here, we present this
        finite-state machine in a specific graphical syntax where states are represented as squares
        and transitions by arrow between squares. Input and outputs are present above transitions.
        Here, "h/w" says that we consume an "h" to produce a "w".</para>
      <figure>
        <title> Example of IO/State machines</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/helloWorldFSM.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>This simple state machine can be modeled and executed easily in Kermeta. See the
        following meta-model presented in a class diagram syntax. You can retrieve this metamodel
        named fsm.ecore into fr.irisa.triskell.kermeta.samples.fsm.demoAspect/metamodels/fsm.ecore </para>
      <figure>
        <title> FSM metamodel</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/FSMBeginningMM.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section id="CreateFsmMetamodel">
      <title>Create the fsm meta-model </title>
      <para> In this tutorial we want to create the fsm metamodel with EMF. To start with, create a
        new EMF project (File-> New-> Other -> Eclipse Modeling Framework -> Empty EMF Project) and
        name it <emphasis role="strong">org.kermeta.fsm.emf </emphasis> . Then create a new folder
        model on it. If you want to create an EMF metamodel for fsm from scratch you can follow the
        tutorial <ulink type="" url="../KerMeta-Create-Meta-model-With-EMF/index.html">"How to
          create an EMF meta model?""</ulink> and use the EMF Sample reflexive editor to create a
        metamodel like in the following figure into the folder model. Name it<emphasis role="italic"
          > fsm.ecore</emphasis>. Otherwise, you can simply copy the file fsm.ecore from <emphasis
          role="bold"
          >fr.irisa.triskell.kermeta.samples.fsm.demoAspect/metamodels/fsm.ecore</emphasis>
          to<emphasis role="bold"> org.kermeta.fsm.emf/model</emphasis> folder.</para>
      <para/>
      <para>
        <tip>
          <para> An FSM EMF editor is ever deployed into the Kermeta Eclipse. It is available in
            File-> New -> Other -> Kermeta -> FSM Samples -> Fsm Model. </para>
        </tip>
      </para>
      <para>At this stage of the tutorial, you should have the following metamodel: </para>
      <figure>
        <title> A simple fsm metamodel</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/resulting_emf_metamodel.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para> Then you can use this metamodel to create instances of models conform to it.</para>
    </section>
  </chapter>
  <chapter>
    <title>Editor</title>
    <para>In this chapter we present how to create instances of the Fsm metamodel.  You can use two
      ways to do  that, creating dynamic instances directly or using an EMF tree editor.</para>
    <section>
      <title>Dynamic instances<phrase id="create_model"/></title>
      <para> Like shown in the Process tutorial create a dynamic instance is an easy way to create
        an instance of a metamodel during the first development phases. To do so : <orderedlist>
          <listitem>
            <para>Create a new folder dynamic_instance in org.eclipse.fsm.emf .Open the fsm.ecore
              file with the Sample Ecore Model Editor (Right click on the file -> Open with  ->
              Sample Ecore Model Editor) </para>
          </listitem>
          <listitem>
            <para>Right click on the FSM metaclass -> Create Dynamic Instance and select the folder
              dynamic_instance.</para>
          </listitem>
        </orderedlist></para>
      <figure id="refIllustration8">
        <title>Create dynamic instance from an Ecore file</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/create_dynamic_instance.png"
              width="9.528cm" depth="5.136cm"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Name your instance fsm.xmi and open it with the sample reflexive Ecore Model Editor. You
        can add two State st1 and st2 on the FSM class and then a transition a that produce b
        between st1 and st2 like in the following image : </para>
      <figure id="refIllustration8_1">
        <title> Example of dynamic instance</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/example_dynamic_instance.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The Logo tutorial presents how to create a dynamic instance with an ecorediag.</para>
    </section>
    <section id="treeViewEditor">
      <title>Tree view editor</title>
      <para>Since it allows to customize the generated editor to match meta-model specificities.
        (see the end of this article: <ulink
          url="http://www.eclipse.org/articles/Article-Using%20EMF/using-emf.html" type=""> Eclipse
          Corner Article : Using EMF</ulink>),  this solution should be favoured for meta-models
        that are relatively stable and for final development phase.</para>
      <section>
        <title>Generate the editor </title>
        <para>This is the most ergonomic – but longest – way to create an instance of a meta-model.
          This method is here presented in its main lines:<orderedlist>
            <listitem>
              <para>Create a new project and a new ecore metamodel ( this step was ever made in the
                section <link linkend="CreateFsmMetamodel">Create the fsm meta-model </link>
                )</para>
            </listitem>
            <listitem>
              <para>Once the meta-model is created, it is possible to create a model for model
                generation, called <emphasis>genmodel</emphasis>:<orderedlist>
                  <listitem>
                    <para>Right click on the file fsm.ecore <emphasis role="strong"><emphasis
                          role="strong">File </emphasis></emphasis><emphasis role="strong">&gt; New
                        &gt; </emphasis><emphasis role="strong">O</emphasis><emphasis role="strong"
                        >ther &gt; Eclipse Modeling Framework </emphasis>folder<emphasis
                        role="strong"> &gt; EMF Generator Model</emphasis>;</para>
                  </listitem>
                  <listitem>
                    <para>Keep the proposed name (<emphasis>fsm.genmodel</emphasis>) and  click on
                      load.  Then,  select Ecore model in the following wizard;</para>
                  </listitem>
                  <listitem>
                    <para>Select <emphasis role="strong">Browse workspace</emphasis> button, and
                      find the meta-model file (<emphasis>fsm.ecore</emphasis> into <emphasis
                        role="italic">or.kermeta.fsm.emf/model)</emphasis>;</para>
                  </listitem>
                  <listitem>
                    <para>Select the unique package <emphasis>fsm</emphasis> and click on
                      Finish</para>
                  </listitem>
                  <listitem>
                    <para>In order to avoid weird behaviour (particularly if the current project was
                      not set as a “Java project”) the model directory of the genmodel needs to be
                      changed in the <emphasis role="strong">Properties</emphasis> tab of the
                      genmodel. For this purpose, click on the root node of the
                        <emphasis>fsm.genmodel</emphasis> and check that the property called
                        <emphasis role="strong">Model Directory</emphasis> (in the Model folder) is
                        <emphasis>/org.kermeta.fsm.emf.model/src</emphasis>, so that the EMF source
                      code is generated in a new empty project that will exclusively contain this
                      source code.</para>
                    <figure>
                      <title> Model Directory Property</title>
                      <mediaobject>
                        <imageobject>
                          <imagedata
                            fileref="KerMeta-The-FSM-example_figures/check_model_directory.png"/>
                        </imageobject>
                      </mediaobject>
                    </figure>
                  </listitem>
                  <listitem>
                    <para>Right-click on the root node of the <emphasis>fsm.genmodel</emphasis>
                      (second sub node, it corresponds to the fsm package), and choose the <emphasis
                        role="strong">Generate all</emphasis> item.</para>
                  </listitem>
                </orderedlist></para>
            </listitem>
          </orderedlist></para>
        <para>You should obtain the following plugins (if we not consider the folder
          dynamic_instance which is not linked with the EMF editor creation) : </para>
        <para>
          <figure>
            <title>Plugins Generated with EMF</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="KerMeta-The-FSM-example_figures/emf_editor_generation.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </para>
        <para> You can customize this EMF editor following the example given on  the section <link
            linkend="CustomizeEMF_Editor"> Customize the generated EMF editor</link> . </para>
      </section>
      <section>
        <title>Use the editor</title>
        <para>To be able to use the generated reflexive editor, a new runtime workbench has to be
          launched through the tool bar menu:</para>
        <orderedlist continuation="restarts" numeration="arabic">
          <listitem>
            <para>In Eclipse Galileo (3.5), right click on org.kermeta.fsm.emf.editor and select Run
              As -> Eclipse Application</para>
          </listitem>
          <listitem>
            <para>Once the new eclipse application is launched, create a new General project (e.g.
              called <emphasis>MyFirstEMFInstances</emphasis>), and select <emphasis role="strong"
                  ><emphasis role="strong">File </emphasis></emphasis><emphasis role="strong">&gt;
                New &gt; </emphasis>Other &gt; Example EMF Model Creation Wizards folder<emphasis
                role="strong"> &gt; Fsm Model</emphasis>;</para>
          </listitem>
          <listitem>
            <para>To add elements to your model just right click on the FSM container and add new
              Child or new Sibling like in metamodels 's creation steps (cf fsm.xmi example in the
              section <link linkend="create_model"> Dynamic Instances </link> ;</para>
          </listitem>
        </orderedlist>
        <para>
          <note>
            <title> Parallelism between edit a model or a metamodel</title>
            <para> Creation of an EMF model follows the same principles that the creation of an
              Ecore model. Note that the model object, which was <emphasis role="strong"
                >EPackage</emphasis> in the meta-model creation, becomes <emphasis role="strong"
                >Fsm</emphasis> in the EMF model creation. </para>
          </note>
        </para>
        <para> You can use another editors to create instances models such as graphical or textual
          editors. The following sections presents rapidly this kind of editors.</para>
      </section>
    </section>
    <section>
      <title> Textual editors</title>
      <para> You can also use textuals editors like <ulink type=""
          url="http://www.eclipse.org/Xtext/"> XText</ulink> , <ulink type=""
          url="http://www.emftext.org/index.php/EMFText"> EMFText</ulink>, <ulink type=""
          url="http://www.kermeta.org/sintaks/"> Sintaks </ulink> (which is part of the Kermeta
        project) . This textuals editors are not detailed here, please refer to the logo tutorial.
      </para>
    </section>
    <section>
      <title> Graphical editors</title>
      <para> EMF metamodels can be used with tools like <ulink
          url="http://www.eclipse.org/modeling/gmf/"> GMF (Graphical Modelling Framework)</ulink> or
          <ulink type="" url="http://www.topcased.org/"> Topcased</ulink> (the FSM Diagram from
        Kermeta -> Samples FSM is created with Topcased) to create graphical editors for model
        instances. The tutorial <ulink type=""
          url="../KerMeta-Create-FSM-Graphical-Editor-With-GMF/index.html"> How to create a FSM
          graphical editor with GMF? </ulink> explains the creation of an GMF editor with a very
        simple FSM metamodel. You can retrieve the result of this tutorial and the gmf models into
        fr.irisa.triskell..kermeta.samples.fsm.gmf. </para>
      <para> You know how to create a model conform to the Fsm metamodel. The next chapter explains
        how to manipulate models with Kermeta. </para>
    </section>
  </chapter>
  <chapter>
    <title> Model manipulation in Kermeta </title>
    <para>Firstly, we present to you how to create a KerMeta file. Then loading a first Kermeta
      program can be achieved by just copying the code provided in the following sections, following
      carefully the suggested instructions. Readers who want to directly load their own models
      should directly go to the section <link linkend="completeKermetaProgramTemplate"> A template
        for a complete Kermeta program </link> and customize the given template. </para>
    <para> You can start with opening the Kermeta perspective with Window->Open Perspective -> Other
      -> Kermeta and create a new Kermeta project (File -> New -> New Kermeta Project into the
      Kermeta perspective). Name it org.kermeta.fsm.serialisation, copy the file fsm.ecore into
      metamodel folder. </para>
    <section>
      <title> Preparing a Kermeta program </title>
      <section>
        <title> Create a new KerMeta file</title>
        <para>We want to add a new kermeta file into the folder kermeta into
          org.kermeta.fsm.serialisation/src.</para>
        <para>
          <tip>
            <para> This sample is available in the FSM Solutions in the project
              fr.irisa.triskell.kermeta.samples.fsm.serialisation </para>
          </tip>
        </para>
        <para>To do this, select in the main menu of Eclipse</para>
        <para>"File" &gt; "New" ->"New Kermeta File"</para>
        <para>This action opens the following window.</para>
        <para/>
        <figure>
          <title> Wizard to create a new Kermeta file</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/kmt-file.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Give a name (Serialisation.kmt for instance) to the new file, select a location (The
          default one is good for us) and leave Main class and Main operation blank for the moment.
          It will be used later to run models. Click on "Finish".</para>
        <para>Now your main window should look like the one below. The file is written in KerMeta
          language. So you can edit this file to add some classes, attributes and so on using the
          KerMeta language (read <ulink type="" url="http://www.kermeta.org/documents/manual/">
            Kermeta Manual</ulink> for more details on KerMeta language).</para>
        <para/>
        <figure>
          <title> New Kermeta file</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/kmt-blank-file.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <tip>
          <title> Create a Kermeta file into another perspective</title>
          <para> If you are not into the Kermeta perspective you can create a new Kermeta file with
            File -> New -> Other -> Kermeta -> New Kermeta File</para>
        </tip>
        <tip>
          <title> Add the Kermeta nature to a project</title>
          <para> If your project is not a Kemeta project you can add the Kermeta nature on it. Right
            click on the project Kermeta-> Add Kermeta nature. It permit to check the .kmt files at
            the beginning of Eclipse. </para>
        </tip>
        <para>Now, we add Kermeta code to load and save models compliant with the fsm.ecore
          metamodel. For this you need to register the EMF metamodel into the Package
          Registry.</para>
      </section>
    </section>
    <section id="PackageRegistry_Presentation">
      <title> Package registry</title>
      <para> If you want to save a model conform to a particular metamodel whatever you want into
        the workspace it is usefull to register its metamodel into the EMF Package Registry. Indeed,
        if the meta-model is not registered into the EMF Package Registry, a relative path is used
        to link the instance file with its meta-model. So we need to register this meta model into
        the EMF Package Registry. There is two ways to do that, deploying an EMF plugin like in the
        section <link linkend="treeViewEditor"> Tree view editor </link> which add permanently the
        meta model to the Eclipse's EMF Package Registry or register dynamically the meta model on
        it thanks to the menu EPackages registration -> Register EPackages into repository.</para>
      <warning>
        <title> Dynamical EMF Registration is not permanent</title>
        <para> You need to register again the meta models for each new instance of Eclipse. </para>
      </warning>
      <para>The following menu EPackages registration have three entries :</para>
      <orderedlist continuation="restarts">
        <listitem>
          <para>
            <emphasis role="strong"> Re-Register EPackages into registry : </emphasis> unregister
            and register again the EPackage in order to take into account the meta model's changes
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong"> Unregister EPackages into registry : </emphasis> remove
            EPackage from EMF EPackage registry </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong"> Register EPackages into registry : </emphasis> add EPackage
            from EMF EPackage registry </para>
        </listitem>
      </orderedlist>
      <figure id="refIllustration81">
        <title>Register the meta model into the EMF EPackage Registry</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/registration1.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Then click on the followings icons : </para>
      <figure id="refIllustration82">
        <title> Kermeta icon</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/kermeta_corbeille.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <figure id="refIllustration83">
        <title>Reload icon</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/kermeta_reload.png"/>
          </imageobject>
        </mediaobject>
      </figure>
     <para>Now, we  use Kermeta to load an save models i.e to serialize the models. So, register the
        fsm.ecore model  as we presented above to use it in the example.</para>
    </section>
    <section>
      <title> Serialisation</title>
      <para>By serialisation , we mean here : to  save and load models thanks to the presistence
        library. For this three following sections copy and paste on your new file Serialisation.kmt
        or look at the file serialisation.kmt into
        fr.irisa.triskell.kermeta.sample.fsm.serialisation/kermeta. Create a new dynamic instance
        for FSM named <emphasis role="bold"> Fsm_dyn_sample1.xmi</emphasis> in the folder <emphasis
          role="bold">model </emphasis> like in the section <link linkend="create_model"> Dynamic
          instances </link> . Add on it two states st1 et st2, one transition t1 with st1 as source
        and st2 as target and t2 with t2 as source and t1 as target. Add also inputs and outputs to
        these transitions (input : a , output : b for st1 and input : c, output : d for st2). This
        xmi file should look like this : </para>
      <figure id="refIllustration84">
        <title>Fsm_dyn_sample1.xmi </title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/model_Fsm_dyn_sample1.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <section>
        <title>Load an EMF model with Kermeta </title>
        <para>The following code sample load a previously created FSM model. Copy and paste it on
            <emphasis role="bold">
            org.kermeta.fsm.serialisation/src/kermeta/serialisation.kmt</emphasis> or see
            the<emphasis role="bold"> serialisation.kmt file </emphasis>on <emphasis role="bold"
            >fr.irisa.triskell.kermeta.samples.fsm.serialisation/src/kermeta/serialisation.kmt</emphasis>.<example>
            <title> Load an EMF model with Kermeta </title>
            <programlisting language="kermeta">
         @mainClass "fsm_package::Main"
         @mainOperation "main"

        package fsm_package;

        require kermeta
         require  "http://www.kermeta.org/fsm"
         <co id="load.emfmodel.metamodelfsm.co" linkends="load.emfmodel.metamodelfsm.callout"/>
         
        using kermeta::persistence 
           <co id="load.emfmodel.using.persistence.co" linkends="load.emfmodel.using.persistence.callout"/>
           
         using kermeta::standard
         class Main
         {
         operation main() : Void is do
        // Input fsm
        var fsm1 : fsm::FSM
        // Create the repository, then the resource
         var repository : EMFRepository init EMFRepository.new
         var resource : EMFResource 
         resource ?= repository.createResource("platform:/resource/org.kermeta.fsm.serialisation/model/Fsm_dyn_sample1.xmi", "platform:/resource/org.kermeta.fsm.serialisation/metamodel/fsm.ecore")
         <co id="load.emfmodel.createResource.co" linkends="load.emfmodel.createResource.callout"/>
         resource.load

// Load the fsm (we get the instance)
 fsm1 ?= resource.one
 <co id="load.emfmodel.resource.co" linkends="load.emfmodel.resource.callout"/>
// Check that the fsm was correctly loaded
fsm1.ownedState.each { s | stdio.writeln("-> "+s.name) 
 		  s.outgoingTransition.each { ti | stdio.writeln( "outgoing : " + " source " + ti.source.name  + " target " + ti.target.name + " input : " + ti.input +  " output :  " + ti.output)}
 		 s.incomingTransition.each { to | stdio.writeln( "incoming :  " + " source " + to.source.name  + " target " + to.target.name +" input : " + to.input +  " output : " + to.output )}
 		}
end
 }      </programlisting>
            <para>
              <calloutlist>
                <callout arearefs="load.emfmodel.metamodelfsm.co"
                  id="load.emfmodel.metamodelfsm.callout">
                  <para> To serialize the class definition, the nsURI of the meta model need to be
                    known. </para>
                </callout>
                <callout arearefs="load.emfmodel.createResource.co"
                  id="load.emfmodel.createResource.callout">
                  <para> The persistence permits to load and save EMF models. The key word
                      <emphasis>using</emphasis> is used to simplify writing code like import in
                    Java. </para>
                </callout>
                <callout arearefs="load.emfmodel.using.persistence.co"
                  id="load.emfmodel.using.persistence.callout">
                  <para> The second parameter of this method permit to know what exactly will be
                    saved. </para>
                </callout>
                <callout arearefs="load.emfmodel.resource.co" id="load.emfmodel.resource.callout">
                  <para> resource is collection of instances which are in the root file. The first
                    instance of this resource is retrieve by the method one. <tip>
                      <title>Browse through the resource</title>
                      <para> You can use <emphasis role="strong">resource.each </emphasis> if you
                        want to browse through the resource.</para>
                    </tip>
                  </para>
                </callout>
              </calloutlist>
            </para>
          </example>To run this file simply right click on it (Run As -> Kermeta Application). You
          should obtain the following trace in the Eclipse's console : </para>
        <figure id="refIllustration85">
          <title>Fsm_dyn_sample1.xmi content </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/fsm_model_elements.png"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section>
        <title>Modify and save an EMF model with Kermeta</title>
        <para>At this stage, it should be interesting to be able to modify a previously loaded model
          using Kermeta before saving it. The procedure is very simple: do your manipulation as if
          your loaded FSM model is a Kermeta model (which is, in effect, the case!), and then,
          simply call a save method on the handling resource. For this purpose, the following code
          can be added at the end of the <emphasis>main</emphasis> operation defined in the above
          section:</para>
        <programlisting language="kermeta">var newstate : fsm::State init fsm::State.new
		newstate.name := "s_new" 
		fsm1.ownedState.add(newstate) 
		newstate.owningFSM := fsm1
// save fsm1 
resource.save()</programlisting>
        <para>A new state s_new appears on the file Fsm_dyn_sample1.xmi.</para>
        <para>It is also possible to save the modified model in a new file instead of overwriting
          the initial one by using the <literal>saveWithNewURI()</literal> method. To this end, just
          replace the last line of above code (<literal>resource.save()</literal>) by the following
          one:</para>
        <programlisting language="kermeta">resource.saveWithNewURI("platform:/resource/org.kermeta.fsm.serialisation/model/modified_dyn_sample1.xmi")</programlisting>
      </section>
      <section>
        <title>Create a model in Kermeta, and save it as an EMF model</title>
        <para>Saving a programmatically generated model requires to use a new specific instruction
          that add the created <emphasis>Fsm</emphasis> root class to the destination resource. The
          following code chunk creates a simple EMF model with 2 states (named “foo”, and “bar”),
          and 2 transitions. Saving it then consists in adding the root class (i.e. the model
          object) stored in the variable <literal>fsm2</literal> into the resource instances.</para>
        <programlisting language="kermeta">var another_resource : EMFResource
		another_resource ?= repository.createResource(
       "platform:/resource/org.kermeta.fsm.serialisation/model/Fsm_scratch_sample.xmi",
       "platform:/resource/org.kermeta.fsm.serialisation/metamodel/fsm.ecore")
		var fsm2 : fsm::FSM init fsm::FSM.new
		var s0 : fsm::State init fsm::State.new
		var s1 : fsm::State init fsm::State.new
		var t01 : fsm::Transition init fsm::Transition.new
		var t11 : fsm::Transition init fsm::Transition.new
		s0.name := "foo"
		s1.name := "bar"
		t01.source := s0
		t01.target := s1
		t11.source := s1
		t11.target := s1
		fsm2.ownedState.add(s0)
		fsm2.ownedState.add(s1)
		s0.outgoingTransition.add(t01)
		s1.outgoingTransition.add(t11)
		// save the from-scratch model!
		another_resource.add(fsm2)
		another_resource.save()</programlisting>
        <para>This program should return the following FSM model (viewed with the reflexive
          editor):</para>
        <figure id="refIllustration9">
          <title>Fsm_scratch_sample view</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/fsm_scratch_sample.png"
                width="14.707cm" depth="9.02cm"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para/>
      </section>
      <section id="completeKermetaProgramTemplate">
        <title>A template for a complete Kermeta program<phrase id="template"/></title>
        <para>The following short code sample provides a comprehensive code template (replace the
            <emphasis>&lt;words&gt;</emphasis>) for model loading. Note here that the term
            <emphasis>model object</emphasis> is appropriate (better than <emphasis>root
            class</emphasis>!): loading a model consists in getting the root class, from which,
          thanks to the containment property (see section, all the contained instances can be
          accessed.</para>
        <programlisting language="kermeta">@mainClass "fsm_package::Main"
@mainOperation "main"
package fsm_package;
require kermeta 
require "&lt; nsURI of the metamodel &gt;" 

using kermeta::persistence
using kermeta::standard
class Main
{
 operation main() : Void is do 
      // Variable for your input EMF model
      var &lt;my_model_object&gt; : &lt;type_of_my_model&gt;
      // Create the repository, then the resource
      var &lt;my_rep&gt; : EMFRepository init EMFRepository.new 
      var &lt;my_resource&gt; : EMFResource 
      &lt;my_resource&gt; ?= repository.createResource(
      "&lt;relative_path_of_my_model_to_load&gt;",
      "&lt;relative_path_of_the_metamodel&gt;")
      &lt;my_resource&gt;.load
     // Load the emf model - get the root class 
      &lt;my_model_object&gt; ?= resource.one
     // You can now browse your model through its attributes/references 
      &lt;my_model_object&gt;.&lt;an_attribute_of_it&gt;.each { o | 
         stdio.writeln("-&gt; "+o.toString) } )
    // Save your model in another file
      &lt;my_resource&gt;.saveWithNewUri("&lt;relative_path_of_a_file_where_to_save_model&gt;")
 end
}
</programlisting>
      </section>
      <section>
        <title> Load and save for models divided into several resources</title>
        <para>
          <warning>
            <title> Depending models on the same EMFRepository</title>
            <para> Several models which have links between them <emphasis> must</emphasis> be saved
              into the same EMFRepository. Be careful on saving the resources (unlike load which
              retrieve all the resources). </para>
          </warning> If your models have no dependancy between them, you can save them into several
          EMFRepository. </para>
        <para>In the following chapters, we will study the sample
          fr.irisa.triskell.kermeta.samples.fsm.demoAspect.</para>
      </section>
    </section>
  </chapter>
  <chapter>
    <title> Check model </title>
    <para>Check all the invariants for a model can be useful if you use a model provided by a third
      party or resulting from a transformation, it permits to check well-formed rules. For more
      informations about it, please refer to the Model Checking Manual. Look at the file<emphasis
        role="bold"> checkInvariants.kmt</emphasis> in <emphasis role="bold"
        >fr.irisa.triskell.kermeta.samples.fsm.demoAspect/launcher/checkInvariants.kmt</emphasis> .
      This class permits to check all the invariants from the meta model thanks to the method
      checkAllInvariants.
      <programlisting language="kermeta">
    class InvariantChecker
    {
    operation main(input_automaton : String) : Void is do 
    var rep : EMFRepository init EMFRepository.new
    var theFSM : FSM init AutomatonHelper.new.loadEMFAutomaton(rep, input_automaton, "http://www.kermeta.org/fsm")
    
    // To check all contained elements by "theFSM"
    stdio.writeln("> call of the checkAllInvariants method")
    theFSM.checkAllInvariants
    // To check only the states that are contained in "theFSM"
    stdio.writeln("> call of the checkInvariants method")
    end
    }
    </programlisting>
      Look at the Run Configuration FSM check invariant. If you run it you should obtain the
      following trace : <figure id="refIllustration9_1">
        <title>Fsm_scratch_sample view</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/fsm_check_invariant_trace_ok.png"/>
          </imageobject>
        </mediaobject>
      </figure></para>
    <para>Now, we will study the case of an error which violate an invariant. Look at the file
      FSMConstraints.kmt into fr.triskell.kermeta.fsm.demo/kermeta/constraints/FSMConstraints.kmt .
      You will see the following invariant </para>
    <programlisting language="kermeta"> aspect class State{ inv invariant1 is do self.outgoingTransition.forAll{ tr1 | self.outgoingTransition.forAll{ tr2 | tr2.input.equals(tr1.input).equals(tr1.equals(tr2))}} end } </programlisting>
    <para>It means that several outgoing transitions from a state cannot have the same input. Look
      at the file samplerunErrorInvariant.fsm.  Right click on Aspect check invariantsError and
      click on Apply and Run. This fsm model have two transitions with the same input. Like
      invariant is violated, Kermeta raises an exception. So, you should obtain the following trace
      : <figure id="refIllustration9_2">
        <title>Invariant error 's trace</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/error_invariant.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </para>
    <para> Now you know how to check models. The next section explains how you can improve kermeta
      programs adding on them Design by contract which consist in adding pre and post
      conditions.</para>
  </chapter>
  <chapter id="Contract">
    <title>Design by contract</title>
    <para> By Design by contract, we mean add pre or post condition to our ecore model in order to
      add constraints on the Fsm's execution. It permits to use good practices into kermeta
      development. You can retrieve the Design by Contract concepts languages like Eiffel. Firstly,
      we present how to run configurations to parametrize this pre or post conditions. Then we
      present examples of pre and post conditions. In this section we study the example available in
        <emphasis role="bold">fr.irisa.kemeta.samples.fsm.demoAspect</emphasis>.</para>
    <section id="RunConfiguration">
      <title>Run configurations</title>
      <para/>
      <section>
        <title>An entry point for the program</title>
        <para>We want to execute an FSM model. To do that we must call the "run" operation of the
          "FSM" class. We are going to do that thanks to a KerMeta script. This script will : load
          an instance of the FSM meta model stored in a file and call the run operation of these
          instance. </para>
        <tip>
          <para> To launch a script, the interpreter must know the entry point of the program. It
            can "ask" it to the user thanks to an Eclipse window. Another way might be to add the
            following statements into your kermeta code : </para>
          <itemizedlist>
            <listitem>
              <para>@mainClass which stands for the main class,</para>
            </listitem>
          </itemizedlist>
          <itemizedlist>
            <listitem>
              <para>@mainOperation which stands for the main operation of the main class.</para>
            </listitem>
          </itemizedlist>
        </tip>
        <para>In the FSM example ( <emphasis role="bold"
            >fr.irisa.triskell.kermeta.samples.fsm.demoAspect</emphasis>) , those scripts are in the
          "launcher" directory. Look at "minimization.kmt" script. Here the interpreter knows that
          entry point of the program is the operation "main" in the "Minimization" class.</para>
        <figure>
          <title> The launcher folder</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/launchers.png"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section>
        <title>Execution without parameters</title>
        <para>Let's have a look at the file named "minimization.kmt". Open it. Look at the code of
          the main operation. There is no parameter. To run this script with constraint checking,
          right click on "minimization.kmt" and select "Run As" and "Kermeta Constrained
          Application". To run this script without constraint checking, right click on
          "minimization.kmt" and select "Run As" and  "Run As Kermeta Application".</para>
        <figure>
          <title> Execution of minimization example</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/minimization-execution.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>The program asks you for a filename. Put in "../models/sample1.fsm" for example. You
          are lastly asked for a filename which will correspond to the file generated by the
          program. Put in "../generated.fsm" and see the execution.</para>
      </section>
      <section>
        <title>Execution with parameter(s)</title>
        <para>Now if you have a look at the three others scripts (checkInvariants, determinization
          and fsmLauncher) into <emphasis role="bold"
            >fr.triskell.kermeta.samples.fsm.demoAspect/launcher </emphasis> you will notice that
          the main operation of the main class takes one argument. Let's focus on "fsmLauncher.kmt"
          launcher. The main operation takes one parameter which is the name of the file containing
          the FSM model. It loads the model, prints it and runs it. If you try the running method
          above, an exception is raised because the parameterized file does not exist. Indeed we did
          not specify any filename to the program. So, you cannot use the method above to run those
          kind of script. That is the reason why we are going to use run configurations. Then right
          click on "fsmLauncher.kmt" file and select "Run As" and "Run Configurations...". A window
          appears like the one below. Select the run configuration named "loaderFSM" and look at the
          different options. Have a special look at the file parameters : </para>
        <itemizedlist>
          <listitem>
            <para>"Location of your program file", here this is "fsmLauncher.kmt" filename relative
              to the project's root directory.</para>
          </listitem>
          <listitem>
            <para>"Class qualified name", that is to say the main class of the program.</para>
          </listitem>
          <listitem>
            <para>"Operation name", that is to say the main operation of the main class.</para>
          </listitem>
          <listitem>
            <para>"Operation arguments", the parameters you want to send to the main
              operation.</para>
          </listitem>
        </itemizedlist>
        <para>Here, we give the string "../models/sample1.fsm" as a parameter to mainLoadFSM
          operation to "fsm::Main" class. By clicking on "Run" button, it will start the execution.
          You can create yourself some new run configurations. Just by left clicking on "Kermeta
          Application " or "Kermeta Constraint Application" (depending on the constraint checking
          you want) and select "New" and fill in the required fields.</para>
        <caution>
          <para>Eclipse is slash sensible. It only accepts front slash and no backslash. Then
            /fr.irisa.triskell.kermeta.samples.fsm.demo/launcher/fsmLauncher.kmt is a valid filename
            whereas \fr.irisa.triskell.kermeta.samples.fsm.demo\launcher\fsmLauncher.kmt is
            not.</para>
        </caution>
        <figure>
          <title> Run configurations </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/run_configuration.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
        <tip> <para>
        	If you want to create a new configuration, just right click on Kermeta Application, or Kermeta Constrained Application and New. Then, fill the fields like above.
        </para>
        </tip>
        </para>
       
      </section>
    </section>
    <section id="ConstraintCheckingSample">
      <title>Constraints checking execution sample</title>
      <para>This section will present an example of constraint checking execution. Have a look at
        the  "fsm.kmt" file (into <emphasis role="bold"
          >fr.triskell.kermeta.samples.fsm.demo/kermeta</emphasis>. This kermeta file requires two
        files : <orderedlist>
          <listitem>
            <para>fsm_Operationnal_Semantics.kmt from <emphasis role="bold"
                >fr.triskell.kermeta.samples.fsm.demo/kermeta/semantics/ </emphasis> which defines
              the fsm 's behaviour ( cf section <link linkend="Behaviour">Behaviour </link> ) </para>
            <para>The following code shows the behaviour of the step operation : </para>
            <programlisting language="kermeta">aspect class State {
	
		reference combination : Set&lt;State>
	

	// Go to the next state
	operation step(c : String) : String raises FSMException
	is do
		// Get the valid transitions
		var validTransitions : Collection&lt;Transition> 
		validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
		// Check if there is one and only one valid transition
		if validTransitions.empty then raise NoTransition.new end
		if validTransitions.size > 1 then raise NonDeterminism.new end
		
		// Fire the transition
		result := validTransitions.one.fire
	end
	
	// Create a new state from self state
	operation copy() : State is do
		result := State.new
		result.name := String.clone(name)
		result.combination := Set&lt;State>.new
	end
}</programlisting>
<para> <tip> <para> The key-word<emphasis role="bold"> aspect</emphasis> (cf <link linkend="Behaviour">Behaviour
                  </link>  ) permits to add some operations.</para></tip></para>

          </listitem>
          <listitem>
            <para>FSMConstraints.kmt from <emphasis role="bold"
                >fr.triskell.kermeta.samples.fsm.demo/kermeta/constraints/ </emphasis> which defines
              an invariant and pre and post conditions. </para>
            <programlisting language="kermeta">aspect class State{ 
inv invariant1 is
do
self.outgoingTransition.forAll{ tr1 | self.outgoingTransition.forAll{ tr2 | tr2.input.equals(tr1.input).equals(tr1.equals(tr2))}}
end
}
aspect class State{

operation step(c : String) :String
	pre pre2 is do
		c.equals(void).~not.~and(c.size.isGreater(0)) 
	end
	post post3 is do
		result.equals(void).~not.~and(result.size.isGreater(0)) 
	end
	is abstract

}</programlisting>
          </listitem>
        </orderedlist></para>
      <para>There is a pre condition (<emphasis role="bold">pre2</emphasis>) which says that the
        character given as a parameter must not be void or empty string. The post condition<emphasis
          role="bold"> (post3)</emphasis> says that the result must not be void or empty string. For
        each "step" method call, the pre and post conditions will be checked. If there are evaluated
        as false, the program is aborted otherwise the program goes on. Look at the run
        configuration named "FSM Aspect loader with pre-post check". If you do not retrieve this
        configuration right click on FSM Aspect loader with pre-post check.launch Run As -> FSM
        Aspect loader with pre-post check. Open the file (../models/sample1postv.fsm) used as
        parameter for this configuration. Observe the finite state diagram.</para>
      <section>
        <title>Pre condition violation</title>
        <para>Execute "FSM Aspect loader with pre-post check" configuration. When you are asked for
          a letter , just press enter to send an empty string. Normally, it should provoke the
          violation of the pre condition. You should obtain the following trace into the console
          :</para>
        <para>
          <programlisting language="kermeta">State : s1
  Transition : s1-(c/NC)->s2
State : s2
  Transition : s2-(x/y)->s2
Current state : s1
give me a letter : 

stepping...
[kermeta::exceptions::ConstraintViolatedPre:4603]
pre pre2 of operation step of class State violated</programlisting>
        </para>
      </section>
      <section>
        <title>Post condition violation</title>
        <para>Execute "FSM Aspect loader with pre-post check" configuration. When you are asked for
          a letter , press c and then press enter. Normally, the post condition will be violated
          because the result will be an empty string. You should obtain the following trace into the
          console :</para>
        <para>
          <programlisting language="kermeta">State : s1
  Transition : s1-(c/NC)->s2
State : s2
  Transition : s2-(x/y)->s2
Current state : s1
give me a letter : c
c
stepping...
[kermeta::exceptions::ConstraintViolatedPost:5548]
post post3 of operation step of class State violated</programlisting>
        </para>
        <para>This chapter presented the use of pre and post condition on an execution.The next
          chapter explain how you can simulate an execution of the modelling system thank to
          behaviour. </para>
      </section>
    </section>
  </chapter>
  <chapter id="Behaviour">
    <title>Behaviour </title>
    <section>
      <title> Expected behaviour for this tutorial </title>
      <para> Adding a behaviour to the FSM meta-model consists in to make a simulation of execution
        with operations and an execution context represented by the current state of the FSM. That's
        why you need to add a currentState reference and three operation : </para>
      <orderedlist continuation="restarts">
        <listitem>
          <para> run() for FSM class,</para>
        </listitem>
        <listitem>
          <para> step(String): String for State class,</para>
        </listitem>
        <listitem>
          <para>and fire(): String for Transition class </para>
        </listitem>
      </orderedlist>
      <para>Adding behavior to this meta model look like change the meta model according the
        following schema : </para>
      <figure>
        <title> FSM metamodel with behavior</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/FSMBehaviorMM.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para> The old way to add behavior in Kermeta was transform the ecore meta model into a
        Kermeta file and add the code for the methods. This tutorial presents the new approach, use
        aspect to add this new operations. With aspect, you can add new elements and new operations
        to a fixed meta-model. You can also combine several aspects. This section show you how to
        add behaviour with aspect into a metamodel. Have a look on the file
        fsm_Operationnal_Semantics.kmt from <emphasis role="bold"
          >fr.irisa.triskell.samples.fsm.demo/kermeta/semantics</emphasis> which contains the fsm 's
        behaviour operations.</para>
    </section>
    <section>
      <title> Structuration of this behavior with aspects</title>
      <para> So, this part presents the use of aspects to implement behavior. An aspect into a
        KerMeta file can be created simply with :</para>
      <para>
        <example>
          <title> Aspect in Kermeta</title>
          <programlisting language="kermeta">require kermeta
     require "http://www.kermeta.org/fsm"
       <co id="add.behavior.require.co" linkends="add.behavior.require.callout"/>
       
     using fsm
       <co id="add.behavior.using.co" linkends="add.behavior.using.callout"/> 
     using kermeta::standard
      
      aspect class Transition 
      <co id="add.behavior.class.Transition.co" linkends="add.behavior.class.Transition.callout"/>
	{	
	// Fire the transition
	operation fire() : String is do
	<co id="add.behavior.operation.fire.co" linkends="add.behavior.operation.fire.callout"/>
	  [...]
	end
	}
      
     
     }
    </programlisting>
          <para>
            <calloutlist>
              <callout arearefs="add.behavior.require.co" id="add.behavior.require.callout">
                <para> You need to load the meta model where you will weave aspects. </para>
              </callout>
              <callout arearefs="add.behavior.using.co" id="add.behavior.using.callout">
                <para> The key word using fsm permits to simplify the writing of the elements from
                  the fsm meta model like an import in the Java language. </para>
              </callout>
              <callout arearefs="add.behavior.class.Transition.co"
                id="add.behavior.class.Transition.callout">
                <para> The key word aspect is used to add attribute or operation to an existing
                  metaclass (in this case Transition) of the loaded meta model. </para>
              </callout>
              <callout arearefs="add.behavior.operation.fire.co"
                id="add.behavior.operation.fire.callout">
                <para> Now, you can add attribute or operation like in a classical Kermeta file.
                </para>
              </callout>
            </calloutlist>
          </para>
        </example>
      </para>
      <warning>
        <title/>
        <para> None of the elements added by aspect take part of the ecore meta model, so these
          elements are transient that’s why it cannot be serialized by this way. If you want to
          serialize a new element to the meta model you need to add it into.</para>
      </warning>
      <para> Have a look on the Kermeta file fsm_Operationnal_Semantics.kmt in the folder
        kermeta/semantics of fr.irisa.triskell.kermeta.samples.fsm.demo. You can add several aspects
        in the same file. So, this code is structured like this : </para>
      <para>
        <example>
          <title> Structuration of the fsm_Operationnal_Semantics.kmt file</title>
          <programlisting language="kermeta"> 
     package fsm;

	require kermeta
	require "http://www.kermeta.org/fsm"
	using fsm
	using kermeta::standard
	using kermeta::persistence
	using kermeta::exceptions

 
 
	aspect class FSM 
	{
	reference currentState : State
	 <co id="add.behavior.exampleAspect.reference.co" linkends="add.behavior.exampleAspect.reference.callout"/>
	 
	  
	// Operational semantic
	operation run() :  Void raises FSMException is do 
	<co id="add.behavior.exampleAspect.raises.co" linkends="add.behavior.exampleAspect.raises.callout"/>
    // [...]
     end 
     
     /** Initialize a new automaton from an existing one 
	 *  param :
	 *    p_state : the initial state
	 *    isInitComb
	 */
	operation initialize(p_state : State, isInitComb : Boolean) is do
     // [...]
     end
     
  } 
   <co id="add.behavior.exampleAspect.endAspect.co" linkends="add.behavior.exampleAspect.endAspect.callout"/>
  
  aspect class State {
  
  // Go to the next state
	operation step(c : String) : String raises FSMException
	//[...]
	end
	
  } 
  
  aspect class Transition 
{	
	
	// Fire the transition
	operation fire() : String is do
	//[...]
	end
	}
     </programlisting>
          <para>
            <calloutlist>
              <callout arearefs="add.behavior.exampleAspect.reference.co"
                id="add.behavior.exampleAspect.reference.callout">
                <para> The reference currentState is added by aspect into the fsm meta model.
                </para>
              </callout>
              <callout arearefs="add.behavior.exampleAspect.raises.co"
                id="add.behavior.exampleAspect.raises.callout">
                <para> The key word raises declare an exception that an operation can throw. </para>
              </callout>
              <callout arearefs="add.behavior.exampleAspect.endAspect.co"
                id="add.behavior.exampleAspect.endAspect.callout">
                <para> Don't forget to close the brace at the and of an aspect definition. </para>
              </callout>
            </calloutlist>
          </para>
        </example>
      </para>
      <para> The next section presents the differents algorithms in details.</para>
    </section>
    <section>
      <title> Behavior algorithms</title>
      <para>Now, we will present in details the algorithm for the operations run(), step(String) and
        fire (String).</para>
      <itemizedlist>
        <listitem>
          <para>The run operation is used as a user interface. Thanks to this operation, we are
            going to display information about the finite state machine, read user input and process
            steps.</para>
        </listitem>
        <listitem>
          <para>The step operation is used to go to an other state depending on the user's input and
            the transitions available from the current state.</para>
        </listitem>
        <listitem>
          <para>The fire operation is used to change the current state and to get the produced
            string.</para>
        </listitem>
      </itemizedlist>
      <para>Let us see the behavior of these three operations.</para>
      <section>
        <title> Run algorithm</title>
        <para>Behavior :</para>
        <para>1 – initialize current state</para>
        <para>2 – loop until the user's input equal to "quit"</para>
        <para>print the current state</para>
        <para>read a string</para>
        <para>process a step</para>
        <para>catch exceptions if there are some and exit the program displaying the error.</para>
        <para>Here is the code of the operation :</para>
        <programlisting language="kermeta">operation run() :  Void raises FSMException is do  
		// reset if there is no current state
		if self.currentState == void then self.currentState := self.initialState end
		self
		from var str : String init "init"
		until str == "quit"
		loop
			stdio.writeln("Current state : " + self.currentState.name)
			str := stdio.read("give me a letter : ")
			if str == "quit" then
				stdio.writeln("")
				stdio.writeln("quitting ...")
			else 
				if str == "print" then
					stdio.writeln("")
				else	
					stdio.writeln(str)			
					stdio.writeln("stepping...")
					do
						var textRes : String
						textRes := self.currentState.step(str)
						if( textRes == void or textRes == "" )
						then
							textRes := "NC"
						end
						
						stdio.writeln("string produced : " + textRes)
					
						rescue (err : ConstraintViolatedPre)
		            		stdio.writeln(err.toString)
		            		stdio.writeln(err.message)
		            		str := "quit"
		            	rescue (err : ConstraintViolatedPost)
	            			stdio.writeln(err.toString)
	            			stdio.writeln(err.message)
	            			str := "quit"
	            		
						rescue(err : NonDeterminism)
							stdio.writeln(err.toString)
							str := "quit"	
						rescue(err : NoTransition)
							stdio.writeln(err.toString)
							str := "quit"
	            	end
				end
			end
		end
	end</programlisting>
      </section>
      <section>
        <title> Step algorithm </title>
        <para>In this operation, there are pre and post conditions. These are conditions checked
          each time the operation is called. If they are evaluated to false an exception is raised.
          You can choose to check them or not. The following chapter presents how to run
          configurations.</para>
        <para>Behavior :</para>
        <para>1 – Select the possible transitions.</para>
        <para>2 – If there is none raise a NoTransition exception.</para>
        <para>If there is more than one raise a NonDeterminism exception.</para>
        <para>3 – If there is only one transition, call its fire operation and return its
          result.</para>
        <programlisting language="kermeta">// Go to the next state
	operation step(c : String) : String raises FSMException
	is do
		// Get the valid transitions
		var validTransitions : Collection&lt;Transition> 
		validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
		// Check if there is one and only one valid transition
		if validTransitions.empty then raise NoTransition.new end
		if validTransitions.size > 1 then raise NonDeterminism.new end
		
		// Fire the transition
		result := validTransitions.one.fire
	end
</programlisting>
      </section>
      <section>
        <title> Fire algorithm </title>
        <para>Behavior :</para>
        <para>1 – change the current state of the FSM</para>
        <para>2 – return the produced string</para>
        <programlisting language="kermeta">// Fire the transition
	operation fire() : String is do
		// update FSM current state
		source.owningFSM.currentState := target
		result := output
	end</programlisting>
      </section>
    </section>
    <section>
      <title> Run an fsm example of behaviour</title>
      <para>In this example we execute a step into the fsm behaviour algorithm with the file
        samplerun.fsm stored into <emphasis role="bold"
          >fr.irisa.triskell.kermeta.samples.fsm.demo/models/samplerun.fsm</emphasis>. The following
        image presents the file samplerun.fsm.<inlinegraphic
          fileref="Kermeta-The-FSM-example_figures/samplerun_fsm_file.png"/></para>
      <para>In this example, you use the transition c to go to s1 to s2 and produce the string v .
        the behaviour can be produced thanks to the operations run(), step() and fire() defined in
        the last section. To run this behaviour right click on <emphasis role="italic"> FSM Aspect
          Behaviour</emphasis> -> Run as -> FSM Aspect Behaviour.</para>
      <para>You should obtain the following trace : </para>
      <para>
        <figure>
          <title> Example of behaviour execution</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/result_example_behaviour.png"/>
            </imageobject>
          </mediaobject>
        </figure>
      </para>
      <para>You can continue the behaviour of finite state machine if you want.  This section has
        presented  how to add a behaviour on the meta model. The next section present how to use
        model transformation.</para>
    </section>
  </chapter>
  <chapter>
    <title> Model Transformation</title>
    <para> The files minimization.kmt and determinization.kmt from<emphasis role="bold">
        fr.irisa.triskell.kermeta.samples.fsm.demo/launcher</emphasis> are examples of
      transformation of one model to one another,let you have a look on it. These examples are
      separated into three main steps : </para>
    <orderedlist continuation="restarts">
      <listitem>
        <para> load the model to transform and initialize the output model</para>
      </listitem>
      <listitem>
        <para> traitment of the transformation (use an algoritm to determin the new results and add
          it into other output model).</para>
      </listitem>
      <listitem>
        <para>save the output model</para>
      </listitem>
    </orderedlist>
    <para>You can execute these examples following the section <link linkend="RunConfiguration">Run
        configurations</link>. This section give you an example of model transformation. The next
      section will present how to customize the EMF editor presented on section  <link
        linkend="treeViewEditor">Tree view editor</link>.</para>
  </chapter>
  <chapter>
    <title> UI improvements </title>
    <para> You can customize your user interface like shown below. For more samples please refer to
      the Logo sample. </para>
    <section id="CustomizeEMF_Editor">
      <title> Customize the generated EMF editor</title>
      <para> Generated code can be modified for customization. An EMF editor for FSM models is ever
        deployed into Eclipse Kermeta. Retrieve the plugin code source with File -> Import ->
        Plug-in Development -> Plug-ins and Fragments and click two times on Next. Then choose the
        following plugins : </para>
      <figure>
        <title> Import EMF and Topcased FSM Editor deployed plugins</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="KerMeta-The-FSM-example_figures/import_plugins.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The plugin .model, .edit and .editor correspond to the fsm EMF editor whereas the
        .graphicalEditor represents the Topcased editor.</para>
      <tip>
        <title> Add custom code</title>
        <para> To keep your customized code for each generation you need to add
          <programlisting language="java"> 
         /**
	       * 
	       * @generated NOT
	       */
         </programlisting>
          just before the name of the method you want to customize.</para>
      </tip>
      <section>
        <title> Change the editor's icons</title>
        <para> To change an icon you need only to replace the icon from
          fr.triskell.kermeta.samples.fsm.edit/icons/full/obj16 to another with the same name and
          the same extension. It is the case on this deployed plugin. The following image presents
          this plugin, the .gif images have been changed from the initial EMF generation.</para>
        <figure>
          <title> Customize icons</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/CustomIcons.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Respectively the icons FSM.gif, State.gif and Transition.gif look like this : </para>
        <figure>
          <title> FSM icon</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/FSM.gif"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure>
          <title> State icon</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/State.gif"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure>
          <title> Transition icon</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="KerMeta-The-FSM-example_figures/Transition.gif"/>
            </imageobject>
          </mediaobject>
        </figure>
        <note>
          <para>Like GMF use EMF icons for the palette you can customize the palette icons by this
            way.</para>
        </note>
        <para> You will see the change when you will use the generated editor like in the following
          section.</para>
      </section>
      <section>
        <title> Change text presentation</title>
        <para>The following method comes from FSMItemProvider in the package
          fr.triskell.kermeta.samples.fsm.provider in the project
          fr.irisa.triskell.kermeta.samples.fsm.model.edit. It permits to disply thr initial state
          or if it is missing or if the final state is missing.</para>
        <para><programlisting language="java">
        /**
	 * This returns the label text for the adapted class.
	 * &lt;!-- begin-user-doc -->
	 * &lt;!-- end-user-doc -->
	 * @generated NOT
	 */
	public String getText(Object object) {
		
		String initialState = " [an initial state is required]";
		if(object instanceof FSM &amp;&amp; ((FSM) object).getInitialState()!=null) {
			initialState = " [initial state = " + ((FSM) object).getInitialState().getName() + "]";
		}
		String finalState = " - [at least one final state is required]";
		if(object instanceof FSM &amp;&amp; ((FSM) object).getFinalState().size()>0) {
			finalState = "";
		}
		return getString("_UI_FSM_type") + initialState + finalState;
	}
         </programlisting>
          . </para>
        <para/>
      </section>
    </section>
  </chapter>
  <chapter>
    <title> Conclusion</title>
    <para> This tutorial give an illustration of the steps presented into the Processes to build a
      DSL Document (cf hyperlien), in particular it focus on traitment of an ecore meta model into
      Kermeta. For more informations please refer to others tutorials available <ulink url="http://www.kermeta.org/documents/tutorials">http://www.kermeta.org/documents/tutorials</ulink>  .</para>
  </chapter>
</book>
