@mainClass "fsm2::Main" 
@mainOperation "main"


package fsm2;

require kermeta 
require "fsmmodel.kmt"

using fsm_package
using kermeta::standard
using kermeta::persistence

class Main 
{

	/**
	 * The entry point
	 */
	operation main() is do
		var theFSM : FSM init createFSM()
		printFSM(theFSM)
		theFSM.run()
		printFSM(theFSM)
	end
	
	operation mainload() is do
		var theFSM : FSM init loadfsm()
		printFSM(theFSM)
		theFSM.run()
		printFSM(theFSM)
			
	end
	
	operation loadfsm() : FSM is do
		var res : EMFRepository init EMFRepository.new
        var resource : EMFResource init res.createResource("../ecore/fsm1.xmi", "../ecore/fsm.ecore")
        stdio.writeln("before loading")
        resource.load()
       	stdio.writeln("after loading")
        var fsm1 : FSM
        fsm1 ?= resource.instances.one  
        result  := fsm1
	end

	operation simpleMain() is do
		var theFSM : FSM init createFSM()
		printFSM(theFSM)
	end
	/**
	 * Print the FSM on the standard output
	 */
	operation printFSM(fsm : FSM) is do
		fsm.ownedState.each 
		{ s | 
			stdio.writeln("State : " + s.name)
			s.outgoingTransition.each { t | 
				stdio.writeln("  Transition : " + t.source.name + "-(" + t.input + "/" + t.output + ")->" + t.target.name)
			}
		}
	end

	/**
	 * Create a sample FSM
	 */
	operation createFSM() : FSM is do
		// The FSM
		result := FSM.new
		//result.serializer := self	
		
		// Create the states of the FSM
		var s1 : State init State.new 	s1.name := "s1"		result.ownedState.add(s1)
		var s2 : State init State.new	s2.name := "s2"		result.ownedState.add(s2)
		var s3 : State init State.new	s3.name := "s3"		result.ownedState.add(s3)
		
		
		
		// Create the transitions
		var t12 : Transition init Transition.new
			t12.input := "a"	t12.source := s1
			t12.output := "b"	t12.target := s2
		var t23x : Transition init Transition.new
			t23x.input := "x"	t23x.source := s2
			t23x.output := "y"	t23x.target := s3
		var t23y : Transition init Transition.new
			t23y.input := "y"	t23y.source := s2
			t23y.output := "x"	t23y.target := s3
		var t31 : Transition init Transition.new
			t31.input := "b"	t31.source := s3
			t31.output := "a"	t31.target := s1
		
		var tQuitS1 : Transition init Transition.new
			tQuitS1.input := "b"	tQuitS1.source := s1
			tQuitS1.output := "a"	tQuitS1.target := s1

		// Set the initial state
		result.initialState := s1
	end
}


