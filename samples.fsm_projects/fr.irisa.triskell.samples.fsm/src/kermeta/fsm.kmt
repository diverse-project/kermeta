@mainClass "fsm::Main" 
@mainOperation "main"
package fsm;

require kermeta 
using kermeta::standard

class Main {

	/**
	 * The entry point
	 */
	operation main() is do
		var theFSM : FSM init createFSM()
		printFSM(theFSM)
		theFSM.run()
		printFSM(theFSM)
		
	end

	operation simpleMain() is do
		var theFSM : FSM init createFSM()
		printFSM(theFSM)
		
	end
	/**
	 * Print the FSM on the standard output
	 */
	operation printFSM(fsm : FSM) is do
		fsm.ownedState.each { s | 
			stdio.writeln("State : " + s.name)
			s.outgoingTransition.each { t | 
				stdio.writeln("  Transition : " + t.source.name + "-(" + t.input + "/" + t.output + ")->" + t.target.name)
			}
		}
	end

	/**
	 * Create a sample FSM
	 */
	operation createFSM() : FSM is do
		// The FSM
		result := FSM.new
		result.serializer := self	
		
		// Create the states of the FSM
		var s1 : State init State.new 	s1.name := "s1"		result.ownedState.add(s1)
		var s2 : State init State.new	s2.name := "s2"		result.ownedState.add(s2)
		var s3 : State init State.new	s3.name := "s3"		result.ownedState.add(s3)
		
		
		
		// Create the transitions
		var t12 : Transition init Transition.new
			t12.input := "a"	t12.source := s1
			t12.output := "b"	t12.target := s2
		var t23x : Transition init Transition.new
			t23x.input := "x"	t23x.source := s2
			t23x.output := "y"	t23x.target := s3
		var t23y : Transition init Transition.new
			t23y.input := "y"	t23y.source := s2
			t23y.output := "x"	t23y.target := s3
		var t31 : Transition init Transition.new
			t31.input := "b"	t31.source := s3
			t31.output := "a"	t31.target := s1
		
		var tQuitS1 : Transition init Transition.new
			tQuitS1.input := "b"	tQuitS1.source := s1
			tQuitS1.output := "a"	tQuitS1.target := s1

		// Set the initial state
		result.initialState := s1
	end
}

/*********************************
 * SIMPLE STATE MACHINE METAMODEL
 *********************************/
class FSM
{
	attribute ownedState : set State[0..*]#owningFSM
	reference initialState : State[1..1] 
	
	reference currentState : State 
	
	reference serializer : Main 
	
	
	operation run() : Void raises FSMException is do  
		// reset if there is no current state
		if currentState == void then reset end
		self
		from var str : String init "init"
		until str == "quit"
		loop
			stdio.writeln("etat courrant : " + currentState.name)
			str := stdio.read("entrez une chaine : ")
			if str == "quit" then
				stdio.writeln("")
				stdio.writeln("quitting ...")
			else 
				if str == "print" then
					stdio.writeln("")
					serializer.printFSM(self)
				else	
					stdio.writeln(str)			
					stdio.writeln("stepping...")
					stdio.writeln("chaine produite : " + currentState.step(str))
				end
			end
		end
	end
	
	operation reset() : Void is do
		currentState := initialState
	end
}

class State {
	attribute name : String
	reference owningFSM : FSM#ownedState
	attribute outgoingTransition : set Transition[0..*]#source
	reference incomingTransition : set Transition[0..*]#target
	
	operation step(c : String) : String raises FSMException is do
		// Get the valid transitions
		var validTransitions : Collection<Transition> 
		validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
		// Check if there is one and only one valid transition
		if validTransitions.empty then raise NoTransition.new end
		if validTransitions.size > 1 then raise NonDeterminism.new end
		// fire the transition
		result := validTransitions.one.fire
	end
}

class Transition {
	reference source : State[1..1]#outgoingTransition
	reference target : State[1..1]#incomingTransition
	attribute output : String
	attribute input : String
	
	operation fire() : String is do
		// update FSM current state
		source.owningFSM.currentState := target
		result := output
	end
}

abstract class FSMException {}
class NonDeterminism inherits FSMException {}
class NoTransition inherits FSMException {}
