package ecore;

require kermeta

using kermeta::reflection
using kermeta::standard

class EAttribute inherits EStructuralFeature
{
	attribute iD : EBoolean
}

class EClass inherits EClassifier
{
	reference ~abstract : EBoolean
	reference eSuperTypes : EClass[0..*]
	attribute eOperations : EOperation[0..*]#eContainingClass
	attribute eStructuralFeatures : EStructuralFeature[0..*]#eContainingClass
	
	method getSignature() : Signature is do
		if signature == void then 
			var s : ClassSignature init ClassSignature.new
			s.cls := self
			signature := s
		end
		result := signature
	end
	
}
abstract class EClassifier inherits ENamedElement, Mergeable
{
	
	reference ePackage : EPackage#eClassifiers
	
	method sigEqual(other : Mergeable) : Boolean is do
		var t1 : Type init self.getMetaClass
		var t2 : Type init other.getMetaClass
		
		if t1 == t2 then
			if self.getSignature == other.getSignature then
				result := true
			else
				result := false
			end
		else
			result := false
		end 
	end
	
	method getSignature() : Signature is do
		if signature == void then 
			var s : StringSignature init StringSignature.new
			s.sign := name
			signature := s
		end
		result := signature
	end
}
class EDataType inherits EClassifier
{
	
}

abstract class EModelElement 
{
	// attribute eAnnotations : EAnnotation[0..*]#eModelElement
	
	operation getmatchingElements(elements : Collection<EModelElement>) : seq EModelElement[0..*] is do
		var e1 : Mergeable	e1 ?= self
		if e1 == void then
			result := Sequence<EModelElement>.new
		else
			result := elements.select{ e | 
				var e2 : Mergeable	e2 ?= e
				if e2 == void then false else e1.getSignature ==  e2.getSignature end
			}
		end
		
	end
	
	operation getClassFromType(t : Type) : Class is do
		if t.getMetaClass == kermeta::language::structure::PrimitiveType then
			var pt : PrimitiveType		pt ?= t
			result := getClassFromType(pt.instanceType)
		else
			result ?= t
		end
	end
	
	operation getSAttributes() : Collection<Property> is do
		result := getAllProps.select{ p | 
			var c : Class init getClassFromType(p.type)
			not Mergeable.isSubType(c)
		}
	end
	operation getComponents() : Collection<Property> is do
		result := getAllProps.select{ p | 
			var c : Class init getClassFromType(p.type)
			Mergeable.isSubType(c) and
			p.isComposite 
		}
	end
	
	operation getAllProps() : Collection<Property> is do
		var cd : ClassDefinition init self.getMetaClass.classDefinition
		result := getAllPropertiesOfClass(cd) 
	end
	
	operation isMergeableType(c : Class) : Boolean is do
		result := Mergeable.isSubType(c)
	end
	
		
	operation getAllPropertiesOfClass(cd : ClassDefinition) : Collection<Property> is do
			result := Set<Property>.new
			
			result.addAll(cd.ownedAttributes) 
			
			cd.superType.each{ t | 
				var sc : Class		sc ?= t
				getAllPropertiesOfClass(sc.classDefinition).each{ p | 
					if not result.contains(p) then
						result.add(p)
					end
				}
			}
			 
			result := result.select{ k | not k.isDerived }

	end
	
}

abstract class ENamedElement inherits EModelElement
{
	reference name : EString
}


class EOperation inherits ETypedElement, Mergeable
{
	reference eContainingClass : EClass#eOperations
	attribute eParameters : EParameter[0..*]#eOperation
	reference eExceptions : EClassifier[0..*]
	method sigEqual(other : Mergeable) : Boolean is do
		var t1 : Type init self.getMetaClass
		var t2 : Type init other.getMetaClass
		
		if t1 == t2 then
			if self.getSignature == other.getSignature then
				result := true
			else
				result := false
			end
		else
			result := false
		end 
	end
	
	method getSignature() : Signature is do
		if signature == void then 
			var s : OperationSignature init OperationSignature.new
			s.op := self
			signature := s
		end
		result := signature
	end
}
class EPackage inherits ENamedElement, Mergeable
{
	attribute eClassifiers : EClassifier[0..*]#ePackage
	attribute eSubpackages : EPackage[0..*]#eSuperPackage
	reference eSuperPackage : EPackage#eSubpackages
	
	method sigEqual(other : Mergeable) : Boolean is do
		var t1 : Type init self.getMetaClass
		var t2 : Type init other.getMetaClass
		
		if t1 == t2 then
			if self.getSignature == other.getSignature then
				result := true
			else
				result := false
			end
		else
			result := false
		end 
	end
	
	
	method getSignature() : Signature is do
		if signature == void then 
			var s : StringSignature init StringSignature.new
			s.sign := name
			signature := s
		end
		result := signature
	end
}
class EParameter inherits ETypedElement, Mergeable
{
	reference eOperation : EOperation#eParameters
	
		method sigEqual(other : Mergeable) : Boolean is do
		var t1 : Type init self.getMetaClass
		var t2 : Type init other.getMetaClass
		
		if t1 == t2 then
			if self.getSignature == other.getSignature then
				result := true
			else
				result := false
			end
		else
			result := false
		end 
	end
	
	method getSignature() : Signature is do
		if signature == void then 
			var s : ParameterSignature init ParameterSignature.new
			s.param := self
			signature := s
		end
		result := signature
	end
}
class EReference inherits EStructuralFeature
{
	reference containment : EBoolean
	reference eOpposite : EReference
	
}
abstract class EStructuralFeature inherits ETypedElement, Mergeable
{
	
	reference derived : EBoolean
	reference eContainingClass : EClass#eStructuralFeatures
	
	method sigEqual(other : Mergeable) : Boolean is do
		var t1 : Type init self.getMetaClass
		var t2 : Type init other.getMetaClass
		
		if t1 == t2 then
			if self.getSignature == other.getSignature then
				result := true
			else
				result := false
			end
		else
			result := false
		end 
	end
	
	method getSignature() : Signature is do
		if signature == void then 
			var s : StringSignature init StringSignature.new
			s.sign := name
			signature := s
		end
		result := signature
	end
}
abstract class ETypedElement inherits ENamedElement
{
	reference ordered : EBoolean
	reference unique : EBoolean
	reference lowerBound : EInt
	reference upperBound : EInt
	reference eType : EClassifier
}

alias EBoolean : kermeta::standard::Boolean;
alias EInt : kermeta::standard::Integer;
alias EString : kermeta::standard::String;

abstract class Mergeable inherits EModelElement
{
	reference signature : Signature[1..1]
	
	
	operation merge(other : Mergeable) : Mergeable is do

		var type : Class init self.getMetaClass 
		result ?= type.new
	
		stdio.writeln("-> MERGE " + self.toString + " AND " + other.toString)
		
		var props : Collection<Property> init self.getAllProps
		
		props.each{ p | 
			
			if Mergeable.isSubType(p.type)  then 
			
					if self.get(p) == void then
						result.~set(p, other.get(p))
					else
						if other.get(p) == void then
							result.~set(p, self.get(p))
						else
						
							if p.upper != 1 then
								var ocol1 : Collection<kermeta::reflection::Object> 	ocol1 ?= self.get(p) 
								var col1 : Collection<EModelElement> init Sequence<EModelElement>.new
								ocol1.each{ k | 
									var m : EModelElement	m ?= k
									col1.add(m)
								}
								var ocol2 : Collection<kermeta::reflection::Object> 	ocol2 ?= other.get(p) 
								var col2 : Collection<EModelElement> init Sequence<EModelElement>.new
								ocol2.each{ k | 
									var m : EModelElement	m ?= k
									col2.add(m)
								}
								col1.each{ me | 
									
									var matching : Collection<EModelElement> init me.getmatchingElements(col2)
									var col : Collection<kermeta::reflection::Object>
									col ?= result.get(p)
									if matching.size == 0 then
										col.add(me)
									else
										matching.each{ me2 | 
											var mergable : Mergeable	mergable ?= me
											var mergable2 : Mergeable	mergable2 ?= me2

											if p.isComposite then
												col.add(mergable.merge(mergable2))
											else
												col.add(mergable)
											end
										}
									end	
								}
								
								col2.each{ me | 
									
									var matching : Collection<EModelElement> init me.getmatchingElements(col1)
									var col : Collection<kermeta::reflection::Object>
									col ?= result.get(p)
									if matching.size == 0 then
										col.add(me)
									end
								}
								
							
								
							else
								var me1 : Mergeable		me1 ?= self.get(p)
								var me2 : Mergeable		me2 ?= other.get(p)
								
								if me1 == void or me2 == void then
									stdio.writeln("WARNING : Elements are not mergeable")
								else
									if me1.getSignature == me2.getSignature then
										if p.isComposite then
											stdio.writeln("Recursive merge")
											result.~set(p, me1.merge(me2))
										else
											result.~set(p, me1)
										end
									else
										stdio.writeln("ERROR : Elements signature do not match")
									end
								end
							end
						end
					end

			else
				if self.get(p) == void then
					result.~set(p, other.get(p))
				else
					if self.get(p) == void then
						result.~set(p, self.get(p))
					else
						if self.get(p) == other.get(p) then
							result.~set(p, self.get(p))
						else
							stdio.writeln("WARNING : conflicting value for property " + p.name + " picking the first value")
							result.~set(p, self.get(p))
						end
					end
				end
			end
		
		
		}
		
		
		
		
	end

	operation getSignature() : Signature is abstract
	operation sigEqual(other : Mergeable) : EBoolean is abstract

}
class Composer
{
	operation main(e1 : EModelElement, e2 : EModelElement) : Void is do
		var e3 : EModelElement
		
		var m1 : Mergeable
		var m2 : Mergeable
		
		m1 ?= e1
		m2 ?= e2
		
		if m1 == void or m2 == void then
			raise "Model elements are not mergeable"
		end
		
		if m1.sigEqual(m2) then 
			e3 := m1.merge(m2)
			stdio.writeln("Elements merged " + e3.toString)
		else
			stdio.writeln("Models not mergeable")
		end
		
		
	end
}
abstract class Signature
{
}
class StringSignature inherits Signature
{
	attribute sign : String
	
	method equals(other : Object ) : Boolean is do
		var othersign : StringSignature
		othersign ?= other
		if othersign != void then
			result := sign == othersign.sign
		else
			result := false
		end
	end
	
}

class ClassSignature inherits Signature
{
	reference cls : EClass 
	
	method equals(other : Object ) : Boolean is do
		var othersign : ClassSignature
		othersign ?= other
		if othersign != void then
			result := self.cls.name == othersign.cls.name 
			and
				self.cls.~abstract == othersign.cls.~abstract 
			
		else
			result := false
		end
	end
	
}


class OperationSignature inherits Signature
{
	reference op : EOperation 
	
	method equals(other : Object ) : Boolean is do
		var othersign : OperationSignature
		othersign ?= other
		if othersign != void then
			result := self.op.name == othersign.op.name 
			
			self.op.eParameters.each{ p1 | 
				if result then
					result := othersign.op.eParameters.select{ p2 | p1.sigEqual(p2) }.size == 1
				end
			}
			
		else
			result := false
		end
	end
	
}

class ParameterSignature inherits Signature
{
	reference param : EParameter 
	
	method equals(other : Object ) : Boolean is do
		var othersign : ParameterSignature
		othersign ?= other
		if othersign != void then
			result := self.param.name == othersign.param.name and
				self.param.eType.sigEqual(othersign.param.eType)
		else
			result := false
		end
	end
	
}

