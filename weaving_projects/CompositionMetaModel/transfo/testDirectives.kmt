/* $Id: testDirectives.kmt,v 1.1 2006-07-28 23:26:01 ffleurey Exp $
 * Creation date: July 28, 2006
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "composition::Main"
@mainOperation "main"


package composition;


require kermeta
require "../metamodel/directives.kmt"

using kermeta::standard
using kermeta::persistence
using ecore


class Main
{

	operation createDirectives() : Composer is do
		var comp : Composer init Composer.new
		
		// Create Class as c
		var createC : Create init Create.new	comp.predirectives.add(createC)
		createC.className := "Class"	createC.identifier := "c"
		
		// $c name = "C"
		var setCName : Set init Set.new		comp.predirectives.add(setCName)
		setCName.propertyName := "name"		
		var setCNameT : IDRef init IDRef.new 	setCNameT.identifier := "c"
		setCName.target := setCNameT
		var setCNameV : StringLiteral init StringLiteral.new	setCNameV.~value := "C"
		setCName.~value := setCNameV
		
		// Package eClassifiers + $c 
		var addC : Add init Add.new		comp.predirectives.add(addC)
		addC.propertyName := "eClassifiers"		
		var addCT : NameRef init NameRef.new 	addCT.qname := "Package"
		addC.target := addCT
		var addCV : IDRef init IDRef.new 	addCV.identifier := "c"
		addC.~value := addCV
		
		result := comp
		
	end

    operation main() : Void is do 
        var model1 : EPackage init loadECoreModel("../models/Model1.ecore")
        printModel(model1)
        stdio.writeln("execute pre directives")
        createDirectives.executePreDirectives(model1)
        stdio.writeln("here is the result")
        printModel(model1)
        
    end
    
    
    operation loadECoreModel(path : String) : EPackage is do
    	var resource : kermeta::persistence::EMFResource             
   		var repository : EMFRepository init EMFRepository.new             
       	resource ?= repository.createResource(path, "../metamodel/ecore.ecore")
        resource.load
       result ?= resource.instances.one
   end
    
    operation printModel(p : EPackage) is do
    	
    	// Print the package
    	stdio.writeln("package " + p.name)
    	// Print the classes
    	p.eClassifiers.each{ e | 
    		var c : EClass		c ?= e
    		var d : EDataType	d ?= e
    		if c != void then
    			stdio.writeln("  class " + c.name.toString)
    			// Print Attributes and References
    			c.eStructuralFeatures.each{ p | 
    				var s : EAttribute		s ?= p
    				var r : EReference		r ?= p
    				if r != void then 
    					stdio.write("    ref  " + r.name.toString)
    					stdio.write(" : " + r.eType.name + "[" + r.lowerBound.toString + ".." + r.upperBound.toString +"]")
    					if r.eOpposite != void then 
    						stdio.write(" opposite of " + r.eOpposite.name)
    					end
    					stdio.writeln("")
    				else
    					stdio.write("    attr " + s.name.toString)
    					stdio.writeln(" : " + s.eType.name)
    				end
    			}
    			//Print Operations
    			c.eOperations.each{ o | 
    				stdio.write("    op   " + o.name + "(")
    				o.eParameters.each{ p | 
    					stdio.write(p.name + " : " + p.eType.name + " ")
    				}
    				stdio.write(")")
    				if o.eType != void then
    					stdio.write(" : " + o.eType.name)
    				end
    				stdio.writeln("")
    			}
    			
    			
    		else
    			stdio.writeln("  datatype " + d.name)
    		end
    	
    	}
    
    end
}