/* $Id: loadKM.kmt,v 1.3 2007-08-23 09:56:18 dvojtise Exp $
 * Creation date: May 24, 2007
 * License: EPL
 * Copyright: 
 * Authors: 
 *		Rafael Duarte
 *		Didier Vojtisek
 */
@mainClass "modelmerging::ModelLoader"
@mainOperation "main"

package modelmerging;

require kermeta

require "Merger.kmt"

//require "platform:/resource/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
using kermeta::standard
using kermeta::persistence
using kermeta::reflection

class ModelLoader
{
	attribute repository : kermeta::persistence::EMFRepository 
	
	operation initialize() is do
		repository := kermeta::persistence::EMFRepository.new
	end
	
	operation main() : Void is do 
		initialize
		var mu1 : ModelingUnit init loadModel("LeftInputModel.km")
		var mu2 : ModelingUnit init loadModel("RightInputModel.km")
		//printPackage(pack1)
		//printPackage(pack2)
		stdio.writeln("### initializing merger ###")
		var merger : AbstractMerger init DefaultMerger.new.initialize
		//merger.initialize
		var mergedMU : ModelingUnit init merger.mergeModelingUnit(mu1, mu2)
		stdio.writeln("### printing merged package ###")
		//printPackage(mergedPack)
		saveModel(mergedMU, "MergedPackage.km")
		//saveModel(pack1, "LeftInputModelAfter.km")
		//saveModel(pack2, "RightInputModelAfter.km")
	end

	/*
	 * loads a model (package) given its path, using kermeta as metamodel
	 */
    operation loadModel(path : String) : ModelingUnit 
   		pre notVoid is do not path.equals("") end
       	pre notVoid is do path != void end
    is do
    	var resource : kermeta::persistence::Resource             
       	//resource ?= repository.createResource(path, "./metamodel/kermeta_java.ecore")
        resource := repository.getResource(path)
        stdio.writeln(path + " loaded")
        // resource.load() // not necessary since a getresource already load the model
        // since v0.6.0 models should only contain one ModelingUnit
		result ?= resource.detect{m | ModelingUnit.isInstance(m)}
   	end
   
   	/*
   	 * saves a merged package as a .km file given its path
   	 */
	operation saveModel(m : ModelingUnit, path : String) is do
    	var resource : kermeta::persistence::Resource             
		resource := repository.createResource(path,
			"./metamodel/kermeta_java.ecore")
     	resource.add(m)
     	stdio.writeln("Saving model... " + path)
     	resource.save()
     	stdio.writeln("Model successfully saved")
	end
   
	/*
	 * prints the contents of a package
	 */
   	operation printPackage(p : Package) 
   		is do
		stdio.writeln("### Printing package " + p.name)
		var types : Set<TypeDefinition> init p.ownedTypeDefinition
		var classes : Sequence<TypeDefinition> 
		classes := types.select{c |
			ClassDefinition.isInstance(c)
		}
		var cAux : ClassDefinition
		classes.each{c |
			stdio.writeln("-----------------------------")
			cAux ?= c
			stdio.writeln("  Class: " + c.name +" - abstract: " + cAux.isAbstract.toString)
			stdio.write("   superclasses: ")
			cAux.superType.each{c | stdio.write(c.name + " ")}
			stdio.writeln("")
			var atts : Sequence<Property> init cAux.ownedAttribute.asSequence
			atts.each{a |
				stdio.writeln("    prop: " + a.name + " : " + a.type.toString)
			}
			var ops : Sequence<Operation> init cAux.ownedOperation.asSequence
			ops.each{o |
				stdio.writeln("    oper: " + o.name + " : " + o.type.toString)
				stdio.writeln("     num. of exceptions: " + o.raisedException.size.toString)
				var params : Sequence<Parameter> init o.ownedParameter.asSequence
				params.each{p |
					stdio.writeln("      param: " + p.name + " : " + p.type.toString)
				}
				
			}
		}
		stdio.writeln("-----------------------------")
	end
}

