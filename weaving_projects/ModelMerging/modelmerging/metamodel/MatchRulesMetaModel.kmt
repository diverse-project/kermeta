package modelmerging::metamodel;

require "../Utils.kmt"

using kermeta::reflection
using kermeta::standard
using modelmerging

class MatchRuleFile
{
	attribute rules : set MatchRule[0..*]

}

class MatchRule
{
	attribute expression : BooleanExpression

	reference name : kermeta::standard::String[1..1]
	
}
abstract class BooleanExpression
{
	reference utils : Utils 
	
	// not type safe, had to do this way due to the lack of generics support in sintaks
	reference context : Sequence<Object> 
	
	operation evaluate() : kermeta::standard::Boolean is
		abstract
	
}
class UnaryExpression inherits BooleanExpression
{
	attribute operand : BooleanExpression[1..1]

	reference operator : kermeta::standard::String[1..1]
	
	method evaluate() : kermeta::standard::Boolean is do
		operand.context := self.context
		if operator == "not" then 
			result := not operand.evaluate()
		else
			raise "unary operator not supported"
		end
	end
		

}
abstract class Predicate inherits BooleanExpression
{

	reference name : kermeta::standard::String[1..1]

}

abstract class ClassPredicate inherits Predicate
{

}

abstract class PropertyPredicate inherits Predicate
{

}

abstract class OperationPredicate inherits Predicate
{

}

abstract class BinaryExpression inherits BooleanExpression
{
	attribute left : BooleanExpression[1..1]

	attribute right : BooleanExpression[1..1]
	
}
class AndExpression inherits BinaryExpression
{
	method evaluate() : kermeta::standard::Boolean is do
		left.context := self.context
		right.context := self.context
		result := left.evaluate() and right.evaluate()
	end
}
class OrExpression inherits BinaryExpression
{
	method evaluate() : kermeta::standard::Boolean is do
		left.context := self.context
		right.context := self.context
		result := left.evaluate() or right.evaluate()
	end
}

/*
 *	matches if both classes are abstract or if both are concrete
 */
class BothAbstractClasses inherits ClassPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		var e1:ClassDefinition
		e1 ?= context.elementAt(0)
		var e2:ClassDefinition
		e2 ?= context.elementAt(1)
		result := (e1.isAbstract() and e2.isAbstract) 
						or (not e1.isAbstract() and not e2.isAbstract)
	end
}

/*
 *	matches if both classes have the same superclasses
 */
class SameSuperclasses inherits ClassPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var e1:ClassDefinition
		e1 ?= context.elementAt(0)
		var e2:ClassDefinition
		e2 ?= context.elementAt(1)
		var u : Utils init self.utils
		result := utils.equalsClassSet(e1.superType,e2.superType)
	end
}

/*
 *	matches if the superclasses are conforming, i.e. there is a conforming class
 *  for each class present in one of the sets.
 */
class ConformingSuperclasses inherits ClassPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var e1:ClassDefinition
		e1 ?= context.elementAt(0)
		var e2:ClassDefinition
		e2 ?= context.elementAt(1)
		result := utils.conformingClasses(e1.superType, e2.superType)
	end
}
/*
2. Properties
 - sameType
 - conformingType*
 - sameMultiplicity
 - containedMultiplicity
 - sameContainment (i.e. ref X att)
*/

/*
 *	matches if the types are the same (if they have the same name)
 */
class SameType inherits PropertyPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var e1:Property
		e1 ?= context.elementAt(0)
		var e2:Property
		e2 ?= context.elementAt(1)
		result := utils.equalsType(e1.type, e2.type)
	end
}


/*
 *	matches if the types are conforming (one is a subclass of the other)
 */
class ConformingType inherits PropertyPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var e1:Property
		e1 ?= context.elementAt(0)
		var e2:Property
		e2 ?= context.elementAt(1)
		result := utils.conformingType(e1.type,e2.type)
	end
}


/*
 *	matches if the properties have exactly the same multiplicity
 */
class SameMultiplicity inherits PropertyPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		var e1:Property
		e1 ?= context.elementAt(0)
		var e2:Property
		e2 ?= context.elementAt(1)
		result := (e1.lower == e2.lower) and (e1.upper == e2.upper) 
	end
}

/*
 *	matches if the properties have the same type of containment, i.e. both 
 *  attributes or both references
 */
class SameContainment inherits PropertyPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		var e1:Property
		e1 ?= context.elementAt(0)
		var e2:Property
		e2 ?= context.elementAt(1)
		result := (e1.isComposite and e2.isComposite) 
							or ((not e1.isComposite) and (not e2.isComposite))
	end
}

/*
 *	matches if the multiplicity of one property is contained in the other.
 *  e.g: 2..4 and 0..6
 */
class ContainedMultiplicity inherits PropertyPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		var e1:Property
		e1 ?= context.elementAt(0)
		var e2:Property
		e2 ?= context.elementAt(1)
		result := (e1.lower >= e2.lower and e1.upper <= e2.upper)
						or (e1.lower <= e2.lower and e1.upper >= e2.upper)
	end
}

/*
3. Operations
 - bothAbstract
 - sameReturnType
 - conformingReturnType*
 - sameParameters
 - conformingParameters*
 - containedParameters 
 - sameType
 - sameExceptions
 - conformingExceptions
*/

/*
 *	matches if both operations are abstract or if both are concrete
 */
class BothAbstractOperations inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		result := (o1.isAbstract() and o2.isAbstract) 
						or (not o1.isAbstract() and not o2.isAbstract)
	end
}

/*
 *	matches if both operations have the same return type
 */
class SameReturnType inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		result := utils.equalsType(o1.type, o2.type)
	end
}

/*
 *	matches if operations have a conforming return type
 */
class ConformingReturnType inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		result := utils.conformingType(o1.type, o2.type)
	end
}

/*
 *	matches if both operations have exactly the same parameters
 */
class SameParameters inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		result := utils.equalsParameters(o1.ownedParameter, o2.ownedParameter)
	end
}

/*
 *	matches if operations have conforming parameters, i.e. every parameter in 
 *  the the defined order has a conforming counterpart in the other operation
 */
class ConformingParameters inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		var paramsNames1 : Sequence<String> init o1.ownedParameter.collect{p| p.name}
		var paramsNames2 : Sequence<String> init o2.ownedParameter.collect{p| p.name}
		if paramsNames1.equals(paramsNames2) then
			var params1 : Sequence<Type> init o1.ownedParameter.collect{p| p.type}
			var params2 : Sequence<Type> init o2.ownedParameter.collect{p| p.type}
			result := utils.conformingTypes(params1, params2)
		else
			result := false
		end
	end
}

/*
 *	matches if the parameters of one operation are contained by the other
 */
class ContainedParameters inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		if o1.ownedParameter.size >= o2.ownedParameter.size then
			// op1 contains op2 parameters
			result := o2.ownedParameter.forAll{p2 | o1.ownedParameter.exists{p1 | utils.equalsParameter(p1,p2)}}
		else
			// op2 contains op1 parameters
			result := o1.ownedParameter.forAll{p1 | o2.ownedParameter.exists{p2 | utils.equalsParameter(p1,p2)}}
		end
	end
}

/*
 *	matches if both are operations or if both are methods
 */
class SameTypeOfOperation inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		result := (o1.superOperation != void and o2.superOperation != void)
				    or (o1.superOperation == void and o2.superOperation == void)
	end
}

/*
 *	matches if both operations declare the same exceptions
 */
class SameExceptions inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		var res : Boolean init false
		self.utils := Utils.new
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		if o1.raisedException.size == o2.raisedException.size then
			if o1.raisedException.size == 0 then
				res := true
			else
				res := o1.raisedException.forAll{e1 | o2.raisedException.exists{e2 | self.utils.equalsType(e1,e2)}}
			end
		end
		result := res
	end
}

/*
 *	matches if operations declare conforming exceptions
 */
class ConformingExceptions inherits OperationPredicate
{
	method evaluate() : kermeta::standard::Boolean is do
		self.utils := Utils.new
		var o1:Operation
		o1 ?= context.elementAt(0)
		var o2:Operation
		o2 ?= context.elementAt(1)
		result := utils.conformingTypes(o1.raisedException.asSequence, o2.raisedException.asSequence)
	end
}

