<%@ ket package="specialize" 
	require="platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt" 
	using="ecore EcoreHelpers" 
	class="AdaptationTemplate"  
	parameters="classif:Set<EClassifier>, domainMM:String, domainMMPattern:String, shortName:String"
%>

/* 
 * Author: Brice Morin
 * Creation date: 
 * License: 
 * Copyright: IRISA Rennes - Equipe Projet INRIA Triskell
 */

/*
 * This file was automatically generated
 */
<%var helper:EcoreHelper init EcoreHelper.new%>

package org;
require kermeta
require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "<%=domainMM%>"
require "<%=domainMMPattern%>"

using kermeta::standard
using kermeta::utils
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore
using org::smartadapters::utils

package smartadapters
{
	package core
	{
		aspect class Adapter 
		{
			operation initConvert(): Void is do
				stdio.write("Mapping MM' to MM...")
				converter := Converter.new
				convert := Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>.new
				<%
				var name:String 
				classif.each{cl |
					var c:EClass
					c?=cl
					if(c!=void) then
						if(not(c.~abstract) and not(c.interface)) then
					name:=helper.getClassifierQualifiedName(c)%>
				convert.put(pattern::<%=name%>,<%=name%>)
					<%end
					end
					}%>
				converter.initConverter(convert)
				stdio.writeln("OK!")
			end
		}
		
	package adaptations
	{
		<%classif.each{cl | 
		var c:EClass
		var qualifiedName:String
		qualifiedName:=helper.getClassifierQualifiedName(cl)
		c?=cl %>
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of <%=qualifiedName%>
		 */
		 
		<%
		if(c!=void) then
			if(not(c.~abstract) and not(c.interface)) then%>
		
		class Create<%=qualifiedName.replace("::","")%> inherits createAdaptation
		{
			attribute new<%=c.name%> : pattern::<%=qualifiedName%>
					
			method check(): Boolean is do
				result := new<%=c.name%> != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(new<%=c.name%>, void, isUnique)					
			end
		}

		class Clone<%=qualifiedName.replace("::","")%> inherits cloneAdaptation
		{
			reference <%=c.name%>ToClone : pattern::<%=qualifiedName%>
			attribute cloned<%=c.name%> : pattern::<%=qualifiedName%>
			
			method check(): Boolean is do
				result := <%=c.name%>ToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(cloned<%=c.name%>, <%=c.name%>ToClone, isUnique)
			end					
		}
		<%end%>

		class Set<%=qualifiedName.replace("::","")%> inherits setAdaptation
		{
			reference <%=c.name%>ToSet : pattern::<%=qualifiedName%>
			<%
			var card:String
			var fQualName:String
			var newObj:kermeta::language::structure::Object
			var primitive:kermeta::language::structure::PrimitiveType
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
					fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
					if(not(f.upperBound==1))then%>
						<%card:="[0..*]"
					else%>
						<%card:=""
					end
					if(primitive==void) then%>
			reference ref<%=f.name%> : pattern::<%=fQualName%><%=card%>
					<%else%>
			reference ref<%=f.name%> : <%=fQualName%><%=card%>
					<%end%>
				<%end
				}%>
			
			method check(): Boolean is do
				result := <%=c.name%>ToSet != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var temp<%=c.name%> : <%=qualifiedName%>
				temp<%=c.name%> ?= ad.getRealObject(<%=c.name%>ToSet,false)
				
				<%c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then%>
				<%if f.upperBound==1 then%>
				temp<%=c.name%>.<%=f.name%> ?= ad.setSingleProperty(ref<%=f.name%>, temp<%=c.name%>.<%=f.name%>)
				<%else%>
				ad.setMultipleProperty(temp<%=c.name%>.<%=f.name%>,ref<%=f.name%>)
				<%end%>
				<%end
				}%>
				
				//Instantiating the reverse adaptation
				if(reverse) then
					var unset : Unset<%=qualifiedName.replace("::","")%> init Unset<%=qualifiedName.replace("::","")%>.new
					unset.<%=c.name%>ToUnset := self.<%=c.name%>ToSet
					<%c.eAllStructuralFeatures.each{f | 
					if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then%>
						<%if(not(f.upperBound==1))then%>
					unset.ref<%=f.name%>.clear
					unset.ref<%=f.name%>.addAll(self.ref<%=f.name%>)
						<%else%>
					unset.ref<%=f.name%> := self.ref<%=f.name%>
						<%end%>
					<%end%>
					<%}%>
					unset.reverse := self
					self.reverse := unset
				end	
			end			
		}
		
		class Unset<%=qualifiedName.replace("::","")%> inherits unsetAdaptation
		{
			reference <%=c.name%>ToUnset : pattern::<%=qualifiedName%>
			<%
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then%>
					<%fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj%>
					<%if(not(f.upperBound==1))then%>
						<%card:="[0..*]"%>
					<%else%>
						<%card:=""%>
					<%end%>
					<%if(primitive==void) then%>
			reference ref<%=f.name%> : pattern::<%=fQualName%><%=card%>
					<%else%>
			reference ref<%=f.name%> : <%=fQualName%><%=card%>
					<%end%>
				<%end%>
			<%}%>
			
			method check(): Boolean is do
				result := <%=c.name%>ToUnset != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var temp<%=c.name%> : <%=qualifiedName%>
				temp<%=c.name%> ?= ad.getRealObject(<%=c.name%>ToUnset,false)
				
				<%c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then%>
				<%if f.upperBound==1 then%>
				temp<%=c.name%>.<%=f.name%> ?= ad.unsetSingleProperty(ref<%=f.name%>, temp<%=c.name%>.<%=f.name%>)
				<%else%>
				ad.unsetMultipleProperty(temp<%=c.name%>.<%=f.name%>,ref<%=f.name%>)
				<%end%>
				<%end
				}%>
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : Set<%=qualifiedName.replace("::","")%> init Set<%=qualifiedName.replace("::","")%>.new
					~set.<%=c.name%>ToSet := self.<%=c.name%>ToUnset
					<%c.eAllStructuralFeatures.each{f | 
					if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then%>
						<%if(not(f.upperBound==1))then%>
					~set.ref<%=f.name%>.clear
					~set.ref<%=f.name%>.addAll(self.ref<%=f.name%>)
						<%else%>
					~set.ref<%=f.name%> := self.ref<%=f.name%>
						<%end%>
					<%end%>
					<%}%>
					~set.reverse := self
					self.reverse := ~set
				end
			end
		}
		<%end
		}%>
	}
}}