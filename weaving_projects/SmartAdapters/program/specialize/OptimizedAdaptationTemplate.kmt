package specialize;
require kermeta
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
using kermeta::standard
using kermeta::utils
using ecore
using EcoreHelpers
class AdaptationTemplate{
operation generate(classif:Set<EClassifier>, domainMM:String, domainMMPattern:String, shortName:String):String is do
var _res: StringBuffer init StringBuffer.new
_res.append("/* Authors: Brice Morin\n * Creation date: \n * License: \n * Copyright: IRISA Rennes - Equipe Projet INRIA Triskell\n */\n\n")
var helper:EcoreHelper init EcoreHelper.new
_res.append("\npackage org;\nrequire kermeta\nrequire \"platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt\"\nrequire \"")
_res.append(domainMM)
_res.append("\"\nrequire \"")
_res.append(domainMMPattern)
_res.append("\"\n\nusing kermeta::standard\nusing kermeta::utils\nusing patternframework\nusing org::smartadapters::core\nusing org::smartadapters::extension\nusing ecore\nusing org::smartadapters::utils\n\npackage smartadapters\n{\n\tpackage core\n\t{\n\t\t@aspect \"true\"\n\t\tclass Adapter \n\t\t{\n\t\t\toperation initConvert(): Void is do\n\t\t\t\tstdio.write(\"Mapping MM\' to MM...\")\n\t\t\t\tconverter := Converter.new\n\t\t\t\tconvert := Hashtable<kermeta::reflection::Class,kermeta::reflection::Class>.new\n")

				var name:String 
				classif.each{cl |
					var c:EClass
					c?=cl
					if(c!=void) then
						if(not(c.~abstract) and not(c.interface)) then
					name:=helper.getClassifierQualifiedName(c)
_res.append("\t\t\t\tconvert.put(pattern::")
_res.append(name)
_res.append(",")
_res.append(name)
_res.append(")\n")
end
					end
					}
_res.append("\t\t\t\tconverter.initConverter(convert)\n\t\t\t\tstdio.writeln(\"OK!\")\n\t\t\tend\n\t\t}\n\t\t\n\tpackage adaptations\n\t{\n")
classif.each{cl | 
		var c:EClass
		var qualifiedName:String
		qualifiedName:=helper.getClassifierQualifiedName(cl)
		c?=cl
		if(c!=void) then
			if(not(c.~abstract) and not(c.interface)) then
_res.append("\t\t\n\t\tclass Create")
_res.append(c.name)
_res.append(" inherits createAdaptation\n\t\t{\n\t\t\tattribute new")
_res.append(c.name)
_res.append(" : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := new")
_res.append(c.name)
_res.append("!=void\n\t\t\tend\n\t\t\t\t\t\n\t\t\tmethod execute(): Void is do\n\t\t\t\tadapter.cloneAgain(new")
_res.append(c.name)
_res.append(", void, isUnique)\t\t\t\t\t\n\t\t\tend\n\t\t}\n\n\t\tclass Clone")
_res.append(c.name)
_res.append(" inherits cloneAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToClone : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\tattribute cloned")
_res.append(c.name)
_res.append(" : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToClone!=void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(): Void is do\n\t\t\t\tadapter.cloneAgain(cloned")
_res.append(c.name)
_res.append(", ")
_res.append(c.name)
_res.append("ToClone, isUnique)\n\t\t\tend\t\t\t\t\t\n\t\t}\n")
end
_res.append("\n\t\tclass Set")
_res.append(c.name)
_res.append(" inherits setAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToSet : pattern::")
_res.append(qualifiedName)
_res.append("\n")

			var card:String
			var fQualName:String
			var newObj:kermeta::reflection::Object
			var primitive:kermeta::language::structure::PrimitiveType
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
					fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
					if(not(f.upperBound==1))then
_res.append("")
card:="[0..*]"
					else
_res.append("")
card:=""
					end
					if(primitive==void) then
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : pattern::")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
else
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : ")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
end
_res.append("")
end
				}
_res.append("\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToSet!=void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(): Void is do\n\t\t\t\tvar temp")
_res.append(c.name)
_res.append(" : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp")
_res.append(c.name)
_res.append(" ?= adapter.getRealObject(")
_res.append(c.name)
_res.append("ToSet,false)\n\t\t\t\t\n")
c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
_res.append("")
if f.upperBound==1 then
_res.append("\t\t\t\ttemp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(" ?= adapter.setSingleProperty(ref")
_res.append(f.name)
_res.append(", temp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(")\n")
else
_res.append("\t\t\t\tadapter.setMultipleProperty(temp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(",ref")
_res.append(f.name)
_res.append(")\n")
end
_res.append("")
end
				}
_res.append("\t\t\tend\t\t\t\n\t\t}\n\t\t\n\t\tclass Unset")
_res.append(c.name)
_res.append(" inherits unsetAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToUnset : pattern::")
_res.append(qualifiedName)
_res.append("\n")

			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
_res.append("")
fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
_res.append("")
if(not(f.upperBound==1))then
_res.append("")
card:="[0..*]"
_res.append("")
else
_res.append("")
card:=""
_res.append("")
end
_res.append("")
if(primitive==void) then
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : pattern::")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
else
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : ")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
end
_res.append("")
end
_res.append("")
}
_res.append("\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToUnset!=void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(): Void is do\n\t\t\t\tvar temp")
_res.append(c.name)
_res.append(" : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp")
_res.append(c.name)
_res.append(" ?= adapter.getRealObject(")
_res.append(c.name)
_res.append("ToUnset,false)\n\t\t\t\t\n")
c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
_res.append("")
if f.upperBound==1 then
_res.append("\t\t\t\ttemp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(" ?= adapter.unsetSingleProperty(ref")
_res.append(f.name)
_res.append(", temp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(")\n")
else
_res.append("\t\t\t\tadapter.unsetMultipleProperty(temp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(",ref")
_res.append(f.name)
_res.append(")\n")
end
_res.append("")
end
				}
_res.append("\t\t\tend\n\t\t}\n")
end
		}
_res.append("\t}\n}}")
result := _res.toString
end
}
