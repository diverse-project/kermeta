<%@ ket 
	package="specialize" 
	require="platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt" 
	using="ecore EcoreHelpers" 
	class="AdaptationTemplate"  
	parameters="classif:Set<EClassifier>, domainMM:String, domainMMPattern:String, shortName:String" %>


<%var helper:EcoreHelper init EcoreHelper.new%>

package org;
require kermeta
require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "<%=domainMM%>"
require "<%=domainMMPattern%>"

using kermeta::standard
using kermeta::utils
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore
using org::smartadapters::utils

package smartadapters
{
	package core
	{
		@aspect "true"
		class Adapter 
		{
			operation initConvert(): Void is do
				stdio.write("Mapping MM' to MM...")
				converter := Converter.new
				convert := Hashtable<kermeta::reflection::Class,kermeta::reflection::Class>.new
				<%
				var name:String 
				classif.each{cl |
					var c:EClass
					c?=cl
					if(c!=void) then
						if(not(c.~abstract) and not(c.interface)) then
					name:=helper.getClassifierQualifiedName(c)%>
				convert.put(pattern::<%=name%>,<%=name%>)
					<%end
					end
					}%>
				stdio.writeln("OK!")
			end
		}
		
	package adaptations
	{
		<%classif.each{cl | 
		var c:EClass
		var qualifiedName:String
		qualifiedName:=helper.getClassifierQualifiedName(cl)
		c?=cl
		if(c!=void) then
			if(not(c.~abstract) and not(c.interface)) then%>
		
		class Create<%=c.name%> inherits createAdaptation
		{
			attribute new<%=c.name%> : pattern::<%=qualifiedName%>
					
			method check(): Boolean is do
				result := new<%=c.name%>!=void
			end
					
			method execute(): Void is do
				var real<%=c.name%> : <%=qualifiedName%>
				if(adapter.created.getValue(new<%=c.name%>) == void or not(isUnique==uniqueType.unique)) then
					real<%=c.name%> ?= adapter.converter.getConverted(new<%=c.name%>)
					adapter.created.put(new<%=c.name%>,real<%=c.name%>)
				else
					var clone : Boolean init false
					if(isUnique==uniqueType.onDemand) then
						var input : String init stdio.read("create "+new<%=c.name%>.toString+" (true/false) :")
			               clone := input.toBoolean
					end									
					if(isUnique == uniqueType.non_unique or clone) then
						real<%=c.name%> ?= adapter.converter.getConverted(new<%=c.name%>)
						adapter.created.put(new<%=c.name%>,real<%=c.name%>)
					end
				end						
			end
		}

		class Clone<%=c.name%> inherits cloneAdaptation
		{
			reference <%=c.name%>ToClone : pattern::<%=qualifiedName%>
			attribute cloned<%=c.name%> : pattern::<%=qualifiedName%>
			
			method check(): Boolean is do
				result := <%=c.name%>ToClone!=void
			end
			
			method execute(): Void is do
				var realCloned<%=c.name%> : <%=qualifiedName%>
				var temp : <%=qualifiedName%>
				temp?=adapter.getRealObject(<%=c.name%>ToClone,false)
				if(isUnique == uniqueType.unique) then
					if(not(adapter.cloned.exists{o | o == temp})) then
						realCloned<%=c.name%> ?= Object.clone(temp)
						adapter.created.put(cloned<%=c.name%>,realCloned<%=c.name%>)
						adapter.cloned.add(temp)
					end
				else
					var clone : Boolean init false
					if(isUnique == uniqueType.onDemand) then
						var input : String init stdio.read("clone "+<%=c.name%>ToClone.toString+" (true/false) :")
		                clone := input.toBoolean
					end
					if(isUnique == uniqueType.non_unique or clone) then
						realCloned<%=c.name%> ?= Object.clone(temp)
						adapter.created.put(cloned<%=c.name%>,realCloned<%=c.name%>)
						adapter.cloned.add(temp)
					end
				end
			end					
		}
		<%end%>

		class Set<%=c.name%> inherits setAdaptation
		{
			reference <%=c.name%>ToSet : pattern::<%=qualifiedName%>
			<%
			var card:String
			var fQualName:String
			var newObj:kermeta::reflection::Object
			var primitive:kermeta::language::structure::PrimitiveType
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
					fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
					if(not(f.upperBound==1))then%>
						<%card:="[0..*]"
					else%>
						<%card:=""
					end
					if(primitive==void) then%>
			reference ref<%=f.name%> : pattern::<%=fQualName%><%=card%>
					<%else%>
			reference ref<%=f.name%> : <%=fQualName%><%=card%>
					<%end%>
				<%end
				}%>
			
			method check(): Boolean is do
				result := <%=c.name%>ToSet!=void
			end
			
			method execute(): Void is do
				var temp<%=c.name%> : <%=qualifiedName%>
				temp<%=c.name%> ?= adapter.getRealObject(<%=c.name%>ToSet,false)
				if(temp<%=c.name%> != void) then
				<%c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then	
					fQualName:=helper.getClassifierQualifiedName(f.eType)
					if(not(f.upperBound==1))then%>
					var temp<%=f.name%> : Collection<kermeta::reflection::Object>
					<%else%>
					var temp<%=f.name%> : <%=fQualName%>
					<%end%>
					<%newObj:=f.eType.getMetaClass.new
					primitive?=newObj%>
					if(ref<%=f.name%>!=void) then
						<%if(primitive==void) then%>
						<%if(f.upperBound==1)then%>
						temp<%=f.name%> ?= adapter.getRealObject(ref<%=f.name%>,false)
						<%else%>
						temp<%=f.name%> ?= adapter.getRealObject(ref<%=f.name%>,true)
						<%end%>
						<%else%>
						temp<%=f.name%>:=ref<%=f.name%>
						<%end%>
						if(temp<%=f.name%>!=void) then
							<%if(f.upperBound==1) then%>
							temp<%=c.name%>.<%=f.name%> := temp<%=f.name%>
							<%else%>
							temp<%=f.name%>.each{o | 
								var temp : <%=fQualName%>
								temp?=o
								if(temp!=void) then
									temp<%=c.name%>.<%=f.name%>.add(temp)
								end}
							<%end%>
						end
					end
				<%end
				}%>
				end			
			end			
		}
		
		class Unset<%=c.name%> inherits unsetAdaptation
		{
			reference <%=c.name%>ToUnset : pattern::<%=qualifiedName%>
			<%
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then%>
					<%fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj%>
					<%if(not(f.upperBound==1))then%>
						<%card:="[0..*]"%>
					<%else%>
						<%card:=""%>
					<%end%>
					<%if(primitive==void) then%>
			reference ref<%=f.name%> : pattern::<%=fQualName%><%=card%>
					<%else%>
			reference ref<%=f.name%> : <%=fQualName%><%=card%>
					<%end%>
				<%end%>
			<%}%>
			
			method check(): Boolean is do
				result := <%=c.name%>ToUnset!=void
			end
			
			method execute(): Void is do
				var temp<%=c.name%> : <%=qualifiedName%>
				temp<%=c.name%>?=adapter.getRealObject(<%=c.name%>ToUnset,false)
				if(temp<%=c.name%>!=void) then
					<%c.eAllStructuralFeatures.each{f | 
					if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then%>
					if(ref<%=f.name%> != void) then
						<%fQualName:=helper.getClassifierQualifiedName(f.eType)
						if(not(f.upperBound==1))then%>
						var temp<%=f.name%> : Collection<kermeta::reflection::Object>
						temp<%=f.name%>?=adapter.getRealObject(ref<%=f.name%>,true)
						if(temp<%=f.name%>!=void) then
							temp<%=f.name%>.each{o | 
								var temp : <%=fQualName%>
								temp?=o
								if(temp!=void) then
									temp<%=c.name%>.<%=f.name%>.remove(temp)
								end
							}
						end
						<%else%>
						var temp<%=f.name%> : <%=fQualName%>
						temp<%=f.name%> ?= adapter.getRealObject(ref<%=f.name%>,false)
						if(temp<%=f.name%>!=void) then
							if(temp<%=f.name%>==temp<%=c.name%>.<%=f.name%>) then
								temp<%=c.name%>.<%=f.name%>:=void
							end
						end						
						<%end%>
					end
				<%end%>
				<%}%>
				end
			end
		}
		<%end
		}%>
	}
}}