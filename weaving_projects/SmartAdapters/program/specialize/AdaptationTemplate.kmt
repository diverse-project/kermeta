package specialize;
require kermeta
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
using kermeta::standard
using kermeta::utils
using ecore
using EcoreHelpers
class AdaptationTemplate{
operation generate(classif:Set<EClassifier>, domainMM:String, domainMMPattern:String, shortName:String):String is do
var _res: StringBuffer init StringBuffer.new
_res.append("/* Authors: Brice Morin\n * Creation date: \n * License: \n * Copyright: IRISA Rennes - Equipe Projet INRIA Triskell\n */\n\n")
var helper:EcoreHelper init EcoreHelper.new
_res.append("\npackage org;\nrequire kermeta\nrequire \"platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt\"\nrequire \"")
_res.append(domainMM)
_res.append("\"\nrequire \"")
_res.append(domainMMPattern)
_res.append("\"\n\nusing kermeta::standard\nusing kermeta::utils\nusing patternframework\nusing org::smartadapters::core\nusing org::smartadapters::extension\nusing ecore\nusing org::smartadapters::utils\n\npackage smartadapters\n{\n\tpackage core\n\t{\n\t\t@aspect \"true\"\n\t\tclass Adapter \n\t\t{\n\t\t\toperation initConvert(): Void is do\n\t\t\t\tstdio.write(\"Mapping MM\\' to MM...\")\n\t\t\t\tconverter := Converter.new\n\t\t\t\tconvert := Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>.new\n")

				var name:String 
				classif.each{cl |
					var c:EClass
					c?=cl
					if(c!=void) then
						if(not(c.~abstract) and not(c.interface)) then
					name:=helper.getClassifierQualifiedName(c)
_res.append("\t\t\t\tconvert.put(pattern::")
_res.append(name)
_res.append(",")
_res.append(name)
_res.append(")\n")
end
					end
					}
_res.append("\t\t\t\tstdio.writeln(\"OK!\")\n\t\t\tend\n\t\t}\n\t\t\n\tpackage adaptations\n\t{\n")
classif.each{cl | 
		var c:EClass
		var qualifiedName:String
		qualifiedName:=helper.getClassifierQualifiedName(cl)
		c?=cl
		if(c!=void) then
			if(not(c.~abstract) and not(c.interface)) then
_res.append("\t\t\n\t\tclass Create")
_res.append(c.name)
_res.append(" inherits createAdaptation\n\t\t{\n\t\t\tattribute new")
_res.append(c.name)
_res.append(" : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := new")
_res.append(c.name)
_res.append("!=void\n\t\t\tend\n\t\t\t\t\t\n\t\t\tmethod execute(): Void is do\n\t\t\t\tvar real")
_res.append(c.name)
_res.append(" : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\tif(adapter.created.getValue(new")
_res.append(c.name)
_res.append(") == void or not(isUnique==uniqueType.unique)) then\n\t\t\t\t\treal")
_res.append(c.name)
_res.append(" ?= adapter.converter.getConverted(new")
_res.append(c.name)
_res.append(")\n\t\t\t\t\tadapter.created.put(new")
_res.append(c.name)
_res.append(",real")
_res.append(c.name)
_res.append(")\n\t\t\t\telse\n\t\t\t\t\tvar clone : Boolean init false\n\t\t\t\t\tif(isUnique==uniqueType.onDemand) then\n\t\t\t\t\t\tvar input : String init stdio.read(\"create \"+new")
_res.append(c.name)
_res.append(".toString+\" (true/false) :\")\n\t\t\t               clone := input.toBoolean\n\t\t\t\t\tend\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tif(isUnique == uniqueType.non_unique or clone) then\n\t\t\t\t\t\treal")
_res.append(c.name)
_res.append(" ?= adapter.converter.getConverted(new")
_res.append(c.name)
_res.append(")\n\t\t\t\t\t\tadapter.created.put(new")
_res.append(c.name)
_res.append(",real")
_res.append(c.name)
_res.append(")\n\t\t\t\t\tend\n\t\t\t\tend\t\t\t\t\t\t\n\t\t\tend\n\t\t}\n\n\t\tclass Clone")
_res.append(c.name)
_res.append(" inherits cloneAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToClone : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\tattribute cloned")
_res.append(c.name)
_res.append(" : pattern::")
_res.append(qualifiedName)
_res.append("\n\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToClone!=void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(): Void is do\n\t\t\t\tvar realCloned")
_res.append(c.name)
_res.append(" : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\tvar temp : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp?=adapter.getRealObject(")
_res.append(c.name)
_res.append("ToClone,false)\n\t\t\t\tif(isUnique == uniqueType.unique) then\n\t\t\t\t\tif(not(adapter.cloned.exists{o | o == temp})) then\n\t\t\t\t\t\trealCloned")
_res.append(c.name)
_res.append(" ?= Object.clone(temp)\n\t\t\t\t\t\tadapter.created.put(cloned")
_res.append(c.name)
_res.append(",realCloned")
_res.append(c.name)
_res.append(")\n\t\t\t\t\t\tadapter.cloned.add(temp)\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tvar clone : Boolean init false\n\t\t\t\t\tif(isUnique == uniqueType.onDemand) then\n\t\t\t\t\t\tvar input : String init stdio.read(\"clone \"+")
_res.append(c.name)
_res.append("ToClone.toString+\" (true/false) :\")\n\t\t                clone := input.toBoolean\n\t\t\t\t\tend\n\t\t\t\t\tif(isUnique == uniqueType.non_unique or clone) then\n\t\t\t\t\t\trealCloned")
_res.append(c.name)
_res.append(" ?= Object.clone(temp)\n\t\t\t\t\t\tadapter.created.put(cloned")
_res.append(c.name)
_res.append(",realCloned")
_res.append(c.name)
_res.append(")\n\t\t\t\t\t\tadapter.cloned.add(temp)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\t\t\t\t\t\n\t\t}\n")
end
_res.append("\n\t\tclass Set")
_res.append(c.name)
_res.append(" inherits setAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToSet : pattern::")
_res.append(qualifiedName)
_res.append("\n")

			var card:String
			var fQualName:String
			var newObj:kermeta::language::structure::Object
			var primitive:kermeta::language::structure::PrimitiveType
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
					fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
					if(not(f.upperBound==1))then
_res.append("")
card:="[0..*]"
					else
_res.append("")
card:=""
					end
					if(primitive==void) then
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : pattern::")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
else
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : ")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
end
_res.append("")
end
				}
_res.append("\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToSet!=void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(): Void is do\n\t\t\t\tvar temp")
_res.append(c.name)
_res.append(" : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp")
_res.append(c.name)
_res.append(" ?= adapter.getRealObject(")
_res.append(c.name)
_res.append("ToSet,false)\n\t\t\t\tif(temp")
_res.append(c.name)
_res.append(" != void) then\n")
c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then	
					fQualName:=helper.getClassifierQualifiedName(f.eType)
					if(not(f.upperBound==1))then
_res.append("\t\t\t\t\tvar temp")
_res.append(f.name)
_res.append(" : Collection<kermeta::language::structure::Object>\n")
else
_res.append("\t\t\t\t\tvar temp")
_res.append(f.name)
_res.append(" : ")
_res.append(fQualName)
_res.append("\n")
end
_res.append("")
newObj:=f.eType.getMetaClass.new
					primitive?=newObj
_res.append("\t\t\t\t\tif(ref")
_res.append(f.name)
_res.append("!=void) then\n")
if(primitive==void) then
_res.append("")
if(f.upperBound==1)then
_res.append("\t\t\t\t\t\ttemp")
_res.append(f.name)
_res.append(" ?= adapter.getRealObject(ref")
_res.append(f.name)
_res.append(",false)\n")
else
_res.append("\t\t\t\t\t\ttemp")
_res.append(f.name)
_res.append(" ?= adapter.getRealObject(ref")
_res.append(f.name)
_res.append(",true)\n")
end
_res.append("")
else
_res.append("\t\t\t\t\t\ttemp")
_res.append(f.name)
_res.append(":=ref")
_res.append(f.name)
_res.append("\n")
end
_res.append("\t\t\t\t\t\tif(temp")
_res.append(f.name)
_res.append("!=void) then\n")
if(f.upperBound==1) then
_res.append("\t\t\t\t\t\t\ttemp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(" := temp")
_res.append(f.name)
_res.append("\n")
else
_res.append("\t\t\t\t\t\t\ttemp")
_res.append(f.name)
_res.append(".each{o | \n\t\t\t\t\t\t\t\tvar temp : ")
_res.append(fQualName)
_res.append("\n\t\t\t\t\t\t\t\ttemp?=o\n\t\t\t\t\t\t\t\tif(temp!=void) then\n\t\t\t\t\t\t\t\t\ttemp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(".add(temp)\n\t\t\t\t\t\t\t\tend}\n")
end
_res.append("\t\t\t\t\t\tend\n\t\t\t\t\tend\n")
end
				}
_res.append("\t\t\t\tend\t\t\t\n\t\t\tend\t\t\t\n\t\t}\n\t\t\n\t\tclass Unset")
_res.append(c.name)
_res.append(" inherits unsetAdaptation\n\t\t{\n\t\t\treference ")
_res.append(c.name)
_res.append("ToUnset : pattern::")
_res.append(qualifiedName)
_res.append("\n")

			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
_res.append("")
fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
_res.append("")
if(not(f.upperBound==1))then
_res.append("")
card:="[0..*]"
_res.append("")
else
_res.append("")
card:=""
_res.append("")
end
_res.append("")
if(primitive==void) then
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : pattern::")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
else
_res.append("\t\t\treference ref")
_res.append(f.name)
_res.append(" : ")
_res.append(fQualName)
_res.append(card)
_res.append("\n")
end
_res.append("")
end
_res.append("")
}
_res.append("\t\t\t\n\t\t\tmethod check(): Boolean is do\n\t\t\t\tresult := ")
_res.append(c.name)
_res.append("ToUnset!=void\n\t\t\tend\n\t\t\t\n\t\t\tmethod execute(): Void is do\n\t\t\t\tvar temp")
_res.append(c.name)
_res.append(" : ")
_res.append(qualifiedName)
_res.append("\n\t\t\t\ttemp")
_res.append(c.name)
_res.append("?=adapter.getRealObject(")
_res.append(c.name)
_res.append("ToUnset,false)\n\t\t\t\tif(temp")
_res.append(c.name)
_res.append("!=void) then\n")
c.eAllStructuralFeatures.each{f | 
					if(not(f.derived or f.unsettable) and f.changeable and not(f.name.equals("tag") or f.name.equals("ownedTag"))) then
_res.append("\t\t\t\t\tif(ref")
_res.append(f.name)
_res.append(" != void) then\n")
fQualName:=helper.getClassifierQualifiedName(f.eType)
						if(not(f.upperBound==1))then
_res.append("\t\t\t\t\t\tvar temp")
_res.append(f.name)
_res.append(" : Collection<kermeta::language::structure::Object>\n\t\t\t\t\t\ttemp")
_res.append(f.name)
_res.append("?=adapter.getRealObject(ref")
_res.append(f.name)
_res.append(",true)\n\t\t\t\t\t\tif(temp")
_res.append(f.name)
_res.append("!=void) then\n\t\t\t\t\t\t\ttemp")
_res.append(f.name)
_res.append(".each{o | \n\t\t\t\t\t\t\t\tvar temp : ")
_res.append(fQualName)
_res.append("\n\t\t\t\t\t\t\t\ttemp?=o\n\t\t\t\t\t\t\t\tif(temp!=void) then\n\t\t\t\t\t\t\t\t\ttemp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(".remove(temp)\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tend\n")
else
_res.append("\t\t\t\t\t\tvar temp")
_res.append(f.name)
_res.append(" : ")
_res.append(fQualName)
_res.append("\n\t\t\t\t\t\ttemp")
_res.append(f.name)
_res.append(" ?= adapter.getRealObject(ref")
_res.append(f.name)
_res.append(",false)\n\t\t\t\t\t\tif(temp")
_res.append(f.name)
_res.append("!=void) then\n\t\t\t\t\t\t\tif(temp")
_res.append(f.name)
_res.append("==temp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(") then\n\t\t\t\t\t\t\t\ttemp")
_res.append(c.name)
_res.append(".")
_res.append(f.name)
_res.append(":=void\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\t\t\t\t\t\t\n")
end
_res.append("\t\t\t\t\tend\n")
end
_res.append("")
}
_res.append("\t\t\t\tend\n\t\t\tend\n\t\t}\n")
end
		}
_res.append("\t}\n}}")
result := _res.toString
end
}
