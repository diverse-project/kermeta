<%@ ket package="specialize" require="platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt" using="ecore EcoreHelpers" class="AdaptationTemplate"  parameters="classif:Set<EClassifier>, domainMM:String, domainMMPattern:String, shortName:String" %>
/* $Id: bmorin
 * Creation date: August 27, 2007
 * License:
 * Copyright:
 * Authors: Brice Morin
 */

<%var helper:EcoreHelper init EcoreHelper.new%>

package org;
require kermeta
require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "<%=domainMM%>"
require "<%=domainMMPattern%>"

using kermeta::standard
using kermeta::utils
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore
using utils

package smartadapters4<%=shortName%>
{
	package core
	{
		
		class <%=shortName%>Adapter inherits Adapter
		{
			method initConvert(): Void is do
				stdio.write("Mapping MM\' to MM...")
				converter:=Converter.new
				convert:=Hashtable<kermeta::reflection::Class,kermeta::reflection::Class>.new
				<%
				var name:String 
				classif.each{cl |
					var c:EClass
					c?=cl
					if(c!=void) then
						if(not(c.~abstract) and not(c.interface)) then
					name:=helper.getClassifierQualifiedName(c)%>
				convert.put(pattern::<%=name%>,<%=name%>)
					<%end
					end
					}%>
				stdio.writeln("OK!")
			end
		}
		
	package adaptations
	{
		<%classif.each{cl | 
		var c:EClass
		var qualifiedName:String
		qualifiedName:=helper.getClassifierQualifiedName(cl)
		c?=cl
		if(c!=void) then
			if(not(c.~abstract) and not(c.interface)) then%>
		
		class Create<%=c.name%> inherits createAdaptation
		{
			attribute new<%=c.name%>:pattern::<%=qualifiedName%>
					
			method check(): Boolean is do
				result:=new<%=c.name%>!=void
			end
					
			method execute(): Void is do
				var real<%=c.name%>:<%=qualifiedName%>
				if(adapter.created.getValue(new<%=c.name%>)==void or not(isUnique==uniqueType.unique)) then
					real<%=c.name%>?=adapter.converter.convert(Object.clone(new<%=c.name%>), adapter.convert)
					adapter.created.put(new<%=c.name%>,real<%=c.name%>)
				else
					var clone:Boolean init false
					if(isUnique==uniqueType.onDemand) then
						var input:String init stdio.read("create "+new<%=c.name%>.toString+" (true/false) :")
			               clone:=input.toBoolean
					end									
					if(isUnique==uniqueType.non_unique or clone) then
						real<%=c.name%>?=adapter.converter.convert(Object.clone(new<%=c.name%>), adapter.convert)
						adapter.created.put(new<%=c.name%>,real<%=c.name%>)
					end
				end						
			end
		}

		class Clone<%=c.name%> inherits cloneAdaptation
		{
			reference <%=c.name%>ToClone:pattern::<%=qualifiedName%>
			attribute cloned<%=c.name%>:pattern::<%=qualifiedName%>
			
			method check(): Boolean is do
				result:=<%=c.name%>ToClone!=void
			end
			
			method execute(): Void is do
				var realCloned<%=c.name%>:<%=qualifiedName%>
				var temp:<%=qualifiedName%>
				temp?=adapter.getRealObject(<%=c.name%>ToClone,false)
				if(isUnique==uniqueType.unique) then
					if(not(adapter.cloned.exists{o | o==temp})) then
						realCloned<%=c.name%>?=adapter.converter.convert(Object.clone(temp), adapter.convert)
						adapter.created.put(cloned<%=c.name%>,realCloned<%=c.name%>)
						adapter.cloned.add(temp)
					end
				else
					var clone:Boolean init false
					if(isUnique==uniqueType.onDemand) then
						var input:String init stdio.read("clone "+<%=c.name%>ToClone.toString+" (true/false) :")
		                clone:=input.toBoolean
					end
					if(isUnique==uniqueType.non_unique or clone) then
						realCloned<%=c.name%>?=adapter.converter.convert(Object.clone(temp), adapter.convert)
						adapter.created.put(cloned<%=c.name%>,realCloned<%=c.name%>)
						adapter.cloned.add(temp)
					end
				end
			end					
		}
		<%end%>

		class Set<%=c.name%> inherits setAdaptation
		{
			reference <%=c.name%>ToSet:pattern::<%=qualifiedName%>
			<%
			var card:String
			var fQualName:String
			var newObj:kermeta::reflection::Object
			var primitive:kermeta::language::structure::PrimitiveType
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable) then
					fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj
					if(not(f.upperBound==1))then%>
						<%card:="[0..*]"
					else%>
						<%card:=""
					end
					if(primitive==void) then%>
			reference ref<%=f.name%>:pattern::<%=fQualName%><%=card%>
					<%else%>
			reference ref<%=f.name%>:<%=fQualName%><%=card%>
					<%end%>
				<%end
				}%>
			
			method check(): Boolean is do
				result:=ref<%=c.name%>!=void
			end
			
			method execute(): Void is do
				var temp<%=c.name%>:<%=qualifiedName%>
				temp<%=c.name%>?=adapter.getRealObject(ref<%=c.name%>,false)
				if(temp<%=c.name%>!=void) then
					<%c.eAllStructuralFeatures.each{f | 
					if(not(f.derived or f.unsettable) and f.changeable) then	
						fQualName:=helper.getClassifierQualifiedName(f.eType)
						if(not(f.upperBound==1))then%>
						var temp<%=f.name%>:Collection<kermeta::reflection::Object>
						<%else%>
						var temp<%=f.name%>:<%=fQualName%>
						<%end%>
						<%newObj:=f.eType.getMetaClass.new
						primitive?=newObj%>
						if(ref<%=f.name%>!=void) then
							<%if(primitive==void) then%>
							<%if(f.upperBound==1)then%>
							temp<%=f.name%>?=adapter.getRealObject(ref<%=f.name%>,false)
							<%else%>
							temp<%=f.name%>?=adapter.getRealObject(ref<%=f.name%>,true)
							<%end%>
							<%else%>
							temp<%=f.name%>:=ref<%=f.name%>
							<%end%>
							if(temp<%=f.name%>!=void) then
								<%if(f.upperBound==1) then%>
								temp<%=c.name%>.<%=f.name%>:=temp<%=f.name%>
								<%else%>
								temp<%=f.name%>.each{o | 
									var temp:<%=fQualName%>
									temp?=o
									if(temp!=void) then
										temp<%=c.name%>.<%=f.name%>.add(temp)
									end}
								<%end%>
							end
						end
					<%end
					}%>
				end			
			end			
		}
		
		class Unset<%=c.name%> inherits unsetAdaptation
		{
			reference <%=c.name%>ToUnset:pattern::<%=qualifiedName%>
			<%
			c.eAllStructuralFeatures.each{f | 
				if(not(f.derived or f.unsettable) and f.changeable) then%>
					<%fQualName:=helper.getClassifierQualifiedName(f.eType)
					newObj:=f.eType.getMetaClass.new
					primitive?=newObj%>
					<%if(not(f.upperBound==1))then%>
						<%card:="[0..*]"%>
					<%else%>
						<%card:=""%>
					<%end%>
					<%if(primitive==void) then%>
			reference ref<%=f.name%>:pattern::<%=fQualName%><%=card%>
					<%else%>
			reference ref<%=f.name%>:<%=fQualName%><%=card%>
					<%end%>
				<%end%>
			<%}%>
			
			method check(): Boolean is do
				result:=ref<%=c.name%>!=void
			end
			
			method execute(): Void is do
				var temp<%=c.name%>:<%=qualifiedName%>
				temp<%=c.name%>?=adapter.getRealObject(ref<%=c.name%>,false)
				if(temp<%=c.name%>!=void) then
					<%c.eAllStructuralFeatures.each{f | 
					if(not(f.derived or f.unsettable) and f.changeable) then%>
					if(ref<%=f.name%>!=void) then
						<%fQualName:=helper.getClassifierQualifiedName(f.eType)
						if(not(f.upperBound==1))then%>
						var temp<%=f.name%>:Collection<kermeta::reflection::Object>
						temp<%=f.name%>?=adapter.getRealObject(ref<%=f.name%>,true)
						if(temp<%=f.name%>!=void) then
							temp<%=f.name%>.each{o | 
								var temp:<%=fQualName%>
								temp?=o
								if(temp!=void) then
									temp<%=c.name%>.<%=f.name%>.remove(temp)
								end
							}
						end
						<%else%>
						var temp<%=f.name%>:<%=fQualName%>
						temp<%=f.name%>?=adapter.getRealObject(ref<%=f.name%>,false)
						if(temp<%=f.name%>!=void) then
							if(temp<%=f.name%>==temp<%=c.name%>.<%=f.name%>) then
								temp<%=c.name%>.<%=f.name%>:=void
							end
						end						
						<%end%>
					end
				<%end%>
				<%}%>
				end
			end
		}
		<%end
		}%>
	}
}}