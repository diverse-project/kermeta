/* $Id: CustomWeaver.kmt,v 1.4 2008-06-24 14:39:11 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright: IRISA / INRIA Rennes Bretagne Atlantique
 * Authors: Brice Morin bmorin@irisa.fr
 */

package weaver;

require kermeta

require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/flora2/PatternMatchingFlora2.kmt"

using kermeta::standard 
using kermeta::utils
using kermeta::persistence
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using kermeta::pattern
using kermeta::pattern::flora2

class Weaver
{	
	attribute matcher : PatternMatchingFlora2
	attribute handler : EcoreHelpers::EcoreHelper
	attribute resourceModel : Resource
	
	attribute inputMetamodel : Sequence<ecore::EPackage>
	attribute inputPatternMetamodel : Sequence<ecore::EPackage>
	
	attribute adapter : Adapter
	
	operation initWeaver() is
	do
		if matcher == void then
			matcher := PatternMatchingFlora2.new
		end
		if handler == void then
			handler := EcoreHelpers::EcoreHelper.new   	  
	    	handler.initialize()
		end
		if inputMetamodel == void then
			inputMetamodel := Sequence<ecore::EPackage>.new 
		end
		if inputPatternMetamodel == void then
			inputPatternMetamodel := Sequence<ecore::EPackage>.new
		end
	end
		
	operation loadMetamodel(domainMMUri : String) is
	do
		inputMetamodel.clear
		inputMetamodel.addAll(handler.loadEcoreModel(EMFRepository.new,domainMMUri))
	end
	
	operation loadMetamodelPattern(domainMMPatternUri : String) is
	do
		inputPatternMetamodel.clear
		inputPatternMetamodel.addAll(handler.loadEcoreModel(EMFRepository.new, domainMMPatternUri))
	end
	
	operation loadModel(baseModelUri : String, domainMMUri : String) is
	do
		resourceModel := EMFRepository.new.createResource(baseModelUri, domainMMUri)
		resourceModel.load
	end
	
	operation loadAdapter(adapterUri : String, adaptMMUri : String) is
	do
		var resourceAdapter : Resource init EMFRepository.new.createResource(adapterUri, adaptMMUri)
		resourceAdapter.load
		adapter ?= resourceAdapter.instances.one
	end

	operation saveModel(model : String, metamodel : String)is
	do  	
    	resourceModel.saveWithNewURI(model) 
	end

	operation finalizeWeaver() is
	do
		if matcher == void then
			matcher.finalize
		end
	end

	operation weaving(domainMMUri : String, domainMMPatternUri : String) : Void is do
		/*var continue : Boolean init true
		stdio.writeln("Checking all invariants before weaving")
		do
			resourceModel.instances.one.checkAllInvariantsIte
		rescue (e : kermeta::exceptions::ConstraintViolatedInv)
			stdio.errorln(e.message)
			do 
				continue := stdio.read("$>Base model violates invariants. Continue weaving ? (y/n): ").toBoolean
			rescue (e2 : kermeta::exceptions::Exception)
				stdio.errorln("Cannot read value. Default value = n")
				continue := false
			end
		end
		stdio.writeln("")
	
		if continue then*/
	
			adapter.initClone
		
			/*---Pattern matching---*/
			stdio.writeln("Searching base model elements matching the interface model...")
			stdio.writeln("- The Metamodel and the model are transformed into a Prolog knowledge base")
			stdio.writeln("- The inferface model (~pointcut) is tranformed into a Prolog query")
			
			var iteBindings : Iterator<Hashtable<Object, Object>> 
			init Iterator<Hashtable<Object, Object>>.new
			iteBindings := matcher.optimizedMatch(inputMetamodel, resourceModel.instances, adapter.~aspect.template, true, false, false)
					       
			/*---Applying the adapter to the base model---*/       
			var binding : Hashtable<Object, Object>			
			adapter.setDisplayInfo(false)
			stdio.writeln("Weaving the graft model into the base model...")
			stdio.writeln("  - contextualization of the interface model with the result of the Prolog query")
			stdio.writeln("  - conversion MM' (interface/graft model) -> MM (base model)")
			stdio.writeln("  - execution of the sequence of adaptations")
			if iteBindings.hasNext() then
				adapter.apply(iteBindings.next) //aspect weaving: do not require domain concepts
			else
				stdio.writeln("No join point!")
			end
			
			/*stdio.writeln("")
			stdio.writeln("Checking all invariants after weaving")
			do
				resourceModel.instances.one.checkAllInvariantsIte
			rescue (e : kermeta::exceptions::ConstraintViolatedInv)
				stdio.errorln(e.message)
				//stdio.errorln(e.stackTrace)
			end*/
			stdio.writeln("")
		//end	
	end	
}