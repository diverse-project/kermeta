/* $Id: CustomWeaver.kmt,v 1.5 2008-07-04 10:04:45 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright: IRISA / INRIA Rennes Bretagne Atlantique
 * Authors: Brice Morin bmorin@irisa.fr
 */

package weaver;

require kermeta

require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/flora2/PatternMatchingFlora2.kmt"

using kermeta::standard 
using kermeta::utils
using kermeta::persistence
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using kermeta::pattern
using kermeta::pattern::flora2

class Weaver
{	
	attribute matcher : PatternMatchingFlora2
	attribute handler : EcoreHelpers::EcoreHelper
	attribute resourceModel : Resource
	
	attribute inputMetamodel : Sequence<ecore::EPackage>
	attribute inputPatternMetamodel : Sequence<ecore::EPackage>
	
	attribute adapter : Adapter
	
	attribute keepModelFacts : Boolean
	attribute keepQuery : Boolean
	
	operation initWeaver() is
	do
		keepModelFacts := false
		keepQuery := false
		if matcher == void then
			matcher := PatternMatchingFlora2.new
		end
		if handler == void then
			handler := EcoreHelpers::EcoreHelper.new   	  
	    	handler.initialize()
		end
		if inputMetamodel == void then
			inputMetamodel := Sequence<ecore::EPackage>.new 
		end
		if inputPatternMetamodel == void then
			inputPatternMetamodel := Sequence<ecore::EPackage>.new
		end
	end
		
	operation loadMetamodel(domainMMUri : String) is
	do
		inputMetamodel.clear
		inputMetamodel.addAll(handler.loadEcoreModel(EMFRepository.new,domainMMUri))
	end
	
	operation loadMetamodelPattern(domainMMPatternUri : String) is
	do
		inputPatternMetamodel.clear
		inputPatternMetamodel.addAll(handler.loadEcoreModel(EMFRepository.new, domainMMPatternUri))
	end
	
	operation loadModel(baseModelUri : String, domainMMUri : String) is
	do
		resourceModel := EMFRepository.new.createResource(baseModelUri, domainMMUri)
		resourceModel.load
	end
	
	operation loadAdapter(adapterUri : String, adaptMMUri : String) is
	do
		var resourceAdapter : Resource init EMFRepository.new.createResource(adapterUri, adaptMMUri)
		resourceAdapter.load
		adapter ?= resourceAdapter.instances.one
	end

	operation saveModel(model : String, metamodel : String)is
	do  
		stdio.errorln(model+", "+metamodel)
		var repository : EMFRepository init EMFRepository.new
		var newResource : Resource init repository.createResource(model,metamodel)
		newResource.instances.add(resourceModel.one)
		newResource.saveWithNewURI(model)
    	//resourceModel.saveWithNewURI(model) 
	end

	operation finalizeWeaver() is
	do
		if matcher == void then
			matcher.finalize
		end
	end

	operation weaving(domainMMUri : String, domainMMPatternUri : String) : Void is do
			var time : Integer

			adapter.initClone
		
			/*---Pattern matching---*/
			stdio.writeln("Searching base model elements matching the interface model...")
			stdio.writeln("- The Metamodel and the model are transformed into a Prolog knowledge base")
			stdio.writeln("- The inferface model (~pointcut) is tranformed into a Prolog query")
			
			var iteBindings : Iterator<Hashtable<Object, Object>> 
			init Iterator<Hashtable<Object, Object>>.new
			/*
			 * Boolean: 
			 * 1) does the metamodel remain unchanged ? 
			 * 2) does the model remain unchanged or the weaving do not make new join points to appear
			 *     -> TODO: Freddy
			 * 3) does the query remain unchanged
			 */
			extern org::diva::causalLink::smartadapters::fractal::KermetaDate.start(self)
			iteBindings := matcher.optimizedMatch(inputMetamodel, resourceModel.instances, adapter.~aspect.template, true, keepModelFacts, keepQuery)
			time ?= extern org::diva::causalLink::smartadapters::fractal::KermetaDate.getTime(self)
			stdio.errorln("Matching took "+(time.toReal/(1000.toReal)).toString+" s")
					       
			/*---Applying the adapter to the base model---*/       
			var binding : Hashtable<Object, Object>			
			adapter.setDisplayInfo(true)
			stdio.writeln("Weaving the graft model into the base model...")
			stdio.writeln("  - contextualization of the interface model with the result of the Prolog query")
			stdio.writeln("  - conversion MM' (interface/graft model) -> MM (base model)")
			stdio.writeln("  - execution of the sequence of adaptations")

			if not iteBindings.hasNext() then
				stdio.errorln("No join point!")
			else		
				from iteBindings
				until iteBindings.isOff
				loop
					extern org::diva::causalLink::smartadapters::fractal::KermetaDate.start(self)
					adapter.apply(iteBindings.next) //aspect weaving: do not require domain concepts
					if iteBindings.hasNext() then
						adapter.updateClones
					end
					time ?= extern org::diva::causalLink::smartadapters::fractal::KermetaDate.getTime(self)
					stdio.errorln("Weaving took "+(time.toReal/(1000.toReal)).toString+" s")	
				end
					
				stdio.writeln("")
				stdio.writeln("Checking all invariants after weaving")
				extern org::diva::causalLink::smartadapters::fractal::KermetaDate.start(self)
				do	
					resourceModel.instances.one.checkAllInvariants
				rescue (e : kermeta::exceptions::ConstraintViolatedInv)
					stdio.errorln(e.message)
				end
				time ?= extern org::diva::causalLink::smartadapters::fractal::KermetaDate.getTime(self)
				stdio.errorln("Checking invariants took "+(time.toReal/(1000.toReal)).toString+" s")
				stdio.writeln("")
			end
	end	
}