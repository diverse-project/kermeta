/* $Id: semanticWeaver.kmt,v 1.1 2007-07-18 06:58:24 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright:
 * Authors: bmorin
 */
@mainClass "weaver::SemanticWeaver"
@mainOperation "main"


package weaver;


require kermeta
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/flora2/PatternMatchingFlora2.kmt"

using ecore
using EcoreHelpers
using kermeta::standard
using kermeta::utils
using kermeta::persistence
using patternframework
using kermeta::pattern
using kermeta::pattern::flora2

class SemanticWeaver
{
	operation weavingSemantic(domainMM:String, ecore:String, ecorePattern:String, pattern:String) : Void is do
		var handler : EcoreHelpers::EcoreHelper init EcoreHelpers::EcoreHelper.new   	  
	    handler.initialize()
		var repository:EMFRepository init EMFRepository.new

		var inputMetamodel:Sequence<EPackage> init handler.loadEcoreModel(EMFRepository.new, ecore)
		var inputPatternMetamodel:Sequence<EPackage> init handler.loadEcoreModel(EMFRepository.new, ecorePattern)

		var inputModel:Set<Object> init Set<Object>.new
		var tempModel:Sequence<EPackage> init handler.loadEcoreModel(repository, ecore)
		tempModel.each{p | inputModel.add(p)}
		
		
		var inputPattern:Set<Object> init loadModel(repository, pattern, ecorePattern)
		var p:ModelPattern
		p?=inputPattern.select{o | ModelPattern.isInstance(o)}.first
		
		var matcher : PatternMatching init PatternMatchingFlora2.new
        var iteBindings : Iterator<Hashtable<Object, Object>> init Iterator<Hashtable<Object, Object>>.new
        iteBindings := matcher.match(inputMetamodel, inputModel, p)
        stdio.writeln("") 
        stdio.writeln("")
        stdio.writeln("") 
        var hash : Hashtable<Object, Object>
		var keys:Set<Object>
		var i:Integer init 0
		from iteBindings until iteBindings.isOff loop 
		     hash := iteBindings.next
			 i:=i+1
			 stdio.writeln("")
			 stdio.writeln("")
		     stdio.writeln("  -Binding"+i.toString+":")
			 keys:=hash.keys
			 keys.each{k | stdio.writeln(k.toString+" -> "+hash.getValue(k).toString)}                 
		end
	end
	
	
	operation loadModel(repository : EMFRepository, modelPath : String, metamodelPath : String) : Set<kermeta::standard::Object> is do                   
    	stdio.writeln("  loading: "+modelPath+"("+metamodelPath+")")
   		var resource : Resource init repository.createResource(modelPath, metamodelPath)
       	resource.load()
       	//stdio.writeln("  loading: OK!")
        result := resource.instances
    end	
	
    operation saveModel(obj : Set<Object>, uri : String, domainMM : String) is do
    	var repository:EMFRepository init EMFRepository.new
	    var resource : Resource init repository.createResource(uri , domainMM)
	    obj.each{o | resource.instances.add(o)}
	    resource.save
    end
}