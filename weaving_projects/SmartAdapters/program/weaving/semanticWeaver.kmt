/* $Id: semanticWeaver.kmt,v 1.2 2007-07-18 12:20:47 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright:
 * Authors: bmorin
 */
@mainClass "weaver::SemanticWeaver"
@mainOperation "main"


package weaver;


require kermeta
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/flora2/PatternMatchingFlora2.kmt"
require "platform:/resource/SmartAdapters/metamodel/domain/EcorePattern.ecore"

using ecore
using EcoreHelpers
using kermeta::standard
using kermeta::utils
using kermeta::persistence
using patternframework
using kermeta::pattern
using kermeta::pattern::flora2

class SemanticWeaver
{
	operation weavingSemantic(domainMM:String, ecore:String, patternFramework:String, pattern:String) : Void is do
		var handler : EcoreHelpers::EcoreHelper init EcoreHelpers::EcoreHelper.new   	  
	    handler.initialize()
		var repository:EMFRepository init EMFRepository.new

		var inputMetamodel:Sequence<EPackage> init handler.loadEcoreModel(EMFRepository.new, ecore)
		inputMetamodel.each{o | stdio.writeln(o.name)}

		var inputModel:Set<Object> init loadModel(repository, domainMM, ecore)
		/*var tempModel:Sequence<EPackage> init handler.loadEcoreModel(repository, domainMM)
		tempModel.each{p | 
			stdio.writeln("  "+p.name)
			getAllNestedClassifiers(p).each{o | inputModel.add(o)}}*/
		inputModel.each{o | stdio.writeln("    "+o.toString)}
				
		var inputPattern:Set<Object> init loadModel(EMFRepository.new, pattern, patternFramework)
		var p:ModelPattern
		p?=inputPattern.select{o | ModelPattern.isInstance(o)}.first

		var matcher : PatternMatching init PatternMatchingFlora2.new
        var iteBindings : Iterator<Hashtable<Object, Object>> init Iterator<Hashtable<Object, Object>>.new
        stdio.writeln("Executing pattern matching...")
        iteBindings := matcher.match(inputMetamodel, inputModel, p)
        stdio.writeln("") 
        stdio.writeln("")
        stdio.writeln("") 
        var hash : Hashtable<Object, Object>
		var keys:Set<Object>
		var i:Integer init 0
		from iteBindings until iteBindings.isOff loop 
		     hash := iteBindings.next
			 i:=i+1
			 stdio.writeln("")
			 stdio.writeln("")
		     stdio.writeln("  -Binding"+i.toString+":")
			 keys:=hash.keys
			 keys.each{k | stdio.writeln(k.toString+" -> "+hash.getValue(k).toString)}                 
		end
	end
	
	
	operation loadModel(repository : EMFRepository, modelPath : String, metamodelPath : String) : Set<kermeta::standard::Object> is do                   
    	stdio.writeln("  loading: "+modelPath+"("+metamodelPath+")")
   		var resource : Resource init repository.createResource(modelPath, metamodelPath)
       	resource.load()
       	//stdio.writeln("  loading: OK!")
        result := resource.instances
    end	
	
    operation saveModel(obj : Set<Object>, uri : String, domainMM : String) is do
    	var repository:EMFRepository init EMFRepository.new
	    var resource : Resource init repository.createResource(uri , domainMM)
	    obj.each{o | resource.instances.add(o)}
	    resource.save
    end
    
    operation getAllNestedClassifiers(pack : EPackage) : Set<EClassifier> is do
       var eclassifiers : Set<EClassifier> init Set<EClassifier>.new
       eclassifiers.addAll( pack.eClassifiers)
       pack.eSubpackages.each{ subpack | 
                eclassifiers.addAll( getAllNestedClassifiers(subpack))}
       result := eclassifiers
    end    
}