/* $Id: weaver.kmt,v 1.18 2008-03-11 14:34:29 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright:
 * Authors: bmorin
 */

package weaver;
 
require kermeta

require "platform:/resource/SmartAdapters/program/weaving/print.kmt"
require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/flora2/PatternMatchingFlora2.kmt"

 
using ecore
using kermeta::standard 
using kermeta::utils
using kermeta::persistence
using patternframework
using org::smartadapters::core
using kermeta::pattern
using kermeta::pattern::flora2

class Weaver
{
	operation weaving(baseModelUri:String, adapterUri:String, adaptMMUri:String, domainMMUri:String, domainMMPatternUri:String, resultUri:String) : Void is do 
		var handler : EcoreHelpers::EcoreHelper init EcoreHelpers::EcoreHelper.new   	  
	    handler.initialize()
		var repository:EMFRepository init EMFRepository.new

		var inputMetamodel:Sequence<EPackage> init Sequence<EPackage>.new 
		handler.loadEcoreModel(EMFRepository.new, domainMMUri).each{p | inputMetamodel.add(p)}
		var inputPatternMetamodel:Sequence<EPackage> init Sequence<EPackage>.new 
		handler.loadEcoreModel(EMFRepository.new, domainMMPatternUri).each{p | inputPatternMetamodel.add(p)}

		stdio.writeln("Loading models...")
		var inputModel:Set<Object> init loadModel(repository, baseModelUri, domainMMUri)
		var rootElement : Object init inputModel.one
		var inputAdapter:Set<Object> init loadModel(repository, adapterUri, adaptMMUri)

		var adapter:Adapter
		inputAdapter.each{o | 
							var temp:Adapter
							temp?=o
							if(temp!=void) then
								adapter:=temp
							end
						}
		stdio.writeln(" OK!")

		adapter.checkAllInvariants
		
		var doWeave : Boolean
		var doUnweave : Boolean
		var doMatch : Boolean
		var displayInfo : Boolean
		
		stdio.writeln("Initializing default actions")
		doWeave := stdio.read("$>default value for doWeave ? (true/false): ").toBoolean
		doUnweave := stdio.read("$>default value for doUnweave ? (true/false): ").toBoolean
		doMatch := stdio.read("$>default value for doMatch ? (true/false): ").toBoolean
		displayInfo := stdio.read("$>display weaving info ? (y/n): ").toBoolean
		stdio.writeln("")
		
		if (adapter.adapt.size>0) then
			stdio.writeln(" OK!")
			adapter.initClone
			
			if (adapter.~aspect.template != void) then
				/*---Pattern matching---*/
				stdio.writeln("Searching base model elements matching template...")
		        var matcher : PatternMatching init PatternMatchingFlora2.new
		        var iteBindings : Iterator<Hashtable<Object, Object>> 
		        	init Iterator<Hashtable<Object, Object>>.new
		        iteBindings := matcher.optimizedMatch(inputMetamodel, inputModel, adapter.~aspect.template, true, false, true)
		        stdio.writeln("") 
		        stdio.writeln("")
		        stdio.writeln("")                
		
	                         	
				/*---Applying the adapter to the base model---*/       
				var i : Integer init 0
				var binding : Hashtable<Object, Object>			
				var doAction : Boolean
			 	adapter.setDisplayInfo(displayInfo)
			 	//iterating on bindings
				from iteBindings until iteBindings.isOff loop 
					 doAction := false
				     binding := iteBindings.next
					 i:=i+1
					 stdio.writeln("")
					 stdio.writeln("")
					 //display current binding
				     stdio.writeln("Binding"+i.toString+":")
				     stdio.writeln("*******************************************")
					 binding.keys.each{k | stdio.write("-------\n"+k.printObject+"bound to\n"+binding.getValue(k).printObject)}
					 stdio.writeln("*******************************************")
					 stdio.writeln("")				 
					 //interaction with user
					 do
						 doAction := stdio.read("$>weave the aspect for this binding ? (y/n/default=any): ").toBoolean
					 rescue (e : kermeta::exceptions::Exception)
					 	doAction := doWeave
					 end
					 //apply composition protocol for the current binding
					 if doAction then
					 	stdio.writeln("----------------------------")
					 	stdio.writeln("#>weaving the aspect for binding"+i.toString+"...")
						adapter.apply(binding, rootElement) //aspect weaving: do not require domain concepts
					 	stdio.writeln("#>weaving the aspect for binding"+i.toString+" done!")
					 	stdio.writeln("----------------------------")
					 	stdio.writeln("")
					 	//interaction with user
					 	do
					 		doAction := stdio.read("$>unweave the aspect for this binding ? (y/n/default=any): ").toBoolean
					 	rescue (e : kermeta::exceptions::Exception)
					 		doAction := doUnweave
					 	end
					 	if doAction then
					 		stdio.writeln("----------------------------")
					 		stdio.writeln("#>unweaving the aspect for binding"+i.toString+"...")
					 		adapter.unweave(rootElement)
					 		stdio.writeln("#>unweaving the aspect for binding"+i.toString+" done!")
					 		stdio.writeln("----------------------------")
					 		stdio.writeln("")
					 	end
					 	adapter.updateClones
					 	if (iteBindings.hasNext and not doAction) then //weaving + unweaving = no change
					 		//interaction with user
						 	do
						 		doAction := stdio.read("$>execute pattern matching ? (y/n/default=any): ").toBoolean
						 	rescue (e : kermeta::exceptions::Exception)
						 		doAction := doMatch
						 	end
						 	//executing pattern matching again 
						 	//(the composition might have change the base model)
						 	if doAction then
						 		iteBindings := Iterator<Hashtable<Object, Object>>.new
						 		iteBindings := matcher.optimizedMatch(inputMetamodel, inputModel, adapter.~aspect.template, true, false, true)
						 		i := 0
						 	end
						else
							matcher.finalize
						end
					 end     
				end	
				end
			/*
			Saving modified base model
			*/
			stdio.writeln("Saving Result")
			inputModel.clear
			inputModel.add(rootElement)
			saveModel(inputModel, resultUri, domainMMUri)		
		else
			var e:kermeta::exceptions::Exception init kermeta::exceptions::Exception.new
			e.message:="WeaverException: Adapter contains no adaptation or at least one adaptation is not well typed"
			raise e
		end		
	end

    operation loadModel(repository : EMFRepository, modelPath : String, metamodelPath : String) : Set<kermeta::standard::Object> is do                   
    	stdio.writeln("  loading: "+modelPath+" ("+metamodelPath+")")
   		var resource : Resource init repository.createResource(modelPath, metamodelPath)
       	resource.load()
        result := resource.instances
    end	
	
    operation saveModel(obj : Set<Object>, uri : String, domainMM : String) is do
 		stdio.writeln("  saving: "+uri+" ("+domainMM+")")
    	var repository : EMFRepository init EMFRepository.new
	    var resource : Resource init repository.createResource(uri , domainMM)
	    obj.each{o | resource.instances.add(o)}
	    resource.save
    end
}