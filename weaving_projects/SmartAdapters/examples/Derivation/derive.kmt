/* $Id: derive.kmt,v 1.4 2008-02-20 17:51:53 bmorin Exp $
 * Creation date: April 23, 2007
 * License:
 * Copyright:
 * Authors:
 */
@mainClass "root_package::Derive"
@mainOperation "main"


package root_package;


require kermeta
require "platform:/resource/SmartAdapters/metamodel/specific/FSM_AOM_Framework2.kmt"
require "platform:/plugin/fr.irisa.triskell.kermeta.ecore/src/kermeta/helpers/EcoreHelper.kmt"

using ecore
using EcoreHelpers
using kermeta::standard
using kermeta::persistence
using org::smartadapters::core
using org::smartadapters::core::adaptations
using org::smartadapters::extension

class Derive
{
	/**
	TODO : quand le problème EMF/kermeta de chargement multiple sera résolu, mettre sous la forme d'un moteur de dérivation
	input : 2 uri : derivable adapter + derivation
	output : adapter
	*/
	operation main() : Void is do 
		var handler : EcoreHelpers::EcoreHelper init EcoreHelpers::EcoreHelper.new
		var repository:EMFRepository init EMFRepository.new
	    handler.initialize()

		/**
		Creating adaptations
		*/
		var adapt1:Adaptation init SetState.new
		adapt1.name:="adapt1"
		adapt1.isOptional:=false
		
		var adapt2:Adaptation init SetTransition.new
		adapt2.name:="adapt2"
		adapt2.isOptional:=false
		
		var adapt3:Adaptation init SetTransition.new
		adapt3.name:="adapt3"
		adapt3.isOptional:=false
		
		var adapt4:Adaptation init SetTransition.new
		adapt4.name:="adapt4"
		adapt4.isOptional:=true
		
		/**
		Creating conjunctions
		*/
		//conj1 = {adapt1 AND adapt2}
		var conj1:EntityConjunction init EntityConjunction.new
		conj1.name:="conj1"
		conj1.isOptional:=false
		conj1.~and.add(adapt1)
		conj1.~and.add(adapt2)
				
		/**
		Creating alternatives
		*/
		//alt1 = {conj1 XOR adapt3} = {{adapt1 AND adapt2} XOR adapt3}
		var alt1:EntityAlternative init EntityAlternative.new
		alt1.name:="alt1"
		alt1.isOptional:=false
		alt1.xor.add(conj1)
		alt1.xor.add(adapt3)
		
		/**
		Creating constraints
		*/
		//c1 : conj1 REQUIRES adapt4
		var c1:Dependency init Dependency.new
		c1.source:=conj1
		c1.dependencies.add(adapt4)
		
		//c2 : c2 EXCLUDES {adapt3, adapt4}
		var c2:MutualExclusion init MutualExclusion.new
		c2.entities.add(adapt3)
		c2.entities.add(adapt4)
		
		/**
		Creating a derivable adapter
		*/
		var derivable:DerivableAdapter init DerivableAdapter.new
		derivable.adapt.add(adapt4)
		derivable.alternatives.add(alt1)
		derivable.constraints.add(c1)
		derivable.constraints.add(c2)
		
		/**
		Création d'une dérivation (cohérente) produisant un adapter concret
		*/
		var derivation:Derivation init Derivation.new
		var elt1:DerivationElement init DerivationElement.new
		derivation.elements.add(elt1)
		elt1.alternative:=alt1

		//elt1.selectedVariant:=adapt3

		elt1.selectedVariant:=conj1
		derivation.selectedOptions.add(adapt4)
		
		/**
		Deriving derivable adapter according to the derivation and saving the result
		*/
		var resultAdapter:Set<Object> init Set<Object>.new
		var resultAdapt:Adapter init derivable.resolve(derivation)
		resultAdapter.add(resultAdapt)
		stdio.write("Saving result...")
		saveModel(resultAdapter, "platform:/resource/SmartAdapters/examples/Derivation/result.xmi", "platform:/resource/SmartAdapters/metamodel/specific/FSM_AOM_Framework.ecore")
		stdio.writeln("  OK!")


		/*Loading Adapter and Derivation does not work because 
		elements shared between Adapter and Derivation are loaded twice...
		cf bug on forge
		*/
/*			
	
		var adaptMM:String init "../../metamodel/specificSmartAdapters/FSM-specificSmartAdapters.ecore"
		var derivable:String init "./DerivableAdapter.xmi"
		var derivationModel:String init "./Derivation.xmi"
		
		var inputAdapter:Set<Object> init loadModel(repository, derivable, adaptMM)
		var inputDerivation:Set<Object> init loadModel(repository,derivationModel, adaptMM)

		var derivableAdapter:DerivableAdapter
		derivableAdapter?=inputAdapter.select{o | DerivableAdapter.isInstance(o)}.first
		
		var derivation:Derivation
		derivation?=inputDerivation.select{o | Derivation.isInstance(o)}.first
		
		var resultAdapter:Set<Object> init Set<Object>.new
		resultAdapter.add(derivableAdapter.resolve(derivation))
		saveModel(resultAdapter, "./result.xmi", adaptMM)
*/	
	end
	
	operation loadModel(repository : EMFRepository, modelPath : String, metamodelPath : String) : Set<kermeta::standard::Object> is do                   
   		var resource : Resource init repository.createResource(modelPath, metamodelPath)
       	resource.load()
        result := resource.instances
    end	
	
    operation saveModel(obj : Set<Object>, uri : String, domainMM : String) is do
    	var repository:EMFRepository init EMFRepository.new
	    var resource : Resource init repository.createResource(uri , domainMM)
	    obj.each{o | resource.instances.add(o)}
	    resource.save
    end	
}