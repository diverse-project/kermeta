/* $Id: genericSmartAdapters.kmt,v 1.6 2008-01-09 13:15:28 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright:
 * Authors: bmorin
 */

package org;

require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdaptersBase.kmt"
require "platform:/resource/SmartAdapters/program/weaving/converter.kmt"

require "platform:/resource/SmartAdapters/metamodel/domain/FSMMM.ecore"
require "platform:/resource/SmartAdapters/metamodel/domain/FSMMMPattern.ecore"

using kermeta::standard
using kermeta::utils
using kermeta::persistence
using kermeta::exceptions
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore
using org::smartadapters::utils

package smartadapters
{
	package core
	{
		@aspect "true"
		class Adapter
		{	
			/**
			key : aspect element
			value : associated clone
			*/
			attribute clone : Hashtable<Object, Object>
			attribute binding : Hashtable<Object, Object>
			attribute cloned : Set<Object>
			attribute convert : Hashtable<kermeta::reflection::Class,kermeta::reflection::Class>
			attribute enum : Hashtable<kermeta::reflection::Enumeration,kermeta::reflection::Enumeration>
			attribute converter : Converter
			
			operation initConvert() : Void is abstract
			
			operation apply(b:Hashtable<Object, Object>) is do
				binding := b
				
				adapt.each{a |
					stdio.writeln("#>"+a.getMetaClass.name+"...") 
					a.execute()
					stdio.writeln("#>done!")
				}
	
				/*clone.keys.each{k | 
					stdio.writeln("clone: "+k.toString+", "+clone.getValue(k).toString)
				}
				cloned.each{k | 
					stdio.writeln("cloned: "+k.toString)
				}*/
		
				updateClones
			end
			
			operation initAdapter() : Void is 
			do
				if (clone == void) then
					clone := Hashtable<Object, Object>.new
				end
				if (convert == void) then
					initConvert
				end
				if (cloned == void) then
					cloned := Set<Object>.new
				end
			end		
				
			/**
			initClone must be called before the first binding
			*/
			operation initClone() is do
				initAdapter
				if (aspect.structure!=void) then
					aspect.structure.content.each{elt |
							var newCloned:Object
							newCloned:=converter.getConverted(elt)
							if (newCloned!=void) then
								clone.put(elt, newCloned)
							end
					}
				end
			end
			
			/**
			updateClone must be called after every binding
			*/
			operation updateClones() is do
				//stdio.writeln("updateClones...")
				if (aspect.structure!=void) then
					aspect.structure.content.each{o | 
						if (not(aspect.persistent.contains(o))) then
							//stdio.writeln("updateClone: "+o.toString)
							updateClone(o,void)
						end
					}
				end
				//stdio.writeln("updateClones: END!")
			end
			
			operation updateClone(handler : Object, template : Object) is do
				//stdio.writeln("?>  updateClone "+pObj.toString+" ("+template.toString+") ")
				clone.remove(handler)
				converter.deleteConverted(handler)
			
				var realHandler : Object
				var realTemplate : Object
			
				if (template != void) then
					//stdio.writeln("?>   template != void")
					realTemplate := getRealObject(template,false)
					realHandler:=Object.clone(realTemplate)
					cloned.remove(realTemplate)
				else
					//stdio.writeln("?>   template == void")
					realHandler:=converter.getConverted(handler)
				end
				if (realHandler != void) then
					//stdio.writeln("?>   new clone created")
					clone.put(handler, realHandler)
					if (template != void) then
						cloned.add(realTemplate)
					end
				end
				//stdio.writeln(newCloned.toString)
			end

			operation cloneAgain(handler : Object, template : Object, type : uniqueType)	: Void is do
				//stdio.writeln("operation cloneAgain " + (template!=void).toString)
				
				var toClone : Boolean init type == uniqueType.non_unique
				if (not(toClone) and type == uniqueType.unique) then
					//stdio.writeln("?>unique")
					if (template != void) then
						cloned.each{o | stdio.writeln("cloned: "+o.toString)}
						toClone := not(cloned.contains(getRealObject(template,false)))
						clone.remove(handler)
						clone.put(handler, getRealObject(template,false))
					else
						toClone := not(clone.containsKey(handler)) 
					end
				end
				if (not(toClone) and type == uniqueType.onDemand) then
					var input : String init stdio.read("$>clone "+handler.toString+" (true/false) :")
			        toClone := input.toBoolean
				end
				
				stdio.writeln(toClone.toString)
				
				if (toClone) then
					//stdio.writeln("?>updating clones...")
					if(template != void) then
						//stdio.writeln("?>  with template")
						updateClone(handler,template)
					else
						//stdio.writeln("?>  from scratch")
						updateClone(handler,void)
					end
				end
				
				stdio.writeln(getRealObject(handler,false).toString)
				clone.keys.each{k |
					var a : pattern::FSM::State
					var b : FSM::State
					a ?= k
					b ?= clone.getValue(k) 
					if(a != void and b != void) then
						stdio.writeln("clone: "+a.name+" -> "+b.name)
					end
				}
				binding.keys.each{k | 
					var a : pattern::FSM::State
					var b : FSM::State
					a ?= k
					b ?= binding.getValue(k)
					if(a != void and b != void) then 
						stdio.writeln("binding: "+a.name+" -> "+b.name)
					end
				}
			end
			
			operation setMultipleProperty(prty : Object, o : Object) : Void is do
				//stdio.writeln("  setProperty: "+prty.toString+", "+o.toString)
				if(o != void) then
					var coll : Collection<kermeta::reflection::Object>
					var collToSet : Collection<kermeta::reflection::Object>
					coll ?= o
					collToSet ?= prty
					if(coll != void and collToSet != void and coll.size > 0) then
						var realColl : Collection<kermeta::reflection::Object>
						realColl ?= getRealObject(o,true)
						collToSet.addAll(realColl)
					end
				end
			end
			
			operation setSingleProperty(o : Object, old : Object) : Object is do
				if(o != void) then
					result := getRealObject(o,false)
				else
					result := old
				end
			end

			operation unsetSingleProperty(o : Object, old : Object) : Object is do
				if(o != void) then
					result := void
				else
					result := old
				end
			end

			operation unsetMultipleProperty(prty : Object, o : Object) : Void is do
				//stdio.writeln("unsetProperty: "+prty.toString+", "+o.toString)
				if(prty != void and o != void) then
					var coll : Collection<kermeta::reflection::Object>
					var collToSet : Collection<kermeta::reflection::Object>
					coll ?= o
					collToSet ?= prty
					if(coll != void and collToSet != void) then
						//stdio.writeln("  unsetProperty: Collection")
						var realColl : Collection<kermeta::reflection::Object>
						realColl ?= getRealObject(o,true)
						realColl.each{o |
							collToSet.remove(o)
						}
					end
				end
			end			
						
			operation getRealObject(obj : Object, isCollect:Boolean) : Object is do
				if (isCollect) then
					var col : Collection<kermeta::reflection::Object>
					col ?= obj
					var res : Set<Object> init Set<Object>.new
					col.each{o | res.add(getRealObject(o,false))}
					result := res
				else
					var realObj : Object
					realObj := clone.getValue(obj)
					if (realObj != void) then
						result := realObj
					else
						realObj := binding.getValue(obj)
						if (realObj != void) then
							result := realObj
						else
							var pObj : PObject
							pObj ?= obj
							if (pObj != void) then
								result := converter.getConverted(obj)
							else
								result := obj
							end
						end
					end
				end			
			end
		}
	}
	
	package extension
	{
		@aspect "true"
		class DerivableAdapter inherits Adapter
		{
			operation resolve(derivation:Derivation):Adapter is do
				var adapter:DerivableAdapter init DerivableAdapter.new
				var isChecked:Boolean init true
				constraints.each{c | isChecked:=isChecked and c.check(derivation)}
				if(isChecked) then
					adapt.each{a | adapter.addAdaptation(derivation,a)}
					alternatives.each{a | adapter.addAlternative(derivation,a)}
					if(adapter.isConcretizable) then
						var concreteAdapter:Adapter init Adapter.new
						converter.addEntry(adapter.getMetaClass,concreteAdapter.getMetaClass)
						adapter.adapt.each{a | converter.addEntry(a.getMetaClass, a.getMetaClass)}
						if(converter==void) then
							converter:=Converter.new
						end
						concreteAdapter?=converter.getConverted(adapter)
						result:=concreteAdapter
					else
						result:=adapter
					end					
				else
					var e:NonApplicableDerivation init NonApplicableDerivation.new
					e.display
					raise e
				end
			end
			
			operation addAdaptation(d:Derivation, a:Adaptation) is do
				if(not(a.isOptional) or d.selectedOptions.contains(a)) then
					adapt.add(a)
				end
			end
			
			operation addConjunction(d:Derivation, c:EntityConjunction) is do
				if(not(c.isOptional) or d.selectedOptions.contains(c)) then
					c.~and.each{e |
						var a:Adaptation
						a?=e
						if(a!=void) then
							addAdaptation(d,a)
						else
							var alt:EntityAlternative
							alt?=e
							if(alt!=void) then
								addAlternative(d,alt)
							else
								var conj:EntityConjunction
								conj?=e
								if(conj!=void) then
									addConjunction(d,conj)
								end
							end
						end
					}
				end
			end
			
			operation addAlternative(d:Derivation, alt:EntityAlternative) is do
				if(d.elements.exists{e | e.alternative==alt}) then
					var v:AdapterElement 
					var elt:DerivationElement
					elt:=d.elements.select{e | e.alternative==alt}.one
					v:=elt.selectedVariant
					var a:Adaptation
					a?=v
					if(a!=void) then
						addAdaptation(d,a)
					else
					   var altern:EntityAlternative
					   altern?=v
					   if(altern!=void) then
					   		addAlternative(d,altern)
					   else
					   		var c:EntityConjunction
					   		c?=v
					   		if(c!=void) then
					   			addConjunction(d,c)
					   		end
					   end
					end

				else
					if(not(alt.isOptional) or d.selectedOptions.contains(alt)) then
						self.alternatives.add(alt)
					end
				end
			end

			
			operation isConcretizable() : ecore::EBoolean is do
				result:=(alternatives.size==0)
			end			
		}
		
		class NonApplicableDerivation inherits kermeta::exceptions::Exception {
			operation display() is do
				message:="Derivation is not applicable to DerivableAdapter. Maybe the derivation is not well formed.\n
				Please check that the derivation respects all the explicit and implicit constraints..."			
			end
		}		
	}
}

