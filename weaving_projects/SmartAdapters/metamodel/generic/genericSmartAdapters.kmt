/* $Id: genericSmartAdapters.kmt,v 1.17 2008-03-04 14:00:35 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright:
 * Authors: bmorin
 */

package org;

require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdaptersBase.kmt"
require "platform:/resource/SmartAdapters/program/weaving/converter.kmt"
 

using kermeta::standard
using kermeta::utils
using kermeta::persistence
using kermeta::exceptions
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore
using org::smartadapters::utils


package smartadapters
{
	package core
	{	
		aspect class Adaptation
		{
			reference reverse : Adaptation
		
			operation print() : String is
			do
				var o : Object
				var print : String
				var coll : Collection<kermeta::language::structure::Object>
				print := String.new
				getMetaClass().ownedAttribute.each{p |
					print := print + "\t" + p.name + ": "
					if p.upper == 1 then
						o := get(p)
						o := adapter.getRealObject(o,false)
						print := print + o.toString + "\n"
					else
						coll ?= get(p)
						coll.each{b | 
							print := print + adapter.getRealObject(b,false).toString + " ("+ b.toString + ") "
						}
						print := print + "\n"
					end
					get(p).getMetaClass().ownedAttribute.each{pr | 
						print := print + "\t\t - "+pr.name+" = "
						if pr.upper == 1 then
							print := print + adapter.getRealObject(o.get(pr),false).toString + " ("+ o.toString + ")" + "\n"
						else
							coll ?= o.get(pr)
							coll.each{b | 
								print := print + adapter.getRealObject(b, false).toString
							}
							print := print + "\n"
						end
					}
				}
				result := print
			end
			
			/**
			 * Return the adapter associated to the adaptation or to the reverse adaptation
			 */
			operation getAdapter() : Adapter 
				post notVoid is result != void
			is do
				var ad : Adapter
				ad := adapter
				if ad == void then
					ad := self.reverse.adapter
				end
				result := ad
			end
		}
		
		aspect class Adapter
		{	
			reference displayInfo : Boolean
		
			inv checkedAdapt is adapt.detect{a | not a.check} == void
		
			/**
			key : aspect element
			value : associated clone
			*/
			attribute clone : Hashtable<Object, Object>
			attribute binding : Hashtable<Object, Object>
			attribute cloned : Set<Object>
			attribute convert : Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>
			attribute converter : Converter
			
			/*
			 * attributes for managing roll-back
			 */
			attribute notRemovable : Set<Object> //objects that cannot be removed
			attribute removable : Set<Object> //objects that may be removed after weaving the aspect for a given binding
			attribute removed : Set<Object> //objects that have been removed when unweaving the aspect fof a given binding
			
			/**
			 * This operation maps the concepts of MM' to the concepts of MM
			 * The body of the operation will be generated when specializing the AOM framework
			 * for a given domain 
			 */
			operation initConvert() : Void 
				post converterNotVoid is converter != void
				is abstract
			
			/**
			 * This operation weaves the the aspect for the binding b
			 * In other words, it executes all the adaptations of the composition protocol  
			 */
			operation apply(b : Hashtable<Object, Object>, model : Object) 
				pre modelCheckedBefore is do
					var isChecked : Boolean init true
					do
						model.checkAllInvariants
					rescue
						isChecked := false
					end
					isChecked
				end
				post modelCheckedAfter is do
					var isChecked : Boolean init true
					do
						model.checkAllInvariants
					rescue
						isChecked := false
					end
					isChecked
				end
			is do
				var i : Integer init 1
				binding := b
				removable.clear
				removed.clear
				adapt.each{a |
					if displayInfo then
						stdio.writeln("Adaptation "+i.toString)
						stdio.writeln("------------")
						stdio.writeln("#>weaving: "+a.getMetaClass.name+"...")
					end
					
					a.execute(true)
					
					if displayInfo then
						stdio.write(a.print)
						stdio.writeln("#>weaving: done!")
						stdio.writeln("")
						i := i+1
					end
				}
			end
			
			/**
			 * This operation unweaves the previously woven aspect, for the current binding
			 * In other words, it performs a roll back.
			 */
			operation unweave(model : Object) 
				pre modelCheckedBefore is do
					var isChecked : Boolean init true
					do
						model.checkAllInvariants
					rescue
						isChecked := false
					end
					isChecked
				end
				post modelCheckedAfter is do
					var isChecked : Boolean init true
					do
						model.checkAllInvariants
					rescue
						isChecked := false
					end
					isChecked
				end
			is do
				var i : Integer init 1
				adapt.each{a | 
					if(a.reverse != void) then
						if displayInfo then
							stdio.writeln("Reverse adaptation "+i.toString)
							stdio.writeln("------------")
							stdio.writeln("#>unweaving: "+a.getMetaClass.name+" (i.e., executing "+a.reverse.getMetaClass.name+")"+"...")
						end
						
						a.reverse.execute(false)
						
						if displayInfo then
							stdio.write(a.print)
							stdio.writeln("#>unweaving: done!")
							stdio.writeln("")
							i := i+1
						end
					end
				}
			end

			/**
			 * This operation should be called before any other operation
			 */
			operation initAdapter() : Void is 
			do
				if (clone == void) then
					clone := Hashtable<Object, Object>.new
				end
				if (convert == void) then
					initConvert
				end
				if (cloned == void) then
					cloned := Set<Object>.new
				end
				if (notRemovable == void) then
					notRemovable := Set<Object>.new
				end
				if (removable == void) then
					removable := Set<Object>.new
				end
				if (removed == void) then
					removed := Set<Object>.new
				end			
			end		
				
			operation setDisplayInfo(display : Boolean) is
			do
				displayInfo := display
			end	
				
			/**
			 *initClone must be called before the first binding
			 */
			operation initClone() is do
				initAdapter
				if (~aspect.structure!=void) then
					~aspect.structure.content.each{elt |
							var newCloned:Object
							newCloned:=converter.getConverted(elt)
							if (newCloned!=void) then
								clone.put(elt, newCloned)
							end
					}
				end
			end
			
			/**
			updateClone must be called after every binding
			*/
			operation updateClones() is do
				if (~aspect.structure!=void) then
					~aspect.structure.content.each{o | 
						if (not(~aspect.persistent.contains(o))) then
							updateClone(o,void)
						end
					}
				end
				
				/*
				 * non removed removable objects become non removable
				 */
				removable.each{o |
					var real : Object init getRealObject(o,false)
					if not removed.contains(real) then
						notRemovable.add(real)
					end
				}	
			end
			
			operation updateClone(handler : Object, template : Object) is do
				clone.remove(handler)
				converter.deleteConverted(handler)
			
				var realHandler : Object
				var realTemplate : Object
			
				if (template != void) then
					realTemplate := getRealObject(template,false)
					realHandler := Object.clone(realTemplate)
					cloned.remove(realTemplate)
				else
					realHandler:=converter.getConverted(handler)
				end
				if (realHandler != void) then
					clone.put(handler, realHandler)
					if (template != void) then
						cloned.add(realTemplate)
					end
				end
			end

			/**
			 * This operation is called by domain-specific clone* / create* adaptations
			 */
			operation cloneAgain(handler : Object, template : Object, type : uniqueType) : Void is do
				var update : Boolean init false
				if type == uniqueType.non_unique then
					updateClone(handler,template)
					removable.add(getRealObject(handler,false))
				else 
					if type == uniqueType.unique then
						if (template != void) then
							update := not (cloned.contains(getRealObject(template,false)))
						else
							update :=  not(clone.containsKey(handler))
						end
					else
						update := stdio.read("$>clone "+handler.toString+" (true/false) :").toBoolean
					end 
				end
				if update then
					updateClone(handler,template)
					removable.add(getRealObject(handler,false))
				end
			end
			
			
			/**
			 * This operation is called by domain-specific set* adaptations,
			 * for all the multiple properties (upper > 1) 
			 */
			operation setMultipleProperty(prty : Object, o : Object) : Void is do
				if(o != void) then
					var coll : Collection<kermeta::language::structure::Object>
					var collToSet : Collection<kermeta::language::structure::Object>
					coll ?= o
					collToSet ?= prty
					if(coll != void and collToSet != void and coll.size > 0) then
						var realColl : Collection<kermeta::language::structure::Object>
						realColl ?= getRealObject(o,true)
						collToSet.addAll(realColl)
					end
				end
			end

			/**
			 * This operation is called by domain-specific set* adaptations,
			 * for all the single properties (upper = 1) 
			 */			
			operation setSingleProperty(o : Object, old : Object) : Object is do
				if(o != void) then					
					result := getRealObject(o,false)
				else
					result := old
				end
			end

			/**
			 * This operation is called by domain-specific unset* adaptations,
			 * for all the single properties (upper = 1) 
			 */
			operation unsetSingleProperty(o : Object, old : Object) : Object is do
				if(o != void) then
					var e : Object init getRealObject(o,false)
					if not notRemovable.contains(e) then
						removed.add(e)
						result := void
					else
						result := old
					end
				else
					result := old
				end
			end

			/**
			 * This operation is called by domain-specific unset* adaptations,
			 * for all the multiple properties (upper > 1) 
			 */
			operation unsetMultipleProperty(prty : Object, o : Object) : Void is do
				if(prty != void and o != void) then
					var coll : Collection<kermeta::language::structure::Object>
					var collToSet : Collection<kermeta::language::structure::Object>
					coll ?= o
					collToSet ?= prty
					if(coll != void and collToSet != void) then
						var realColl : Collection<kermeta::language::structure::Object>
						realColl ?= getRealObject(o,true)
						realColl.each{e |
							if not notRemovable.contains(e) then
								collToSet.remove(e)
								removed.add(e)
							end
						}
					end
				end
			end			
			
			/**
			 * Return the real object (instance of MM) associated to obj
			 * e.g., it returns the base model element associated to an element from the pointcut
			 * or returns a converted clone associated to a created element
			 */		
			operation getRealObject(obj : Object, isCollect:Boolean) : Object is do
				if obj == void then
					result := void
				else
					if (isCollect) then
						var col : Collection<kermeta::language::structure::Object>
						col ?= obj
						var res : Set<Object> init Set<Object>.new
						col.each{o | res.add(getRealObject(o,false))}
						result := res
					else
						var realObj : Object
						realObj := binding.getValue(obj)
						if (realObj != void) then
							result := realObj
						else
							realObj := clone.getValue(obj)
							if (realObj != void) then
								result := realObj
							else
								var pObj : PObject
								pObj ?= obj
								if (pObj != void) then
									result := converter.getConverted(obj)
								else
									result := obj
								end
							end
						end
					end
				end	
			end
		}
	}
	
	/**
	 * This package contains all the concepts for variability
	 */
	package extension
	{
		aspect class DerivableAdapter inherits Adapter
		{
			operation resolve(derivation:Derivation) : Adapter is do
				var adapter : DerivableAdapter init DerivableAdapter.new
				var isChecked : Boolean init true
				constraints.each{c | isChecked:=isChecked and c.check(derivation)}
				if(isChecked) then
					adapt.each{a | adapter.addAdaptation(derivation,a)}
					alternatives.each{a | adapter.addAlternative(derivation,a)}
					if(adapter.isConcretizable) then
						var concreteAdapter:Adapter init Adapter.new
						if converter == void then
							converter := Converter.new
							converter.initConverter(Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>.new)
						end
						converter.addEntry(adapter.getMetaClass,concreteAdapter.getMetaClass)
						adapter.adapt.each{a | converter.addEntry(a.getMetaClass, a.getMetaClass)}
						concreteAdapter ?= converter.getConverted(adapter)
						result := concreteAdapter
					else
						result := adapter
					end					
				else
					var e:NonApplicableDerivation init NonApplicableDerivation.new
					e.message := "Derivation "+derivation.toString+" is not applicable to DerivableAdapter "+self.toString+". \n
					Maybe the derivation is not well formed. \n
					Please check that the derivation respects all the explicit and implicit constraints..."	
					raise e
				end
			end
			
			operation addAdaptation(d:Derivation, a:Adaptation) is do
				if(not(a.isOptional) or d.selectedOptions.contains(a)) then
					adapt.add(a)
				end
			end
			
			operation addConjunction(d:Derivation, c:EntityConjunction) is do
				if(not(c.isOptional) or d.selectedOptions.contains(c)) then
					c.~and.each{e |
						var a:Adaptation
						a?=e
						if(a!=void) then
							addAdaptation(d,a)
						else
							var alt:EntityAlternative
							alt?=e
							if(alt!=void) then
								addAlternative(d,alt)
							else
								var conj:EntityConjunction
								conj?=e
								if(conj!=void) then
									addConjunction(d,conj)
								end
							end
						end
					}
				end
			end
			
			operation addAlternative(d:Derivation, alt:EntityAlternative) is do
				if(d.elements.exists{e | e.alternative==alt}) then
					var v:AdapterElement 
					var elt:DerivationElement
					elt:=d.elements.select{e | e.alternative==alt}.one
					v:=elt.selectedVariant
					var a:Adaptation
					a?=v
					if(a!=void) then
						addAdaptation(d,a)
					else
					   var altern:EntityAlternative
					   altern?=v
					   if(altern!=void) then
					   		addAlternative(d,altern)
					   else
					   		var c:EntityConjunction
					   		c?=v
					   		if(c!=void) then
					   			addConjunction(d,c)
					   		end
					   end
					end

				else
					if(not(alt.isOptional) or d.selectedOptions.contains(alt)) then
						self.alternatives.add(alt)
					end
				end
			end

			
			operation isConcretizable() : ecore::EBoolean is do
				result:=(alternatives.size==0)
			end			
		}
		
		class NonApplicableDerivation inherits kermeta::exceptions::Exception {
			
		}		
	}
}

