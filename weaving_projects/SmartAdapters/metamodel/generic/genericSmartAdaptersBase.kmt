/* $Id: genericSmartAdaptersBase.kmt,v 1.8 2008-02-20 12:52:06 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright:
 * Authors: bmorin
 */

package org;

require kermeta 
require "http://www.eclipse.org/emf/2002/Ecore" 
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore"

using kermeta::standard
using kermeta::utils
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore

package smartadapters
{
	package core
	{
		class Adapter
		{
			attribute ~aspect : Aspect[1..1]
			
			attribute adapt : Adaptation[0..*]#adapter
			
			reference reverse : Adaptation[0..*]
						
			attribute name : ecore::EString		
		}

		class Aspect
		{ 
			attribute template : ModelPattern[0..1]
			
			attribute structure : PModel[1..1]
			
			/**
			persistent refers to aspectual PObject that must not be
			cloned between two bindings
			TODO : contraints...
			*/
			reference persistent : PObject[0..*]
			
		}

		abstract class Adaptation inherits smartadapters::extension::AdapterElement
		{
			reference adapter : Adapter[1..1]#adapt			
			
			operation check() : Boolean
				is abstract
			
			/**
			Execute the adaptation for a given binding
			Sub-classes must implement this method
			*/		         
			operation execute(reverse : Boolean) : Void
				pre checking is check 
				is abstract

		}
		
		abstract class cloneAdaptation inherits Adaptation
		{
			attribute isUnique : uniqueType
		}
		
		abstract class createAdaptation inherits Adaptation
		{
			attribute isUnique : uniqueType
		}
		
		abstract class setAdaptation inherits Adaptation
		{
		
		}
		
		abstract class unsetAdaptation inherits Adaptation
		{
		
		}

		class makeUnique inherits Adaptation
		{
			reference element : PObject[1..1]
			
			method check() : Boolean is do
				var res:Boolean init false
				if(adapter.~aspect.structure!=void)then
					if(adapter.~aspect.structure.content!=void) then
						res:=(element!=void and adapter.~aspect.structure.content.contains(element))
					end			
				end
				result := res
			end
			
			method execute(reverse : Boolean) : Void is do
				adapter.~aspect.persistent.add(element)
			end
		}
		
		enumeration uniqueType{unique; non_unique; onDemand;}		
	}
	

	package extension
	{
		class AdapterElement
		{
			attribute name : ecore::EString

			attribute isOptional : ecore::EBoolean

		}
		class DerivableAdapter inherits smartadapters::core::Adapter
		{
			attribute alternatives : EntityAlternative[0..*]

			attribute constraints : Constraint[0..*]#adapter
		}
		class EntityAlternative inherits AdapterElement
		{			
			attribute xor : AdapterElement[0..*]	
		}
		
		
		class EntityConjunction inherits AdapterElement
		{
			attribute ~and : AdapterElement[0..*]

		}
		
		abstract class Constraint
		{
			reference adapter:DerivableAdapter[1..1]#constraints
			
			operation check(d:Derivation): Boolean is abstract
		}
		
		class MutualExclusion inherits Constraint
		{
			reference entities : AdapterElement[2..*]
			
			method check(d:Derivation): Boolean is do
				var c:Set<AdapterElement> init Set<AdapterElement>.new
				c.addAll(d.selectedOptions)
				d.elements.each{e | c.add(e.selectedVariant)}
				result:=c.intersection(entities).size<=1
			end
		}
		
		class Dependency inherits Constraint
		{
			reference source : AdapterElement[1..1]
			
			reference dependencies : AdapterElement[1..*]

			method check(d:Derivation): Boolean is do
				var c:Collection<AdapterElement> init Set<AdapterElement>.new
				c.addAll(d.selectedOptions)
				d.elements.each{e | c.add(e.selectedVariant)}
				result:=not(c.contains(source)) or c.containsAll(self.dependencies)
			end			
		}
		
		class Derivation
		{
			reference elements : DerivationElement[0..*]
			
			reference selectedOptions : AdapterElement[0..*]
		}
		
		class DerivationElement
		{
			reference alternative:EntityAlternative[1..1]
			
			reference selectedVariant:AdapterElement[1..1]
		}	
	}
	
}

