/* $Id: genericSmartAdaptersBase.kmt,v 1.13 2008-03-27 16:33:50 bmorin Exp $
 * Creation date: July 17, 2007
 * License:
 * Copyright:
 * Authors: bmorin
 */

package org;

require kermeta 
require "http://www.eclipse.org/emf/2002/Ecore" 
require "platform:/resource/fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore"

using kermeta::standard
using kermeta::utils
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore

/**
* This is the generic version of SmartAdapters
* see <a href="http://www.kircher-schwanninger.de/workshops/MDD&AOSD/old/ECOOP2007/papers/TowardsGenericAOMFramework.pdf" target="_blank">Towards a Generic AOM Framework</a>
* see <a href="http://www.springerlink.com/content/6045275650757000/" target="_blank">Introducing Variability into Aspect-Oriented Modeling Approaches</a>
* see <a href="http://www.sse.uni-due.de/vamos/2008/papers/VAMOS08_06.pdf" target="_blank">Weaving Aspect Configurations for Managing System Variability</a>
*/
package smartadapters
{
	package core
	{
		/**
		 * An adapter describes <b><i>how</i></b> to compose an aspect with a composition protocole
		 * (an ordered set of adaptations)
		 */
		class Adapter
		{
			attribute ~aspect : Aspect[1..1]
			
			attribute adapt : oset Adaptation[0..*]#adapter
						
			attribute name : ecore::EString
		}

		/**
		 * Aspect encapsulate the structure of a concern (<b><i>what ?</i></b>) and the template (<i><b>where ?</i></b>)
		 */
		class Aspect
		{ 
			attribute template : ModelPattern[0..1]
			
			attribute structure : PModel[0..1]
			
			/**
			persistent refers to aspectual PObject that must not be
			cloned between two bindings
			*/
			reference persistent : PObject[0..*]
			
		}

		/**
		 *	Adaptation are basic weaving operations
		 *  A sequence of adaptations describes a composition protocol (<i><b>how ?</i></b>)
		 *  A pre-defined set of adaptations is automatically generated when specializing
		 *  specializing the framework for a given domain
		 */
		abstract class Adaptation inherits smartadapters::extension::AdapterElement
		{
			reference adapter : Adapter[1..1]#adapt			
			
			operation check() : Boolean
				is abstract
			
			/**
			Execute the adaptation for a given binding
			Sub-classes must implement this method
			*/		         
			operation execute(reverse : Boolean) : Void
				pre checking is check 
				is abstract

		}
		
		/**
		 * Create a new element from an existing one
		 */
		abstract class cloneAdaptation inherits Adaptation
		{
			attribute isUnique : uniqueType
		}

		/**
		 * Create a new element from scratch
		 */		
		abstract class createAdaptation inherits Adaptation
		{
			attribute isUnique : uniqueType
		}
		
		/**
		 * Set any feature of a given model element
		 */
		abstract class setAdaptation inherits Adaptation
		{
		
		}

		/**
		 * Unset any feature of a given model element
		 */			
		abstract class unsetAdaptation inherits Adaptation
		{
		
		}

		/**
		 * Adaptation for making any element from the structure unique
		 * i.e., unique elements are cloned only once when applying the 
		 * protocol for several bindings
		 */		
		class makeUnique inherits Adaptation
		{
			reference element : PObject[1..1]
			
			method check() : Boolean is do
				var res:Boolean init false
				if((adapter.~aspect.structure != void).andThen{v | (adapter.~aspect.structure.content != void)}) then
					res:=((element!=void).andThen{v | adapter.~aspect.structure.content.contains(element)})
				end			
				result := res
			end
			
			method execute(reverse : Boolean) : Void is do
				adapter.~aspect.persistent.add(element)
			end
		}
		
		enumeration uniqueType{unique; non_unique; onDemand;}		
	}
	
	/**
	* This package contains the features related to variability
	* see <a href="http://www.springerlink.com/content/6045275650757000/" target="_blank">Introducing Variability into Aspect-Oriented Modeling Approaches</a>
	*/
	package extension
	{
		class AdapterElement
		{
			attribute name : ecore::EString

			attribute isOptional : ecore::EBoolean

		}
		class DerivableAdapter inherits smartadapters::core::Adapter
		{
			attribute alternatives : EntityAlternative[0..*]

			attribute constraints : Constraint[0..*]#adapter
		}
		class EntityAlternative inherits AdapterElement
		{			
			attribute xor : AdapterElement[0..*]	
		}
		
		
		class EntityConjunction inherits AdapterElement
		{
			attribute ~and : AdapterElement[0..*]

		}
		
		abstract class Constraint
		{
			reference adapter:DerivableAdapter[1..1]#constraints
			
			operation check(d:Derivation): Boolean is abstract
		}
		
		class MutualExclusion inherits Constraint
		{
			reference entities : AdapterElement[2..*]
			
			method check(d:Derivation): Boolean is do
				var c:Set<AdapterElement> init Set<AdapterElement>.new
				c.addAll(d.selectedOptions)
				d.elements.each{e | c.add(e.selectedVariant)}
				result:=c.intersection(entities).size<=1
			end
		}
		
		class Dependency inherits Constraint
		{
			reference source : AdapterElement[1..1]
			
			reference dependencies : AdapterElement[1..*]

			method check(d:Derivation): Boolean is do
				var c:Collection<AdapterElement> init Set<AdapterElement>.new
				c.addAll(d.selectedOptions)
				d.elements.each{e | c.add(e.selectedVariant)}
				result:=not(c.contains(source)).orElse{v | c.containsAll(self.dependencies)}
			end			
		}
		
		class Derivation
		{
			attribute elements : DerivationElement[0..*]
			
			reference selectedOptions : AdapterElement[0..*]
		}
		
		class DerivationElement
		{
			reference alternative:EntityAlternative[1..1]
			
			reference selectedVariant:AdapterElement[1..1]
		}	
	}
	
}

