
/* 
 * Author: Brice Morin
 * Creation date: 
 * License: 
 * Copyright: IRISA Rennes - Equipe Projet INRIA Triskell
 */

/*
 * This file was automatically generated
 */

package org;
require kermeta
require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "platform:/resource/SmartAdapters/metamodel/domain/FSMMM.ecore"
require "platform:/resource/SmartAdapters/metamodel/domain/FSMMMPattern.ecore"

using kermeta::standard
using kermeta::utils
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore
using org::smartadapters::utils

package smartadapters
{
	package core
	{
		aspect class Adapter 
		{
			operation initConvert(): Void is do
				stdio.write("Mapping MM\' to MM...")
				converter := Converter.new
				convert := Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>.new
				convert.put(pattern::FSM::State,FSM::State)
				convert.put(pattern::FSM::Transition,FSM::Transition)
				convert.put(pattern::FSM::Fsm,FSM::Fsm)
				converter.initConverter(convert)
				stdio.writeln("OK!")
			end
		}
		
	package adaptations
	{
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of FSM::State
		 */
		 
		
		class CreateState inherits createAdaptation
		{
			attribute newState : pattern::FSM::State
					
			method check(): Boolean is do
				result := newState != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newState, void, isUnique)					
			end
		}

		class CloneState inherits cloneAdaptation
		{
			reference StateToClone : pattern::FSM::State
			attribute clonedState : pattern::FSM::State
			
			method check(): Boolean is do
				result := StateToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedState, StateToClone, isUnique)
			end					
		}

		class SetState inherits setAdaptation
		{
			reference StateToSet : pattern::FSM::State
			reference refname : pattern::FSM::label
			
			method check(): Boolean is do
				result := StateToSet != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempState : FSM::State
				tempState ?= ad.getRealObject(StateToSet,false)
				
				tempState.name ?= ad.setSingleProperty(refname, tempState.name)
				
				//Instantiating the reverse adaptation
				if(reverse) then
					var unset : UnsetState init UnsetState.new
					unset.StateToUnset := self.StateToSet
					unset.refname := self.refname
					unset.reverse := self
					self.reverse := unset
				end	
			end			
		}
		
		class UnsetState inherits unsetAdaptation
		{
			reference StateToUnset : pattern::FSM::State
			reference refname : pattern::FSM::label
			
			method check(): Boolean is do
				result := StateToUnset != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempState : FSM::State
				tempState ?= ad.getRealObject(StateToUnset,false)
				
				tempState.name ?= ad.unsetSingleProperty(refname, tempState.name)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetState init SetState.new
					~set.StateToSet := self.StateToUnset
					~set.refname := self.refname
					~set.reverse := self
					self.reverse := ~set
				end
			end
		}
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of FSM::Transition
		 */
		 
		
		class CreateTransition inherits createAdaptation
		{
			attribute newTransition : pattern::FSM::Transition
					
			method check(): Boolean is do
				result := newTransition != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newTransition, void, isUnique)					
			end
		}

		class CloneTransition inherits cloneAdaptation
		{
			reference TransitionToClone : pattern::FSM::Transition
			attribute clonedTransition : pattern::FSM::Transition
			
			method check(): Boolean is do
				result := TransitionToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedTransition, TransitionToClone, isUnique)
			end					
		}

		class SetTransition inherits setAdaptation
		{
			reference TransitionToSet : pattern::FSM::Transition
			reference refsource : pattern::FSM::State
			reference reftarget : pattern::FSM::State
			
			method check(): Boolean is do
				result := TransitionToSet != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempTransition : FSM::Transition
				tempTransition ?= ad.getRealObject(TransitionToSet,false)
				
				tempTransition.source ?= ad.setSingleProperty(refsource, tempTransition.source)
				tempTransition.target ?= ad.setSingleProperty(reftarget, tempTransition.target)
				
				//Instantiating the reverse adaptation
				if(reverse) then
					var unset : UnsetTransition init UnsetTransition.new
					unset.TransitionToUnset := self.TransitionToSet
					unset.refsource := self.refsource
					unset.reftarget := self.reftarget
					unset.reverse := self
					self.reverse := unset
				end	
			end			
		}
		
		class UnsetTransition inherits unsetAdaptation
		{
			reference TransitionToUnset : pattern::FSM::Transition
			reference refsource : pattern::FSM::State
			reference reftarget : pattern::FSM::State
			
			method check(): Boolean is do
				result := TransitionToUnset != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempTransition : FSM::Transition
				tempTransition ?= ad.getRealObject(TransitionToUnset,false)
				
				tempTransition.source ?= ad.unsetSingleProperty(refsource, tempTransition.source)
				tempTransition.target ?= ad.unsetSingleProperty(reftarget, tempTransition.target)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetTransition init SetTransition.new
					~set.TransitionToSet := self.TransitionToUnset
					~set.refsource := self.refsource
					~set.reftarget := self.reftarget
					~set.reverse := self
					self.reverse := ~set
				end
			end
		}
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of FSM::Fsm
		 */
		 
		
		class CreateFsm inherits createAdaptation
		{
			attribute newFsm : pattern::FSM::Fsm
					
			method check(): Boolean is do
				result := newFsm != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newFsm, void, isUnique)					
			end
		}

		class CloneFsm inherits cloneAdaptation
		{
			reference FsmToClone : pattern::FSM::Fsm
			attribute clonedFsm : pattern::FSM::Fsm
			
			method check(): Boolean is do
				result := FsmToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedFsm, FsmToClone, isUnique)
			end					
		}

		class SetFsm inherits setAdaptation
		{
			reference FsmToSet : pattern::FSM::Fsm
			reference refstates : pattern::FSM::State[0..*]
			reference reftransitions : pattern::FSM::Transition[0..*]
			
			method check(): Boolean is do
				result := FsmToSet != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempFsm : FSM::Fsm
				tempFsm ?= ad.getRealObject(FsmToSet,false)
				
				stdio.writeln("FSM before")
				tempFsm.states.each{s |
					stdio.writeln("\t - "+s.name+" "+s.toString)
				}
				
				stdio.writeln("------------")
				refstates.each{s | 
					var realState : FSM::State 
					realState ?= ad.getRealObject(s,false)
					stdio.writeln("\t * "+s.name+" : "+realState.name+" "+realState.toString)
				}
				stdio.writeln("------------")
				
				ad.setMultipleProperty(tempFsm.states,refstates)
				ad.setMultipleProperty(tempFsm.transitions,reftransitions)
				
				stdio.writeln("FSM after")
				tempFsm.states.each{s |
					stdio.writeln("\t - "+s.name+" "+s.toString)
				}
				
				//Instantiating the reverse adaptation
				if(reverse) then
					var unset : UnsetFsm init UnsetFsm.new
					unset.FsmToUnset := self.FsmToSet
					unset.refstates.clear
					unset.refstates.addAll(self.refstates)
					unset.reftransitions.clear
					unset.reftransitions.addAll(self.reftransitions)
					unset.reverse := self
					self.reverse := unset
				end	
			end			
		}
		
		class UnsetFsm inherits unsetAdaptation
		{
			reference FsmToUnset : pattern::FSM::Fsm
			reference refstates : pattern::FSM::State[0..*]
			reference reftransitions : pattern::FSM::Transition[0..*]
			
			method check(): Boolean is do
				result := FsmToUnset != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempFsm : FSM::Fsm
				tempFsm ?= ad.getRealObject(FsmToUnset,false)

				stdio.writeln("FSM before")
				tempFsm.states.each{s |
					stdio.writeln("\t - "+s.name+" "+s.toString)
				}
				
				stdio.writeln("------------")
				refstates.each{s | 
					var realState : FSM::State 
					realState ?= ad.getRealObject(s,false)
					stdio.writeln("\t * "+s.name+" : "+realState.name+" "+realState.toString)
				}
				stdio.writeln("------------")
				
				ad.unsetMultipleProperty(tempFsm.states,refstates)
				ad.unsetMultipleProperty(tempFsm.transitions,reftransitions)
				
				
				stdio.writeln("FSM after")
				tempFsm.states.each{s |
					stdio.writeln("\t - "+s.name+" "+s.toString)
				}
				
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFsm init SetFsm.new
					~set.FsmToSet := self.FsmToUnset
					~set.refstates.clear
					~set.refstates.addAll(self.refstates)
					~set.reftransitions.clear
					~set.reftransitions.addAll(self.reftransitions)
					~set.reverse := self
					self.reverse := ~set
				end
			end
		}
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of FSM::label
		 */
		 
	}
}}