
/* 
 * Author: Brice Morin
 * Creation date: 
 * License: 
 * Copyright: IRISA Rennes - Equipe Projet INRIA Triskell
 */

/*
 * This file was automatically generated
 */

package org;
require kermeta
require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "platform:/resource/SmartAdapters/metamodel/domain/FSMMM.ecore"
require "platform:/resource/SmartAdapters/metamodel/domain/FSMMMPattern.ecore"

using kermeta::standard
using kermeta::utils
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore
using org::smartadapters::utils

package smartadapters
{
	package core
	{
		aspect class Adapter 
		{
			operation initConvert(): Void is do
				stdio.write("Mapping MM\' to MM...")
				converter := Converter.new
				convert := Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>.new
				convert.put(pattern::FSM::State,FSM::State)
				convert.put(pattern::FSM::Transition,FSM::Transition)
				convert.put(pattern::FSM::Fsm,FSM::Fsm)
				converter.initConverter(convert)
				stdio.writeln("OK!")
			end
		}
		
	package adaptations
	{
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of FSM::State
		 */
		 
		
		class CreateState inherits createAdaptation
		{
			attribute newState : pattern::FSM::State
					
			method check(): Boolean is do
				result := newState != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newState, void, isUnique)					
			end
		}

		class CloneState inherits cloneAdaptation
		{
			reference StateToClone : pattern::FSM::State
			attribute clonedState : pattern::FSM::State
			
			method check(): Boolean is do
				result := StateToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedState, StateToClone, isUnique)
			end					
		}

		class SetState inherits setAdaptation
		{
			reference StateToSet : pattern::FSM::State
			reference refname : pattern::FSM::label
			
			method check(): Boolean is do
				result := StateToSet != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempState : FSM::State
				tempState ?= ad.getRealObject(StateToSet,false)
				
				tempState.name ?= ad.setSingleProperty(refname, tempState.name)
				
				//Instantiating the reverse adaptation
				if(reverse) then
					
					var unset : UnsetState 
					if self.reverse == void then
						unset := UnsetState.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.StateToUnset := self.StateToSet
					unset.refname := self.refname
				end	
			end			
		}
		
		class UnsetState inherits unsetAdaptation
		{
			reference StateToUnset : pattern::FSM::State
			reference refname : pattern::FSM::label
			
			method check(): Boolean is do
				result := StateToUnset != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempState : FSM::State
				tempState ?= ad.getRealObject(StateToUnset,false)
				
				tempState.name ?= ad.unsetSingleProperty(refname, tempState.name)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetState 
					if self.reverse == void then
						~set := SetState.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.StateToSet := self.StateToUnset
					~set.refname := self.refname
				end
			end
		}
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of FSM::Transition
		 */
		 
		
		class CreateTransition inherits createAdaptation
		{
			attribute newTransition : pattern::FSM::Transition
					
			method check(): Boolean is do
				result := newTransition != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newTransition, void, isUnique)					
			end
		}

		class CloneTransition inherits cloneAdaptation
		{
			reference TransitionToClone : pattern::FSM::Transition
			attribute clonedTransition : pattern::FSM::Transition
			
			method check(): Boolean is do
				result := TransitionToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedTransition, TransitionToClone, isUnique)
			end					
		}

		class SetTransition inherits setAdaptation
		{
			reference TransitionToSet : pattern::FSM::Transition
			reference refsource : pattern::FSM::State
			reference reftarget : pattern::FSM::State
			
			method check(): Boolean is do
				result := TransitionToSet != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempTransition : FSM::Transition
				tempTransition ?= ad.getRealObject(TransitionToSet,false)
				
				tempTransition.source ?= ad.setSingleProperty(refsource, tempTransition.source)
				tempTransition.target ?= ad.setSingleProperty(reftarget, tempTransition.target)
				
				//Instantiating the reverse adaptation
				if(reverse) then
					
					var unset : UnsetTransition 
					if self.reverse == void then
						unset := UnsetTransition.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.TransitionToUnset := self.TransitionToSet
					unset.refsource := self.refsource
					unset.reftarget := self.reftarget
				end	
			end			
		}
		
		class UnsetTransition inherits unsetAdaptation
		{
			reference TransitionToUnset : pattern::FSM::Transition
			reference refsource : pattern::FSM::State
			reference reftarget : pattern::FSM::State
			
			method check(): Boolean is do
				result := TransitionToUnset != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempTransition : FSM::Transition
				tempTransition ?= ad.getRealObject(TransitionToUnset,false)
				
				tempTransition.source ?= ad.unsetSingleProperty(refsource, tempTransition.source)
				tempTransition.target ?= ad.unsetSingleProperty(reftarget, tempTransition.target)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetTransition 
					if self.reverse == void then
						~set := SetTransition.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.TransitionToSet := self.TransitionToUnset
					~set.refsource := self.refsource
					~set.reftarget := self.reftarget
				end
			end
		}
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of FSM::Fsm
		 */
		 
		
		class CreateFsm inherits createAdaptation
		{
			attribute newFsm : pattern::FSM::Fsm
					
			method check(): Boolean is do
				result := newFsm != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newFsm, void, isUnique)					
			end
		}

		class CloneFsm inherits cloneAdaptation
		{
			reference FsmToClone : pattern::FSM::Fsm
			attribute clonedFsm : pattern::FSM::Fsm
			
			method check(): Boolean is do
				result := FsmToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedFsm, FsmToClone, isUnique)
			end					
		}

		class SetFsm inherits setAdaptation
		{
			reference FsmToSet : pattern::FSM::Fsm
			reference refstates : pattern::FSM::State[0..*]
			reference reftransitions : pattern::FSM::Transition[0..*]
			
			method check(): Boolean is do
				result := FsmToSet != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempFsm : FSM::Fsm
				tempFsm ?= ad.getRealObject(FsmToSet,false)
				
				ad.setMultipleProperty(tempFsm.states,refstates)
				ad.setMultipleProperty(tempFsm.transitions,reftransitions)
				
				//Instantiating the reverse adaptation
				if(reverse) then
					
					var unset : UnsetFsm 
					if self.reverse == void then
						unset := UnsetFsm.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.FsmToUnset := self.FsmToSet
					unset.refstates.clear
					unset.refstates.addAll(self.refstates)
					unset.reftransitions.clear
					unset.reftransitions.addAll(self.reftransitions)
				end	
			end			
		}
		
		class UnsetFsm inherits unsetAdaptation
		{
			reference FsmToUnset : pattern::FSM::Fsm
			reference refstates : pattern::FSM::State[0..*]
			reference reftransitions : pattern::FSM::Transition[0..*]
			
			method check(): Boolean is do
				result := FsmToUnset != void
			end
			
			method execute(reverse : Boolean): Void is do
				var ad : Adapter init getAdapter
				var tempFsm : FSM::Fsm
				tempFsm ?= ad.getRealObject(FsmToUnset,false)
				
				ad.unsetMultipleProperty(tempFsm.states,refstates)
				ad.unsetMultipleProperty(tempFsm.transitions,reftransitions)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFsm 
					if self.reverse == void then
						~set := SetFsm.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.FsmToSet := self.FsmToUnset
					~set.refstates.clear
					~set.refstates.addAll(self.refstates)
					~set.reftransitions.clear
					~set.reftransitions.addAll(self.reftransitions)
				end
			end
		}
		
		/*
		 * Adaptations dedicated to the manipulation
		 * of FSM::label
		 */
		 
	}
}}