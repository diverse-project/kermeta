
/* 
 * Author: Brice Morin
 * Creation date: 
 * License: 
 * Copyright: IRISA Rennes - Equipe Projet INRIA Triskell
 */

/*
 * This file was automatically generated
 */

package org;
require kermeta
require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"
require "platform:/resource/SmartAdapters/metamodel/domain/Fractal.ecore"
require "platform:/resource/SmartAdapters/metamodel/domain/FractalPattern.ecore"

using kermeta::standard
using kermeta::utils
using patternframework
using org::smartadapters::core
using org::smartadapters::extension
using ecore
using org::smartadapters::utils

package smartadapters
{
	package core
	{
		aspect class Adapter 
		{
			/**
			 * Associates concrete meta-classes from MM\' to concrete meta-classes from MM
			 */
			operation initConvert(): Void is do
				converter := Converter.new
				convert := Hashtable<kermeta::language::structure::Class,kermeta::language::structure::Class>.new
				convert.put(pattern::Fractal::System,Fractal::System)
				convert.put(pattern::Fractal::Component,Fractal::Component)
				convert.put(pattern::Fractal::Membrane,Fractal::Membrane)
				convert.put(pattern::Fractal::Content,Fractal::Content)
				convert.put(pattern::Fractal::Interface,Fractal::Interface)
				convert.put(pattern::Fractal::Binding,Fractal::Binding)
				convert.put(pattern::Fractal::ComponentType,Fractal::ComponentType)
				convert.put(pattern::Fractal::InterfaceType,Fractal::InterfaceType)
				convert.put(pattern::Fractal::BasicNameController,Fractal::BasicNameController)
				convert.put(pattern::Fractal::BasicLifeCycleController,Fractal::BasicLifeCycleController)
				convert.put(pattern::Fractal::GenericAttributeController,Fractal::GenericAttributeController)
				convert.put(pattern::Fractal::Attribute,Fractal::Attribute)
				convert.put(pattern::Fractal::Java::Interface,Fractal::Java::Interface)
				convert.put(pattern::Fractal::Java::Class,Fractal::Java::Class)
				convert.put(pattern::Fractal::Julia::Membrane,Fractal::Julia::Membrane)
				convert.put(pattern::Fractal::Julia::Interceptor,Fractal::Julia::Interceptor)
				converter.initConverter(convert)
			end
		}
		
	package adaptations
	{
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::System
		 */
		
		/**
		 * Creates a new Fractal::System from scratch
		 * This new element is handled by refering to newSystem
		 */
		class CreateFractalSystem inherits createAdaptation
		{
			attribute newSystem : pattern::Fractal::System
					
			method check(): Boolean is do
				result := newSystem != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newSystem, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::System from an existing one
		 * This cloned element is handled by refering to clonedSystem
		 */
		class CloneFractalSystem inherits cloneAdaptation
		{
			reference SystemToClone : pattern::Fractal::System
			attribute clonedSystem : pattern::Fractal::System
			
			method check(): Boolean is do
				result := SystemToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedSystem, SystemToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::System
		 * All the references expect SystemToSet may be void
		 */
		class SetFractalSystem inherits setAdaptation
		{
			reference SystemToSet : pattern::Fractal::System
			reference refcomponent : pattern::Fractal::Component[0..*]
			reference reftype : pattern::Fractal::Type[0..*]
			
			method check(): Boolean is do
				result := SystemToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalSystem is do
				var ad : Adapter init getAdapter
				var tempSystemToSet : Fractal::System
				tempSystemToSet ?= ad.getRealObject(SystemToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				c ?= ad.getRealObject(refcomponent,true)
				c.each{o | var p : Fractal::Component p?=o isCorrectlySetted := isCorrectlySetted and tempSystemToSet.component.contains(p)}
				c ?= ad.getRealObject(reftype,true)
				c.each{o | var p : Fractal::Type p?=o isCorrectlySetted := isCorrectlySetted and tempSystemToSet.type.contains(p)}
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempSystem : Fractal::System
				tempSystem ?= ad.getRealObject(SystemToSet,false)
				
				ad.setMultipleProperty(tempSystem.component,refcomponent)
				ad.setMultipleProperty(tempSystem.type,reftype)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalSystem 
					if self.reverse == void then
						unset := UnsetFractalSystem.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.SystemToUnset := self.SystemToSet
					unset.refcomponent.clear
					unset.refcomponent.addAll(self.refcomponent)
					unset.reftype.clear
					unset.reftype.addAll(self.reftype)
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::System
		 * All the references expect SystemToUnset may be void 
		 */		
		class UnsetFractalSystem inherits unsetAdaptation
		{
			reference SystemToUnset : pattern::Fractal::System
			reference refcomponent : pattern::Fractal::Component[0..*]
			reference reftype : pattern::Fractal::Type[0..*]
			
			method check(): Boolean is do
				result := SystemToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalSystem is do
				var ad : Adapter init getAdapter
				var tempSystemToUnset : Fractal::System
				tempSystemToUnset ?= ad.getRealObject(SystemToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				c ?= ad.getRealObject(refcomponent,true)
				c.each{o | var p : Fractal::Component p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempSystemToUnset.component.contains(p)
					end
				}
				c ?= ad.getRealObject(reftype,true)
				c.each{o | var p : Fractal::Type p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempSystemToUnset.type.contains(p)
					end
				}
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempSystem : Fractal::System
				tempSystem ?= ad.getRealObject(SystemToUnset,false)
				
				ad.unsetMultipleProperty(tempSystem.component,refcomponent)
				ad.unsetMultipleProperty(tempSystem.type,reftype)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalSystem 
					if self.reverse == void then
						~set := SetFractalSystem.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.SystemToSet := self.SystemToUnset
					~set.refcomponent.clear
					~set.refcomponent.addAll(self.refcomponent)
					~set.reftype.clear
					~set.reftype.addAll(self.reftype)
				end
			end
		}
		 

		/**
		 * Sets any property of Fractal::Type
		 * All the references expect TypeToSet may be void
		 */
		class SetFractalType inherits setAdaptation
		{
			reference TypeToSet : pattern::Fractal::Type
			
			method check(): Boolean is do
				result := TypeToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalType is do
				var ad : Adapter init getAdapter
				var tempTypeToSet : Fractal::Type
				tempTypeToSet ?= ad.getRealObject(TypeToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempType : Fractal::Type
				tempType ?= ad.getRealObject(TypeToSet,false)
				
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalType 
					if self.reverse == void then
						unset := UnsetFractalType.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.TypeToUnset := self.TypeToSet
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Type
		 * All the references expect TypeToUnset may be void 
		 */		
		class UnsetFractalType inherits unsetAdaptation
		{
			reference TypeToUnset : pattern::Fractal::Type
			
			method check(): Boolean is do
				result := TypeToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalType is do
				var ad : Adapter init getAdapter
				var tempTypeToUnset : Fractal::Type
				tempTypeToUnset ?= ad.getRealObject(TypeToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempType : Fractal::Type
				tempType ?= ad.getRealObject(TypeToUnset,false)
				
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalType 
					if self.reverse == void then
						~set := SetFractalType.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.TypeToSet := self.TypeToUnset
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Component
		 */
		
		/**
		 * Creates a new Fractal::Component from scratch
		 * This new element is handled by refering to newComponent
		 */
		class CreateFractalComponent inherits createAdaptation
		{
			attribute newComponent : pattern::Fractal::Component
					
			method check(): Boolean is do
				result := newComponent != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newComponent, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Component from an existing one
		 * This cloned element is handled by refering to clonedComponent
		 */
		class CloneFractalComponent inherits cloneAdaptation
		{
			reference ComponentToClone : pattern::Fractal::Component
			attribute clonedComponent : pattern::Fractal::Component
			
			method check(): Boolean is do
				result := ComponentToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedComponent, ComponentToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Component
		 * All the references expect ComponentToSet may be void
		 */
		class SetFractalComponent inherits setAdaptation
		{
			reference ComponentToSet : pattern::Fractal::Component
			reference reftype : pattern::Fractal::Type
			reference refmembrane : pattern::Fractal::Membrane
			reference refcontent : pattern::Fractal::Content
			reference refsuperComponent : pattern::Fractal::Component[0..*]
			
			method check(): Boolean is do
				result := ComponentToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalComponent is do
				var ad : Adapter init getAdapter
				var tempComponentToSet : Fractal::Component
				tempComponentToSet ?= ad.getRealObject(ComponentToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if reftype != void then
					isCorrectlySetted := isCorrectlySetted and tempComponentToSet.type == ad.getRealObject(reftype,false)
				end
				if refmembrane != void then
					isCorrectlySetted := isCorrectlySetted and tempComponentToSet.membrane == ad.getRealObject(refmembrane,false)
				end
				if refcontent != void then
					isCorrectlySetted := isCorrectlySetted and tempComponentToSet.content == ad.getRealObject(refcontent,false)
				end
				c ?= ad.getRealObject(refsuperComponent,true)
				c.each{o | var p : Fractal::Component p?=o isCorrectlySetted := isCorrectlySetted and tempComponentToSet.superComponent.contains(p)}
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempComponent : Fractal::Component
				tempComponent ?= ad.getRealObject(ComponentToSet,false)
				
				tempComponent.type ?= ad.setSingleProperty(reftype, tempComponent.type)
				tempComponent.membrane ?= ad.setSingleProperty(refmembrane, tempComponent.membrane)
				tempComponent.content ?= ad.setSingleProperty(refcontent, tempComponent.content)
				ad.setMultipleProperty(tempComponent.superComponent,refsuperComponent)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalComponent 
					if self.reverse == void then
						unset := UnsetFractalComponent.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.ComponentToUnset := self.ComponentToSet
					unset.reftype := self.reftype
					unset.refmembrane := self.refmembrane
					unset.refcontent := self.refcontent
					unset.refsuperComponent.clear
					unset.refsuperComponent.addAll(self.refsuperComponent)
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Component
		 * All the references expect ComponentToUnset may be void 
		 */		
		class UnsetFractalComponent inherits unsetAdaptation
		{
			reference ComponentToUnset : pattern::Fractal::Component
			reference reftype : pattern::Fractal::Type
			reference refmembrane : pattern::Fractal::Membrane
			reference refcontent : pattern::Fractal::Content
			reference refsuperComponent : pattern::Fractal::Component[0..*]
			
			method check(): Boolean is do
				result := ComponentToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalComponent is do
				var ad : Adapter init getAdapter
				var tempComponentToUnset : Fractal::Component
				tempComponentToUnset ?= ad.getRealObject(ComponentToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if reftype != void then 
				if not ad.notRemovable.contains(ad.getRealObject(reftype,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempComponentToUnset.type == void
				end end
				if refmembrane != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refmembrane,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempComponentToUnset.membrane == void
				end end
				if refcontent != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refcontent,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempComponentToUnset.content == void
				end end
				c ?= ad.getRealObject(refsuperComponent,true)
				c.each{o | var p : Fractal::Component p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempComponentToUnset.superComponent.contains(p)
					end
				}
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempComponent : Fractal::Component
				tempComponent ?= ad.getRealObject(ComponentToUnset,false)
				
				tempComponent.type ?= ad.unsetSingleProperty(reftype, tempComponent.type)
				tempComponent.membrane ?= ad.unsetSingleProperty(refmembrane, tempComponent.membrane)
				tempComponent.content ?= ad.unsetSingleProperty(refcontent, tempComponent.content)
				ad.unsetMultipleProperty(tempComponent.superComponent,refsuperComponent)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalComponent 
					if self.reverse == void then
						~set := SetFractalComponent.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.ComponentToSet := self.ComponentToUnset
					~set.reftype := self.reftype
					~set.refmembrane := self.refmembrane
					~set.refcontent := self.refcontent
					~set.refsuperComponent.clear
					~set.refsuperComponent.addAll(self.refsuperComponent)
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Membrane
		 */
		
		/**
		 * Creates a new Fractal::Membrane from scratch
		 * This new element is handled by refering to newMembrane
		 */
		class CreateFractalMembrane inherits createAdaptation
		{
			attribute newMembrane : pattern::Fractal::Membrane
					
			method check(): Boolean is do
				result := newMembrane != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newMembrane, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Membrane from an existing one
		 * This cloned element is handled by refering to clonedMembrane
		 */
		class CloneFractalMembrane inherits cloneAdaptation
		{
			reference MembraneToClone : pattern::Fractal::Membrane
			attribute clonedMembrane : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := MembraneToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedMembrane, MembraneToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Membrane
		 * All the references expect MembraneToSet may be void
		 */
		class SetFractalMembrane inherits setAdaptation
		{
			reference MembraneToSet : pattern::Fractal::Membrane
			reference refowner : pattern::Fractal::Component
			reference refexternalInterface : pattern::Fractal::Interface[0..*]
			reference refinternalInterface : pattern::Fractal::Interface[0..*]
			reference refcontroller : pattern::Fractal::Controller[0..*]
			
			method check(): Boolean is do
				result := MembraneToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalMembrane is do
				var ad : Adapter init getAdapter
				var tempMembraneToSet : Fractal::Membrane
				tempMembraneToSet ?= ad.getRealObject(MembraneToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.owner == ad.getRealObject(refowner,false)
				end
				c ?= ad.getRealObject(refexternalInterface,true)
				c.each{o | var p : Fractal::Interface p?=o isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.externalInterface.contains(p)}
				c ?= ad.getRealObject(refinternalInterface,true)
				c.each{o | var p : Fractal::Interface p?=o isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.internalInterface.contains(p)}
				c ?= ad.getRealObject(refcontroller,true)
				c.each{o | var p : Fractal::Controller p?=o isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.controller.contains(p)}
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempMembrane : Fractal::Membrane
				tempMembrane ?= ad.getRealObject(MembraneToSet,false)
				
				tempMembrane.owner ?= ad.setSingleProperty(refowner, tempMembrane.owner)
				ad.setMultipleProperty(tempMembrane.externalInterface,refexternalInterface)
				ad.setMultipleProperty(tempMembrane.internalInterface,refinternalInterface)
				ad.setMultipleProperty(tempMembrane.controller,refcontroller)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalMembrane 
					if self.reverse == void then
						unset := UnsetFractalMembrane.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.MembraneToUnset := self.MembraneToSet
					unset.refowner := self.refowner
					unset.refexternalInterface.clear
					unset.refexternalInterface.addAll(self.refexternalInterface)
					unset.refinternalInterface.clear
					unset.refinternalInterface.addAll(self.refinternalInterface)
					unset.refcontroller.clear
					unset.refcontroller.addAll(self.refcontroller)
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Membrane
		 * All the references expect MembraneToUnset may be void 
		 */		
		class UnsetFractalMembrane inherits unsetAdaptation
		{
			reference MembraneToUnset : pattern::Fractal::Membrane
			reference refowner : pattern::Fractal::Component
			reference refexternalInterface : pattern::Fractal::Interface[0..*]
			reference refinternalInterface : pattern::Fractal::Interface[0..*]
			reference refcontroller : pattern::Fractal::Controller[0..*]
			
			method check(): Boolean is do
				result := MembraneToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalMembrane is do
				var ad : Adapter init getAdapter
				var tempMembraneToUnset : Fractal::Membrane
				tempMembraneToUnset ?= ad.getRealObject(MembraneToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempMembraneToUnset.owner == void
				end end
				c ?= ad.getRealObject(refexternalInterface,true)
				c.each{o | var p : Fractal::Interface p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempMembraneToUnset.externalInterface.contains(p)
					end
				}
				c ?= ad.getRealObject(refinternalInterface,true)
				c.each{o | var p : Fractal::Interface p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempMembraneToUnset.internalInterface.contains(p)
					end
				}
				c ?= ad.getRealObject(refcontroller,true)
				c.each{o | var p : Fractal::Controller p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempMembraneToUnset.controller.contains(p)
					end
				}
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempMembrane : Fractal::Membrane
				tempMembrane ?= ad.getRealObject(MembraneToUnset,false)
				
				tempMembrane.owner ?= ad.unsetSingleProperty(refowner, tempMembrane.owner)
				ad.unsetMultipleProperty(tempMembrane.externalInterface,refexternalInterface)
				ad.unsetMultipleProperty(tempMembrane.internalInterface,refinternalInterface)
				ad.unsetMultipleProperty(tempMembrane.controller,refcontroller)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalMembrane 
					if self.reverse == void then
						~set := SetFractalMembrane.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.MembraneToSet := self.MembraneToUnset
					~set.refowner := self.refowner
					~set.refexternalInterface.clear
					~set.refexternalInterface.addAll(self.refexternalInterface)
					~set.refinternalInterface.clear
					~set.refinternalInterface.addAll(self.refinternalInterface)
					~set.refcontroller.clear
					~set.refcontroller.addAll(self.refcontroller)
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Content
		 */
		
		/**
		 * Creates a new Fractal::Content from scratch
		 * This new element is handled by refering to newContent
		 */
		class CreateFractalContent inherits createAdaptation
		{
			attribute newContent : pattern::Fractal::Content
					
			method check(): Boolean is do
				result := newContent != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newContent, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Content from an existing one
		 * This cloned element is handled by refering to clonedContent
		 */
		class CloneFractalContent inherits cloneAdaptation
		{
			reference ContentToClone : pattern::Fractal::Content
			attribute clonedContent : pattern::Fractal::Content
			
			method check(): Boolean is do
				result := ContentToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedContent, ContentToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Content
		 * All the references expect ContentToSet may be void
		 */
		class SetFractalContent inherits setAdaptation
		{
			reference ContentToSet : pattern::Fractal::Content
			reference refowner : pattern::Fractal::Component
			reference refsubComponent : pattern::Fractal::Component[0..*]
			reference refbinding : pattern::Fractal::Binding[0..*]
			
			method check(): Boolean is do
				result := ContentToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalContent is do
				var ad : Adapter init getAdapter
				var tempContentToSet : Fractal::Content
				tempContentToSet ?= ad.getRealObject(ContentToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempContentToSet.owner == ad.getRealObject(refowner,false)
				end
				c ?= ad.getRealObject(refsubComponent,true)
				c.each{o | var p : Fractal::Component p?=o isCorrectlySetted := isCorrectlySetted and tempContentToSet.subComponent.contains(p)}
				c ?= ad.getRealObject(refbinding,true)
				c.each{o | var p : Fractal::Binding p?=o isCorrectlySetted := isCorrectlySetted and tempContentToSet.binding.contains(p)}
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempContent : Fractal::Content
				tempContent ?= ad.getRealObject(ContentToSet,false)
				
				tempContent.owner ?= ad.setSingleProperty(refowner, tempContent.owner)
				ad.setMultipleProperty(tempContent.subComponent,refsubComponent)
				ad.setMultipleProperty(tempContent.binding,refbinding)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalContent 
					if self.reverse == void then
						unset := UnsetFractalContent.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.ContentToUnset := self.ContentToSet
					unset.refowner := self.refowner
					unset.refsubComponent.clear
					unset.refsubComponent.addAll(self.refsubComponent)
					unset.refbinding.clear
					unset.refbinding.addAll(self.refbinding)
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Content
		 * All the references expect ContentToUnset may be void 
		 */		
		class UnsetFractalContent inherits unsetAdaptation
		{
			reference ContentToUnset : pattern::Fractal::Content
			reference refowner : pattern::Fractal::Component
			reference refsubComponent : pattern::Fractal::Component[0..*]
			reference refbinding : pattern::Fractal::Binding[0..*]
			
			method check(): Boolean is do
				result := ContentToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalContent is do
				var ad : Adapter init getAdapter
				var tempContentToUnset : Fractal::Content
				tempContentToUnset ?= ad.getRealObject(ContentToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempContentToUnset.owner == void
				end end
				c ?= ad.getRealObject(refsubComponent,true)
				c.each{o | var p : Fractal::Component p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempContentToUnset.subComponent.contains(p)
					end
				}
				c ?= ad.getRealObject(refbinding,true)
				c.each{o | var p : Fractal::Binding p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempContentToUnset.binding.contains(p)
					end
				}
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempContent : Fractal::Content
				tempContent ?= ad.getRealObject(ContentToUnset,false)
				
				tempContent.owner ?= ad.unsetSingleProperty(refowner, tempContent.owner)
				ad.unsetMultipleProperty(tempContent.subComponent,refsubComponent)
				ad.unsetMultipleProperty(tempContent.binding,refbinding)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalContent 
					if self.reverse == void then
						~set := SetFractalContent.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.ContentToSet := self.ContentToUnset
					~set.refowner := self.refowner
					~set.refsubComponent.clear
					~set.refsubComponent.addAll(self.refsubComponent)
					~set.refbinding.clear
					~set.refbinding.addAll(self.refbinding)
				end
			end
		}
		 
		 
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Interface
		 */
		
		/**
		 * Creates a new Fractal::Interface from scratch
		 * This new element is handled by refering to newInterface
		 */
		class CreateFractalInterface inherits createAdaptation
		{
			attribute newInterface : pattern::Fractal::Interface
					
			method check(): Boolean is do
				result := newInterface != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newInterface, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Interface from an existing one
		 * This cloned element is handled by refering to clonedInterface
		 */
		class CloneFractalInterface inherits cloneAdaptation
		{
			reference InterfaceToClone : pattern::Fractal::Interface
			attribute clonedInterface : pattern::Fractal::Interface
			
			method check(): Boolean is do
				result := InterfaceToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedInterface, InterfaceToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Interface
		 * All the references expect InterfaceToSet may be void
		 */
		class SetFractalInterface inherits setAdaptation
		{
			reference InterfaceToSet : pattern::Fractal::Interface
			reference refowner : pattern::Fractal::Component
			reference reftype : pattern::Fractal::Type
			reference refname : pattern::Fractal::Name
			reference refvisibility : pattern::Fractal::Visibility
			
			method check(): Boolean is do
				result := InterfaceToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalInterface is do
				var ad : Adapter init getAdapter
				var tempInterfaceToSet : Fractal::Interface
				tempInterfaceToSet ?= ad.getRealObject(InterfaceToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceToSet.owner == ad.getRealObject(refowner,false)
				end
				if reftype != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceToSet.type == ad.getRealObject(reftype,false)
				end
				if refname != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceToSet.name == ad.getRealObject(refname,false)
				end
				if refvisibility != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceToSet.visibility == ad.getRealObject(refvisibility,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempInterface : Fractal::Interface
				tempInterface ?= ad.getRealObject(InterfaceToSet,false)
				
				tempInterface.owner ?= ad.setSingleProperty(refowner, tempInterface.owner)
				tempInterface.type ?= ad.setSingleProperty(reftype, tempInterface.type)
				tempInterface.name ?= ad.setSingleProperty(refname, tempInterface.name)
				tempInterface.visibility ?= ad.setSingleProperty(refvisibility, tempInterface.visibility)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalInterface 
					if self.reverse == void then
						unset := UnsetFractalInterface.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.InterfaceToUnset := self.InterfaceToSet
					unset.refowner := self.refowner
					unset.reftype := self.reftype
					unset.refname := self.refname
					unset.refvisibility := self.refvisibility
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Interface
		 * All the references expect InterfaceToUnset may be void 
		 */		
		class UnsetFractalInterface inherits unsetAdaptation
		{
			reference InterfaceToUnset : pattern::Fractal::Interface
			reference refowner : pattern::Fractal::Component
			reference reftype : pattern::Fractal::Type
			reference refname : pattern::Fractal::Name
			reference refvisibility : pattern::Fractal::Visibility
			
			method check(): Boolean is do
				result := InterfaceToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalInterface is do
				var ad : Adapter init getAdapter
				var tempInterfaceToUnset : Fractal::Interface
				tempInterfaceToUnset ?= ad.getRealObject(InterfaceToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceToUnset.owner == void
				end end
				if reftype != void then 
				if not ad.notRemovable.contains(ad.getRealObject(reftype,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceToUnset.type == void
				end end
				if refname != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refname,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceToUnset.name == void
				end end
				if refvisibility != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refvisibility,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceToUnset.visibility == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempInterface : Fractal::Interface
				tempInterface ?= ad.getRealObject(InterfaceToUnset,false)
				
				tempInterface.owner ?= ad.unsetSingleProperty(refowner, tempInterface.owner)
				tempInterface.type ?= ad.unsetSingleProperty(reftype, tempInterface.type)
				tempInterface.name ?= ad.unsetSingleProperty(refname, tempInterface.name)
				tempInterface.visibility ?= ad.unsetSingleProperty(refvisibility, tempInterface.visibility)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalInterface 
					if self.reverse == void then
						~set := SetFractalInterface.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.InterfaceToSet := self.InterfaceToUnset
					~set.refowner := self.refowner
					~set.reftype := self.reftype
					~set.refname := self.refname
					~set.refvisibility := self.refvisibility
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Binding
		 */
		
		/**
		 * Creates a new Fractal::Binding from scratch
		 * This new element is handled by refering to newBinding
		 */
		class CreateFractalBinding inherits createAdaptation
		{
			attribute newBinding : pattern::Fractal::Binding
					
			method check(): Boolean is do
				result := newBinding != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newBinding, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Binding from an existing one
		 * This cloned element is handled by refering to clonedBinding
		 */
		class CloneFractalBinding inherits cloneAdaptation
		{
			reference BindingToClone : pattern::Fractal::Binding
			attribute clonedBinding : pattern::Fractal::Binding
			
			method check(): Boolean is do
				result := BindingToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedBinding, BindingToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Binding
		 * All the references expect BindingToSet may be void
		 */
		class SetFractalBinding inherits setAdaptation
		{
			reference BindingToSet : pattern::Fractal::Binding
			reference refclient : pattern::Fractal::Interface
			reference refserver : pattern::Fractal::Interface
			
			method check(): Boolean is do
				result := BindingToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalBinding is do
				var ad : Adapter init getAdapter
				var tempBindingToSet : Fractal::Binding
				tempBindingToSet ?= ad.getRealObject(BindingToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refclient != void then
					isCorrectlySetted := isCorrectlySetted and tempBindingToSet.client == ad.getRealObject(refclient,false)
				end
				if refserver != void then
					isCorrectlySetted := isCorrectlySetted and tempBindingToSet.server == ad.getRealObject(refserver,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempBinding : Fractal::Binding
				tempBinding ?= ad.getRealObject(BindingToSet,false)
				
				tempBinding.client ?= ad.setSingleProperty(refclient, tempBinding.client)
				tempBinding.server ?= ad.setSingleProperty(refserver, tempBinding.server)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalBinding 
					if self.reverse == void then
						unset := UnsetFractalBinding.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.BindingToUnset := self.BindingToSet
					unset.refclient := self.refclient
					unset.refserver := self.refserver
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Binding
		 * All the references expect BindingToUnset may be void 
		 */		
		class UnsetFractalBinding inherits unsetAdaptation
		{
			reference BindingToUnset : pattern::Fractal::Binding
			reference refclient : pattern::Fractal::Interface
			reference refserver : pattern::Fractal::Interface
			
			method check(): Boolean is do
				result := BindingToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalBinding is do
				var ad : Adapter init getAdapter
				var tempBindingToUnset : Fractal::Binding
				tempBindingToUnset ?= ad.getRealObject(BindingToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refclient != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refclient,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempBindingToUnset.client == void
				end end
				if refserver != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refserver,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempBindingToUnset.server == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempBinding : Fractal::Binding
				tempBinding ?= ad.getRealObject(BindingToUnset,false)
				
				tempBinding.client ?= ad.unsetSingleProperty(refclient, tempBinding.client)
				tempBinding.server ?= ad.unsetSingleProperty(refserver, tempBinding.server)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalBinding 
					if self.reverse == void then
						~set := SetFractalBinding.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.BindingToSet := self.BindingToUnset
					~set.refclient := self.refclient
					~set.refserver := self.refserver
				end
			end
		}
		 
		 
		 
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::ComponentType
		 */
		
		/**
		 * Creates a new Fractal::ComponentType from scratch
		 * This new element is handled by refering to newComponentType
		 */
		class CreateFractalComponentType inherits createAdaptation
		{
			attribute newComponentType : pattern::Fractal::ComponentType
					
			method check(): Boolean is do
				result := newComponentType != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newComponentType, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::ComponentType from an existing one
		 * This cloned element is handled by refering to clonedComponentType
		 */
		class CloneFractalComponentType inherits cloneAdaptation
		{
			reference ComponentTypeToClone : pattern::Fractal::ComponentType
			attribute clonedComponentType : pattern::Fractal::ComponentType
			
			method check(): Boolean is do
				result := ComponentTypeToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedComponentType, ComponentTypeToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::ComponentType
		 * All the references expect ComponentTypeToSet may be void
		 */
		class SetFractalComponentType inherits setAdaptation
		{
			reference ComponentTypeToSet : pattern::Fractal::ComponentType
			reference refinterfaceType : pattern::Fractal::InterfaceType[0..*]
			
			method check(): Boolean is do
				result := ComponentTypeToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalComponentType is do
				var ad : Adapter init getAdapter
				var tempComponentTypeToSet : Fractal::ComponentType
				tempComponentTypeToSet ?= ad.getRealObject(ComponentTypeToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				c ?= ad.getRealObject(refinterfaceType,true)
				c.each{o | var p : Fractal::InterfaceType p?=o isCorrectlySetted := isCorrectlySetted and tempComponentTypeToSet.interfaceType.contains(p)}
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempComponentType : Fractal::ComponentType
				tempComponentType ?= ad.getRealObject(ComponentTypeToSet,false)
				
				ad.setMultipleProperty(tempComponentType.interfaceType,refinterfaceType)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalComponentType 
					if self.reverse == void then
						unset := UnsetFractalComponentType.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.ComponentTypeToUnset := self.ComponentTypeToSet
					unset.refinterfaceType.clear
					unset.refinterfaceType.addAll(self.refinterfaceType)
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::ComponentType
		 * All the references expect ComponentTypeToUnset may be void 
		 */		
		class UnsetFractalComponentType inherits unsetAdaptation
		{
			reference ComponentTypeToUnset : pattern::Fractal::ComponentType
			reference refinterfaceType : pattern::Fractal::InterfaceType[0..*]
			
			method check(): Boolean is do
				result := ComponentTypeToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalComponentType is do
				var ad : Adapter init getAdapter
				var tempComponentTypeToUnset : Fractal::ComponentType
				tempComponentTypeToUnset ?= ad.getRealObject(ComponentTypeToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				c ?= ad.getRealObject(refinterfaceType,true)
				c.each{o | var p : Fractal::InterfaceType p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempComponentTypeToUnset.interfaceType.contains(p)
					end
				}
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempComponentType : Fractal::ComponentType
				tempComponentType ?= ad.getRealObject(ComponentTypeToUnset,false)
				
				ad.unsetMultipleProperty(tempComponentType.interfaceType,refinterfaceType)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalComponentType 
					if self.reverse == void then
						~set := SetFractalComponentType.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.ComponentTypeToSet := self.ComponentTypeToUnset
					~set.refinterfaceType.clear
					~set.refinterfaceType.addAll(self.refinterfaceType)
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::InterfaceType
		 */
		
		/**
		 * Creates a new Fractal::InterfaceType from scratch
		 * This new element is handled by refering to newInterfaceType
		 */
		class CreateFractalInterfaceType inherits createAdaptation
		{
			attribute newInterfaceType : pattern::Fractal::InterfaceType
					
			method check(): Boolean is do
				result := newInterfaceType != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newInterfaceType, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::InterfaceType from an existing one
		 * This cloned element is handled by refering to clonedInterfaceType
		 */
		class CloneFractalInterfaceType inherits cloneAdaptation
		{
			reference InterfaceTypeToClone : pattern::Fractal::InterfaceType
			attribute clonedInterfaceType : pattern::Fractal::InterfaceType
			
			method check(): Boolean is do
				result := InterfaceTypeToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedInterfaceType, InterfaceTypeToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::InterfaceType
		 * All the references expect InterfaceTypeToSet may be void
		 */
		class SetFractalInterfaceType inherits setAdaptation
		{
			reference InterfaceTypeToSet : pattern::Fractal::InterfaceType
			reference refname : pattern::Fractal::Name
			reference refrole : pattern::Fractal::Role
			reference refcardinality : pattern::Fractal::Cardinality
			reference refcontingency : pattern::Fractal::Contingency
			reference refsignature : pattern::Fractal::LanguageInterfaceType
			
			method check(): Boolean is do
				result := InterfaceTypeToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalInterfaceType is do
				var ad : Adapter init getAdapter
				var tempInterfaceTypeToSet : Fractal::InterfaceType
				tempInterfaceTypeToSet ?= ad.getRealObject(InterfaceTypeToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceTypeToSet.name == ad.getRealObject(refname,false)
				end
				if refrole != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceTypeToSet.role == ad.getRealObject(refrole,false)
				end
				if refcardinality != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceTypeToSet.cardinality == ad.getRealObject(refcardinality,false)
				end
				if refcontingency != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceTypeToSet.contingency == ad.getRealObject(refcontingency,false)
				end
				if refsignature != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceTypeToSet.signature == ad.getRealObject(refsignature,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempInterfaceType : Fractal::InterfaceType
				tempInterfaceType ?= ad.getRealObject(InterfaceTypeToSet,false)
				
				tempInterfaceType.name ?= ad.setSingleProperty(refname, tempInterfaceType.name)
				tempInterfaceType.role ?= ad.setSingleProperty(refrole, tempInterfaceType.role)
				tempInterfaceType.cardinality ?= ad.setSingleProperty(refcardinality, tempInterfaceType.cardinality)
				tempInterfaceType.contingency ?= ad.setSingleProperty(refcontingency, tempInterfaceType.contingency)
				tempInterfaceType.signature ?= ad.setSingleProperty(refsignature, tempInterfaceType.signature)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalInterfaceType 
					if self.reverse == void then
						unset := UnsetFractalInterfaceType.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.InterfaceTypeToUnset := self.InterfaceTypeToSet
					unset.refname := self.refname
					unset.refrole := self.refrole
					unset.refcardinality := self.refcardinality
					unset.refcontingency := self.refcontingency
					unset.refsignature := self.refsignature
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::InterfaceType
		 * All the references expect InterfaceTypeToUnset may be void 
		 */		
		class UnsetFractalInterfaceType inherits unsetAdaptation
		{
			reference InterfaceTypeToUnset : pattern::Fractal::InterfaceType
			reference refname : pattern::Fractal::Name
			reference refrole : pattern::Fractal::Role
			reference refcardinality : pattern::Fractal::Cardinality
			reference refcontingency : pattern::Fractal::Contingency
			reference refsignature : pattern::Fractal::LanguageInterfaceType
			
			method check(): Boolean is do
				result := InterfaceTypeToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalInterfaceType is do
				var ad : Adapter init getAdapter
				var tempInterfaceTypeToUnset : Fractal::InterfaceType
				tempInterfaceTypeToUnset ?= ad.getRealObject(InterfaceTypeToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refname,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceTypeToUnset.name == void
				end end
				if refrole != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refrole,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceTypeToUnset.role == void
				end end
				if refcardinality != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refcardinality,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceTypeToUnset.cardinality == void
				end end
				if refcontingency != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refcontingency,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceTypeToUnset.contingency == void
				end end
				if refsignature != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refsignature,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceTypeToUnset.signature == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempInterfaceType : Fractal::InterfaceType
				tempInterfaceType ?= ad.getRealObject(InterfaceTypeToUnset,false)
				
				tempInterfaceType.name ?= ad.unsetSingleProperty(refname, tempInterfaceType.name)
				tempInterfaceType.role ?= ad.unsetSingleProperty(refrole, tempInterfaceType.role)
				tempInterfaceType.cardinality ?= ad.unsetSingleProperty(refcardinality, tempInterfaceType.cardinality)
				tempInterfaceType.contingency ?= ad.unsetSingleProperty(refcontingency, tempInterfaceType.contingency)
				tempInterfaceType.signature ?= ad.unsetSingleProperty(refsignature, tempInterfaceType.signature)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalInterfaceType 
					if self.reverse == void then
						~set := SetFractalInterfaceType.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.InterfaceTypeToSet := self.InterfaceTypeToUnset
					~set.refname := self.refname
					~set.refrole := self.refrole
					~set.refcardinality := self.refcardinality
					~set.refcontingency := self.refcontingency
					~set.refsignature := self.refsignature
				end
			end
		}
		 

		/**
		 * Sets any property of Fractal::LanguageInterfaceType
		 * All the references expect LanguageInterfaceTypeToSet may be void
		 */
		class SetFractalLanguageInterfaceType inherits setAdaptation
		{
			reference LanguageInterfaceTypeToSet : pattern::Fractal::LanguageInterfaceType
			
			method check(): Boolean is do
				result := LanguageInterfaceTypeToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalLanguageInterfaceType is do
				var ad : Adapter init getAdapter
				var tempLanguageInterfaceTypeToSet : Fractal::LanguageInterfaceType
				tempLanguageInterfaceTypeToSet ?= ad.getRealObject(LanguageInterfaceTypeToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempLanguageInterfaceType : Fractal::LanguageInterfaceType
				tempLanguageInterfaceType ?= ad.getRealObject(LanguageInterfaceTypeToSet,false)
				
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalLanguageInterfaceType 
					if self.reverse == void then
						unset := UnsetFractalLanguageInterfaceType.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.LanguageInterfaceTypeToUnset := self.LanguageInterfaceTypeToSet
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::LanguageInterfaceType
		 * All the references expect LanguageInterfaceTypeToUnset may be void 
		 */		
		class UnsetFractalLanguageInterfaceType inherits unsetAdaptation
		{
			reference LanguageInterfaceTypeToUnset : pattern::Fractal::LanguageInterfaceType
			
			method check(): Boolean is do
				result := LanguageInterfaceTypeToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalLanguageInterfaceType is do
				var ad : Adapter init getAdapter
				var tempLanguageInterfaceTypeToUnset : Fractal::LanguageInterfaceType
				tempLanguageInterfaceTypeToUnset ?= ad.getRealObject(LanguageInterfaceTypeToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempLanguageInterfaceType : Fractal::LanguageInterfaceType
				tempLanguageInterfaceType ?= ad.getRealObject(LanguageInterfaceTypeToUnset,false)
				
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalLanguageInterfaceType 
					if self.reverse == void then
						~set := SetFractalLanguageInterfaceType.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.LanguageInterfaceTypeToSet := self.LanguageInterfaceTypeToUnset
				end
			end
		}
		 

		/**
		 * Sets any property of Fractal::Controller
		 * All the references expect ControllerToSet may be void
		 */
		class SetFractalController inherits setAdaptation
		{
			reference ControllerToSet : pattern::Fractal::Controller
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := ControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalController is do
				var ad : Adapter init getAdapter
				var tempControllerToSet : Fractal::Controller
				tempControllerToSet ?= ad.getRealObject(ControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempController : Fractal::Controller
				tempController ?= ad.getRealObject(ControllerToSet,false)
				
				tempController.owner ?= ad.setSingleProperty(refowner, tempController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalController 
					if self.reverse == void then
						unset := UnsetFractalController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.ControllerToUnset := self.ControllerToSet
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Controller
		 * All the references expect ControllerToUnset may be void 
		 */		
		class UnsetFractalController inherits unsetAdaptation
		{
			reference ControllerToUnset : pattern::Fractal::Controller
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := ControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalController is do
				var ad : Adapter init getAdapter
				var tempControllerToUnset : Fractal::Controller
				tempControllerToUnset ?= ad.getRealObject(ControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempController : Fractal::Controller
				tempController ?= ad.getRealObject(ControllerToUnset,false)
				
				tempController.owner ?= ad.unsetSingleProperty(refowner, tempController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalController 
					if self.reverse == void then
						~set := SetFractalController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.ControllerToSet := self.ControllerToUnset
					~set.refowner := self.refowner
				end
			end
		}
		 

		/**
		 * Sets any property of Fractal::AttributeController
		 * All the references expect AttributeControllerToSet may be void
		 */
		class SetFractalAttributeController inherits setAdaptation
		{
			reference AttributeControllerToSet : pattern::Fractal::AttributeController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := AttributeControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalAttributeController is do
				var ad : Adapter init getAdapter
				var tempAttributeControllerToSet : Fractal::AttributeController
				tempAttributeControllerToSet ?= ad.getRealObject(AttributeControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempAttributeControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempAttributeController : Fractal::AttributeController
				tempAttributeController ?= ad.getRealObject(AttributeControllerToSet,false)
				
				tempAttributeController.owner ?= ad.setSingleProperty(refowner, tempAttributeController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalAttributeController 
					if self.reverse == void then
						unset := UnsetFractalAttributeController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.AttributeControllerToUnset := self.AttributeControllerToSet
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::AttributeController
		 * All the references expect AttributeControllerToUnset may be void 
		 */		
		class UnsetFractalAttributeController inherits unsetAdaptation
		{
			reference AttributeControllerToUnset : pattern::Fractal::AttributeController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := AttributeControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalAttributeController is do
				var ad : Adapter init getAdapter
				var tempAttributeControllerToUnset : Fractal::AttributeController
				tempAttributeControllerToUnset ?= ad.getRealObject(AttributeControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempAttributeControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempAttributeController : Fractal::AttributeController
				tempAttributeController ?= ad.getRealObject(AttributeControllerToUnset,false)
				
				tempAttributeController.owner ?= ad.unsetSingleProperty(refowner, tempAttributeController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalAttributeController 
					if self.reverse == void then
						~set := SetFractalAttributeController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.AttributeControllerToSet := self.AttributeControllerToUnset
					~set.refowner := self.refowner
				end
			end
		}
		 

		/**
		 * Sets any property of Fractal::BindingController
		 * All the references expect BindingControllerToSet may be void
		 */
		class SetFractalBindingController inherits setAdaptation
		{
			reference BindingControllerToSet : pattern::Fractal::BindingController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := BindingControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalBindingController is do
				var ad : Adapter init getAdapter
				var tempBindingControllerToSet : Fractal::BindingController
				tempBindingControllerToSet ?= ad.getRealObject(BindingControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempBindingControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempBindingController : Fractal::BindingController
				tempBindingController ?= ad.getRealObject(BindingControllerToSet,false)
				
				tempBindingController.owner ?= ad.setSingleProperty(refowner, tempBindingController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalBindingController 
					if self.reverse == void then
						unset := UnsetFractalBindingController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.BindingControllerToUnset := self.BindingControllerToSet
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::BindingController
		 * All the references expect BindingControllerToUnset may be void 
		 */		
		class UnsetFractalBindingController inherits unsetAdaptation
		{
			reference BindingControllerToUnset : pattern::Fractal::BindingController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := BindingControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalBindingController is do
				var ad : Adapter init getAdapter
				var tempBindingControllerToUnset : Fractal::BindingController
				tempBindingControllerToUnset ?= ad.getRealObject(BindingControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempBindingControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempBindingController : Fractal::BindingController
				tempBindingController ?= ad.getRealObject(BindingControllerToUnset,false)
				
				tempBindingController.owner ?= ad.unsetSingleProperty(refowner, tempBindingController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalBindingController 
					if self.reverse == void then
						~set := SetFractalBindingController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.BindingControllerToSet := self.BindingControllerToUnset
					~set.refowner := self.refowner
				end
			end
		}
		 

		/**
		 * Sets any property of Fractal::ContentController
		 * All the references expect ContentControllerToSet may be void
		 */
		class SetFractalContentController inherits setAdaptation
		{
			reference ContentControllerToSet : pattern::Fractal::ContentController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := ContentControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalContentController is do
				var ad : Adapter init getAdapter
				var tempContentControllerToSet : Fractal::ContentController
				tempContentControllerToSet ?= ad.getRealObject(ContentControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempContentControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempContentController : Fractal::ContentController
				tempContentController ?= ad.getRealObject(ContentControllerToSet,false)
				
				tempContentController.owner ?= ad.setSingleProperty(refowner, tempContentController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalContentController 
					if self.reverse == void then
						unset := UnsetFractalContentController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.ContentControllerToUnset := self.ContentControllerToSet
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::ContentController
		 * All the references expect ContentControllerToUnset may be void 
		 */		
		class UnsetFractalContentController inherits unsetAdaptation
		{
			reference ContentControllerToUnset : pattern::Fractal::ContentController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := ContentControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalContentController is do
				var ad : Adapter init getAdapter
				var tempContentControllerToUnset : Fractal::ContentController
				tempContentControllerToUnset ?= ad.getRealObject(ContentControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempContentControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempContentController : Fractal::ContentController
				tempContentController ?= ad.getRealObject(ContentControllerToUnset,false)
				
				tempContentController.owner ?= ad.unsetSingleProperty(refowner, tempContentController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalContentController 
					if self.reverse == void then
						~set := SetFractalContentController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.ContentControllerToSet := self.ContentControllerToUnset
					~set.refowner := self.refowner
				end
			end
		}
		 

		/**
		 * Sets any property of Fractal::LifeCycleController
		 * All the references expect LifeCycleControllerToSet may be void
		 */
		class SetFractalLifeCycleController inherits setAdaptation
		{
			reference LifeCycleControllerToSet : pattern::Fractal::LifeCycleController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := LifeCycleControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalLifeCycleController is do
				var ad : Adapter init getAdapter
				var tempLifeCycleControllerToSet : Fractal::LifeCycleController
				tempLifeCycleControllerToSet ?= ad.getRealObject(LifeCycleControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempLifeCycleControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempLifeCycleController : Fractal::LifeCycleController
				tempLifeCycleController ?= ad.getRealObject(LifeCycleControllerToSet,false)
				
				tempLifeCycleController.owner ?= ad.setSingleProperty(refowner, tempLifeCycleController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalLifeCycleController 
					if self.reverse == void then
						unset := UnsetFractalLifeCycleController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.LifeCycleControllerToUnset := self.LifeCycleControllerToSet
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::LifeCycleController
		 * All the references expect LifeCycleControllerToUnset may be void 
		 */		
		class UnsetFractalLifeCycleController inherits unsetAdaptation
		{
			reference LifeCycleControllerToUnset : pattern::Fractal::LifeCycleController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := LifeCycleControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalLifeCycleController is do
				var ad : Adapter init getAdapter
				var tempLifeCycleControllerToUnset : Fractal::LifeCycleController
				tempLifeCycleControllerToUnset ?= ad.getRealObject(LifeCycleControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempLifeCycleControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempLifeCycleController : Fractal::LifeCycleController
				tempLifeCycleController ?= ad.getRealObject(LifeCycleControllerToUnset,false)
				
				tempLifeCycleController.owner ?= ad.unsetSingleProperty(refowner, tempLifeCycleController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalLifeCycleController 
					if self.reverse == void then
						~set := SetFractalLifeCycleController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.LifeCycleControllerToSet := self.LifeCycleControllerToUnset
					~set.refowner := self.refowner
				end
			end
		}
		 
		 

		/**
		 * Sets any property of Fractal::NameController
		 * All the references expect NameControllerToSet may be void
		 */
		class SetFractalNameController inherits setAdaptation
		{
			reference NameControllerToSet : pattern::Fractal::NameController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := NameControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalNameController is do
				var ad : Adapter init getAdapter
				var tempNameControllerToSet : Fractal::NameController
				tempNameControllerToSet ?= ad.getRealObject(NameControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempNameControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempNameController : Fractal::NameController
				tempNameController ?= ad.getRealObject(NameControllerToSet,false)
				
				tempNameController.owner ?= ad.setSingleProperty(refowner, tempNameController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalNameController 
					if self.reverse == void then
						unset := UnsetFractalNameController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.NameControllerToUnset := self.NameControllerToSet
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::NameController
		 * All the references expect NameControllerToUnset may be void 
		 */		
		class UnsetFractalNameController inherits unsetAdaptation
		{
			reference NameControllerToUnset : pattern::Fractal::NameController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := NameControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalNameController is do
				var ad : Adapter init getAdapter
				var tempNameControllerToUnset : Fractal::NameController
				tempNameControllerToUnset ?= ad.getRealObject(NameControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempNameControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempNameController : Fractal::NameController
				tempNameController ?= ad.getRealObject(NameControllerToUnset,false)
				
				tempNameController.owner ?= ad.unsetSingleProperty(refowner, tempNameController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalNameController 
					if self.reverse == void then
						~set := SetFractalNameController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.NameControllerToSet := self.NameControllerToUnset
					~set.refowner := self.refowner
				end
			end
		}
		 

		/**
		 * Sets any property of Fractal::SuperController
		 * All the references expect SuperControllerToSet may be void
		 */
		class SetFractalSuperController inherits setAdaptation
		{
			reference SuperControllerToSet : pattern::Fractal::SuperController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := SuperControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalSuperController is do
				var ad : Adapter init getAdapter
				var tempSuperControllerToSet : Fractal::SuperController
				tempSuperControllerToSet ?= ad.getRealObject(SuperControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempSuperControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempSuperController : Fractal::SuperController
				tempSuperController ?= ad.getRealObject(SuperControllerToSet,false)
				
				tempSuperController.owner ?= ad.setSingleProperty(refowner, tempSuperController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalSuperController 
					if self.reverse == void then
						unset := UnsetFractalSuperController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.SuperControllerToUnset := self.SuperControllerToSet
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::SuperController
		 * All the references expect SuperControllerToUnset may be void 
		 */		
		class UnsetFractalSuperController inherits unsetAdaptation
		{
			reference SuperControllerToUnset : pattern::Fractal::SuperController
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := SuperControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalSuperController is do
				var ad : Adapter init getAdapter
				var tempSuperControllerToUnset : Fractal::SuperController
				tempSuperControllerToUnset ?= ad.getRealObject(SuperControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempSuperControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempSuperController : Fractal::SuperController
				tempSuperController ?= ad.getRealObject(SuperControllerToUnset,false)
				
				tempSuperController.owner ?= ad.unsetSingleProperty(refowner, tempSuperController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalSuperController 
					if self.reverse == void then
						~set := SetFractalSuperController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.SuperControllerToSet := self.SuperControllerToUnset
					~set.refowner := self.refowner
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::BasicNameController
		 */
		
		/**
		 * Creates a new Fractal::BasicNameController from scratch
		 * This new element is handled by refering to newBasicNameController
		 */
		class CreateFractalBasicNameController inherits createAdaptation
		{
			attribute newBasicNameController : pattern::Fractal::BasicNameController
					
			method check(): Boolean is do
				result := newBasicNameController != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newBasicNameController, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::BasicNameController from an existing one
		 * This cloned element is handled by refering to clonedBasicNameController
		 */
		class CloneFractalBasicNameController inherits cloneAdaptation
		{
			reference BasicNameControllerToClone : pattern::Fractal::BasicNameController
			attribute clonedBasicNameController : pattern::Fractal::BasicNameController
			
			method check(): Boolean is do
				result := BasicNameControllerToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedBasicNameController, BasicNameControllerToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::BasicNameController
		 * All the references expect BasicNameControllerToSet may be void
		 */
		class SetFractalBasicNameController inherits setAdaptation
		{
			reference BasicNameControllerToSet : pattern::Fractal::BasicNameController
			reference refname : pattern::Fractal::String
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := BasicNameControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalBasicNameController is do
				var ad : Adapter init getAdapter
				var tempBasicNameControllerToSet : Fractal::BasicNameController
				tempBasicNameControllerToSet ?= ad.getRealObject(BasicNameControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then
					isCorrectlySetted := isCorrectlySetted and tempBasicNameControllerToSet.name == ad.getRealObject(refname,false)
				end
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempBasicNameControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempBasicNameController : Fractal::BasicNameController
				tempBasicNameController ?= ad.getRealObject(BasicNameControllerToSet,false)
				
				tempBasicNameController.name ?= ad.setSingleProperty(refname, tempBasicNameController.name)
				tempBasicNameController.owner ?= ad.setSingleProperty(refowner, tempBasicNameController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalBasicNameController 
					if self.reverse == void then
						unset := UnsetFractalBasicNameController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.BasicNameControllerToUnset := self.BasicNameControllerToSet
					unset.refname := self.refname
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::BasicNameController
		 * All the references expect BasicNameControllerToUnset may be void 
		 */		
		class UnsetFractalBasicNameController inherits unsetAdaptation
		{
			reference BasicNameControllerToUnset : pattern::Fractal::BasicNameController
			reference refname : pattern::Fractal::String
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := BasicNameControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalBasicNameController is do
				var ad : Adapter init getAdapter
				var tempBasicNameControllerToUnset : Fractal::BasicNameController
				tempBasicNameControllerToUnset ?= ad.getRealObject(BasicNameControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refname,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempBasicNameControllerToUnset.name == void
				end end
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempBasicNameControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempBasicNameController : Fractal::BasicNameController
				tempBasicNameController ?= ad.getRealObject(BasicNameControllerToUnset,false)
				
				tempBasicNameController.name ?= ad.unsetSingleProperty(refname, tempBasicNameController.name)
				tempBasicNameController.owner ?= ad.unsetSingleProperty(refowner, tempBasicNameController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalBasicNameController 
					if self.reverse == void then
						~set := SetFractalBasicNameController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.BasicNameControllerToSet := self.BasicNameControllerToUnset
					~set.refname := self.refname
					~set.refowner := self.refowner
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::BasicLifeCycleController
		 */
		
		/**
		 * Creates a new Fractal::BasicLifeCycleController from scratch
		 * This new element is handled by refering to newBasicLifeCycleController
		 */
		class CreateFractalBasicLifeCycleController inherits createAdaptation
		{
			attribute newBasicLifeCycleController : pattern::Fractal::BasicLifeCycleController
					
			method check(): Boolean is do
				result := newBasicLifeCycleController != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newBasicLifeCycleController, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::BasicLifeCycleController from an existing one
		 * This cloned element is handled by refering to clonedBasicLifeCycleController
		 */
		class CloneFractalBasicLifeCycleController inherits cloneAdaptation
		{
			reference BasicLifeCycleControllerToClone : pattern::Fractal::BasicLifeCycleController
			attribute clonedBasicLifeCycleController : pattern::Fractal::BasicLifeCycleController
			
			method check(): Boolean is do
				result := BasicLifeCycleControllerToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedBasicLifeCycleController, BasicLifeCycleControllerToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::BasicLifeCycleController
		 * All the references expect BasicLifeCycleControllerToSet may be void
		 */
		class SetFractalBasicLifeCycleController inherits setAdaptation
		{
			reference BasicLifeCycleControllerToSet : pattern::Fractal::BasicLifeCycleController
			reference refstatus : pattern::Fractal::LifeCycleStatus
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := BasicLifeCycleControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalBasicLifeCycleController is do
				var ad : Adapter init getAdapter
				var tempBasicLifeCycleControllerToSet : Fractal::BasicLifeCycleController
				tempBasicLifeCycleControllerToSet ?= ad.getRealObject(BasicLifeCycleControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refstatus != void then
					isCorrectlySetted := isCorrectlySetted and tempBasicLifeCycleControllerToSet.status == ad.getRealObject(refstatus,false)
				end
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempBasicLifeCycleControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempBasicLifeCycleController : Fractal::BasicLifeCycleController
				tempBasicLifeCycleController ?= ad.getRealObject(BasicLifeCycleControllerToSet,false)
				
				tempBasicLifeCycleController.status ?= ad.setSingleProperty(refstatus, tempBasicLifeCycleController.status)
				tempBasicLifeCycleController.owner ?= ad.setSingleProperty(refowner, tempBasicLifeCycleController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalBasicLifeCycleController 
					if self.reverse == void then
						unset := UnsetFractalBasicLifeCycleController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.BasicLifeCycleControllerToUnset := self.BasicLifeCycleControllerToSet
					unset.refstatus := self.refstatus
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::BasicLifeCycleController
		 * All the references expect BasicLifeCycleControllerToUnset may be void 
		 */		
		class UnsetFractalBasicLifeCycleController inherits unsetAdaptation
		{
			reference BasicLifeCycleControllerToUnset : pattern::Fractal::BasicLifeCycleController
			reference refstatus : pattern::Fractal::LifeCycleStatus
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := BasicLifeCycleControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalBasicLifeCycleController is do
				var ad : Adapter init getAdapter
				var tempBasicLifeCycleControllerToUnset : Fractal::BasicLifeCycleController
				tempBasicLifeCycleControllerToUnset ?= ad.getRealObject(BasicLifeCycleControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refstatus != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refstatus,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempBasicLifeCycleControllerToUnset.status == void
				end end
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempBasicLifeCycleControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempBasicLifeCycleController : Fractal::BasicLifeCycleController
				tempBasicLifeCycleController ?= ad.getRealObject(BasicLifeCycleControllerToUnset,false)
				
				tempBasicLifeCycleController.status ?= ad.unsetSingleProperty(refstatus, tempBasicLifeCycleController.status)
				tempBasicLifeCycleController.owner ?= ad.unsetSingleProperty(refowner, tempBasicLifeCycleController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalBasicLifeCycleController 
					if self.reverse == void then
						~set := SetFractalBasicLifeCycleController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.BasicLifeCycleControllerToSet := self.BasicLifeCycleControllerToUnset
					~set.refstatus := self.refstatus
					~set.refowner := self.refowner
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::GenericAttributeController
		 */
		
		/**
		 * Creates a new Fractal::GenericAttributeController from scratch
		 * This new element is handled by refering to newGenericAttributeController
		 */
		class CreateFractalGenericAttributeController inherits createAdaptation
		{
			attribute newGenericAttributeController : pattern::Fractal::GenericAttributeController
					
			method check(): Boolean is do
				result := newGenericAttributeController != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newGenericAttributeController, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::GenericAttributeController from an existing one
		 * This cloned element is handled by refering to clonedGenericAttributeController
		 */
		class CloneFractalGenericAttributeController inherits cloneAdaptation
		{
			reference GenericAttributeControllerToClone : pattern::Fractal::GenericAttributeController
			attribute clonedGenericAttributeController : pattern::Fractal::GenericAttributeController
			
			method check(): Boolean is do
				result := GenericAttributeControllerToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedGenericAttributeController, GenericAttributeControllerToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::GenericAttributeController
		 * All the references expect GenericAttributeControllerToSet may be void
		 */
		class SetFractalGenericAttributeController inherits setAdaptation
		{
			reference GenericAttributeControllerToSet : pattern::Fractal::GenericAttributeController
			reference refattributes : pattern::Fractal::Attribute[0..*]
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := GenericAttributeControllerToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalGenericAttributeController is do
				var ad : Adapter init getAdapter
				var tempGenericAttributeControllerToSet : Fractal::GenericAttributeController
				tempGenericAttributeControllerToSet ?= ad.getRealObject(GenericAttributeControllerToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				c ?= ad.getRealObject(refattributes,true)
				c.each{o | var p : Fractal::Attribute p?=o isCorrectlySetted := isCorrectlySetted and tempGenericAttributeControllerToSet.attributes.contains(p)}
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempGenericAttributeControllerToSet.owner == ad.getRealObject(refowner,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempGenericAttributeController : Fractal::GenericAttributeController
				tempGenericAttributeController ?= ad.getRealObject(GenericAttributeControllerToSet,false)
				
				ad.setMultipleProperty(tempGenericAttributeController.attributes,refattributes)
				tempGenericAttributeController.owner ?= ad.setSingleProperty(refowner, tempGenericAttributeController.owner)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalGenericAttributeController 
					if self.reverse == void then
						unset := UnsetFractalGenericAttributeController.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.GenericAttributeControllerToUnset := self.GenericAttributeControllerToSet
					unset.refattributes.clear
					unset.refattributes.addAll(self.refattributes)
					unset.refowner := self.refowner
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::GenericAttributeController
		 * All the references expect GenericAttributeControllerToUnset may be void 
		 */		
		class UnsetFractalGenericAttributeController inherits unsetAdaptation
		{
			reference GenericAttributeControllerToUnset : pattern::Fractal::GenericAttributeController
			reference refattributes : pattern::Fractal::Attribute[0..*]
			reference refowner : pattern::Fractal::Membrane
			
			method check(): Boolean is do
				result := GenericAttributeControllerToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalGenericAttributeController is do
				var ad : Adapter init getAdapter
				var tempGenericAttributeControllerToUnset : Fractal::GenericAttributeController
				tempGenericAttributeControllerToUnset ?= ad.getRealObject(GenericAttributeControllerToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				c ?= ad.getRealObject(refattributes,true)
				c.each{o | var p : Fractal::Attribute p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempGenericAttributeControllerToUnset.attributes.contains(p)
					end
				}
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempGenericAttributeControllerToUnset.owner == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempGenericAttributeController : Fractal::GenericAttributeController
				tempGenericAttributeController ?= ad.getRealObject(GenericAttributeControllerToUnset,false)
				
				ad.unsetMultipleProperty(tempGenericAttributeController.attributes,refattributes)
				tempGenericAttributeController.owner ?= ad.unsetSingleProperty(refowner, tempGenericAttributeController.owner)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalGenericAttributeController 
					if self.reverse == void then
						~set := SetFractalGenericAttributeController.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.GenericAttributeControllerToSet := self.GenericAttributeControllerToUnset
					~set.refattributes.clear
					~set.refattributes.addAll(self.refattributes)
					~set.refowner := self.refowner
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Attribute
		 */
		
		/**
		 * Creates a new Fractal::Attribute from scratch
		 * This new element is handled by refering to newAttribute
		 */
		class CreateFractalAttribute inherits createAdaptation
		{
			attribute newAttribute : pattern::Fractal::Attribute
					
			method check(): Boolean is do
				result := newAttribute != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newAttribute, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Attribute from an existing one
		 * This cloned element is handled by refering to clonedAttribute
		 */
		class CloneFractalAttribute inherits cloneAdaptation
		{
			reference AttributeToClone : pattern::Fractal::Attribute
			attribute clonedAttribute : pattern::Fractal::Attribute
			
			method check(): Boolean is do
				result := AttributeToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedAttribute, AttributeToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Attribute
		 * All the references expect AttributeToSet may be void
		 */
		class SetFractalAttribute inherits setAdaptation
		{
			reference AttributeToSet : pattern::Fractal::Attribute
			reference refname : pattern::Fractal::String
			reference refvalue : pattern::Fractal::String
			
			method check(): Boolean is do
				result := AttributeToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalAttribute is do
				var ad : Adapter init getAdapter
				var tempAttributeToSet : Fractal::Attribute
				tempAttributeToSet ?= ad.getRealObject(AttributeToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then
					isCorrectlySetted := isCorrectlySetted and tempAttributeToSet.name == ad.getRealObject(refname,false)
				end
				if refvalue != void then
					isCorrectlySetted := isCorrectlySetted and tempAttributeToSet.~value == ad.getRealObject(refvalue,false)
				end
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempAttribute : Fractal::Attribute
				tempAttribute ?= ad.getRealObject(AttributeToSet,false)
				
				tempAttribute.name ?= ad.setSingleProperty(refname, tempAttribute.name)
				tempAttribute.~value ?= ad.setSingleProperty(refvalue, tempAttribute.~value)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalAttribute 
					if self.reverse == void then
						unset := UnsetFractalAttribute.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.AttributeToUnset := self.AttributeToSet
					unset.refname := self.refname
					unset.refvalue := self.refvalue
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Attribute
		 * All the references expect AttributeToUnset may be void 
		 */		
		class UnsetFractalAttribute inherits unsetAdaptation
		{
			reference AttributeToUnset : pattern::Fractal::Attribute
			reference refname : pattern::Fractal::String
			reference refvalue : pattern::Fractal::String
			
			method check(): Boolean is do
				result := AttributeToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalAttribute is do
				var ad : Adapter init getAdapter
				var tempAttributeToUnset : Fractal::Attribute
				tempAttributeToUnset ?= ad.getRealObject(AttributeToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refname,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempAttributeToUnset.name == void
				end end
				if refvalue != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refvalue,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempAttributeToUnset.~value == void
				end end
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempAttribute : Fractal::Attribute
				tempAttribute ?= ad.getRealObject(AttributeToUnset,false)
				
				tempAttribute.name ?= ad.unsetSingleProperty(refname, tempAttribute.name)
				tempAttribute.~value ?= ad.unsetSingleProperty(refvalue, tempAttribute.~value)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalAttribute 
					if self.reverse == void then
						~set := SetFractalAttribute.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.AttributeToSet := self.AttributeToUnset
					~set.refname := self.refname
					~set.refvalue := self.refvalue
				end
			end
		}
		 
		 
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Java::Interface
		 */
		
		/**
		 * Creates a new Fractal::Java::Interface from scratch
		 * This new element is handled by refering to newInterface
		 */
		class CreateFractalJavaInterface inherits createAdaptation
		{
			attribute newInterface : pattern::Fractal::Java::Interface
					
			method check(): Boolean is do
				result := newInterface != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newInterface, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Java::Interface from an existing one
		 * This cloned element is handled by refering to clonedInterface
		 */
		class CloneFractalJavaInterface inherits cloneAdaptation
		{
			reference InterfaceToClone : pattern::Fractal::Java::Interface
			attribute clonedInterface : pattern::Fractal::Java::Interface
			
			method check(): Boolean is do
				result := InterfaceToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedInterface, InterfaceToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Java::Interface
		 * All the references expect InterfaceToSet may be void
		 */
		class SetFractalJavaInterface inherits setAdaptation
		{
			reference InterfaceToSet : pattern::Fractal::Java::Interface
			reference refname : pattern::Fractal::String
			reference refextend : pattern::Fractal::Java::Interface[0..*]
			
			method check(): Boolean is do
				result := InterfaceToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalJavaInterface is do
				var ad : Adapter init getAdapter
				var tempInterfaceToSet : Fractal::Java::Interface
				tempInterfaceToSet ?= ad.getRealObject(InterfaceToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then
					isCorrectlySetted := isCorrectlySetted and tempInterfaceToSet.name == ad.getRealObject(refname,false)
				end
				c ?= ad.getRealObject(refextend,true)
				c.each{o | var p : Fractal::Java::Interface p?=o isCorrectlySetted := isCorrectlySetted and tempInterfaceToSet.extend.contains(p)}
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempInterface : Fractal::Java::Interface
				tempInterface ?= ad.getRealObject(InterfaceToSet,false)
				
				tempInterface.name ?= ad.setSingleProperty(refname, tempInterface.name)
				ad.setMultipleProperty(tempInterface.extend,refextend)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalJavaInterface 
					if self.reverse == void then
						unset := UnsetFractalJavaInterface.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.InterfaceToUnset := self.InterfaceToSet
					unset.refname := self.refname
					unset.refextend.clear
					unset.refextend.addAll(self.refextend)
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Java::Interface
		 * All the references expect InterfaceToUnset may be void 
		 */		
		class UnsetFractalJavaInterface inherits unsetAdaptation
		{
			reference InterfaceToUnset : pattern::Fractal::Java::Interface
			reference refname : pattern::Fractal::String
			reference refextend : pattern::Fractal::Java::Interface[0..*]
			
			method check(): Boolean is do
				result := InterfaceToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalJavaInterface is do
				var ad : Adapter init getAdapter
				var tempInterfaceToUnset : Fractal::Java::Interface
				tempInterfaceToUnset ?= ad.getRealObject(InterfaceToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refname,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempInterfaceToUnset.name == void
				end end
				c ?= ad.getRealObject(refextend,true)
				c.each{o | var p : Fractal::Java::Interface p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempInterfaceToUnset.extend.contains(p)
					end
				}
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempInterface : Fractal::Java::Interface
				tempInterface ?= ad.getRealObject(InterfaceToUnset,false)
				
				tempInterface.name ?= ad.unsetSingleProperty(refname, tempInterface.name)
				ad.unsetMultipleProperty(tempInterface.extend,refextend)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalJavaInterface 
					if self.reverse == void then
						~set := SetFractalJavaInterface.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.InterfaceToSet := self.InterfaceToUnset
					~set.refname := self.refname
					~set.refextend.clear
					~set.refextend.addAll(self.refextend)
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Java::Class
		 */
		
		/**
		 * Creates a new Fractal::Java::Class from scratch
		 * This new element is handled by refering to newClass
		 */
		class CreateFractalJavaClass inherits createAdaptation
		{
			attribute newClass : pattern::Fractal::Java::Class
					
			method check(): Boolean is do
				result := newClass != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newClass, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Java::Class from an existing one
		 * This cloned element is handled by refering to clonedClass
		 */
		class CloneFractalJavaClass inherits cloneAdaptation
		{
			reference ClassToClone : pattern::Fractal::Java::Class
			attribute clonedClass : pattern::Fractal::Java::Class
			
			method check(): Boolean is do
				result := ClassToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedClass, ClassToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Java::Class
		 * All the references expect ClassToSet may be void
		 */
		class SetFractalJavaClass inherits setAdaptation
		{
			reference ClassToSet : pattern::Fractal::Java::Class
			reference refname : pattern::Fractal::String
			reference refextend : pattern::Fractal::Java::Class
			reference refimplement : pattern::Fractal::Java::Interface[0..*]
			
			method check(): Boolean is do
				result := ClassToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalJavaClass is do
				var ad : Adapter init getAdapter
				var tempClassToSet : Fractal::Java::Class
				tempClassToSet ?= ad.getRealObject(ClassToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then
					isCorrectlySetted := isCorrectlySetted and tempClassToSet.name == ad.getRealObject(refname,false)
				end
				if refextend != void then
					isCorrectlySetted := isCorrectlySetted and tempClassToSet.extend == ad.getRealObject(refextend,false)
				end
				c ?= ad.getRealObject(refimplement,true)
				c.each{o | var p : Fractal::Java::Interface p?=o isCorrectlySetted := isCorrectlySetted and tempClassToSet.implement.contains(p)}
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempClass : Fractal::Java::Class
				tempClass ?= ad.getRealObject(ClassToSet,false)
				
				tempClass.name ?= ad.setSingleProperty(refname, tempClass.name)
				tempClass.extend ?= ad.setSingleProperty(refextend, tempClass.extend)
				ad.setMultipleProperty(tempClass.implement,refimplement)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalJavaClass 
					if self.reverse == void then
						unset := UnsetFractalJavaClass.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.ClassToUnset := self.ClassToSet
					unset.refname := self.refname
					unset.refextend := self.refextend
					unset.refimplement.clear
					unset.refimplement.addAll(self.refimplement)
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Java::Class
		 * All the references expect ClassToUnset may be void 
		 */		
		class UnsetFractalJavaClass inherits unsetAdaptation
		{
			reference ClassToUnset : pattern::Fractal::Java::Class
			reference refname : pattern::Fractal::String
			reference refextend : pattern::Fractal::Java::Class
			reference refimplement : pattern::Fractal::Java::Interface[0..*]
			
			method check(): Boolean is do
				result := ClassToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalJavaClass is do
				var ad : Adapter init getAdapter
				var tempClassToUnset : Fractal::Java::Class
				tempClassToUnset ?= ad.getRealObject(ClassToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refname != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refname,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempClassToUnset.name == void
				end end
				if refextend != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refextend,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempClassToUnset.extend == void
				end end
				c ?= ad.getRealObject(refimplement,true)
				c.each{o | var p : Fractal::Java::Interface p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempClassToUnset.implement.contains(p)
					end
				}
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempClass : Fractal::Java::Class
				tempClass ?= ad.getRealObject(ClassToUnset,false)
				
				tempClass.name ?= ad.unsetSingleProperty(refname, tempClass.name)
				tempClass.extend ?= ad.unsetSingleProperty(refextend, tempClass.extend)
				ad.unsetMultipleProperty(tempClass.implement,refimplement)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalJavaClass 
					if self.reverse == void then
						~set := SetFractalJavaClass.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.ClassToSet := self.ClassToUnset
					~set.refname := self.refname
					~set.refextend := self.refextend
					~set.refimplement.clear
					~set.refimplement.addAll(self.refimplement)
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Julia::Membrane
		 */
		
		/**
		 * Creates a new Fractal::Julia::Membrane from scratch
		 * This new element is handled by refering to newMembrane
		 */
		class CreateFractalJuliaMembrane inherits createAdaptation
		{
			attribute newMembrane : pattern::Fractal::Julia::Membrane
					
			method check(): Boolean is do
				result := newMembrane != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newMembrane, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Julia::Membrane from an existing one
		 * This cloned element is handled by refering to clonedMembrane
		 */
		class CloneFractalJuliaMembrane inherits cloneAdaptation
		{
			reference MembraneToClone : pattern::Fractal::Julia::Membrane
			attribute clonedMembrane : pattern::Fractal::Julia::Membrane
			
			method check(): Boolean is do
				result := MembraneToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedMembrane, MembraneToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Julia::Membrane
		 * All the references expect MembraneToSet may be void
		 */
		class SetFractalJuliaMembrane inherits setAdaptation
		{
			reference MembraneToSet : pattern::Fractal::Julia::Membrane
			reference refcontrollerDesc : pattern::Fractal::String
			reference refinterceptor : pattern::Fractal::Julia::Interceptor[0..*]
			reference refcontent : pattern::Fractal::Java::Class
			reference refowner : pattern::Fractal::Component
			reference refexternalInterface : pattern::Fractal::Interface[0..*]
			reference refinternalInterface : pattern::Fractal::Interface[0..*]
			reference refcontroller : pattern::Fractal::Controller[0..*]
			
			method check(): Boolean is do
				result := MembraneToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalJuliaMembrane is do
				var ad : Adapter init getAdapter
				var tempMembraneToSet : Fractal::Julia::Membrane
				tempMembraneToSet ?= ad.getRealObject(MembraneToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refcontrollerDesc != void then
					isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.controllerDesc == ad.getRealObject(refcontrollerDesc,false)
				end
				c ?= ad.getRealObject(refinterceptor,true)
				c.each{o | var p : Fractal::Julia::Interceptor p?=o isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.interceptor.contains(p)}
				if refcontent != void then
					isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.content == ad.getRealObject(refcontent,false)
				end
				if refowner != void then
					isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.owner == ad.getRealObject(refowner,false)
				end
				c ?= ad.getRealObject(refexternalInterface,true)
				c.each{o | var p : Fractal::Interface p?=o isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.externalInterface.contains(p)}
				c ?= ad.getRealObject(refinternalInterface,true)
				c.each{o | var p : Fractal::Interface p?=o isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.internalInterface.contains(p)}
				c ?= ad.getRealObject(refcontroller,true)
				c.each{o | var p : Fractal::Controller p?=o isCorrectlySetted := isCorrectlySetted and tempMembraneToSet.controller.contains(p)}
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempMembrane : Fractal::Julia::Membrane
				tempMembrane ?= ad.getRealObject(MembraneToSet,false)
				
				tempMembrane.controllerDesc ?= ad.setSingleProperty(refcontrollerDesc, tempMembrane.controllerDesc)
				ad.setMultipleProperty(tempMembrane.interceptor,refinterceptor)
				tempMembrane.content ?= ad.setSingleProperty(refcontent, tempMembrane.content)
				tempMembrane.owner ?= ad.setSingleProperty(refowner, tempMembrane.owner)
				ad.setMultipleProperty(tempMembrane.externalInterface,refexternalInterface)
				ad.setMultipleProperty(tempMembrane.internalInterface,refinternalInterface)
				ad.setMultipleProperty(tempMembrane.controller,refcontroller)
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalJuliaMembrane 
					if self.reverse == void then
						unset := UnsetFractalJuliaMembrane.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.MembraneToUnset := self.MembraneToSet
					unset.refcontrollerDesc := self.refcontrollerDesc
					unset.refinterceptor.clear
					unset.refinterceptor.addAll(self.refinterceptor)
					unset.refcontent := self.refcontent
					unset.refowner := self.refowner
					unset.refexternalInterface.clear
					unset.refexternalInterface.addAll(self.refexternalInterface)
					unset.refinternalInterface.clear
					unset.refinternalInterface.addAll(self.refinternalInterface)
					unset.refcontroller.clear
					unset.refcontroller.addAll(self.refcontroller)
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Julia::Membrane
		 * All the references expect MembraneToUnset may be void 
		 */		
		class UnsetFractalJuliaMembrane inherits unsetAdaptation
		{
			reference MembraneToUnset : pattern::Fractal::Julia::Membrane
			reference refcontrollerDesc : pattern::Fractal::String
			reference refinterceptor : pattern::Fractal::Julia::Interceptor[0..*]
			reference refcontent : pattern::Fractal::Java::Class
			reference refowner : pattern::Fractal::Component
			reference refexternalInterface : pattern::Fractal::Interface[0..*]
			reference refinternalInterface : pattern::Fractal::Interface[0..*]
			reference refcontroller : pattern::Fractal::Controller[0..*]
			
			method check(): Boolean is do
				result := MembraneToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalJuliaMembrane is do
				var ad : Adapter init getAdapter
				var tempMembraneToUnset : Fractal::Julia::Membrane
				tempMembraneToUnset ?= ad.getRealObject(MembraneToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				if refcontrollerDesc != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refcontrollerDesc,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempMembraneToUnset.controllerDesc == void
				end end
				c ?= ad.getRealObject(refinterceptor,true)
				c.each{o | var p : Fractal::Julia::Interceptor p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempMembraneToUnset.interceptor.contains(p)
					end
				}
				if refcontent != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refcontent,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempMembraneToUnset.content == void
				end end
				if refowner != void then 
				if not ad.notRemovable.contains(ad.getRealObject(refowner,false)) then
					isCorrectlyUnsetted := isCorrectlyUnsetted and tempMembraneToUnset.owner == void
				end end
				c ?= ad.getRealObject(refexternalInterface,true)
				c.each{o | var p : Fractal::Interface p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempMembraneToUnset.externalInterface.contains(p)
					end
				}
				c ?= ad.getRealObject(refinternalInterface,true)
				c.each{o | var p : Fractal::Interface p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempMembraneToUnset.internalInterface.contains(p)
					end
				}
				c ?= ad.getRealObject(refcontroller,true)
				c.each{o | var p : Fractal::Controller p?=o 
					if not ad.notRemovable.contains(p) then
						isCorrectlyUnsetted := isCorrectlyUnsetted and not tempMembraneToUnset.controller.contains(p)
					end
				}
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempMembrane : Fractal::Julia::Membrane
				tempMembrane ?= ad.getRealObject(MembraneToUnset,false)
				
				tempMembrane.controllerDesc ?= ad.unsetSingleProperty(refcontrollerDesc, tempMembrane.controllerDesc)
				ad.unsetMultipleProperty(tempMembrane.interceptor,refinterceptor)
				tempMembrane.content ?= ad.unsetSingleProperty(refcontent, tempMembrane.content)
				tempMembrane.owner ?= ad.unsetSingleProperty(refowner, tempMembrane.owner)
				ad.unsetMultipleProperty(tempMembrane.externalInterface,refexternalInterface)
				ad.unsetMultipleProperty(tempMembrane.internalInterface,refinternalInterface)
				ad.unsetMultipleProperty(tempMembrane.controller,refcontroller)
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalJuliaMembrane 
					if self.reverse == void then
						~set := SetFractalJuliaMembrane.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.MembraneToSet := self.MembraneToUnset
					~set.refcontrollerDesc := self.refcontrollerDesc
					~set.refinterceptor.clear
					~set.refinterceptor.addAll(self.refinterceptor)
					~set.refcontent := self.refcontent
					~set.refowner := self.refowner
					~set.refexternalInterface.clear
					~set.refexternalInterface.addAll(self.refexternalInterface)
					~set.refinternalInterface.clear
					~set.refinternalInterface.addAll(self.refinternalInterface)
					~set.refcontroller.clear
					~set.refcontroller.addAll(self.refcontroller)
				end
			end
		}
		 
		/*
		 * Adaptations dedicated to the manipulation
		 * of Fractal::Julia::Interceptor
		 */
		
		/**
		 * Creates a new Fractal::Julia::Interceptor from scratch
		 * This new element is handled by refering to newInterceptor
		 */
		class CreateFractalJuliaInterceptor inherits createAdaptation
		{
			attribute newInterceptor : pattern::Fractal::Julia::Interceptor
					
			method check(): Boolean is do
				result := newInterceptor != void
			end
					
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(newInterceptor, void, isUnique)					
			end
		}

		/**
		 * Creates a new Fractal::Julia::Interceptor from an existing one
		 * This cloned element is handled by refering to clonedInterceptor
		 */
		class CloneFractalJuliaInterceptor inherits cloneAdaptation
		{
			reference InterceptorToClone : pattern::Fractal::Julia::Interceptor
			attribute clonedInterceptor : pattern::Fractal::Julia::Interceptor
			
			method check(): Boolean is do
				result := InterceptorToClone != void
			end
			
			method execute(reverse : Boolean): Void is do
				adapter.cloneAgain(clonedInterceptor, InterceptorToClone, isUnique)
			end					
		}

		/**
		 * Sets any property of Fractal::Julia::Interceptor
		 * All the references expect InterceptorToSet may be void
		 */
		class SetFractalJuliaInterceptor inherits setAdaptation
		{
			reference InterceptorToSet : pattern::Fractal::Julia::Interceptor
			
			method check(): Boolean is do
				result := InterceptorToSet != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlySettedFractalJuliaInterceptor is do
				var ad : Adapter init getAdapter
				var tempInterceptorToSet : Fractal::Julia::Interceptor
				tempInterceptorToSet ?= ad.getRealObject(InterceptorToSet,false)
				var isCorrectlySetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				isCorrectlySetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempInterceptor : Fractal::Julia::Interceptor
				tempInterceptor ?= ad.getRealObject(InterceptorToSet,false)
				
				
				//Instantiating the reverse adaptation
				if(reverse) then		
					var unset : UnsetFractalJuliaInterceptor 
					if self.reverse == void then
						unset := UnsetFractalJuliaInterceptor.new
						unset.reverse := self
						self.reverse := unset
					else
						unset ?= self.reverse
					end		
					unset.InterceptorToUnset := self.InterceptorToSet
				end	
			end			
		}
		
		/**
		 * Unsets any property of Fractal::Julia::Interceptor
		 * All the references expect InterceptorToUnset may be void 
		 */		
		class UnsetFractalJuliaInterceptor inherits unsetAdaptation
		{
			reference InterceptorToUnset : pattern::Fractal::Julia::Interceptor
			
			method check(): Boolean is do
				result := InterceptorToUnset != void
			end
			
			method execute(reverse : Boolean): Void 
			post correctlyUnsettedFractalJuliaInterceptor is do
				var ad : Adapter init getAdapter
				var tempInterceptorToUnset : Fractal::Julia::Interceptor
				tempInterceptorToUnset ?= ad.getRealObject(InterceptorToUnset,false)
				var isCorrectlyUnsetted : Boolean init true
				var c : Collection<kermeta::language::structure::Object>
				isCorrectlyUnsetted
			end
			is do
				var ad : Adapter init getAdapter
				var tempInterceptor : Fractal::Julia::Interceptor
				tempInterceptor ?= ad.getRealObject(InterceptorToUnset,false)
				
				
				//Instantiating the reverse adaptation
				if reverse then
					var ~set : SetFractalJuliaInterceptor 
					if self.reverse == void then
						~set := SetFractalJuliaInterceptor.new
						~set.reverse := self
						self.reverse := ~set
					else
						~set ?= self.reverse
					end
					~set.InterceptorToSet := self.InterceptorToUnset
				end
			end
		}
	}
}}