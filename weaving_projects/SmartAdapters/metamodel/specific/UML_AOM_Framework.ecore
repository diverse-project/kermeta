<?xml version="1.0" encoding="ASCII"?>
<ecore:EPackage xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="org" nsURI="platform:/resource/SmartAdapters/metamodel/specific/UML_AOM_Framework.ecore" nsPrefix="org">
  <eAnnotations source="kermeta.req">
    <details key="platform:/plugin/fr.irisa.triskell.kermeta/lib/framework.km" value="platform:/plugin/fr.irisa.triskell.kermeta/lib/framework.km"/>
    <details key="platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt" value="platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdapters.kmt"/>
    <details key="platform:/resource/SmartAdapters/metamodel/domain/UML.ecore" value="platform:/resource/SmartAdapters/metamodel/domain/UML.ecore"/>
    <details key="platform:/resource/SmartAdapters/metamodel/domain/UMLPattern.ecore" value="platform:/resource/SmartAdapters/metamodel/domain/UMLPattern.ecore"/>
  </eAnnotations>
  <eClassifiers xsi:type="ecore:EDataType" name="Object" instanceClassName="java.lang.Object"/>
  <eClassifiers xsi:type="ecore:EDataType" name="Boolean" instanceClassName="java.lang.Boolean"/>
  <eClassifiers xsi:type="ecore:EDataType" name="Integer" instanceClassName="java.lang.Integer"/>
  <eSubpackages name="smartadapters" nsURI="platform:/resource/SmartAdapters/metamodel/specific/UML_AOM_Framework.ecore#//smartadapters" nsPrefix="smartadapters">
    <eSubpackages name="core" nsURI="platform:/resource/SmartAdapters/metamodel/specific/UML_AOM_Framework.ecore#//smartadapters/core" nsPrefix="core">
      <eClassifiers xsi:type="ecore:EClass" name="Adapter">
        <eOperations name="initConvert">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;stdio.write(&quot;Mapping MM' to MM...&quot;)&#xA;&#x9;convert := kermeta::utils::Hashtable&lt;kermeta::reflection::Class, kermeta::reflection::Class>.new&#xA;&#x9;convert.put(pattern::uml::Element, uml::Element)&#xA;&#x9;convert.put(pattern::uml::Package, uml::Package)&#xA;&#x9;convert.put(pattern::uml::PackageableElement, uml::PackageableElement)&#xA;&#x9;convert.put(pattern::uml::NamedElement, uml::NamedElement)&#xA;&#x9;convert.put(pattern::uml::Namespace, uml::Namespace)&#xA;&#x9;convert.put(pattern::uml::Association, uml::Association)&#xA;&#x9;convert.put(pattern::uml::Classifier, uml::Classifier)&#xA;&#x9;convert.put(pattern::uml::Generalization, uml::Generalization)&#xA;&#x9;convert.put(pattern::uml::Parameter, uml::Parameter)&#xA;&#x9;convert.put(pattern::uml::Property, uml::Property)&#xA;&#x9;convert.put(pattern::uml::Operation, uml::Operation)&#xA;&#x9;convert.put(pattern::uml::Class, uml::Class)&#xA;&#x9;convert.put(pattern::uml::Interface, uml::Interface)&#xA;&#x9;convert.put(pattern::uml::DataType, uml::DataType)&#xA;end"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="apply" ordered="false">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;binding := b&#xA;&#x9;if clone.equals(void) then&#xA;&#x9;&#x9;initClone&#xA;&#xA;&#x9;end&#xA;&#x9;adapt.each{a | a.execute}&#xA;&#x9;updateClones&#xA;end"/>
          </eAnnotations>
          <eParameters name="b">
            <eAnnotations source="kermeta.typeVariableBindings">
              <details key="0" value="Object"/>
              <details key="1" value="Object"/>
            </eAnnotations>
            <eType xsi:type="ecore:EClass" href="../../../../plugin/fr.irisa.triskell.kermeta/lib/framework.ecore#//utils/Hashtable"/>
          </eParameters>
        </eOperations>
        <eOperations name="initClone" ordered="false">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;converter := utils::Converter.new&#xA;&#x9;clone := kermeta::utils::Hashtable&lt;kermeta::standard::Object, kermeta::standard::Object>.new&#xA;&#x9;cloned := kermeta::standard::Set&lt;kermeta::standard::Object>.new&#xA;&#x9;created := kermeta::utils::Hashtable&lt;kermeta::standard::Object, kermeta::standard::Object>.new&#xA;&#x9;if aspect.structure.isNotEqual(void) then&#xA;&#x9;&#x9;aspect.structure.content.each{elt | do&#xA;&#x9;&#x9;&#x9;&#x9;var newCloned : kermeta::standard::Object&#xA;&#x9;&#x9;&#x9;&#x9;newCloned := converter.convert(kermeta::standard::Object.clone(elt), convert)&#xA;&#x9;&#x9;&#x9;&#x9;if newCloned.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;clone.put(elt, newCloned)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;   initClone must be called before the first binding&#xD;&#xA;   */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="updateClones" ordered="false">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if aspect.structure.isNotEqual(void) then&#xA;&#x9;&#x9;aspect.structure.content.each{o | if not (aspect.persistent.contains(o)) then&#xA;&#x9;&#x9;&#x9;&#x9;updateClone(o)&#xA;&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;   updateClone must be called after every binding&#xD;&#xA;   */"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="updateClone" ordered="false">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;clone.remove(pObj)&#xA;&#x9;converter.deleteConverted(pObj)&#xA;&#x9;var newCloned : kermeta::standard::Object&#xA;&#x9;newCloned := converter.convert(kermeta::standard::Object.clone(pObj), convert)&#xA;&#x9;if newCloned.isNotEqual(void) then&#xA;&#x9;&#x9;clone.put(pObj, newCloned)&#xA;&#xA;&#x9;end&#xA;end"/>
          </eAnnotations>
          <eParameters name="pObj" eType="//Object"/>
        </eOperations>
        <eOperations name="getRealObject" eType="//Object">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if isCollect then&#xA;&#x9;&#x9;var col : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;&#x9;col ?= obj&#xA;&#x9;&#x9;var res : kermeta::standard::Set&lt;kermeta::standard::Object> init kermeta::standard::Set&lt;kermeta::standard::Object>.new&#xA;&#x9;&#x9;col.each{o | res.add(getRealObject(o, false))}&#xA;&#x9;&#x9;result := res&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var realObj : kermeta::standard::Object&#xA;&#x9;&#x9;realObj ?= clone.getValue(obj)&#xA;&#x9;&#x9;if realObj.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;result := realObj&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;realObj ?= binding.getValue(obj)&#xA;&#x9;&#x9;&#x9;if realObj.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;result := realObj&#xA;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;realObj ?= created.getValue(obj)&#xA;&#x9;&#x9;&#x9;&#x9;if realObj.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result := realObj&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var pObj : patternframework::PObject&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;pObj ?= obj&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if pObj.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result := converter.convert(kermeta::standard::Object.clone(obj), convert)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result := obj&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;   returns the PObject that is actually in the base model&#xD;&#xA;    - a model base element&#xD;&#xA;   or - a clone of an aspect element already inserted in the base model&#xD;&#xA;   or  - the element itself (composition of two models without using pattern matching)&#xD;&#xA;   */"/>
          </eAnnotations>
          <eParameters name="obj" eType="//Object"/>
          <eParameters name="isCollect" eType="//Boolean"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="aspect" lowerBound="1" eType="//smartadapters/core/Aspect" containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="adapt" upperBound="-1" eType="//smartadapters/core/Adaptation" containment="true" eOpposite="//smartadapters/core/Adaptation/adapter"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="name">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
          </eAnnotations>
          <eType xsi:type="ecore:EDataType" href="http://www.eclipse.org/emf/2002/Ecore#//EString"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="clone" containment="true">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xD;&#xA;   key : aspect element&#xD;&#xA;   value : associated clone&#xD;&#xA;   */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.typeVariableBindings">
            <details key="0" value="Object"/>
            <details key="1" value="Object"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="../../../../plugin/fr.irisa.triskell.kermeta/lib/framework.ecore#//utils/Hashtable"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="cloned" containment="true">
          <eAnnotations source="kermeta.typeVariableBindings">
            <details key="0" value="Object"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="../../../../plugin/fr.irisa.triskell.kermeta/lib/framework.ecore#//standard/Set"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="binding" containment="true">
          <eAnnotations source="kermeta.typeVariableBindings">
            <details key="0" value="Object"/>
            <details key="1" value="Object"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="../../../../plugin/fr.irisa.triskell.kermeta/lib/framework.ecore#//utils/Hashtable"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="convert" containment="true">
          <eAnnotations source="kermeta.typeVariableBindings">
            <details key="0" value="kermeta::reflection::Class"/>
            <details key="1" value="kermeta::reflection::Class"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="../../../../plugin/fr.irisa.triskell.kermeta/lib/framework.ecore#//utils/Hashtable"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="created" containment="true">
          <eAnnotations source="kermeta.typeVariableBindings">
            <details key="0" value="Object"/>
            <details key="1" value="Object"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="../../../../plugin/fr.irisa.triskell.kermeta/lib/framework.ecore#//utils/Hashtable"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="converter" containment="true">
          <eType xsi:type="ecore:EClass" href="platform:/resource/SmartAdapters/metamodel/specific//converter.ecore#//Converter"/>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Aspect">
        <eStructuralFeatures xsi:type="ecore:EReference" name="template" containment="true">
          <eType xsi:type="ecore:EClass" href="../../../fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore#//ModelPattern"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="structure" lowerBound="1" containment="true">
          <eType xsi:type="ecore:EClass" href="../../../fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore#//PModel"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="persistent" upperBound="-1">
          <eAnnotations source="kermeta">
            <details key="documentation" value="/**&#xD;&#xA;   persistent refers to aspectual PObject that must not be&#xD;&#xA;   cloned between two bindings&#xD;&#xA;   TODO : contraints...&#xD;&#xA;   */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EClass" href="../../../fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore#//PObject"/>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Adaptation" abstract="true" eSuperTypes="//smartadapters/extension/AdapterElement">
        <eOperations name="check" eType="//Boolean">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="execute">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
            <details key="documentation" value="/**&#xD;&#xA;   Execute the adaptation for a given binding&#xD;&#xA;   Sub-classes must implement this method&#xD;&#xA;   */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.pre">
            <details key="checking" value="check"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="adapter" lowerBound="1" eType="//smartadapters/core/Adapter" eOpposite="//smartadapters/core/Adapter/adapt"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="makeUnique" eSuperTypes="//smartadapters/core/Adaptation">
        <eOperations name="check" eType="//Boolean">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := (element.isNotEqual(void)) and (adapter.aspect.structure.content.contains(element))&#xA;end"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="execute">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;adapter.aspect.persistent.add(element)&#xA;end"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="element" lowerBound="1">
          <eType xsi:type="ecore:EClass" href="../../../fr.irisa.triskell.kermeta.patternmatching/src/kermeta/pattern/metamodel/PatternFramework.ecore#//PObject"/>
        </eStructuralFeatures>
      </eClassifiers>
      <eSubpackages name="adaptations" nsURI="platform:/resource/SmartAdapters/metamodel/specific/UML_AOM_Framework.ecore#//smartadapters/core/adaptations" nsPrefix="adaptations">
        <eClassifiers xsi:type="ecore:EClass" name="createPackage" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newPackage.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if (adapter.created.getValue(newPackage).equals(void)) or (not (isUnique)) then&#xA;&#x9;&#x9;var realPackage : uml::Package&#xA;&#x9;&#x9;realPackage ?= adapter.converter.convert(kermeta::standard::Object.clone(newPackage), adapter.convert)&#xA;&#x9;&#x9;adapter.created.put(newPackage, realPackage)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newPackage" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Package"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="clonePackage" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newPackage.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var clonedPackage : uml::Package&#xA;&#x9;var temp : uml::Package&#xA;&#x9;temp ?= adapter.getRealObject(newPackage, false)&#xA;&#x9;if isUnique then&#xA;&#x9;&#x9;if not (adapter.cloned.exists{o | o.equals(temp)}) then&#xA;&#x9;&#x9;&#x9;clonedPackage ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;&#x9;adapter.clone.put(realPackage, clonedPackage)&#xA;&#x9;&#x9;&#x9;adapter.cloned.add(temp)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;clonedPackage ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;adapter.clone.put(realPackage, clonedPackage)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newPackage">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Package"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="realPackage" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Package"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="setPackage" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aPackage.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempPackage : uml::Package&#xA;&#x9;tempPackage ?= adapter.getRealObject(aPackage, false)&#xA;&#x9;var temppackagedElement : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;temppackagedElement ?= adapter.getRealObject(apackagedElement, true)&#xA;&#x9;if temppackagedElement.isNotEqual(void) then&#xA;&#x9;&#x9;temppackagedElement.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::PackageableElement&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempPackage.packagedElement.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempPackage.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempPackage.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempPackage.ownedComment.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aPackage">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Package"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="apackagedElement" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/PackageableElement"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="unsetPackage" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aPackage.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempPackage : uml::Package&#xA;&#x9;tempPackage ?= adapter.getRealObject(aPackage, false)&#xA;&#x9;var temppackagedElement : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;temppackagedElement ?= adapter.getRealObject(apackagedElement, true)&#xA;&#x9;if temppackagedElement.isNotEqual(void) then&#xA;&#x9;&#x9;temppackagedElement.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::PackageableElement&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempPackage.packagedElement.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempPackage.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempPackage.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempPackage.ownedComment.remove(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aPackage">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Package"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="apackagedElement" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/PackageableElement"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="createAssociation" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newAssociation.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if (adapter.created.getValue(newAssociation).equals(void)) or (not (isUnique)) then&#xA;&#x9;&#x9;var realAssociation : uml::Association&#xA;&#x9;&#x9;realAssociation ?= adapter.converter.convert(kermeta::standard::Object.clone(newAssociation), adapter.convert)&#xA;&#x9;&#x9;adapter.created.put(newAssociation, realAssociation)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newAssociation" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="cloneAssociation" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newAssociation.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var clonedAssociation : uml::Association&#xA;&#x9;var temp : uml::Association&#xA;&#x9;temp ?= adapter.getRealObject(newAssociation, false)&#xA;&#x9;if isUnique then&#xA;&#x9;&#x9;if not (adapter.cloned.exists{o | o.equals(temp)}) then&#xA;&#x9;&#x9;&#x9;clonedAssociation ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;&#x9;adapter.clone.put(realAssociation, clonedAssociation)&#xA;&#x9;&#x9;&#x9;adapter.cloned.add(temp)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;clonedAssociation ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;adapter.clone.put(realAssociation, clonedAssociation)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newAssociation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="realAssociation" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="setAssociation" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aAssociation.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempAssociation : uml::Association&#xA;&#x9;tempAssociation ?= adapter.getRealObject(aAssociation, false)&#xA;&#x9;var tempownedEnd : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedEnd ?= adapter.getRealObject(aownedEnd, true)&#xA;&#x9;if tempownedEnd.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedEnd.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.ownedEnd.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempmemberEnd : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempmemberEnd ?= adapter.getRealObject(amemberEnd, true)&#xA;&#x9;if tempmemberEnd.isNotEqual(void) then&#xA;&#x9;&#x9;tempmemberEnd.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.memberEnd.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisDerived : uml::Boolean&#xA;&#x9;tempisDerived ?= adapter.getRealObject(aisDerived, false)&#xA;&#x9;if (tempisDerived) != (void) then&#xA;&#x9;&#x9;tempAssociation.isDerived := tempisDerived&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnavigableOwnedEnd : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempnavigableOwnedEnd ?= adapter.getRealObject(anavigableOwnedEnd, true)&#xA;&#x9;if tempnavigableOwnedEnd.isNotEqual(void) then&#xA;&#x9;&#x9;tempnavigableOwnedEnd.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.navigableOwnedEnd.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisAbstract : uml::Boolean&#xA;&#x9;tempisAbstract ?= adapter.getRealObject(aisAbstract, false)&#xA;&#x9;if (tempisAbstract) != (void) then&#xA;&#x9;&#x9;tempAssociation.isAbstract := tempisAbstract&#xA;&#xA;&#x9;end&#xA;&#x9;var tempgeneralization : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempgeneralization ?= adapter.getRealObject(ageneralization, true)&#xA;&#x9;if tempgeneralization.isNotEqual(void) then&#xA;&#x9;&#x9;tempgeneralization.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Generalization&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.generalization.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var temppowertypeExtent : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;temppowertypeExtent ?= adapter.getRealObject(apowertypeExtent, true)&#xA;&#x9;if temppowertypeExtent.isNotEqual(void) then&#xA;&#x9;&#x9;temppowertypeExtent.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::GeneralizationSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.powertypeExtent.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedClassifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedClassifier ?= adapter.getRealObject(aredefinedClassifier, true)&#xA;&#x9;if tempredefinedClassifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedClassifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Classifier&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.redefinedClassifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempAssociation.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.ownedComment.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aAssociation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedEnd" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="amemberEnd" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisDerived">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anavigableOwnedEnd" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisAbstract">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneralization" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="apowertypeExtent" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/GeneralizationSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedClassifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="unsetAssociation" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aAssociation.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempAssociation : uml::Association&#xA;&#x9;tempAssociation ?= adapter.getRealObject(aAssociation, false)&#xA;&#x9;var tempownedEnd : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedEnd ?= adapter.getRealObject(aownedEnd, true)&#xA;&#x9;if tempownedEnd.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedEnd.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.ownedEnd.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempmemberEnd : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempmemberEnd ?= adapter.getRealObject(amemberEnd, true)&#xA;&#x9;if tempmemberEnd.isNotEqual(void) then&#xA;&#x9;&#x9;tempmemberEnd.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.memberEnd.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisDerived : uml::Boolean&#xA;&#x9;tempisDerived ?= adapter.getRealObject(aisDerived, false)&#xA;&#x9;if (tempisDerived) != (void) then&#xA;&#x9;&#x9;tempAssociation.isDerived := tempisDerived&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnavigableOwnedEnd : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempnavigableOwnedEnd ?= adapter.getRealObject(anavigableOwnedEnd, true)&#xA;&#x9;if tempnavigableOwnedEnd.isNotEqual(void) then&#xA;&#x9;&#x9;tempnavigableOwnedEnd.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.navigableOwnedEnd.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisAbstract : uml::Boolean&#xA;&#x9;tempisAbstract ?= adapter.getRealObject(aisAbstract, false)&#xA;&#x9;if (tempisAbstract) != (void) then&#xA;&#x9;&#x9;tempAssociation.isAbstract := tempisAbstract&#xA;&#xA;&#x9;end&#xA;&#x9;var tempgeneralization : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempgeneralization ?= adapter.getRealObject(ageneralization, true)&#xA;&#x9;if tempgeneralization.isNotEqual(void) then&#xA;&#x9;&#x9;tempgeneralization.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Generalization&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.generalization.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var temppowertypeExtent : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;temppowertypeExtent ?= adapter.getRealObject(apowertypeExtent, true)&#xA;&#x9;if temppowertypeExtent.isNotEqual(void) then&#xA;&#x9;&#x9;temppowertypeExtent.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::GeneralizationSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.powertypeExtent.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedClassifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedClassifier ?= adapter.getRealObject(aredefinedClassifier, true)&#xA;&#x9;if tempredefinedClassifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedClassifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Classifier&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.redefinedClassifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempAssociation.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempAssociation.ownedComment.remove(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aAssociation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedEnd" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="amemberEnd" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisDerived">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anavigableOwnedEnd" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisAbstract">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneralization" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="apowertypeExtent" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/GeneralizationSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedClassifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="createGeneralization" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newGeneralization.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if (adapter.created.getValue(newGeneralization).equals(void)) or (not (isUnique)) then&#xA;&#x9;&#x9;var realGeneralization : uml::Generalization&#xA;&#x9;&#x9;realGeneralization ?= adapter.converter.convert(kermeta::standard::Object.clone(newGeneralization), adapter.convert)&#xA;&#x9;&#x9;adapter.created.put(newGeneralization, realGeneralization)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newGeneralization" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="cloneGeneralization" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newGeneralization.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var clonedGeneralization : uml::Generalization&#xA;&#x9;var temp : uml::Generalization&#xA;&#x9;temp ?= adapter.getRealObject(newGeneralization, false)&#xA;&#x9;if isUnique then&#xA;&#x9;&#x9;if not (adapter.cloned.exists{o | o.equals(temp)}) then&#xA;&#x9;&#x9;&#x9;clonedGeneralization ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;&#x9;adapter.clone.put(realGeneralization, clonedGeneralization)&#xA;&#x9;&#x9;&#x9;adapter.cloned.add(temp)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;clonedGeneralization ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;adapter.clone.put(realGeneralization, clonedGeneralization)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newGeneralization">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="realGeneralization" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="setGeneralization" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aGeneralization.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempGeneralization : uml::Generalization&#xA;&#x9;tempGeneralization ?= adapter.getRealObject(aGeneralization, false)&#xA;&#x9;var tempgeneral : uml::Classifier&#xA;&#x9;tempgeneral ?= adapter.getRealObject(ageneral, false)&#xA;&#x9;if tempgeneral.isNotEqual(void) then&#xA;&#x9;&#x9;tempGeneralization.general := tempgeneral&#xA;&#xA;&#x9;end&#xA;&#x9;var tempgeneralizationSet : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempgeneralizationSet ?= adapter.getRealObject(ageneralizationSet, true)&#xA;&#x9;if tempgeneralizationSet.isNotEqual(void) then&#xA;&#x9;&#x9;tempgeneralizationSet.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::GeneralizationSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempGeneralization.generalizationSet.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempspecific : uml::Classifier&#xA;&#x9;tempspecific ?= adapter.getRealObject(aspecific, false)&#xA;&#x9;if tempspecific.isNotEqual(void) then&#xA;&#x9;&#x9;tempGeneralization.specific := tempspecific&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempGeneralization.ownedComment.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aGeneralization">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneral">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneralizationSet" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/GeneralizationSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aspecific">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="unsetGeneralization" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aGeneralization.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempGeneralization : uml::Generalization&#xA;&#x9;tempGeneralization ?= adapter.getRealObject(aGeneralization, false)&#xA;&#x9;var tempgeneral : uml::Classifier&#xA;&#x9;tempgeneral ?= adapter.getRealObject(ageneral, false)&#xA;&#x9;if tempgeneral.isNotEqual(void) then&#xA;&#x9;&#x9;tempGeneralization.general := tempgeneral&#xA;&#xA;&#x9;end&#xA;&#x9;var tempgeneralizationSet : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempgeneralizationSet ?= adapter.getRealObject(ageneralizationSet, true)&#xA;&#x9;if tempgeneralizationSet.isNotEqual(void) then&#xA;&#x9;&#x9;tempgeneralizationSet.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::GeneralizationSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempGeneralization.generalizationSet.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempspecific : uml::Classifier&#xA;&#x9;tempspecific ?= adapter.getRealObject(aspecific, false)&#xA;&#x9;if tempspecific.isNotEqual(void) then&#xA;&#x9;&#x9;tempGeneralization.specific := tempspecific&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempGeneralization.ownedComment.remove(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aGeneralization">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneral">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneralizationSet" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/GeneralizationSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aspecific">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="createParameter" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newParameter.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if (adapter.created.getValue(newParameter).equals(void)) or (not (isUnique)) then&#xA;&#x9;&#x9;var realParameter : uml::Parameter&#xA;&#x9;&#x9;realParameter ?= adapter.converter.convert(kermeta::standard::Object.clone(newParameter), adapter.convert)&#xA;&#x9;&#x9;adapter.created.put(newParameter, realParameter)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newParameter" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Parameter"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="cloneParameter" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newParameter.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var clonedParameter : uml::Parameter&#xA;&#x9;var temp : uml::Parameter&#xA;&#x9;temp ?= adapter.getRealObject(newParameter, false)&#xA;&#x9;if isUnique then&#xA;&#x9;&#x9;if not (adapter.cloned.exists{o | o.equals(temp)}) then&#xA;&#x9;&#x9;&#x9;clonedParameter ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;&#x9;adapter.clone.put(realParameter, clonedParameter)&#xA;&#x9;&#x9;&#x9;adapter.cloned.add(temp)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;clonedParameter ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;adapter.clone.put(realParameter, clonedParameter)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newParameter">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Parameter"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="realParameter" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Parameter"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="setParameter" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aParameter.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempParameter : uml::Parameter&#xA;&#x9;tempParameter ?= adapter.getRealObject(aParameter, false)&#xA;&#x9;var tempparameterSet : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempparameterSet ?= adapter.getRealObject(aparameterSet, true)&#xA;&#x9;if tempparameterSet.isNotEqual(void) then&#xA;&#x9;&#x9;tempparameterSet.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::ParameterSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempParameter.parameterSet.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempdirection : uml::ParameterDirectionKind&#xA;&#x9;tempdirection ?= adapter.getRealObject(adirection, false)&#xA;&#x9;if tempdirection.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.direction := tempdirection&#xA;&#xA;&#x9;end&#xA;&#x9;var tempdefaultValue : uml::ValueSpecification&#xA;&#x9;tempdefaultValue ?= adapter.getRealObject(adefaultValue, false)&#xA;&#x9;if tempdefaultValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.defaultValue := tempdefaultValue&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisException : uml::Boolean&#xA;&#x9;tempisException ?= adapter.getRealObject(aisException, false)&#xA;&#x9;if (tempisException) != (void) then&#xA;&#x9;&#x9;tempParameter.isException := tempisException&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisStream : uml::Boolean&#xA;&#x9;tempisStream ?= adapter.getRealObject(aisStream, false)&#xA;&#x9;if (tempisStream) != (void) then&#xA;&#x9;&#x9;tempParameter.isStream := tempisStream&#xA;&#xA;&#x9;end&#xA;&#x9;var tempend : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempend ?= adapter.getRealObject(aend, true)&#xA;&#x9;if tempend.isNotEqual(void) then&#xA;&#x9;&#x9;tempend.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::ConnectorEnd&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempParameter.~end.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisOrdered : uml::Boolean&#xA;&#x9;tempisOrdered ?= adapter.getRealObject(aisOrdered, false)&#xA;&#x9;if (tempisOrdered) != (void) then&#xA;&#x9;&#x9;tempParameter.isOrdered := tempisOrdered&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisUnique : uml::Boolean&#xA;&#x9;tempisUnique ?= adapter.getRealObject(aisUnique, false)&#xA;&#x9;if (tempisUnique) != (void) then&#xA;&#x9;&#x9;tempParameter.isUnique := tempisUnique&#xA;&#xA;&#x9;end&#xA;&#x9;var tempupperValue : uml::ValueSpecification&#xA;&#x9;tempupperValue ?= adapter.getRealObject(aupperValue, false)&#xA;&#x9;if tempupperValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.upperValue := tempupperValue&#xA;&#xA;&#x9;end&#xA;&#x9;var templowerValue : uml::ValueSpecification&#xA;&#x9;templowerValue ?= adapter.getRealObject(alowerValue, false)&#xA;&#x9;if templowerValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.lowerValue := templowerValue&#xA;&#xA;&#x9;end&#xA;&#x9;var temptype : uml::Type&#xA;&#x9;temptype ?= adapter.getRealObject(atype, false)&#xA;&#x9;if temptype.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.type := temptype&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempParameter.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempParameter.ownedComment.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aParameter">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Parameter"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aparameterSet" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ParameterSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="adirection">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EEnum" href="../domain/UMLPattern.ecore#//uml/ParameterDirectionKind"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="adefaultValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisException">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisStream">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aend" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ConnectorEnd"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisOrdered">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisUnique">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aupperValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="alowerValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="atype">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Type"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="unsetParameter" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aParameter.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempParameter : uml::Parameter&#xA;&#x9;tempParameter ?= adapter.getRealObject(aParameter, false)&#xA;&#x9;var tempparameterSet : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempparameterSet ?= adapter.getRealObject(aparameterSet, true)&#xA;&#x9;if tempparameterSet.isNotEqual(void) then&#xA;&#x9;&#x9;tempparameterSet.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::ParameterSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempParameter.parameterSet.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempdirection : uml::ParameterDirectionKind&#xA;&#x9;tempdirection ?= adapter.getRealObject(adirection, false)&#xA;&#x9;if tempdirection.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.direction := tempdirection&#xA;&#xA;&#x9;end&#xA;&#x9;var tempdefaultValue : uml::ValueSpecification&#xA;&#x9;tempdefaultValue ?= adapter.getRealObject(adefaultValue, false)&#xA;&#x9;if tempdefaultValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.defaultValue := tempdefaultValue&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisException : uml::Boolean&#xA;&#x9;tempisException ?= adapter.getRealObject(aisException, false)&#xA;&#x9;if (tempisException) != (void) then&#xA;&#x9;&#x9;tempParameter.isException := tempisException&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisStream : uml::Boolean&#xA;&#x9;tempisStream ?= adapter.getRealObject(aisStream, false)&#xA;&#x9;if (tempisStream) != (void) then&#xA;&#x9;&#x9;tempParameter.isStream := tempisStream&#xA;&#xA;&#x9;end&#xA;&#x9;var tempend : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempend ?= adapter.getRealObject(aend, true)&#xA;&#x9;if tempend.isNotEqual(void) then&#xA;&#x9;&#x9;tempend.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::ConnectorEnd&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempParameter.~end.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisOrdered : uml::Boolean&#xA;&#x9;tempisOrdered ?= adapter.getRealObject(aisOrdered, false)&#xA;&#x9;if (tempisOrdered) != (void) then&#xA;&#x9;&#x9;tempParameter.isOrdered := tempisOrdered&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisUnique : uml::Boolean&#xA;&#x9;tempisUnique ?= adapter.getRealObject(aisUnique, false)&#xA;&#x9;if (tempisUnique) != (void) then&#xA;&#x9;&#x9;tempParameter.isUnique := tempisUnique&#xA;&#xA;&#x9;end&#xA;&#x9;var tempupperValue : uml::ValueSpecification&#xA;&#x9;tempupperValue ?= adapter.getRealObject(aupperValue, false)&#xA;&#x9;if tempupperValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.upperValue := tempupperValue&#xA;&#xA;&#x9;end&#xA;&#x9;var templowerValue : uml::ValueSpecification&#xA;&#x9;templowerValue ?= adapter.getRealObject(alowerValue, false)&#xA;&#x9;if templowerValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.lowerValue := templowerValue&#xA;&#xA;&#x9;end&#xA;&#x9;var temptype : uml::Type&#xA;&#x9;temptype ?= adapter.getRealObject(atype, false)&#xA;&#x9;if temptype.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.type := temptype&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempParameter.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempParameter.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempParameter.ownedComment.remove(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aParameter">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Parameter"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aparameterSet" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ParameterSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="adirection">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EEnum" href="../domain/UMLPattern.ecore#//uml/ParameterDirectionKind"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="adefaultValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisException">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisStream">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aend" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ConnectorEnd"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisOrdered">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisUnique">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aupperValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="alowerValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="atype">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Type"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="createProperty" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newProperty.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if (adapter.created.getValue(newProperty).equals(void)) or (not (isUnique)) then&#xA;&#x9;&#x9;var realProperty : uml::Property&#xA;&#x9;&#x9;realProperty ?= adapter.converter.convert(kermeta::standard::Object.clone(newProperty), adapter.convert)&#xA;&#x9;&#x9;adapter.created.put(newProperty, realProperty)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newProperty" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="cloneProperty" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newProperty.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var clonedProperty : uml::Property&#xA;&#x9;var temp : uml::Property&#xA;&#x9;temp ?= adapter.getRealObject(newProperty, false)&#xA;&#x9;if isUnique then&#xA;&#x9;&#x9;if not (adapter.cloned.exists{o | o.equals(temp)}) then&#xA;&#x9;&#x9;&#x9;clonedProperty ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;&#x9;adapter.clone.put(realProperty, clonedProperty)&#xA;&#x9;&#x9;&#x9;adapter.cloned.add(temp)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;clonedProperty ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;adapter.clone.put(realProperty, clonedProperty)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newProperty">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="realProperty" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="setProperty" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aProperty.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempProperty : uml::Property&#xA;&#x9;tempProperty ?= adapter.getRealObject(aProperty, false)&#xA;&#x9;var tempdatatype : uml::DataType&#xA;&#x9;tempdatatype ?= adapter.getRealObject(adatatype, false)&#xA;&#x9;if tempdatatype.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.datatype := tempdatatype&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisDerived : uml::Boolean&#xA;&#x9;tempisDerived ?= adapter.getRealObject(aisDerived, false)&#xA;&#x9;if (tempisDerived) != (void) then&#xA;&#x9;&#x9;tempProperty.isDerived := tempisDerived&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisDerivedUnion : uml::Boolean&#xA;&#x9;tempisDerivedUnion ?= adapter.getRealObject(aisDerivedUnion, false)&#xA;&#x9;if (tempisDerivedUnion) != (void) then&#xA;&#x9;&#x9;tempProperty.isDerivedUnion := tempisDerivedUnion&#xA;&#xA;&#x9;end&#xA;&#x9;var tempaggregation : uml::AggregationKind&#xA;&#x9;tempaggregation ?= adapter.getRealObject(aaggregation, false)&#xA;&#x9;if tempaggregation.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.aggregation := tempaggregation&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedProperty : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedProperty ?= adapter.getRealObject(aredefinedProperty, true)&#xA;&#x9;if tempredefinedProperty.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedProperty.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.redefinedProperty.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempowningAssociation : uml::Association&#xA;&#x9;tempowningAssociation ?= adapter.getRealObject(aowningAssociation, false)&#xA;&#x9;if tempowningAssociation.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.owningAssociation := tempowningAssociation&#xA;&#xA;&#x9;end&#xA;&#x9;var tempdefaultValue : uml::ValueSpecification&#xA;&#x9;tempdefaultValue ?= adapter.getRealObject(adefaultValue, false)&#xA;&#x9;if tempdefaultValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.defaultValue := tempdefaultValue&#xA;&#xA;&#x9;end&#xA;&#x9;var tempsubsettedProperty : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempsubsettedProperty ?= adapter.getRealObject(asubsettedProperty, true)&#xA;&#x9;if tempsubsettedProperty.isNotEqual(void) then&#xA;&#x9;&#x9;tempsubsettedProperty.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.subsettedProperty.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempassociation : uml::Association&#xA;&#x9;tempassociation ?= adapter.getRealObject(aassociation, false)&#xA;&#x9;if tempassociation.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.association := tempassociation&#xA;&#xA;&#x9;end&#xA;&#x9;var tempqualifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempqualifier ?= adapter.getRealObject(aqualifier, true)&#xA;&#x9;if tempqualifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempqualifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.qualifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempassociationEnd : uml::Property&#xA;&#x9;tempassociationEnd ?= adapter.getRealObject(aassociationEnd, false)&#xA;&#x9;if tempassociationEnd.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.associationEnd := tempassociationEnd&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisReadOnly : uml::Boolean&#xA;&#x9;tempisReadOnly ?= adapter.getRealObject(aisReadOnly, false)&#xA;&#x9;if (tempisReadOnly) != (void) then&#xA;&#x9;&#x9;tempProperty.isReadOnly := tempisReadOnly&#xA;&#xA;&#x9;end&#xA;&#x9;var tempend : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempend ?= adapter.getRealObject(aend, true)&#xA;&#x9;if tempend.isNotEqual(void) then&#xA;&#x9;&#x9;tempend.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::ConnectorEnd&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.~end.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var temptype : uml::Type&#xA;&#x9;temptype ?= adapter.getRealObject(atype, false)&#xA;&#x9;if temptype.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.type := temptype&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisOrdered : uml::Boolean&#xA;&#x9;tempisOrdered ?= adapter.getRealObject(aisOrdered, false)&#xA;&#x9;if (tempisOrdered) != (void) then&#xA;&#x9;&#x9;tempProperty.isOrdered := tempisOrdered&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisUnique : uml::Boolean&#xA;&#x9;tempisUnique ?= adapter.getRealObject(aisUnique, false)&#xA;&#x9;if (tempisUnique) != (void) then&#xA;&#x9;&#x9;tempProperty.isUnique := tempisUnique&#xA;&#xA;&#x9;end&#xA;&#x9;var tempupperValue : uml::ValueSpecification&#xA;&#x9;tempupperValue ?= adapter.getRealObject(aupperValue, false)&#xA;&#x9;if tempupperValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.upperValue := tempupperValue&#xA;&#xA;&#x9;end&#xA;&#x9;var templowerValue : uml::ValueSpecification&#xA;&#x9;templowerValue ?= adapter.getRealObject(alowerValue, false)&#xA;&#x9;if templowerValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.lowerValue := templowerValue&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.ownedComment.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aProperty">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="adatatype">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisDerived">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisDerivedUnion">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aaggregation">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EEnum" href="../domain/UMLPattern.ecore#//uml/AggregationKind"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedProperty" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aowningAssociation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="adefaultValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="asubsettedProperty" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aassociation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aqualifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aassociationEnd">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisReadOnly">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aend" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ConnectorEnd"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="atype">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Type"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisOrdered">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisUnique">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aupperValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="alowerValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="unsetProperty" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aProperty.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempProperty : uml::Property&#xA;&#x9;tempProperty ?= adapter.getRealObject(aProperty, false)&#xA;&#x9;var tempdatatype : uml::DataType&#xA;&#x9;tempdatatype ?= adapter.getRealObject(adatatype, false)&#xA;&#x9;if tempdatatype.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.datatype := tempdatatype&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisDerived : uml::Boolean&#xA;&#x9;tempisDerived ?= adapter.getRealObject(aisDerived, false)&#xA;&#x9;if (tempisDerived) != (void) then&#xA;&#x9;&#x9;tempProperty.isDerived := tempisDerived&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisDerivedUnion : uml::Boolean&#xA;&#x9;tempisDerivedUnion ?= adapter.getRealObject(aisDerivedUnion, false)&#xA;&#x9;if (tempisDerivedUnion) != (void) then&#xA;&#x9;&#x9;tempProperty.isDerivedUnion := tempisDerivedUnion&#xA;&#xA;&#x9;end&#xA;&#x9;var tempaggregation : uml::AggregationKind&#xA;&#x9;tempaggregation ?= adapter.getRealObject(aaggregation, false)&#xA;&#x9;if tempaggregation.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.aggregation := tempaggregation&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedProperty : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedProperty ?= adapter.getRealObject(aredefinedProperty, true)&#xA;&#x9;if tempredefinedProperty.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedProperty.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.redefinedProperty.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempowningAssociation : uml::Association&#xA;&#x9;tempowningAssociation ?= adapter.getRealObject(aowningAssociation, false)&#xA;&#x9;if tempowningAssociation.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.owningAssociation := tempowningAssociation&#xA;&#xA;&#x9;end&#xA;&#x9;var tempdefaultValue : uml::ValueSpecification&#xA;&#x9;tempdefaultValue ?= adapter.getRealObject(adefaultValue, false)&#xA;&#x9;if tempdefaultValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.defaultValue := tempdefaultValue&#xA;&#xA;&#x9;end&#xA;&#x9;var tempsubsettedProperty : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempsubsettedProperty ?= adapter.getRealObject(asubsettedProperty, true)&#xA;&#x9;if tempsubsettedProperty.isNotEqual(void) then&#xA;&#x9;&#x9;tempsubsettedProperty.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.subsettedProperty.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempassociation : uml::Association&#xA;&#x9;tempassociation ?= adapter.getRealObject(aassociation, false)&#xA;&#x9;if tempassociation.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.association := tempassociation&#xA;&#xA;&#x9;end&#xA;&#x9;var tempqualifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempqualifier ?= adapter.getRealObject(aqualifier, true)&#xA;&#x9;if tempqualifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempqualifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.qualifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempassociationEnd : uml::Property&#xA;&#x9;tempassociationEnd ?= adapter.getRealObject(aassociationEnd, false)&#xA;&#x9;if tempassociationEnd.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.associationEnd := tempassociationEnd&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisReadOnly : uml::Boolean&#xA;&#x9;tempisReadOnly ?= adapter.getRealObject(aisReadOnly, false)&#xA;&#x9;if (tempisReadOnly) != (void) then&#xA;&#x9;&#x9;tempProperty.isReadOnly := tempisReadOnly&#xA;&#xA;&#x9;end&#xA;&#x9;var tempend : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempend ?= adapter.getRealObject(aend, true)&#xA;&#x9;if tempend.isNotEqual(void) then&#xA;&#x9;&#x9;tempend.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::ConnectorEnd&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.~end.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var temptype : uml::Type&#xA;&#x9;temptype ?= adapter.getRealObject(atype, false)&#xA;&#x9;if temptype.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.type := temptype&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisOrdered : uml::Boolean&#xA;&#x9;tempisOrdered ?= adapter.getRealObject(aisOrdered, false)&#xA;&#x9;if (tempisOrdered) != (void) then&#xA;&#x9;&#x9;tempProperty.isOrdered := tempisOrdered&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisUnique : uml::Boolean&#xA;&#x9;tempisUnique ?= adapter.getRealObject(aisUnique, false)&#xA;&#x9;if (tempisUnique) != (void) then&#xA;&#x9;&#x9;tempProperty.isUnique := tempisUnique&#xA;&#xA;&#x9;end&#xA;&#x9;var tempupperValue : uml::ValueSpecification&#xA;&#x9;tempupperValue ?= adapter.getRealObject(aupperValue, false)&#xA;&#x9;if tempupperValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.upperValue := tempupperValue&#xA;&#xA;&#x9;end&#xA;&#x9;var templowerValue : uml::ValueSpecification&#xA;&#x9;templowerValue ?= adapter.getRealObject(alowerValue, false)&#xA;&#x9;if templowerValue.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.lowerValue := templowerValue&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempProperty.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempProperty.ownedComment.remove(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aProperty">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="adatatype">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisDerived">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisDerivedUnion">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aaggregation">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EEnum" href="../domain/UMLPattern.ecore#//uml/AggregationKind"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedProperty" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aowningAssociation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="adefaultValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="asubsettedProperty" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aassociation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Association"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aqualifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aassociationEnd">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisReadOnly">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aend" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ConnectorEnd"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="atype">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Type"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisOrdered">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisUnique">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aupperValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="alowerValue">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ValueSpecification"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="createOperation" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newOperation.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if (adapter.created.getValue(newOperation).equals(void)) or (not (isUnique)) then&#xA;&#x9;&#x9;var realOperation : uml::Operation&#xA;&#x9;&#x9;realOperation ?= adapter.converter.convert(kermeta::standard::Object.clone(newOperation), adapter.convert)&#xA;&#x9;&#x9;adapter.created.put(newOperation, realOperation)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newOperation" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="cloneOperation" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newOperation.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var clonedOperation : uml::Operation&#xA;&#x9;var temp : uml::Operation&#xA;&#x9;temp ?= adapter.getRealObject(newOperation, false)&#xA;&#x9;if isUnique then&#xA;&#x9;&#x9;if not (adapter.cloned.exists{o | o.equals(temp)}) then&#xA;&#x9;&#x9;&#x9;clonedOperation ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;&#x9;adapter.clone.put(realOperation, clonedOperation)&#xA;&#x9;&#x9;&#x9;adapter.cloned.add(temp)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;clonedOperation ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;adapter.clone.put(realOperation, clonedOperation)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newOperation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="realOperation" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="setOperation" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aOperation.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempOperation : uml::Operation&#xA;&#x9;tempOperation ?= adapter.getRealObject(aOperation, false)&#xA;&#x9;var tempinterface : uml::Interface&#xA;&#x9;tempinterface ?= adapter.getRealObject(ainterface, false)&#xA;&#x9;if tempinterface.isNotEqual(void) then&#xA;&#x9;&#x9;tempOperation.interface := tempinterface&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclass : uml::Class&#xA;&#x9;tempclass ?= adapter.getRealObject(aclass, false)&#xA;&#x9;if tempclass.isNotEqual(void) then&#xA;&#x9;&#x9;tempOperation.~class := tempclass&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisQuery : uml::Boolean&#xA;&#x9;tempisQuery ?= adapter.getRealObject(aisQuery, false)&#xA;&#x9;if (tempisQuery) != (void) then&#xA;&#x9;&#x9;tempOperation.isQuery := tempisQuery&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedOperation : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedOperation ?= adapter.getRealObject(aredefinedOperation, true)&#xA;&#x9;if tempredefinedOperation.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedOperation.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Operation&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.redefinedOperation.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempdatatype : uml::DataType&#xA;&#x9;tempdatatype ?= adapter.getRealObject(adatatype, false)&#xA;&#x9;if tempdatatype.isNotEqual(void) then&#xA;&#x9;&#x9;tempOperation.datatype := tempdatatype&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedParameter : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedParameter ?= adapter.getRealObject(aownedParameter, true)&#xA;&#x9;if tempownedParameter.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedParameter.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Parameter&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.ownedParameter.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisAbstract : uml::Boolean&#xA;&#x9;tempisAbstract ?= adapter.getRealObject(aisAbstract, false)&#xA;&#x9;if (tempisAbstract) != (void) then&#xA;&#x9;&#x9;tempOperation.isAbstract := tempisAbstract&#xA;&#xA;&#x9;end&#xA;&#x9;var tempmethod : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempmethod ?= adapter.getRealObject(amethod, true)&#xA;&#x9;if tempmethod.isNotEqual(void) then&#xA;&#x9;&#x9;tempmethod.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Behavior&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.~method.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempraisedException : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempraisedException ?= adapter.getRealObject(araisedException, true)&#xA;&#x9;if tempraisedException.isNotEqual(void) then&#xA;&#x9;&#x9;tempraisedException.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Type&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.raisedException.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedParameterSet : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedParameterSet ?= adapter.getRealObject(aownedParameterSet, true)&#xA;&#x9;if tempownedParameterSet.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedParameterSet.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::ParameterSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.ownedParameterSet.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempOperation.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.ownedComment.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aOperation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ainterface">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Interface"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclass">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Class"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisQuery">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedOperation" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="adatatype">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedParameter" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Parameter"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisAbstract">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="amethod" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Behavior"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="araisedException" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Type"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedParameterSet" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ParameterSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="unsetOperation" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aOperation.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempOperation : uml::Operation&#xA;&#x9;tempOperation ?= adapter.getRealObject(aOperation, false)&#xA;&#x9;var tempinterface : uml::Interface&#xA;&#x9;tempinterface ?= adapter.getRealObject(ainterface, false)&#xA;&#x9;if tempinterface.isNotEqual(void) then&#xA;&#x9;&#x9;tempOperation.interface := tempinterface&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclass : uml::Class&#xA;&#x9;tempclass ?= adapter.getRealObject(aclass, false)&#xA;&#x9;if tempclass.isNotEqual(void) then&#xA;&#x9;&#x9;tempOperation.~class := tempclass&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisQuery : uml::Boolean&#xA;&#x9;tempisQuery ?= adapter.getRealObject(aisQuery, false)&#xA;&#x9;if (tempisQuery) != (void) then&#xA;&#x9;&#x9;tempOperation.isQuery := tempisQuery&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedOperation : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedOperation ?= adapter.getRealObject(aredefinedOperation, true)&#xA;&#x9;if tempredefinedOperation.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedOperation.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Operation&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.redefinedOperation.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempdatatype : uml::DataType&#xA;&#x9;tempdatatype ?= adapter.getRealObject(adatatype, false)&#xA;&#x9;if tempdatatype.isNotEqual(void) then&#xA;&#x9;&#x9;tempOperation.datatype := tempdatatype&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedParameter : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedParameter ?= adapter.getRealObject(aownedParameter, true)&#xA;&#x9;if tempownedParameter.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedParameter.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Parameter&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.ownedParameter.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisAbstract : uml::Boolean&#xA;&#x9;tempisAbstract ?= adapter.getRealObject(aisAbstract, false)&#xA;&#x9;if (tempisAbstract) != (void) then&#xA;&#x9;&#x9;tempOperation.isAbstract := tempisAbstract&#xA;&#xA;&#x9;end&#xA;&#x9;var tempmethod : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempmethod ?= adapter.getRealObject(amethod, true)&#xA;&#x9;if tempmethod.isNotEqual(void) then&#xA;&#x9;&#x9;tempmethod.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Behavior&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.~method.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempraisedException : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempraisedException ?= adapter.getRealObject(araisedException, true)&#xA;&#x9;if tempraisedException.isNotEqual(void) then&#xA;&#x9;&#x9;tempraisedException.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Type&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.raisedException.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedParameterSet : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedParameterSet ?= adapter.getRealObject(aownedParameterSet, true)&#xA;&#x9;if tempownedParameterSet.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedParameterSet.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::ParameterSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.ownedParameterSet.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempOperation.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempOperation.ownedComment.remove(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aOperation">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ainterface">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Interface"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclass">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Class"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisQuery">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedOperation" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="adatatype">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedParameter" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Parameter"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisAbstract">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="amethod" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Behavior"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="araisedException" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Type"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedParameterSet" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/ParameterSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="createClass" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newClass.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if (adapter.created.getValue(newClass).equals(void)) or (not (isUnique)) then&#xA;&#x9;&#x9;var realClass : uml::Class&#xA;&#x9;&#x9;realClass ?= adapter.converter.convert(kermeta::standard::Object.clone(newClass), adapter.convert)&#xA;&#x9;&#x9;adapter.created.put(newClass, realClass)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newClass" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Class"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="cloneClass" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newClass.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var clonedClass : uml::Class&#xA;&#x9;var temp : uml::Class&#xA;&#x9;temp ?= adapter.getRealObject(newClass, false)&#xA;&#x9;if isUnique then&#xA;&#x9;&#x9;if not (adapter.cloned.exists{o | o.equals(temp)}) then&#xA;&#x9;&#x9;&#x9;clonedClass ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;&#x9;adapter.clone.put(realClass, clonedClass)&#xA;&#x9;&#x9;&#x9;adapter.cloned.add(temp)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;clonedClass ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;adapter.clone.put(realClass, clonedClass)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newClass">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Class"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="realClass" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Class"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="setClass" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aClass.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempClass : uml::Class&#xA;&#x9;tempClass ?= adapter.getRealObject(aClass, false)&#xA;&#x9;var tempnestedClassifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempnestedClassifier ?= adapter.getRealObject(anestedClassifier, true)&#xA;&#x9;if tempnestedClassifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempnestedClassifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Classifier&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.nestedClassifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedOperation : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedOperation ?= adapter.getRealObject(aownedOperation, true)&#xA;&#x9;if tempownedOperation.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedOperation.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Operation&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.ownedOperation.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisActive : uml::Boolean&#xA;&#x9;tempisActive ?= adapter.getRealObject(aisActive, false)&#xA;&#x9;if (tempisActive) != (void) then&#xA;&#x9;&#x9;tempClass.isActive := tempisActive&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedBehavior : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedBehavior ?= adapter.getRealObject(aownedBehavior, true)&#xA;&#x9;if tempownedBehavior.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedBehavior.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Behavior&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.ownedBehavior.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclassifierBehavior : uml::Behavior&#xA;&#x9;tempclassifierBehavior ?= adapter.getRealObject(aclassifierBehavior, false)&#xA;&#x9;if tempclassifierBehavior.isNotEqual(void) then&#xA;&#x9;&#x9;tempClass.classifierBehavior := tempclassifierBehavior&#xA;&#xA;&#x9;end&#xA;&#x9;var tempinterfaceRealization : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempinterfaceRealization ?= adapter.getRealObject(ainterfaceRealization, true)&#xA;&#x9;if tempinterfaceRealization.isNotEqual(void) then&#xA;&#x9;&#x9;tempinterfaceRealization.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::InterfaceRealization&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.interfaceRealization.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisAbstract : uml::Boolean&#xA;&#x9;tempisAbstract ?= adapter.getRealObject(aisAbstract, false)&#xA;&#x9;if (tempisAbstract) != (void) then&#xA;&#x9;&#x9;tempClass.isAbstract := tempisAbstract&#xA;&#xA;&#x9;end&#xA;&#x9;var tempgeneralization : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempgeneralization ?= adapter.getRealObject(ageneralization, true)&#xA;&#x9;if tempgeneralization.isNotEqual(void) then&#xA;&#x9;&#x9;tempgeneralization.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Generalization&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.generalization.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var temppowertypeExtent : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;temppowertypeExtent ?= adapter.getRealObject(apowertypeExtent, true)&#xA;&#x9;if temppowertypeExtent.isNotEqual(void) then&#xA;&#x9;&#x9;temppowertypeExtent.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::GeneralizationSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.powertypeExtent.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedClassifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedClassifier ?= adapter.getRealObject(aredefinedClassifier, true)&#xA;&#x9;if tempredefinedClassifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedClassifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Classifier&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.redefinedClassifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempClass.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.ownedComment.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aClass">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Class"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anestedClassifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedOperation" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisActive">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedBehavior" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Behavior"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclassifierBehavior">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Behavior"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ainterfaceRealization" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/InterfaceRealization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisAbstract">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneralization" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="apowertypeExtent" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/GeneralizationSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedClassifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="unsetClass" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aClass.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempClass : uml::Class&#xA;&#x9;tempClass ?= adapter.getRealObject(aClass, false)&#xA;&#x9;var tempnestedClassifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempnestedClassifier ?= adapter.getRealObject(anestedClassifier, true)&#xA;&#x9;if tempnestedClassifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempnestedClassifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Classifier&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.nestedClassifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedOperation : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedOperation ?= adapter.getRealObject(aownedOperation, true)&#xA;&#x9;if tempownedOperation.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedOperation.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Operation&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.ownedOperation.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisActive : uml::Boolean&#xA;&#x9;tempisActive ?= adapter.getRealObject(aisActive, false)&#xA;&#x9;if (tempisActive) != (void) then&#xA;&#x9;&#x9;tempClass.isActive := tempisActive&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedBehavior : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedBehavior ?= adapter.getRealObject(aownedBehavior, true)&#xA;&#x9;if tempownedBehavior.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedBehavior.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Behavior&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.ownedBehavior.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclassifierBehavior : uml::Behavior&#xA;&#x9;tempclassifierBehavior ?= adapter.getRealObject(aclassifierBehavior, false)&#xA;&#x9;if tempclassifierBehavior.isNotEqual(void) then&#xA;&#x9;&#x9;tempClass.classifierBehavior := tempclassifierBehavior&#xA;&#xA;&#x9;end&#xA;&#x9;var tempinterfaceRealization : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempinterfaceRealization ?= adapter.getRealObject(ainterfaceRealization, true)&#xA;&#x9;if tempinterfaceRealization.isNotEqual(void) then&#xA;&#x9;&#x9;tempinterfaceRealization.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::InterfaceRealization&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.interfaceRealization.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisAbstract : uml::Boolean&#xA;&#x9;tempisAbstract ?= adapter.getRealObject(aisAbstract, false)&#xA;&#x9;if (tempisAbstract) != (void) then&#xA;&#x9;&#x9;tempClass.isAbstract := tempisAbstract&#xA;&#xA;&#x9;end&#xA;&#x9;var tempgeneralization : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempgeneralization ?= adapter.getRealObject(ageneralization, true)&#xA;&#x9;if tempgeneralization.isNotEqual(void) then&#xA;&#x9;&#x9;tempgeneralization.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Generalization&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.generalization.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var temppowertypeExtent : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;temppowertypeExtent ?= adapter.getRealObject(apowertypeExtent, true)&#xA;&#x9;if temppowertypeExtent.isNotEqual(void) then&#xA;&#x9;&#x9;temppowertypeExtent.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::GeneralizationSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.powertypeExtent.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedClassifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedClassifier ?= adapter.getRealObject(aredefinedClassifier, true)&#xA;&#x9;if tempredefinedClassifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedClassifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Classifier&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.redefinedClassifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempClass.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempClass.ownedComment.remove(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aClass">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Class"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anestedClassifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedOperation" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisActive">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedBehavior" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Behavior"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclassifierBehavior">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Behavior"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ainterfaceRealization" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/InterfaceRealization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisAbstract">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneralization" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="apowertypeExtent" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/GeneralizationSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedClassifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="createDataType" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newDataType.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;if (adapter.created.getValue(newDataType).equals(void)) or (not (isUnique)) then&#xA;&#x9;&#x9;var realDataType : uml::DataType&#xA;&#x9;&#x9;realDataType ?= adapter.converter.convert(kermeta::standard::Object.clone(newDataType), adapter.convert)&#xA;&#x9;&#x9;adapter.created.put(newDataType, realDataType)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newDataType" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="cloneDataType" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := newDataType.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var clonedDataType : uml::DataType&#xA;&#x9;var temp : uml::DataType&#xA;&#x9;temp ?= adapter.getRealObject(newDataType, false)&#xA;&#x9;if isUnique then&#xA;&#x9;&#x9;if not (adapter.cloned.exists{o | o.equals(temp)}) then&#xA;&#x9;&#x9;&#x9;clonedDataType ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;&#x9;adapter.clone.put(realDataType, clonedDataType)&#xA;&#x9;&#x9;&#x9;adapter.cloned.add(temp)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;clonedDataType ?= kermeta::standard::Object.clone(temp)&#xA;&#x9;&#x9;adapter.clone.put(realDataType, clonedDataType)&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="isUnique" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="true"/>
            </eAnnotations>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="newDataType">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="realDataType" containment="true">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="setDataType" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aDataType.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempDataType : uml::DataType&#xA;&#x9;tempDataType ?= adapter.getRealObject(aDataType, false)&#xA;&#x9;var tempownedAttribute : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedAttribute ?= adapter.getRealObject(aownedAttribute, true)&#xA;&#x9;if tempownedAttribute.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedAttribute.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.ownedAttribute.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedOperation : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedOperation ?= adapter.getRealObject(aownedOperation, true)&#xA;&#x9;if tempownedOperation.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedOperation.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Operation&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.ownedOperation.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisAbstract : uml::Boolean&#xA;&#x9;tempisAbstract ?= adapter.getRealObject(aisAbstract, false)&#xA;&#x9;if (tempisAbstract) != (void) then&#xA;&#x9;&#x9;tempDataType.isAbstract := tempisAbstract&#xA;&#xA;&#x9;end&#xA;&#x9;var tempgeneralization : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempgeneralization ?= adapter.getRealObject(ageneralization, true)&#xA;&#x9;if tempgeneralization.isNotEqual(void) then&#xA;&#x9;&#x9;tempgeneralization.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Generalization&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.generalization.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var temppowertypeExtent : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;temppowertypeExtent ?= adapter.getRealObject(apowertypeExtent, true)&#xA;&#x9;if temppowertypeExtent.isNotEqual(void) then&#xA;&#x9;&#x9;temppowertypeExtent.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::GeneralizationSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.powertypeExtent.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedClassifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedClassifier ?= adapter.getRealObject(aredefinedClassifier, true)&#xA;&#x9;if tempredefinedClassifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedClassifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Classifier&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.redefinedClassifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempDataType.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.ownedComment.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aDataType">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedAttribute" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedOperation" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisAbstract">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneralization" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="apowertypeExtent" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/GeneralizationSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedClassifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
        <eClassifiers xsi:type="ecore:EClass" name="unsetDataType" eSuperTypes="//smartadapters/core/Adaptation">
          <eOperations name="check" eType="//Boolean">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;result := aDataType.isNotEqual(void)&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eOperations name="execute" ordered="false">
            <eAnnotations source="kermeta">
              <details key="body" value="do&#xA;&#x9;var tempDataType : uml::DataType&#xA;&#x9;tempDataType ?= adapter.getRealObject(aDataType, false)&#xA;&#x9;var tempownedAttribute : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedAttribute ?= adapter.getRealObject(aownedAttribute, true)&#xA;&#x9;if tempownedAttribute.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedAttribute.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Property&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.ownedAttribute.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedOperation : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedOperation ?= adapter.getRealObject(aownedOperation, true)&#xA;&#x9;if tempownedOperation.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedOperation.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Operation&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.ownedOperation.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempisAbstract : uml::Boolean&#xA;&#x9;tempisAbstract ?= adapter.getRealObject(aisAbstract, false)&#xA;&#x9;if (tempisAbstract) != (void) then&#xA;&#x9;&#x9;tempDataType.isAbstract := tempisAbstract&#xA;&#xA;&#x9;end&#xA;&#x9;var tempgeneralization : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempgeneralization ?= adapter.getRealObject(ageneralization, true)&#xA;&#x9;if tempgeneralization.isNotEqual(void) then&#xA;&#x9;&#x9;tempgeneralization.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Generalization&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.generalization.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var temppowertypeExtent : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;temppowertypeExtent ?= adapter.getRealObject(apowertypeExtent, true)&#xA;&#x9;if temppowertypeExtent.isNotEqual(void) then&#xA;&#x9;&#x9;temppowertypeExtent.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::GeneralizationSet&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.powertypeExtent.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempredefinedClassifier : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempredefinedClassifier ?= adapter.getRealObject(aredefinedClassifier, true)&#xA;&#x9;if tempredefinedClassifier.isNotEqual(void) then&#xA;&#x9;&#x9;tempredefinedClassifier.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Classifier&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.redefinedClassifier.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempclientDependency : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempclientDependency ?= adapter.getRealObject(aclientDependency, true)&#xA;&#x9;if tempclientDependency.isNotEqual(void) then&#xA;&#x9;&#x9;tempclientDependency.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Dependency&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.clientDependency.add(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;&#x9;var tempnameExpression : uml::StringExpression&#xA;&#x9;tempnameExpression ?= adapter.getRealObject(anameExpression, false)&#xA;&#x9;if tempnameExpression.isNotEqual(void) then&#xA;&#x9;&#x9;tempDataType.nameExpression := tempnameExpression&#xA;&#xA;&#x9;end&#xA;&#x9;var tempownedComment : kermeta::standard::Collection&lt;kermeta::reflection::Object>&#xA;&#x9;tempownedComment ?= adapter.getRealObject(aownedComment, true)&#xA;&#x9;if tempownedComment.isNotEqual(void) then&#xA;&#x9;&#x9;tempownedComment.each{o | do&#xA;&#x9;&#x9;&#x9;&#x9;var temp : uml::Comment&#xA;&#x9;&#x9;&#x9;&#x9;temp ?= o&#xA;&#x9;&#x9;&#x9;&#x9;if temp.isNotEqual(void) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempDataType.ownedComment.remove(temp)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;end&#xA;end"/>
            </eAnnotations>
          </eOperations>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aDataType">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/DataType"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedAttribute" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Property"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedOperation" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Operation"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EAttribute" name="aisAbstract">
            <eAnnotations source="kermeta">
              <details key="isComposite" value="false"/>
            </eAnnotations>
            <eType xsi:type="ecore:EDataType" href="../domain/UMLPattern.ecore#//uml/Boolean"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="ageneralization" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Generalization"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="apowertypeExtent" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/GeneralizationSet"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aredefinedClassifier" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Classifier"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aclientDependency" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Dependency"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="anameExpression">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/StringExpression"/>
          </eStructuralFeatures>
          <eStructuralFeatures xsi:type="ecore:EReference" name="aownedComment" upperBound="-1">
            <eType xsi:type="ecore:EClass" href="../domain/UMLPattern.ecore#//uml/Comment"/>
          </eStructuralFeatures>
        </eClassifiers>
      </eSubpackages>
    </eSubpackages>
    <eSubpackages name="extension" nsURI="platform:/resource/SmartAdapters/metamodel/specific/UML_AOM_Framework.ecore#//smartadapters/extension" nsPrefix="extension">
      <eClassifiers xsi:type="ecore:EClass" name="AdapterElement">
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="name">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
          </eAnnotations>
          <eType xsi:type="ecore:EDataType" href="http://www.eclipse.org/emf/2002/Ecore#//EString"/>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isOptional">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
          </eAnnotations>
          <eType xsi:type="ecore:EDataType" href="http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DerivableAdapter" eSuperTypes="//smartadapters/core/Adapter">
        <eOperations name="resolve" eType="//smartadapters/core/Adapter">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;if derivation.isApplicableTo(self) then&#xA;&#x9;&#x9;stdio.write(&quot;Deriving an adapter...&quot;)&#xA;&#x9;&#x9;var derivable : org::smartadapters::extension::DerivableAdapter init org::smartadapters::extension::DerivableAdapter.new&#xA;&#x9;&#x9;adapt.each{a | if (not (a.isOptional)) or (derivation.adaptations.contains(a)) then&#xA;&#x9;&#x9;&#x9;&#x9;derivable.adapt.add(a)&#xA;&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;alternatives.each{alt | if (alt.number) > (0) then&#xA;&#x9;&#x9;&#x9;&#x9;derivable.adapt.addAll(alt.selected)&#xA;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;if not (alt.isOptional) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;derivable.alternatives.add(alt)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;if derivable.isConcretizable then&#xA;&#x9;&#x9;&#x9;var adapter : org::smartadapters::core::Adapter init org::smartadapters::core::Adapter.new&#xA;&#x9;&#x9;&#x9;var hash : kermeta::utils::Hashtable&lt;kermeta::reflection::Class, kermeta::reflection::Class> init kermeta::utils::Hashtable&lt;kermeta::reflection::Class, kermeta::reflection::Class>.new&#xA;&#x9;&#x9;&#x9;hash.put(derivable.getMetaClass, adapter.getMetaClass)&#xA;&#x9;&#x9;&#x9;derivable.adapt.each{a | hash.put(a.getMetaClass, a.getMetaClass)}&#xA;&#x9;&#x9;&#x9;if converter.equals(void) then&#xA;&#x9;&#x9;&#x9;&#x9;converter := utils::Converter.new&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;&#x9;adapter ?= converter.convert(derivable, hash)&#xA;&#x9;&#x9;&#x9;result := adapter&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := derivable&#xA;&#xA;&#x9;&#x9;end&#xA;&#x9;&#x9;stdio.writeln(&quot;  OK!&quot;)&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var e : org::smartadapters::extension::Exception init org::smartadapters::extension::NonApplicableDerivation.new&#xA;&#x9;&#x9;e.display&#xA;&#x9;&#x9;raise e&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="overloadable" value="false"/>
          </eAnnotations>
          <eAnnotations source="kermeta.raisedExceptions">
            <details key="kermeta::exceptions::Exception" value="kermeta::exceptions::Exception"/>
            <references href="../../../../plugin/fr.irisa.triskell.kermeta/lib/framework.ecore#//exceptions/Exception"/>
          </eAnnotations>
          <eAnnotations source="kermeta.raisedExceptions" references="//smartadapters/extension/Exception">
            <details key="org::smartadapters::extension::Exception" value="org::smartadapters::extension::Exception"/>
          </eAnnotations>
          <eParameters name="derivation" eType="//smartadapters/extension/Derivation"/>
        </eOperations>
        <eOperations name="isReallyAbstract">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := (alternatives.size) &lt; (1)&#xA;end"/>
          </eAnnotations>
          <eType xsi:type="ecore:EDataType" href="http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
        </eOperations>
        <eOperations name="isConcretizable">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;result := (alternatives.size) == (0)&#xA;end"/>
          </eAnnotations>
          <eType xsi:type="ecore:EDataType" href="http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="alternatives" upperBound="-1" eType="//smartadapters/extension/EntityAlternative" containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="options" upperBound="-1" eType="//smartadapters/extension/AdapterElement" containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="xor" upperBound="-1" eType="//smartadapters/extension/MutualExclusion" containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="and" upperBound="-1" eType="//smartadapters/extension/Dependency" containment="true"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EntityAlternative" eSuperTypes="//smartadapters/extension/AdapterElement">
        <eOperations name="isDetermined">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var oldNumber : kermeta::standard::Integer init 0&#xA;&#x9;number := 0&#xA;&#x9;self.selected.clear&#xA;&#x9;error := false&#xA;&#x9;xor.each{elt | if not (error) then&#xA;&#x9;&#x9;&#x9;isSelected(elt, derivation)&#xA;&#x9;&#x9;&#x9;if (oldNumber) > (0) then&#xA;&#x9;&#x9;&#x9;&#x9;error := not ((oldNumber) == (number))&#xA;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;oldNumber := number&#xA;&#xA;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;end}&#xA;&#x9;stdio.writeln(&quot;number: &quot;.plus(number.toString))&#xA;&#x9;stdio.writeln(&quot;error: &quot;.plus(error.toString))&#xA;&#x9;if not (error) then&#xA;&#x9;&#x9;result := true&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;var except : org::smartadapters::extension::Exception init org::smartadapters::extension::NonApplicableDerivation.new&#xA;&#x9;&#x9;except.display&#xA;&#x9;&#x9;raise except&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;   Returns true if the alternative is correctly determined&#xD;&#xA;   (if one and only one variant is fully selected in the derivation)&#xD;&#xA;   */"/>
          </eAnnotations>
          <eAnnotations source="kermeta.raisedExceptions" references="//smartadapters/extension/Exception">
            <details key="org::smartadapters::extension::Exception" value="org::smartadapters::extension::Exception"/>
          </eAnnotations>
          <eType xsi:type="ecore:EDataType" href="http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
          <eParameters name="derivation" eType="//smartadapters/extension/Derivation"/>
        </eOperations>
        <eOperations name="isSelected">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;var adapt : org::smartadapters::core::Adaptation init void&#xA;&#x9;adapt ?= elt&#xA;&#x9;if adapt.isNotEqual(void) then&#xA;&#x9;&#x9;if derivation.adaptations.contains(adapt) then&#xA;&#x9;&#x9;&#x9;number := (number) + (1)&#xA;&#x9;&#x9;&#x9;selected.add(adapt)&#xA;&#x9;&#x9;&#x9;result := true&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;var c : org::smartadapters::extension::EntityConjunction init void&#xA;&#x9;c ?= elt&#xA;&#x9;if c.isNotEqual(void) then&#xA;&#x9;&#x9;var ~select : ecore::EBoolean init true&#xA;&#x9;&#x9;var option : ecore::EBoolean init false&#xA;&#x9;&#x9;var number : kermeta::standard::Integer init 0&#xA;&#x9;&#x9;c.~and.each{e | if not (e.isOptional) then&#xA;&#x9;&#x9;&#x9;&#x9;if isSelected(e, derivation) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;number := (number) + (1)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;~select := false&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;if isSelected(e, derivation) then&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;number := (number) + (1)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;end&#xA;&#xA;&#x9;&#x9;&#x9;end}&#xA;&#x9;&#x9;stdio.writeln(&quot;select:&quot;.plus(~select.toString))&#xA;&#x9;&#x9;if not (~select) then&#xA;&#x9;&#x9;&#x9;error := (number) != (0)&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;&#x9;var altern : org::smartadapters::extension::EntityAlternative init void&#xA;&#x9;altern ?= elt&#xA;&#x9;if altern.isNotEqual(void) then&#xA;&#x9;&#x9;if altern.isDetermined(derivation) then&#xA;&#x9;&#x9;&#x9;result := true&#xA;&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;result := false&#xA;&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;end&#xA;end"/>
            <details key="documentation" value="/**&#xD;&#xA;   Returns 1 if elt is selected in derivation, 0 otherwise&#xD;&#xA;   */"/>
          </eAnnotations>
          <eType xsi:type="ecore:EDataType" href="http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
          <eParameters name="elt" eType="//smartadapters/extension/AdapterElement"/>
          <eParameters name="derivation" eType="//smartadapters/extension/Derivation"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="xor" upperBound="-1" eType="//smartadapters/extension/AdapterElement"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="number" eType="//Integer">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="selected" upperBound="-1" eType="//smartadapters/core/Adaptation"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="error" eType="//Boolean">
          <eAnnotations source="kermeta">
            <details key="isComposite" value="true"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EntityConjunction" eSuperTypes="//smartadapters/extension/AdapterElement">
        <eStructuralFeatures xsi:type="ecore:EReference" name="and" upperBound="-1" eType="//smartadapters/extension/AdapterElement"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="MutualExclusion" eSuperTypes="//smartadapters/extension/AdapterElement">
        <eStructuralFeatures xsi:type="ecore:EReference" name="entities" upperBound="-1" eType="//smartadapters/extension/AdapterElement"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Dependency" eSuperTypes="//smartadapters/extension/AdapterElement">
        <eStructuralFeatures xsi:type="ecore:EReference" name="source" lowerBound="1" eType="//smartadapters/extension/AdapterElement"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="dependencies" upperBound="-1" eType="//smartadapters/extension/AdapterElement"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Derivation">
        <eOperations name="isApplicableTo">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;stdio.writeln(&quot;Checking derivation:&quot;)&#xA;&#x9;var isApplicable : ecore::EBoolean init true&#xA;&#x9;var elements : kermeta::standard::Set&lt;org::smartadapters::extension::AdapterElement> init kermeta::standard::Set&lt;org::smartadapters::extension::AdapterElement>.new&#xA;&#x9;adaptations.each{a | elements.add(a)}&#xA;&#x9;stdio.write(&quot;  - alternatives...&quot;)&#xA;&#x9;derivable.alternatives.each{alt | isApplicable := (isApplicable) and (alt.isDetermined(self))}&#xA;&#x9;if isApplicable then&#xA;&#x9;&#x9;stdio.writeln(&quot;  OK!&quot;)&#xA;&#x9;&#x9;stdio.write(&quot;  - mutual exclusions...&quot;)&#xA;&#x9;&#x9;derivable.xor.each{mutex | isApplicable := (isApplicable) and ((elements.intersection(mutex.entities).size) &lt;= (1))}&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;stdio.writeln(&quot;  Error!&quot;)&#xA;&#xA;&#x9;end&#xA;&#x9;if isApplicable then&#xA;&#x9;&#x9;stdio.writeln(&quot; OK!&quot;)&#xA;&#x9;&#x9;stdio.write(&quot;  - dependencies&quot;)&#xA;&#x9;&#x9;derivable.~and.each{dep | if elements.contains(dep.source) then&#xA;&#x9;&#x9;&#x9;&#x9;isApplicable := (isApplicable) and (elements.containsAll(dep.dependencies))&#xA;&#xA;&#x9;&#x9;&#x9;end}&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;stdio.writeln(&quot;  Error!&quot;)&#xA;&#xA;&#x9;end&#xA;&#x9;if isApplicable then&#xA;&#x9;&#x9;stdio.writeln(&quot;  OK!&quot;)&#xA;&#xA;&#x9;else&#xA;&#x9;&#x9;stdio.writeln(&quot;  Error!&quot;)&#xA;&#xA;&#x9;end&#xA;&#x9;result := isApplicable&#xA;end"/>
          </eAnnotations>
          <eType xsi:type="ecore:EDataType" href="http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
          <eParameters name="derivable" eType="//smartadapters/extension/DerivableAdapter"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="adaptations" upperBound="-1" eType="//smartadapters/core/Adaptation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="Exception" abstract="true">
        <eOperations name="display" ordered="false">
          <eAnnotations source="kermeta">
            <details key="isAbstract" value="true"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="MultipleVariants" eSuperTypes="//smartadapters/extension/Exception">
        <eOperations name="display" ordered="false">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;stdio.writeln(&quot;Many variants of an alternative have been selected. Maybe the derivation is not well formed.&quot;)&#xA;end"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="NonApplicableDerivation" eSuperTypes="//smartadapters/extension/Exception">
        <eOperations name="display" ordered="false">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;stdio.writeln(&quot;Derivation is not applicable to DerivableAdapter. Maybe the derivation is not well formed.&quot;)&#xA;&#x9;stdio.writeln(&quot;Please check that the derivation respects all the explicit and implicit constraints...&quot;)&#xA;end"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="IncompleteConjunction" eSuperTypes="//smartadapters/extension/Exception">
        <eOperations name="display" ordered="false">
          <eAnnotations source="kermeta">
            <details key="body" value="do&#xA;&#x9;stdio.writeln(&quot;At least one mandatory element of a conjunction is missing. Maybe the derivation is not well formed&quot;)&#xA;end"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
  </eSubpackages>
</ecore:EPackage>
