package org;
   require kermeta
   require "platform:/resource/SmartAdapters/metamodel/generic/genericSmartAdaptersMerged.kmt"
   require "platform:/resource/SmartAdapters/metamodel/domain/FSMMM.ecore"
   require "platform:/resource/SmartAdapters/metamodel/domain/FSMMMPattern.ecore"

   using kermeta::standard
   using kermeta::utils
   using patternframework
   using org::smartadapters::core
   using org::smartadapters::extension
   using ecore

   package smartadapters
   { 
       	package core
    	{ 
/*   		@aspect "true"
     		class Adapter{
				operation initConvert() : Void is do
					stdio.write("Mapping MM' to MM...")
					convert.put(pattern::FSM::State,FSM::State)
					convert.put(pattern::FSM::Transition,FSM::Transition)
					convert.put(pattern::FSM::Fsm,FSM::Fsm)
					stdio.writeln("OK!")
				end
			}
*/							
			class FSMAdapter inherits Adapter{
				method initConvert() : Void is do
					stdio.write("Mapping MM' to MM...")
					convert.put(pattern::FSM::State,FSM::State)
					convert.put(pattern::FSM::Transition,FSM::Transition)
					convert.put(pattern::FSM::Fsm,FSM::Fsm)
					stdio.writeln("OK!")
				end
			}
		}
	package adaptations{
	
class createState inherits createAdaptation{
	attribute newState:pattern::FSM::State

	method check() : Boolean is do
		result:=(newState!=void)
	end

	method execute() is do
			var realState:FSM::State
		if(adapter.created.getValue(newState)==void or not(isUnique==uniqueType.unique)) then
			realState?=Object.clone(newState)//adapter.converter.convert(Object.clone(newState), adapter.convert)
			adapter.created.put(newState,realState)
			else
			var clone:Boolean init false
			if(isUnique==uniqueType.non_unique) then
				var input:String init stdio.read("clone "+newState.toString+" (true/false) :")
				clone:=input.toBoolean
			end
			if(isUnique==uniqueType.non_unique or clone) then
				realState?=adapter.converter.convert(Object.clone(newState), adapter.convert)
				adapter.created.put(newState,realState)
			end
		end
	end
}

class cloneState inherits cloneAdaptation{
	reference newState:pattern::FSM::State
	attribute realState:pattern::FSM::State

	method check() : Boolean is do
		result:=(newState!=void)
	end

	method execute() is do
		var clonedState:FSM::State
		var temp:FSM::State
		temp?=adapter.getRealObject(newState,false)
		if(isUnique==uniqueType.unique) then
			if(not(adapter.cloned.exists{o | o==temp})) then
				clonedState?=Object.clone(temp)
				adapter.clone.put(realState,clonedState)
				adapter.cloned.add(temp)
			end
		else
			var clone:Boolean init false
			if(isUnique==uniqueType.non_unique) then
				var input:String init stdio.read("clone "+newState.toString+" (true/false) :")
				clone:=input.toBoolean
			end
			if(isUnique==uniqueType.non_unique or clone) then
				clonedState?=Object.clone(temp)
				adapter.clone.put(realState,clonedState)
				adapter.cloned.add(temp)
			end
		end
	end
}

class setState inherits setAdaptation{
	reference aState:pattern::FSM::State
	reference aname:ecore::EString

	method check() : Boolean is do
		result:=(aState!=void)
	end

	method execute() is do
		var tempState:FSM::State
		tempState?=adapter.getRealObject(aState,false)
		var tempname:ecore::EString
		tempname?=adapter.getRealObject(aname,false)
		if(tempname!=void) then
			tempState.name:=tempname
		end
	end
}

class unsetState inherits unsetAdaptation{
	reference aState:pattern::FSM::State
	reference aname:ecore::EString

	method check() : Boolean is do
		result:=(aState!=void)
	end

	method execute() is do
		var tempState:FSM::State
		tempState?=adapter.getRealObject(aState,false)
		var tempname:ecore::EString
		tempname?=adapter.getRealObject(aname,false)
		if(tempname!=void) then
			tempState.name:=void
		end
	end
}

class createTransition inherits createAdaptation{
	attribute newTransition:pattern::FSM::Transition

	method check() : Boolean is do
		result:=(newTransition!=void)
	end

	method execute() is do
			var realTransition:FSM::Transition
		if(adapter.created.getValue(newTransition)==void or not(isUnique==uniqueType.unique)) then
			realTransition?=Object.clone(newTransition)//adapter.converter.convert(Object.clone(newTransition), adapter.convert)
			adapter.created.put(newTransition,realTransition)
			else
			var clone:Boolean init false
			if(isUnique==uniqueType.non_unique) then
				var input:String init stdio.read("clone "+newTransition.toString+" (true/false) :")
				clone:=input.toBoolean
			end
			if(isUnique==uniqueType.non_unique or clone) then
				realTransition?=adapter.converter.convert(Object.clone(newTransition), adapter.convert)
				adapter.created.put(newTransition,realTransition)
			end
		end
	end
}

class cloneTransition inherits cloneAdaptation{
	reference newTransition:pattern::FSM::Transition
	attribute realTransition:pattern::FSM::Transition

	method check() : Boolean is do
		result:=(newTransition!=void)
	end

	method execute() is do
		var clonedTransition:FSM::Transition
		var temp:FSM::Transition
		temp?=adapter.getRealObject(newTransition,false)
		if(isUnique==uniqueType.unique) then
			if(not(adapter.cloned.exists{o | o==temp})) then
				clonedTransition?=Object.clone(temp)
				adapter.clone.put(realTransition,clonedTransition)
				adapter.cloned.add(temp)
			end
		else
			var clone:Boolean init false
			if(isUnique==uniqueType.non_unique) then
				var input:String init stdio.read("clone "+newTransition.toString+" (true/false) :")
				clone:=input.toBoolean
			end
			if(isUnique==uniqueType.non_unique or clone) then
				clonedTransition?=Object.clone(temp)
				adapter.clone.put(realTransition,clonedTransition)
				adapter.cloned.add(temp)
			end
		end
	end
}

class setTransition inherits setAdaptation{
	reference aTransition:pattern::FSM::Transition
	reference asource:pattern::FSM::State
	reference atarget:pattern::FSM::State

	method check() : Boolean is do
		result:=(aTransition!=void)
	end

	method execute() is do
		var tempTransition:FSM::Transition
		tempTransition?=adapter.getRealObject(aTransition,false)
		var tempsource:FSM::State
		tempsource?=adapter.getRealObject(asource,false)
		if(tempsource!=void) then
			tempTransition.source:=tempsource
		end
		var temptarget:FSM::State
		temptarget?=adapter.getRealObject(atarget,false)
		if(temptarget!=void) then
			tempTransition.target:=temptarget
		end
	end
}

class unsetTransition inherits unsetAdaptation{
	reference aTransition:pattern::FSM::Transition
	reference asource:pattern::FSM::State
	reference atarget:pattern::FSM::State

	method check() : Boolean is do
		result:=(aTransition!=void)
	end

	method execute() is do
		var tempTransition:FSM::Transition
		tempTransition?=adapter.getRealObject(aTransition,false)
		var tempsource:FSM::State
		tempsource?=adapter.getRealObject(asource,false)
		if(tempsource!=void) then
			tempTransition.source:=tempsource
		end
		var temptarget:FSM::State
		temptarget?=adapter.getRealObject(atarget,false)
		if(temptarget!=void) then
			tempTransition.target:=void
		end
	end
}

class setFsm inherits setAdaptation{
	reference aFsm:pattern::FSM::Fsm
	reference astates:pattern::FSM::State[0..*]
	reference atransitions:pattern::FSM::Transition[0..*]

	method check() : Boolean is do
		result:=(aFsm!=void)
	end

	method execute() is do
		var tempFsm:FSM::Fsm
		tempFsm?=adapter.getRealObject(aFsm,false)
		var tempstates:Collection<kermeta::reflection::Object>
		tempstates?=adapter.getRealObject(astates,true)
		if(tempstates!=void) then
			tempstates.each{o | 
				var temp:FSM::State
				temp?=o
				if(temp!=void) then
					tempFsm.states.add(temp)
				end}
		end
		var temptransitions:Collection<kermeta::reflection::Object>
		temptransitions?=adapter.getRealObject(atransitions,true)
		if(temptransitions!=void) then
			temptransitions.each{o | 
				var temp:FSM::Transition
				temp?=o
				if(temp!=void) then
					tempFsm.transitions.add(temp)
				end}
		end
	end
}

class unsetFsm inherits unsetAdaptation{
	reference aFsm:pattern::FSM::Fsm
	reference astates:pattern::FSM::State[0..*]
	reference atransitions:pattern::FSM::Transition[0..*]

	method check() : Boolean is do
		result:=(aFsm!=void)
	end

	method execute() is do
		var tempFsm:FSM::Fsm
		tempFsm?=adapter.getRealObject(aFsm,false)
		var tempstates:Collection<kermeta::reflection::Object>
		tempstates?=adapter.getRealObject(astates,true)
		if(tempstates!=void) then
			tempstates.each{o | 
				var temp:FSM::State
				temp?=o
				if(temp!=void) then
					tempFsm.states.add(temp)
				end}
		end
		var temptransitions:Collection<kermeta::reflection::Object>
		temptransitions?=adapter.getRealObject(atransitions,true)
		if(temptransitions!=void) then
			temptransitions.each{o | 
				var temp:FSM::Transition
				temp?=o
				if(temp!=void) then
					tempFsm.transitions.remove(temp)
				end}
		end
	end
}

						}
	}
}