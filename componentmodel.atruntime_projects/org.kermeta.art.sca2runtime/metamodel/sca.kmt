/* $Id:$ 
 * Creation : June 25, 2009
 * Licence  : EPL 
 * Copyright: INRIA, Centre Rennes - Bretagne Atlantique
 * Authors  : Brice Morin 
 *      
 */


package sca;


require kermeta
require "http://www.osoa.org/xmlns/sca/1.0"
require "http://art"

using kermeta::standard
using kermeta::utils

using sca

using art
using art::instance
using art::type
using art::implem

aspect class SCAtoART{
	reference artSystem : System [1..1]
	reference scaComposite : Composite [1..1]
	
	reference artTypes : PrimitiveType [0..*]
	reference artServices : art::type::Service [0..*]
	
	operation sca2art() is
	do
		artSystem := System.new 
		scaComposite.visit(self, artSystem)
		artSystem.services.addAll(artServices)
		
		//artSystem.root := scaComposite.artComposite
	end
	
	/**
	 * Returns the type of the component by introspecting its 
	 * provided and required ports
	 */
	operation getType(cpt : Component) : PrimitiveType is
	do
		var type : PrimitiveType
		
		type := artTypes.detect{t |
			(t.port.select{p | p.role == "server"}.collect{p | p.name}.containsAll(cpt.service.collect{s | s.name}))
			and (t.port.select{p | p.role == "client"}.collect{p | p.name}.containsAll(cpt.~reference.collect{s | s.name}))
			and t.port.select{p | p.role == "server"}.size ==  cpt.service.size
			and t.port.select{p | p.role == "client"}.size ==  cpt.~reference.size
		}
		
		stdio.errorln(cpt.name+"::"+type.toString)
		
		if type != void then
			if not (type.name == cpt.~property.detect{p | p.name == "Type"}.~value /*cpt.constrainingType.toString*/) then
				var e : kermeta::exceptions::Exception init kermeta::exceptions::Exception.new
				e.message := "Error: two similar component types with different names: "+type.name+" VS "+cpt.constrainingType.toString 
				raise e
			else//update the type if needed
				 cpt.~property.select{p | p.name != "Type" and not type.~attribute.exists{a| p.name == a.name}}
				 	.each{ p | 
						if(p.name == "properties") then
							var dictDecl : Dictionary init Dictionary.new
							dictDecl.name := "properties"
							type.~attribute.add(dictDecl)
						else
							var attDecl : BasicAttribute init BasicAttribute.new
							attDecl.name := p.name
							type.~attribute.add(attDecl)
						end				 	
				 	}
			end
		else
			type := PrimitiveType.new
			
			//stdio.errorln(cpt.constrainingType)
			type.name := cpt.~property.detect{p | p.name == "Type"}.~value//cpt.constrainingType
			//type.name := ""
			cpt.service.each{s | 
				var port : Port init Port.new
				port.name := s.name
				port.role := "server"
				port.service := getService(s.interface.asType(JavaInterface))
				type.port.add(port)
				//type.name := type.name+"!"+s.name
				s.artPort := port
				port.lower := 0
				port.upper := 1
			}
			
			cpt.~reference.each{r | 
				var port : Port init Port.new
				port.name := r.name
				//stdio.errorln("port "+port.name)
				port.role := "client"
				//port.service := getService(r.interfaceGroup.~value.asType(JavaInterface))
				port.service := getService(r.interface.asType(JavaInterface))
				
				if r.multiplicity == void then
					//stdio.errorln("SCA multiplicities are not loaded... To be fixed by Didier ;-)")
				end
				if r.multiplicity == Multiplicity._01 or  r.multiplicity == Multiplicity._0N then
					port.lower := 0
					port.isOptional := true
				else
					port.lower := 1
					port.isOptional := false
				end
				
				if r.multiplicity == Multiplicity._01 or  r.multiplicity == Multiplicity._11 then
					port.upper := 1
				else
					port.upper := -1
				end
				
				type.port.add(port)
				//type.name := type.name+"?"+r.name
				
				r.artPort := port
			}
			
			cpt.~property.each{p | 
				stdio.errorln(cpt.name+"::"+p.name)
			}
				
			cpt.~property.select{p | p.name != "Type"}.each{p |
				if(p.name == "properties") then
					var dictDecl : Dictionary init Dictionary.new
					dictDecl.name := "properties"
					type.~attribute.add(dictDecl)
				else
					var attDecl : BasicAttribute init BasicAttribute.new
					attDecl.name := p.name
					type.~attribute.add(attDecl)
				end
			}
				
			artTypes.add(type)
		end
		
		/*stdio.writeln("Type: "+type.toString)
		type.port.each{p |
			stdio.writeln("  -"+p.name+": "+p.role)
		}*/
		result := type
	end
	
	operation getService(interface : JavaInterface) : art::type::Service is
	do
		//stdio.writeln("getService("+interface.interface+")")
		
		var service : art::type::Service
		service := artServices.detect{s | s.name == interface.interface}
		
		if service == void then
			service := art::type::FunctionalService.new
			service.name := interface.interface
			artServices.add(service)
		end
	
		result := service
	end
}

aspect class Composite
{
	reference artComposite : CompositeInstance [1..1]
	
	operation visit(sca2art : SCAtoART, artSystem : System) is
	do
		artComposite := CompositeInstance.new
		artSystem.root := artComposite
		artComposite.name := self.name
		self.component.each{c | 
			stdio.errorln(self.name+"::"+c.name)
			c.visit(sca2art, artSystem)
			artComposite.subComponent.add(c.artComponent)
		}
		self.wire.each{w | w.visit(sca2art, artSystem)}
	end
}

aspect class Component
{
	reference artComponent : PrimitiveInstance [1..1]
	
	operation visit(sca2art : SCAtoART, artSystem : System) is
	do
		stdio.errorln("visit "+self.name)
	
	/*	stdio.writeln("visit Component")
		stdio.writeln("  artComponent.name: "+self.name)
		stdio.writeln("  artComponent: "+self.toString)
	*/
		artComponent := PrimitiveInstance.new
		artComponent.name := self.name
		
		var implem : OSGiComponent init OSGiComponent.new
		implem.implementingClass := self.implementation.asType(JavaImplementation).~class
		artComponent.implem := implem
		
		var type : PrimitiveType init sca2art.getType(self)
		artComponent.type := type
		artSystem.types.add(type)
		
		
		self.~property.select{p | p.name != "Type"}.each{p |
					if(p.name == "properties") then
						var dictDecl : Dictionary init self.artComponent.type.~attribute.select{a | a.name == "properties"}.one.asType(Dictionary)
						
						var dictVal : DictionaryValuedAttribute init DictionaryValuedAttribute.new
						dictVal.~attribute := dictDecl
						
						p.~value.split(";").each{couple |
							var entry : OtherEntry init OtherEntry.new
							entry.key := couple.split(":").elementAt(0)
							entry.~value :=  couple.split(":").elementAt(1)
							dictVal.entries.add(entry)
						}
						self.artComponent.~attribute.add(dictVal)
					else
						var attDecl : BasicAttribute init self.artComponent.type.~attribute.select{a | a.name == p.name}.one.asType(BasicAttribute)
						
						var attVal : ValuedAttribute init ValuedAttribute.new
						attVal.~attribute := attDecl
						attVal.~value := p.~value
						self.artComponent.~attribute.add(attVal)
					end
				}
		
	/*	stdio.writeln("  artComponent.type: "+artComponent.type.toString)
		stdio.writeln("  artComponent: "+artComponent.toString)
	*/
	end
}

//TODO: promote => Delegation Binding
aspect class Wire
{
	reference artBinding : TransmissionBinding [1..1]
	
	operation visit(sca2art : SCAtoART, artSystem : System) is
	do
	
	/*	stdio.writeln("visit Wire")
		stdio.writeln("  artBinding.server: "+self.target2.artPort.toString)
		stdio.writeln("    artBinding.server.sca: "+self.target2.toString)
		stdio.writeln("  artBinding.client: "+self.source2.artPort.toString)
		stdio.writeln("    artBinding.client.sca: "+self.source2.toString)
		stdio.writeln("  artBinding.serverInstance: "+self.target2.container.asType(Component).artComponent.toString)
		stdio.writeln("  artBinding.clientInstance: "+self.source2.container.asType(Component).artComponent.toString)
	*/
		artBinding := TransmissionBinding.new 
		artBinding.server := self.target2.container.asType(Component).artComponent.type.port.detect{p | p.role == "server" and p.name == self.target2.name}//self.target2.artPort
		artBinding.client := self.source2.container.asType(Component).artComponent.type.port.detect{p | p.role == "client" and p.name == self.source2.name}//self.source2.artPort
		artBinding.serverInstance := self.target2.container.asType(Component).artComponent
		artBinding.id := self.target2.container.asType(Component).artComponent.name
		self.source2.container.asType(Component).artComponent.binding.add(artBinding)
	end
}

aspect class BaseService
{
	reference artPort : Port [1..1]	
}

aspect class BaseReference
{
	reference artPort : Port [1..1]
}

aspect class JavaInterface
{
	reference artService : art::type::Service [1..1]
	
	operation visit(sca2art : SCAtoART, artSystem : System) is
	do
		//stdio.writeln("JavaInterface: "+self.toString)
		artService := art::type::FunctionalService.new
		artService.name := self.interface
		artSystem.services.add(artService)
	end
}